console.log('[Z3DPortable] Script loading started');
"use strict";
var Z3DPortable = (() => {
  console.log('[Z3DPortable] Inside IIFE');
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // packages/z3d-object/src/editor/index.ts
  var editor_exports = {};
  __export(editor_exports, {
    PropertyAdapter: () => PropertyAdapter,
    Z3DObjectEditor: () => Z3DObjectEditor,
    default: () => editor_default
  });

  // packages/z3d-object/src/editor/portable-interface.ts
  var PropertyAdapter = class {
    constructor(host) {
      this.host = host;
      this.mapping = host.propertyMapping || {};
    }
    // Update animation state in z3d-json
    updateAnimationState(animationState) {
      const config = this.getZ3DConfig();
      if (!config.object.animation) {
        config.object.animation = {
          currentAnimation: null,
          currentTime: 0,
          isPlaying: false,
          isLooping: true,
          playbackSpeed: 1
        };
      }
      if (animationState.currentAnimation !== void 0) {
        config.object.animation.currentAnimation = animationState.currentAnimation;
      }
      if (animationState.currentTime !== void 0) {
        config.object.animation.currentTime = animationState.currentTime;
      }
      if (animationState.isPlaying !== void 0) {
        config.object.animation.isPlaying = animationState.isPlaying;
      }
      if (animationState.isLooping !== void 0) {
        config.object.animation.isLooping = animationState.isLooping;
      }
      if (animationState.playbackSpeed !== void 0) {
        config.object.animation.playbackSpeed = animationState.playbackSpeed;
      }
      this.setZ3DConfig(config);
    }
    // Update node visibility in z3d-json
    updateNodeVisibility(nodeName, visible) {
      const config = this.getZ3DConfig();
      if (!config.object.nodeVisibility) {
        config.object.nodeVisibility = {};
      }
      config.object.nodeVisibility[nodeName] = visible;
      this.setZ3DConfig(config);
    }
    // Update skinned mesh data in z3d-json
    updateSkinnedMesh(skinnedMeshData) {
      const config = this.getZ3DConfig();
      if (skinnedMeshData) {
        config.object.skinnedMesh = {
          timestamp: skinnedMeshData.timestamp || performance.now(),
          verticesCompressed: skinnedMeshData.verticesCompressed,
          meshVisibility: skinnedMeshData.visibility || {},
          // Store mesh visibility map
          updateFrequency: skinnedMeshData.updateFrequency || 30
        };
        console.log(
          "[PropertyAdapter] Updated skinned mesh in z3d-json, compressed length:",
          skinnedMeshData.verticesCompressed?.length || 0,
          "visibility map:",
          skinnedMeshData.visibility
        );
      } else {
        delete config.object.skinnedMesh;
        console.log("[PropertyAdapter] Cleared skinned mesh data from z3d-json");
      }
      this.setZ3DConfig(config);
    }
    // Get animation state from z3d-json
    getAnimationState() {
      const config = this.getZ3DConfig();
      return config.object.animation || {
        currentAnimation: null,
        currentTime: 0,
        isPlaying: false,
        isLooping: true,
        playbackSpeed: 1
      };
    }
    // Get node visibility from z3d-json
    getNodeVisibility() {
      const config = this.getZ3DConfig();
      return config.object.nodeVisibility || {};
    }
    getZ3DConfig() {
      try {
        const jsonPropName = this.mapping.z3dJson || "z3d-json";
        const jsonStr = this.host.getPropertyValue(jsonPropName);
        if (!jsonStr)
          return this.getDefaultZ3DConfig();
        const config = JSON.parse(jsonStr);
        if (!config.object)
          config.object = {};
        if (!config.object.transform)
          config.object.transform = {};
        if (!config.object.transform.delta) {
          config.object.transform.delta = {
            position: { x: 0, y: 0, z: 0 },
            rotation: { x: 0, y: 0, z: 0 },
            scale: { x: 1, y: 1, z: 1 }
          };
        }
        return config;
      } catch (error) {
        console.warn("[PropertyAdapter] Failed to parse z3d-json, using defaults:", error);
        return this.getDefaultZ3DConfig();
      }
    }
    setZ3DConfig(config) {
      const jsonPropName = this.mapping.z3dJson || "z3d-json";
      const jsonStr = JSON.stringify(config, null, 2);
      this.host.setPropertyValue(jsonPropName, jsonStr);
    }
    getDefaultZ3DConfig() {
      return {
        object: {
          transform: {
            delta: {
              position: { x: 0, y: 0, z: 0 },
              rotation: { x: 0, y: 0, z: 0 },
              scale: { x: 1, y: 1, z: 1 }
            }
          },
          animation: {
            currentAnimation: null,
            currentTime: 0,
            isPlaying: false,
            isLooping: true,
            playbackSpeed: 1
          },
          nodeVisibility: {}
        }
      };
    }
    getValue(key) {
      if (key === "positionX") {
        return this.host.inst.GetX ? this.host.inst.GetX() : 0;
      }
      if (key === "positionY") {
        return this.host.inst.GetY ? this.host.inst.GetY() : 0;
      }
      if (key === "positionZ") {
        return this.host.inst.GetZElevation ? this.host.inst.GetZElevation() : 0;
      }
      if (key.startsWith("delta")) {
        const config = this.getZ3DConfig();
        const delta = config.object.transform.delta;
        switch (key) {
          case "deltaPositionX":
            return delta.position.x;
          case "deltaPositionY":
            return delta.position.y;
          case "deltaPositionZ":
            return delta.position.z;
          case "deltaRotationX":
            return delta.rotation.x;
          case "deltaRotationY":
            return delta.rotation.y;
          case "deltaRotationZ":
            return delta.rotation.z;
          case "deltaScaleX":
            return delta.scale.x;
          case "deltaScaleY":
            return delta.scale.y;
          case "deltaScaleZ":
            return delta.scale.z;
          default:
            return 0;
        }
      }
      const propName = this.mapping[key];
      if (!propName) {
        console.warn(`[PropertyAdapter] No mapping for key: ${key}`);
        return void 0;
      }
      return this.host.getPropertyValue(propName);
    }
    setValue(key, value) {
      if (key === "positionX") {
        if (this.host.inst.SetX)
          this.host.inst.SetX(value);
        return;
      }
      if (key === "positionY") {
        if (this.host.inst.SetY)
          this.host.inst.SetY(value);
        return;
      }
      if (key === "positionZ") {
        if (this.host.inst.SetZElevation)
          this.host.inst.SetZElevation(value);
        return;
      }
      if (key.startsWith("delta")) {
        const config = this.getZ3DConfig();
        const delta = config.object.transform.delta;
        switch (key) {
          case "deltaPositionX":
            delta.position.x = value;
            break;
          case "deltaPositionY":
            delta.position.y = value;
            break;
          case "deltaPositionZ":
            delta.position.z = value;
            break;
          case "deltaRotationX":
            delta.rotation.x = value;
            break;
          case "deltaRotationY":
            delta.rotation.y = value;
            break;
          case "deltaRotationZ":
            delta.rotation.z = value;
            break;
          case "deltaScaleX":
            delta.scale.x = value;
            break;
          case "deltaScaleY":
            delta.scale.y = value;
            break;
          case "deltaScaleZ":
            delta.scale.z = value;
            break;
          default:
            return;
        }
        this.setZ3DConfig(config);
        return;
      }
      const propName = this.mapping[key];
      if (!propName) {
        console.warn(`[PropertyAdapter] No mapping for key: ${key}`);
        return;
      }
      this.host.setPropertyValue(propName, value);
    }
    getState() {
      const config = this.getZ3DConfig();
      return {
        transform: {
          position: {
            x: this.getValue("positionX"),
            y: this.getValue("positionY"),
            z: this.getValue("positionZ")
          },
          rotation: {
            x: this.getValue("rotationX") || 0,
            y: this.getValue("rotationY") || 0,
            z: this.getValue("rotationZ") || 0
          },
          scale: {
            x: this.getValue("scaleX") || 1,
            y: this.getValue("scaleY") || 1,
            z: this.getValue("scaleZ") || 1
          },
          uniformScale: this.getValue("uniformScale") || 1,
          unitScale: this.getValue("unitScale") || 64,
          rotationOrder: this.getValue("rotationOrder") || "ZXY"
        },
        deltaTransform: {
          position: {
            x: config.object.transform.delta.position.x || 0,
            y: config.object.transform.delta.position.y || 0,
            z: config.object.transform.delta.position.z || 0
          },
          rotation: {
            x: config.object.transform.delta.rotation.x || 0,
            y: config.object.transform.delta.rotation.y || 0,
            z: config.object.transform.delta.rotation.z || 0
          },
          scale: {
            x: config.object.transform.delta.scale.x || 1,
            y: config.object.transform.delta.scale.y || 1,
            z: config.object.transform.delta.scale.z || 1
          }
        },
        wireframe: this.getValue("wireframe") || false,
        modelPath: this.getValue("modelPath") || "",
        // Include animation state from z3d-json
        animation: config.object.animation || {
          currentAnimation: null,
          currentTime: 0,
          isPlaying: false,
          isLooping: true,
          playbackSpeed: 1
        },
        nodeVisibility: config.object.nodeVisibility || {}
      };
    }
    applyState(state) {
      if (state.transform) {
        const t = state.transform;
        if (t.position) {
          if (typeof t.position.x === "number")
            this.setValue("positionX", t.position.x);
          if (typeof t.position.y === "number")
            this.setValue("positionY", t.position.y);
          if (typeof t.position.z === "number")
            this.setValue("positionZ", t.position.z);
        }
        if (t.rotation) {
          if (typeof t.rotation.x === "number")
            this.setValue("rotationX", t.rotation.x);
          if (typeof t.rotation.y === "number")
            this.setValue("rotationY", t.rotation.y);
          if (typeof t.rotation.z === "number")
            this.setValue("rotationZ", t.rotation.z);
        }
        if (t.scale) {
          if (typeof t.scale.x === "number")
            this.setValue("scaleX", t.scale.x);
          if (typeof t.scale.y === "number")
            this.setValue("scaleY", t.scale.y);
          if (typeof t.scale.z === "number")
            this.setValue("scaleZ", t.scale.z);
        }
        if (typeof t.uniformScale === "number")
          this.setValue("uniformScale", t.uniformScale);
        if (typeof t.unitScale === "number")
          this.setValue("unitScale", t.unitScale);
        if (t.rotationOrder)
          this.setValue("rotationOrder", t.rotationOrder);
      }
      if (state.deltaTransform) {
        const config = this.getZ3DConfig();
        if (state.deltaTransform.position) {
          config.object.transform.delta.position = {
            x: state.deltaTransform.position.x || 0,
            y: state.deltaTransform.position.y || 0,
            z: state.deltaTransform.position.z || 0
          };
        }
        if (state.deltaTransform.rotation) {
          config.object.transform.delta.rotation = {
            x: state.deltaTransform.rotation.x || 0,
            y: state.deltaTransform.rotation.y || 0,
            z: state.deltaTransform.rotation.z || 0
          };
        }
        if (state.deltaTransform.scale) {
          config.object.transform.delta.scale = {
            x: state.deltaTransform.scale.x || 1,
            y: state.deltaTransform.scale.y || 1,
            z: state.deltaTransform.scale.z || 1
          };
        }
        this.setZ3DConfig(config);
      }
      if (state.wireframe !== void 0)
        this.setValue("wireframe", state.wireframe);
      if (state.modelPath !== void 0)
        this.setValue("modelPath", state.modelPath);
    }
  };

  // packages/z3d-object/src/editor/assets/three-js-source.ts
  var THREEJS_BASE64 = "dmFyIFRIUkVFPSgoKT0+e3ZhciBobD1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIHZwPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7dmFyIHlwPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO3ZhciBNcD1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3ZhciBTcD0ocyx0KT0+e2Zvcih2YXIgZSBpbiB0KWhsKHMsZSx7Z2V0OnRbZV0sZW51bWVyYWJsZTohMH0pfSxicD0ocyx0LGUsbik9PntpZih0JiZ0eXBlb2YgdD09Im9iamVjdCJ8fHR5cGVvZiB0PT0iZnVuY3Rpb24iKWZvcihsZXQgaSBvZiB5cCh0KSkhTXAuY2FsbChzLGkpJiZpIT09ZSYmaGwocyxpLHtnZXQ6KCk9PnRbaV0sZW51bWVyYWJsZTohKG49dnAodCxpKSl8fG4uZW51bWVyYWJsZX0pO3JldHVybiBzfTt2YXIgRXA9cz0+YnAoaGwoe30sIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLHMpO3ZhciBmeT17fTtTcChmeSx7QUNFU0ZpbG1pY1RvbmVNYXBwaW5nOigpPT5iZixBZGRFcXVhdGlvbjooKT0+JG4sQWRkT3BlcmF0aW9uOigpPT52ZixBZGRpdGl2ZUFuaW1hdGlvbkJsZW5kTW9kZTooKT0+amgsQWRkaXRpdmVCbGVuZGluZzooKT0+WmwsQWdYVG9uZU1hcHBpbmc6KCk9PkFmLEFscGhhRm9ybWF0OigpPT5DZixBbHdheXNDb21wYXJlOigpPT5ZZixBbHdheXNEZXB0aDooKT0+ZGYsQWx3YXlzU3RlbmNpbEZ1bmM6KCk9PkFjLEFtYmllbnRMaWdodDooKT0+SG8sQW5pbWF0aW9uQWN0aW9uOigpPT5RbyxBbmltYXRpb25DbGlwOigpPT56aSxBbmltYXRpb25Mb2FkZXI6KCk9PmloLEFuaW1hdGlvbk1peGVyOigpPT55aCxBbmltYXRpb25PYmplY3RHcm91cDooKT0+dmgsQW5pbWF0aW9uVXRpbHM6KCk9PiR2LEFyY0N1cnZlOigpPT5ybyxBcnJheUNhbWVyYTooKT0+WGEsQXJyb3dIZWxwZXI6KCk9PkhoLEF0dGFjaGVkQmluZE1vZGU6KCk9PmpsLEF1ZGlvOigpPT4kbyxBdWRpb0FuYWx5c2VyOigpPT5faCxBdWRpb0NvbnRleHQ6KCk9Pk5yLEF1ZGlvTGlzdGVuZXI6KCk9Pm1oLEF1ZGlvTG9hZGVyOigpPT5maCxBeGVzSGVscGVyOigpPT5HaCxCYWNrU2lkZTooKT0+VmUsQmFzaWNEZXB0aFBhY2tpbmc6KCk9PkJmLEJhc2ljU2hhZG93TWFwOigpPT5ScCxCYXRjaGVkTWVzaDooKT0+bm8sQm9uZTooKT0+Z3IsQm9vbGVhbktleWZyYW1lVHJhY2s6KCk9PlZuLEJveDI6KCk9PkNoLEJveDM6KCk9PndlLEJveDNIZWxwZXI6KCk9PlZoLEJveEdlb21ldHJ5OigpPT5QaSxCb3hIZWxwZXI6KCk9PnpoLEJ1ZmZlckF0dHJpYnV0ZTooKT0+WnQsQnVmZmVyR2VvbWV0cnk6KCk9Pkh0LEJ1ZmZlckdlb21ldHJ5TG9hZGVyOigpPT5abyxCeXRlVHlwZTooKT0+d2YsQ2FjaGU6KCk9PkluLENhbWVyYTooKT0+dnMsQ2FtZXJhSGVscGVyOigpPT5CaCxDYW52YXNUZXh0dXJlOigpPT5RYyxDYXBzdWxlR2VvbWV0cnk6KCk9PnVvLENhdG11bGxSb21DdXJ2ZTM6KCk9PmFvLENpbmVvblRvbmVNYXBwaW5nOigpPT5TZixDaXJjbGVHZW9tZXRyeTooKT0+Zm8sQ2xhbXBUb0VkZ2VXcmFwcGluZzooKT0+VWUsQ2xvY2s6KCk9PkpvLENvbG9yOigpPT51dCxDb2xvcktleWZyYW1lVHJhY2s6KCk9PkxyLENvbG9yTWFuYWdlbWVudDooKT0+anQsQ29tcHJlc3NlZEFycmF5VGV4dHVyZTooKT0+JGMsQ29tcHJlc3NlZEN1YmVUZXh0dXJlOigpPT5LYyxDb21wcmVzc2VkVGV4dHVyZTooKT0+YnMsQ29tcHJlc3NlZFRleHR1cmVMb2FkZXI6KCk9PnNoLENvbmVHZW9tZXRyeTooKT0+cG8sQ29uc3RhbnRBbHBoYUZhY3RvcjooKT0+Y2YsQ29uc3RhbnRDb2xvckZhY3RvcjooKT0+b2YsQ3ViZUNhbWVyYTooKT0+R2EsQ3ViZVJlZmxlY3Rpb25NYXBwaW5nOigpPT56bixDdWJlUmVmcmFjdGlvbk1hcHBpbmc6KCk9PmVpLEN1YmVUZXh0dXJlOigpPT5MaSxDdWJlVGV4dHVyZUxvYWRlcjooKT0+cmgsQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmc6KCk9PlRzLEN1YmljQmV6aWVyQ3VydmU6KCk9PnhyLEN1YmljQmV6aWVyQ3VydmUzOigpPT5vbyxDdWJpY0ludGVycG9sYW50OigpPT5ObyxDdWxsRmFjZUJhY2s6KCk9PllsLEN1bGxGYWNlRnJvbnQ6KCk9PnFkLEN1bGxGYWNlRnJvbnRCYWNrOigpPT53cCxDdWxsRmFjZU5vbmU6KCk9PlhkLEN1cnZlOigpPT4kZSxDdXJ2ZVBhdGg6KCk9PmhvLEN1c3RvbUJsZW5kaW5nOigpPT5aZCxDdXN0b21Ub25lTWFwcGluZzooKT0+RWYsQ3lsaW5kZXJHZW9tZXRyeTooKT0+QXMsQ3lsaW5kcmljYWw6KCk9PlJoLERhdGEzRFRleHR1cmU6KCk9Pm9yLERhdGFBcnJheVRleHR1cmU6KCk9PmdzLERhdGFUZXh0dXJlOigpPT5PbixEYXRhVGV4dHVyZUxvYWRlcjooKT0+YWgsRGF0YVV0aWxzOigpPT5EbSxEZWNyZW1lbnRTdGVuY2lsT3A6KCk9PnpwLERlY3JlbWVudFdyYXBTdGVuY2lsT3A6KCk9PmtwLERlZmF1bHRMb2FkaW5nTWFuYWdlcjooKT0+ZHAsRGVwdGhGb3JtYXQ6KCk9PmpuLERlcHRoU3RlbmNpbEZvcm1hdDooKT0+Q2ksRGVwdGhUZXh0dXJlOigpPT5kcixEZXRhY2hlZEJpbmRNb2RlOigpPT5UZixEaXJlY3Rpb25hbExpZ2h0OigpPT5rbyxEaXJlY3Rpb25hbExpZ2h0SGVscGVyOigpPT5GaCxEaXNjcmV0ZUludGVycG9sYW50OigpPT5PbyxEaXNwbGF5UDNDb2xvclNwYWNlOigpPT5pbCxEb2RlY2FoZWRyb25HZW9tZXRyeTooKT0+bW8sRG91YmxlU2lkZTooKT0+Zm4sRHN0QWxwaGFGYWN0b3I6KCk9PmVmLERzdENvbG9yRmFjdG9yOigpPT5zZixEeW5hbWljQ29weVVzYWdlOigpPT5ubSxEeW5hbWljRHJhd1VzYWdlOigpPT4kcCxEeW5hbWljUmVhZFVzYWdlOigpPT5qcCxFZGdlc0dlb21ldHJ5OigpPT5nbyxFbGxpcHNlQ3VydmU6KCk9PkVzLEVxdWFsQ29tcGFyZTooKT0+R2YsRXF1YWxEZXB0aDooKT0+cGYsRXF1YWxTdGVuY2lsRnVuYzooKT0+WHAsRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc6KCk9PllzLEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOigpPT5acyxFdWxlcjooKT0+bHIsRXZlbnREaXNwYXRjaGVyOigpPT5sbixFeHRydWRlR2VvbWV0cnk6KCk9Pl9vLEZpbGVMb2FkZXI6KCk9PmNuLEZsb2F0MTZCdWZmZXJBdHRyaWJ1dGU6KCk9Pk9jLEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGU6KCk9Pmd0LEZsb2F0NjRCdWZmZXJBdHRyaWJ1dGU6KCk9PkZjLEZsb2F0VHlwZTooKT0+ZW4sRm9nOigpPT5KYSxGb2dFeHAyOigpPT5aYSxGcmFtZWJ1ZmZlclRleHR1cmU6KCk9PkpjLEZyb250U2lkZTooKT0+Qm4sRnJ1c3R1bTooKT0+SWksR0xCdWZmZXJBdHRyaWJ1dGU6KCk9PkVoLEdMU0wxOigpPT5zbSxHTFNMMzooKT0+VGMsR3JlYXRlckNvbXBhcmU6KCk9PldmLEdyZWF0ZXJEZXB0aDooKT0+Z2YsR3JlYXRlckVxdWFsQ29tcGFyZTooKT0+cWYsR3JlYXRlckVxdWFsRGVwdGg6KCk9Pm1mLEdyZWF0ZXJFcXVhbFN0ZW5jaWxGdW5jOigpPT5KcCxHcmVhdGVyU3RlbmNpbEZ1bmM6KCk9PllwLEdyaWRIZWxwZXI6KCk9Pk5oLEdyb3VwOigpPT5LbixIYWxmRmxvYXRUeXBlOigpPT5wcyxIZW1pc3BoZXJlTGlnaHQ6KCk9PkJvLEhlbWlzcGhlcmVMaWdodEhlbHBlcjooKT0+RGgsSWNvc2FoZWRyb25HZW9tZXRyeTooKT0+eG8sSW1hZ2VCaXRtYXBMb2FkZXI6KCk9PmRoLEltYWdlTG9hZGVyOigpPT5WaSxJbWFnZVV0aWxzOigpPT5hcixJbmNyZW1lbnRTdGVuY2lsT3A6KCk9PkJwLEluY3JlbWVudFdyYXBTdGVuY2lsT3A6KCk9PlZwLEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZTooKT0+aWksSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnk6KCk9PllvLEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyOigpPT5iaCxJbnN0YW5jZWRNZXNoOigpPT5lbyxJbnQxNkJ1ZmZlckF0dHJpYnV0ZTooKT0+RGMsSW50MzJCdWZmZXJBdHRyaWJ1dGU6KCk9Pk5jLEludDhCdWZmZXJBdHRyaWJ1dGU6KCk9PkxjLEludFR5cGU6KCk9PnFoLEludGVybGVhdmVkQnVmZmVyOigpPT5TcyxJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZTooKT0+VWksSW50ZXJwb2xhbnQ6KCk9Pk9pLEludGVycG9sYXRlRGlzY3JldGU6KCk9PktzLEludGVycG9sYXRlTGluZWFyOigpPT5RcyxJbnRlcnBvbGF0ZVNtb290aDooKT0+T2EsSW52ZXJ0U3RlbmNpbE9wOigpPT5IcCxLZWVwU3RlbmNpbE9wOigpPT52aSxLZXlmcmFtZVRyYWNrOigpPT5LZSxMT0Q6KCk9PlFhLExhdGhlR2VvbWV0cnk6KCk9PmJyLExheWVyczooKT0+X3MsTGVzc0NvbXBhcmU6KCk9PkhmLExlc3NEZXB0aDooKT0+ZmYsTGVzc0VxdWFsQ29tcGFyZTooKT0+ZXUsTGVzc0VxdWFsRGVwdGg6KCk9PnFzLExlc3NFcXVhbFN0ZW5jaWxGdW5jOigpPT5xcCxMZXNzU3RlbmNpbEZ1bmM6KCk9PldwLExpZ2h0OigpPT55bixMaWdodFByb2JlOigpPT5YbyxMaW5lOigpPT52bixMaW5lMzooKT0+UGgsTGluZUJhc2ljTWF0ZXJpYWw6KCk9PlJlLExpbmVDdXJ2ZTooKT0+dnIsTGluZUN1cnZlMzooKT0+bG8sTGluZURhc2hlZE1hdGVyaWFsOigpPT5EbyxMaW5lTG9vcDooKT0+aW8sTGluZVNlZ21lbnRzOigpPT5ubixMaW5lYXJEaXNwbGF5UDNDb2xvclNwYWNlOigpPT5GcixMaW5lYXJFbmNvZGluZzooKT0+dHUsTGluZWFyRmlsdGVyOigpPT5vZSxMaW5lYXJJbnRlcnBvbGFudDooKT0+UHIsTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyOigpPT5JcCxMaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyOigpPT5McCxMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXI6KCk9PnBuLExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXI6KCk9PmtzLExpbmVhclNSR0JDb2xvclNwYWNlOigpPT5fbixMaW5lYXJUb25lTWFwcGluZzooKT0+eWYsTGluZWFyVHJhbnNmZXI6KCk9PnRyLExvYWRlcjooKT0+TmUsTG9hZGVyVXRpbHM6KCk9PkRyLExvYWRpbmdNYW5hZ2VyOigpPT5JcixMb29wT25jZTooKT0+TmYsTG9vcFBpbmdQb25nOigpPT5GZixMb29wUmVwZWF0OigpPT5PZixMdW1pbmFuY2VBbHBoYUZvcm1hdDooKT0+TGYsTHVtaW5hbmNlRm9ybWF0OigpPT5QZixNT1VTRTooKT0+QXAsTWF0ZXJpYWw6KCk9PkFlLE1hdGVyaWFsTG9hZGVyOigpPT5xbyxNYXRoVXRpbHM6KCk9PnZtLE1hdHJpeDM6KCk9Pmt0LE1hdHJpeDQ6KCk9Pkx0LE1heEVxdWF0aW9uOigpPT5RbCxNZXNoOigpPT5kZSxNZXNoQmFzaWNNYXRlcmlhbDooKT0+eG4sTWVzaERlcHRoTWF0ZXJpYWw6KCk9PmZyLE1lc2hEaXN0YW5jZU1hdGVyaWFsOigpPT5wcixNZXNoTGFtYmVydE1hdGVyaWFsOigpPT5JbyxNZXNoTWF0Y2FwTWF0ZXJpYWw6KCk9PlVvLE1lc2hOb3JtYWxNYXRlcmlhbDooKT0+TG8sTWVzaFBob25nTWF0ZXJpYWw6KCk9PkNvLE1lc2hQaHlzaWNhbE1hdGVyaWFsOigpPT5SbyxNZXNoU3RhbmRhcmRNYXRlcmlhbDooKT0+Q3IsTWVzaFRvb25NYXRlcmlhbDooKT0+UG8sTWluRXF1YXRpb246KCk9PktsLE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6KCk9PiRzLE1peE9wZXJhdGlvbjooKT0+eGYsTXVsdGlwbHlCbGVuZGluZzooKT0+JGwsTXVsdGlwbHlPcGVyYXRpb246KCk9Pk9yLE5lYXJlc3RGaWx0ZXI6KCk9Pm1lLE5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXI6KCk9PlBwLE5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyOigpPT5DcCxOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyOigpPT5NaSxOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlcjooKT0+emEsTmV2ZXJDb21wYXJlOigpPT5rZixOZXZlckRlcHRoOigpPT51ZixOZXZlclN0ZW5jaWxGdW5jOigpPT5HcCxOb0JsZW5kaW5nOigpPT5VbixOb0NvbG9yU3BhY2U6KCk9PnFlLE5vVG9uZU1hcHBpbmc6KCk9PkRuLE5vcm1hbEFuaW1hdGlvbkJsZW5kTW9kZTooKT0+bmwsTm9ybWFsQmxlbmRpbmc6KCk9PlRpLE5vdEVxdWFsQ29tcGFyZTooKT0+WGYsTm90RXF1YWxEZXB0aDooKT0+X2YsTm90RXF1YWxTdGVuY2lsRnVuYzooKT0+WnAsTnVtYmVyS2V5ZnJhbWVUcmFjazooKT0+RmksT2JqZWN0M0Q6KCk9Pkp0LE9iamVjdExvYWRlcjooKT0+dWgsT2JqZWN0U3BhY2VOb3JtYWxNYXA6KCk9PlZmLE9jdGFoZWRyb25HZW9tZXRyeTooKT0+d3IsT25lRmFjdG9yOigpPT5RZCxPbmVNaW51c0NvbnN0YW50QWxwaGFGYWN0b3I6KCk9PmhmLE9uZU1pbnVzQ29uc3RhbnRDb2xvckZhY3RvcjooKT0+bGYsT25lTWludXNEc3RBbHBoYUZhY3RvcjooKT0+bmYsT25lTWludXNEc3RDb2xvckZhY3RvcjooKT0+cmYsT25lTWludXNTcmNBbHBoYUZhY3RvcjooKT0+QmEsT25lTWludXNTcmNDb2xvckZhY3RvcjooKT0+dGYsT3J0aG9ncmFwaGljQ2FtZXJhOigpPT5NcyxQM1ByaW1hcmllczooKT0+bnIsUENGU2hhZG93TWFwOigpPT5YaCxQQ0ZTb2Z0U2hhZG93TWFwOigpPT5ZZCxQTVJFTUdlbmVyYXRvcjooKT0+dXIsUGF0aDooKT0+RGksUGVyc3BlY3RpdmVDYW1lcmE6KCk9PnZlLFBsYW5lOigpPT5kbixQbGFuZUdlb21ldHJ5OigpPT55cyxQbGFuZUhlbHBlcjooKT0+a2gsUG9pbnRMaWdodDooKT0+Vm8sUG9pbnRMaWdodEhlbHBlcjooKT0+VWgsUG9pbnRzOigpPT5zbyxQb2ludHNNYXRlcmlhbDooKT0+X3IsUG9sYXJHcmlkSGVscGVyOigpPT5PaCxQb2x5aGVkcm9uR2VvbWV0cnk6KCk9PnNpLFBvc2l0aW9uYWxBdWRpbzooKT0+Z2gsUHJvcGVydHlCaW5kaW5nOigpPT5RdCxQcm9wZXJ0eU1peGVyOigpPT5LbyxRdWFkcmF0aWNCZXppZXJDdXJ2ZTooKT0+eXIsUXVhZHJhdGljQmV6aWVyQ3VydmUzOigpPT5NcixRdWF0ZXJuaW9uOigpPT5EZSxRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjazooKT0+cmksUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50OigpPT5GbyxSRURfR1JFRU5fUkdUQzJfRm9ybWF0OigpPT5iYyxSRURfUkdUQzFfRm9ybWF0OigpPT5EZixSRVZJU0lPTjooKT0+am8sUkdCQURlcHRoUGFja2luZzooKT0+emYsUkdCQUZvcm1hdDooKT0+SGUsUkdCQUludGVnZXJGb3JtYXQ6KCk9PktoLFJHQkFfQVNUQ18xMHgxMF9Gb3JtYXQ6KCk9Pl9jLFJHQkFfQVNUQ18xMHg1X0Zvcm1hdDooKT0+cGMsUkdCQV9BU1RDXzEweDZfRm9ybWF0OigpPT5tYyxSR0JBX0FTVENfMTB4OF9Gb3JtYXQ6KCk9PmdjLFJHQkFfQVNUQ18xMngxMF9Gb3JtYXQ6KCk9PnhjLFJHQkFfQVNUQ18xMngxMl9Gb3JtYXQ6KCk9PnZjLFJHQkFfQVNUQ180eDRfRm9ybWF0OigpPT5hYyxSR0JBX0FTVENfNXg0X0Zvcm1hdDooKT0+b2MsUkdCQV9BU1RDXzV4NV9Gb3JtYXQ6KCk9PmxjLFJHQkFfQVNUQ182eDVfRm9ybWF0OigpPT5jYyxSR0JBX0FTVENfNng2X0Zvcm1hdDooKT0+aGMsUkdCQV9BU1RDXzh4NV9Gb3JtYXQ6KCk9PnVjLFJHQkFfQVNUQ184eDZfRm9ybWF0OigpPT5kYyxSR0JBX0FTVENfOHg4X0Zvcm1hdDooKT0+ZmMsUkdCQV9CUFRDX0Zvcm1hdDooKT0+TmEsUkdCQV9FVEMyX0VBQ19Gb3JtYXQ6KCk9PnJjLFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdDooKT0+aWMsUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0OigpPT5uYyxSR0JBX1MzVENfRFhUMV9Gb3JtYXQ6KCk9PklhLFJHQkFfUzNUQ19EWFQzX0Zvcm1hdDooKT0+VWEsUkdCQV9TM1RDX0RYVDVfRm9ybWF0OigpPT5EYSxSR0JfQlBUQ19TSUdORURfRm9ybWF0OigpPT55YyxSR0JfQlBUQ19VTlNJR05FRF9Gb3JtYXQ6KCk9Pk1jLFJHQl9FVEMxX0Zvcm1hdDooKT0+UWgsUkdCX0VUQzJfRm9ybWF0OigpPT5zYyxSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdDooKT0+ZWMsUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQ6KCk9PnRjLFJHQl9TM1RDX0RYVDFfRm9ybWF0OigpPT5MYSxSR0Zvcm1hdDooKT0+VWYsUkdJbnRlZ2VyRm9ybWF0OigpPT4kaCxSYXdTaGFkZXJNYXRlcmlhbDooKT0+d28sUmF5OigpPT5uaSxSYXljYXN0ZXI6KCk9PkFoLFJlYzcwOVByaW1hcmllczooKT0+ZXIsUmVjdEFyZWFMaWdodDooKT0+R28sUmVkRm9ybWF0OigpPT5JZixSZWRJbnRlZ2VyRm9ybWF0OigpPT5KaCxSZWluaGFyZFRvbmVNYXBwaW5nOigpPT5NZixSZW5kZXJUYXJnZXQ6KCk9PkhhLFJlcGVhdFdyYXBwaW5nOigpPT5KcyxSZXBsYWNlU3RlbmNpbE9wOigpPT5GcCxSZXZlcnNlU3VidHJhY3RFcXVhdGlvbjooKT0+JGQsUmluZ0dlb21ldHJ5OigpPT52byxTSUdORURfUkVEX0dSRUVOX1JHVEMyX0Zvcm1hdDooKT0+RWMsU0lHTkVEX1JFRF9SR1RDMV9Gb3JtYXQ6KCk9PlNjLFNSR0JDb2xvclNwYWNlOigpPT54ZSxTUkdCVHJhbnNmZXI6KCk9PnNlLFNjZW5lOigpPT4kYSxTaGFkZXJDaHVuazooKT0+enQsU2hhZGVyTGliOigpPT5vbixTaGFkZXJNYXRlcmlhbDooKT0+SmUsU2hhZG93TWF0ZXJpYWw6KCk9PlRvLFNoYXBlOigpPT5GbixTaGFwZUdlb21ldHJ5OigpPT55byxTaGFwZVBhdGg6KCk9PldoLFNoYXBlVXRpbHM6KCk9PmduLFNob3J0VHlwZTooKT0+UmYsU2tlbGV0b246KCk9PnRvLFNrZWxldG9uSGVscGVyOigpPT5JaCxTa2lubmVkTWVzaDooKT0+amEsU291cmNlOigpPT5QbixTcGhlcmU6KCk9PkVlLFNwaGVyZUdlb21ldHJ5OigpPT5ScixTcGhlcmljYWw6KCk9PndoLFNwaGVyaWNhbEhhcm1vbmljczM6KCk9PldvLFNwbGluZUN1cnZlOigpPT5TcixTcG90TGlnaHQ6KCk9PnpvLFNwb3RMaWdodEhlbHBlcjooKT0+TGgsU3ByaXRlOigpPT5LYSxTcHJpdGVNYXRlcmlhbDooKT0+bXIsU3JjQWxwaGFGYWN0b3I6KCk9PkZhLFNyY0FscGhhU2F0dXJhdGVGYWN0b3I6KCk9PmFmLFNyY0NvbG9yRmFjdG9yOigpPT5qZCxTdGF0aWNDb3B5VXNhZ2U6KCk9PmVtLFN0YXRpY0RyYXdVc2FnZTooKT0+aXIsU3RhdGljUmVhZFVzYWdlOigpPT5RcCxTdGVyZW9DYW1lcmE6KCk9PnBoLFN0cmVhbUNvcHlVc2FnZTooKT0+aW0sU3RyZWFtRHJhd1VzYWdlOigpPT5LcCxTdHJlYW1SZWFkVXNhZ2U6KCk9PnRtLFN0cmluZ0tleWZyYW1lVHJhY2s6KCk9PmtuLFN1YnRyYWN0RXF1YXRpb246KCk9PkpkLFN1YnRyYWN0aXZlQmxlbmRpbmc6KCk9PkpsLFRPVUNIOigpPT5UcCxUYW5nZW50U3BhY2VOb3JtYWxNYXA6KCk9PmFpLFRldHJhaGVkcm9uR2VvbWV0cnk6KCk9Pk1vLFRleHR1cmU6KCk9Pl9lLFRleHR1cmVMb2FkZXI6KCk9Pm9oLFRvcnVzR2VvbWV0cnk6KCk9PlNvLFRvcnVzS25vdEdlb21ldHJ5OigpPT5ibyxUcmlhbmdsZTooKT0+TG4sVHJpYW5nbGVGYW5EcmF3TW9kZTooKT0+TnAsVHJpYW5nbGVTdHJpcERyYXdNb2RlOigpPT5EcCxUcmlhbmdsZXNEcmF3TW9kZTooKT0+VXAsVHViZUdlb21ldHJ5OigpPT5FbyxVVk1hcHBpbmc6KCk9PnRsLFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZTooKT0+Y3IsVWludDMyQnVmZmVyQXR0cmlidXRlOigpPT5ocixVaW50OEJ1ZmZlckF0dHJpYnV0ZTooKT0+SWMsVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlOigpPT5VYyxVbmlmb3JtOigpPT5NaCxVbmlmb3Jtc0dyb3VwOigpPT5TaCxVbmlmb3Jtc0xpYjooKT0+bHQsVW5pZm9ybXNVdGlsczooKT0+UWYsVW5zaWduZWRCeXRlVHlwZTooKT0+Tm4sVW5zaWduZWRJbnQyNDhUeXBlOigpPT5RbixVbnNpZ25lZEludFR5cGU6KCk9PkNuLFVuc2lnbmVkU2hvcnQ0NDQ0VHlwZTooKT0+WWgsVW5zaWduZWRTaG9ydDU1NTFUeXBlOigpPT5aaCxVbnNpZ25lZFNob3J0VHlwZTooKT0+ZWwsVlNNU2hhZG93TWFwOigpPT51bixWZWN0b3IyOigpPT5aLFZlY3RvcjM6KCk9PlIsVmVjdG9yNDooKT0+dGUsVmVjdG9yS2V5ZnJhbWVUcmFjazooKT0+QmksVmlkZW9UZXh0dXJlOigpPT5aYyxXZWJHTDFSZW5kZXJlcjooKT0+WWEsV2ViR0wzRFJlbmRlclRhcmdldDooKT0+Q2MsV2ViR0xBcnJheVJlbmRlclRhcmdldDooKT0+UmMsV2ViR0xDb29yZGluYXRlU3lzdGVtOigpPT5tbixXZWJHTEN1YmVSZW5kZXJUYXJnZXQ6KCk9PldhLFdlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzOigpPT5QYyxXZWJHTFJlbmRlclRhcmdldDooKT0+WmUsV2ViR0xSZW5kZXJlcjooKT0+cWEsV2ViR0xVdGlsczooKT0+cnAsV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbTooKT0+c3IsV2lyZWZyYW1lR2VvbWV0cnk6KCk9PkFvLFdyYXBBcm91bmRFbmRpbmc6KCk9PmpzLFplcm9DdXJ2YXR1cmVFbmRpbmc6KCk9PmJpLFplcm9GYWN0b3I6KCk9PktkLFplcm9TbG9wZUVuZGluZzooKT0+RWksWmVyb1N0ZW5jaWxPcDooKT0+T3AsX1NSR0JBRm9ybWF0OigpPT5WYSxjcmVhdGVDYW52YXNFbGVtZW50OigpPT5KZixzUkdCRW5jb2Rpbmc6KCk9PnRpfSk7dmFyIGpvPSIxNjEiLEFwPXtMRUZUOjAsTUlERExFOjEsUklHSFQ6MixST1RBVEU6MCxET0xMWToxLFBBTjoyfSxUcD17Uk9UQVRFOjAsUEFOOjEsRE9MTFlfUEFOOjIsRE9MTFlfUk9UQVRFOjN9LFhkPTAsWWw9MSxxZD0yLHdwPTMsUnA9MCxYaD0xLFlkPTIsdW49MyxCbj0wLFZlPTEsZm49MixVbj0wLFRpPTEsWmw9MixKbD0zLCRsPTQsWmQ9NSwkbj0xMDAsSmQ9MTAxLCRkPTEwMixLbD0xMDMsUWw9MTA0LEtkPTIwMCxRZD0yMDEsamQ9MjAyLHRmPTIwMyxGYT0yMDQsQmE9MjA1LGVmPTIwNixuZj0yMDcsc2Y9MjA4LHJmPTIwOSxhZj0yMTAsb2Y9MjExLGxmPTIxMixjZj0yMTMsaGY9MjE0LHVmPTAsZGY9MSxmZj0yLHFzPTMscGY9NCxtZj01LGdmPTYsX2Y9NyxPcj0wLHhmPTEsdmY9MixEbj0wLHlmPTEsTWY9MixTZj0zLGJmPTQsRWY9NSxBZj02LGpsPSJhdHRhY2hlZCIsVGY9ImRldGFjaGVkIix0bD0zMDAsem49MzAxLGVpPTMwMixZcz0zMDMsWnM9MzA0LFRzPTMwNixKcz0xZTMsVWU9MTAwMSwkcz0xMDAyLG1lPTEwMDMsemE9MTAwNCxDcD0xMDA0LE1pPTEwMDUsUHA9MTAwNSxvZT0xMDA2LGtzPTEwMDcsTHA9MTAwNyxwbj0xMDA4LElwPTEwMDgsTm49MTAwOSx3Zj0xMDEwLFJmPTEwMTEsZWw9MTAxMixxaD0xMDEzLENuPTEwMTQsZW49MTAxNSxwcz0xMDE2LFloPTEwMTcsWmg9MTAxOCxRbj0xMDIwLENmPTEwMjEsSGU9MTAyMyxQZj0xMDI0LExmPTEwMjUsam49MTAyNixDaT0xMDI3LElmPTEwMjgsSmg9MTAyOSxVZj0xMDMwLCRoPTEwMzEsS2g9MTAzMyxMYT0zMzc3NixJYT0zMzc3NyxVYT0zMzc3OCxEYT0zMzc3OSx0Yz0zNTg0MCxlYz0zNTg0MSxuYz0zNTg0MixpYz0zNTg0MyxRaD0zNjE5NixzYz0zNzQ5MixyYz0zNzQ5NixhYz0zNzgwOCxvYz0zNzgwOSxsYz0zNzgxMCxjYz0zNzgxMSxoYz0zNzgxMix1Yz0zNzgxMyxkYz0zNzgxNCxmYz0zNzgxNSxwYz0zNzgxNixtYz0zNzgxNyxnYz0zNzgxOCxfYz0zNzgxOSx4Yz0zNzgyMCx2Yz0zNzgyMSxOYT0zNjQ5Mix5Yz0zNjQ5NCxNYz0zNjQ5NSxEZj0zNjI4MyxTYz0zNjI4NCxiYz0zNjI4NSxFYz0zNjI4NixOZj0yMjAwLE9mPTIyMDEsRmY9MjIwMixLcz0yMzAwLFFzPTIzMDEsT2E9MjMwMixiaT0yNDAwLEVpPTI0MDEsanM9MjQwMixubD0yNTAwLGpoPTI1MDEsVXA9MCxEcD0xLE5wPTIsdHU9M2UzLHRpPTMwMDEsQmY9MzIwMCx6Zj0zMjAxLGFpPTAsVmY9MSxxZT0iIix4ZT0ic3JnYiIsX249InNyZ2ItbGluZWFyIixpbD0iZGlzcGxheS1wMyIsRnI9ImRpc3BsYXktcDMtbGluZWFyIix0cj0ibGluZWFyIixzZT0ic3JnYiIsZXI9InJlYzcwOSIsbnI9InAzIixPcD0wLHZpPTc2ODAsRnA9NzY4MSxCcD03NjgyLHpwPTc2ODMsVnA9MzQwNTUsa3A9MzQwNTYsSHA9NTM4NixHcD01MTIsV3A9NTEzLFhwPTUxNCxxcD01MTUsWXA9NTE2LFpwPTUxNyxKcD01MTgsQWM9NTE5LGtmPTUxMixIZj01MTMsR2Y9NTE0LGV1PTUxNSxXZj01MTYsWGY9NTE3LHFmPTUxOCxZZj01MTksaXI9MzUwNDQsJHA9MzUwNDgsS3A9MzUwNDAsUXA9MzUwNDUsanA9MzUwNDksdG09MzUwNDEsZW09MzUwNDYsbm09MzUwNTAsaW09MzUwNDIsc209IjEwMCIsVGM9IjMwMCBlcyIsVmE9MTAzNSxtbj0yZTMsc3I9MjAwMSxsbj1jbGFzc3thZGRFdmVudExpc3RlbmVyKHQsZSl7dGhpcy5fbGlzdGVuZXJzPT09dm9pZCAwJiYodGhpcy5fbGlzdGVuZXJzPXt9KTtsZXQgbj10aGlzLl9saXN0ZW5lcnM7blt0XT09PXZvaWQgMCYmKG5bdF09W10pLG5bdF0uaW5kZXhPZihlKT09PS0xJiZuW3RdLnB1c2goZSl9aGFzRXZlbnRMaXN0ZW5lcih0LGUpe2lmKHRoaXMuX2xpc3RlbmVycz09PXZvaWQgMClyZXR1cm4hMTtsZXQgbj10aGlzLl9saXN0ZW5lcnM7cmV0dXJuIG5bdF0hPT12b2lkIDAmJm5bdF0uaW5kZXhPZihlKSE9PS0xfXJlbW92ZUV2ZW50TGlzdGVuZXIodCxlKXtpZih0aGlzLl9saXN0ZW5lcnM9PT12b2lkIDApcmV0dXJuO2xldCBpPXRoaXMuX2xpc3RlbmVyc1t0XTtpZihpIT09dm9pZCAwKXtsZXQgcj1pLmluZGV4T2YoZSk7ciE9PS0xJiZpLnNwbGljZShyLDEpfX1kaXNwYXRjaEV2ZW50KHQpe2lmKHRoaXMuX2xpc3RlbmVycz09PXZvaWQgMClyZXR1cm47bGV0IG49dGhpcy5fbGlzdGVuZXJzW3QudHlwZV07aWYobiE9PXZvaWQgMCl7dC50YXJnZXQ9dGhpcztsZXQgaT1uLnNsaWNlKDApO2ZvcihsZXQgcj0wLGE9aS5sZW5ndGg7cjxhO3IrKylpW3JdLmNhbGwodGhpcyx0KTt0LnRhcmdldD1udWxsfX19LFBlPVsiMDAiLCIwMSIsIjAyIiwiMDMiLCIwNCIsIjA1IiwiMDYiLCIwNyIsIjA4IiwiMDkiLCIwYSIsIjBiIiwiMGMiLCIwZCIsIjBlIiwiMGYiLCIxMCIsIjExIiwiMTIiLCIxMyIsIjE0IiwiMTUiLCIxNiIsIjE3IiwiMTgiLCIxOSIsIjFhIiwiMWIiLCIxYyIsIjFkIiwiMWUiLCIxZiIsIjIwIiwiMjEiLCIyMiIsIjIzIiwiMjQiLCIyNSIsIjI2IiwiMjciLCIyOCIsIjI5IiwiMmEiLCIyYiIsIjJjIiwiMmQiLCIyZSIsIjJmIiwiMzAiLCIzMSIsIjMyIiwiMzMiLCIzNCIsIjM1IiwiMzYiLCIzNyIsIjM4IiwiMzkiLCIzYSIsIjNiIiwiM2MiLCIzZCIsIjNlIiwiM2YiLCI0MCIsIjQxIiwiNDIiLCI0MyIsIjQ0IiwiNDUiLCI0NiIsIjQ3IiwiNDgiLCI0OSIsIjRhIiwiNGIiLCI0YyIsIjRkIiwiNGUiLCI0ZiIsIjUwIiwiNTEiLCI1MiIsIjUzIiwiNTQiLCI1NSIsIjU2IiwiNTciLCI1OCIsIjU5IiwiNWEiLCI1YiIsIjVjIiwiNWQiLCI1ZSIsIjVmIiwiNjAiLCI2MSIsIjYyIiwiNjMiLCI2NCIsIjY1IiwiNjYiLCI2NyIsIjY4IiwiNjkiLCI2YSIsIjZiIiwiNmMiLCI2ZCIsIjZlIiwiNmYiLCI3MCIsIjcxIiwiNzIiLCI3MyIsIjc0IiwiNzUiLCI3NiIsIjc3IiwiNzgiLCI3OSIsIjdhIiwiN2IiLCI3YyIsIjdkIiwiN2UiLCI3ZiIsIjgwIiwiODEiLCI4MiIsIjgzIiwiODQiLCI4NSIsIjg2IiwiODciLCI4OCIsIjg5IiwiOGEiLCI4YiIsIjhjIiwiOGQiLCI4ZSIsIjhmIiwiOTAiLCI5MSIsIjkyIiwiOTMiLCI5NCIsIjk1IiwiOTYiLCI5NyIsIjk4IiwiOTkiLCI5YSIsIjliIiwiOWMiLCI5ZCIsIjllIiwiOWYiLCJhMCIsImExIiwiYTIiLCJhMyIsImE0IiwiYTUiLCJhNiIsImE3IiwiYTgiLCJhOSIsImFhIiwiYWIiLCJhYyIsImFkIiwiYWUiLCJhZiIsImIwIiwiYjEiLCJiMiIsImIzIiwiYjQiLCJiNSIsImI2IiwiYjciLCJiOCIsImI5IiwiYmEiLCJiYiIsImJjIiwiYmQiLCJiZSIsImJmIiwiYzAiLCJjMSIsImMyIiwiYzMiLCJjNCIsImM1IiwiYzYiLCJjNyIsImM4IiwiYzkiLCJjYSIsImNiIiwiY2MiLCJjZCIsImNlIiwiY2YiLCJkMCIsImQxIiwiZDIiLCJkMyIsImQ0IiwiZDUiLCJkNiIsImQ3IiwiZDgiLCJkOSIsImRhIiwiZGIiLCJkYyIsImRkIiwiZGUiLCJkZiIsImUwIiwiZTEiLCJlMiIsImUzIiwiZTQiLCJlNSIsImU2IiwiZTciLCJlOCIsImU5IiwiZWEiLCJlYiIsImVjIiwiZWQiLCJlZSIsImVmIiwiZjAiLCJmMSIsImYyIiwiZjMiLCJmNCIsImY1IiwiZjYiLCJmNyIsImY4IiwiZjkiLCJmYSIsImZiIiwiZmMiLCJmZCIsImZlIiwiZmYiXSxwdT0xMjM0NTY3LHdpPU1hdGguUEkvMTgwLG1zPTE4MC9NYXRoLlBJO2Z1bmN0aW9uIFllKCl7bGV0IHM9TWF0aC5yYW5kb20oKSo0Mjk0OTY3Mjk1fDAsdD1NYXRoLnJhbmRvbSgpKjQyOTQ5NjcyOTV8MCxlPU1hdGgucmFuZG9tKCkqNDI5NDk2NzI5NXwwLG49TWF0aC5yYW5kb20oKSo0Mjk0OTY3Mjk1fDA7cmV0dXJuKFBlW3MmMjU1XStQZVtzPj44JjI1NV0rUGVbcz4+MTYmMjU1XStQZVtzPj4yNCYyNTVdKyItIitQZVt0JjI1NV0rUGVbdD4+OCYyNTVdKyItIitQZVt0Pj4xNiYxNXw2NF0rUGVbdD4+MjQmMjU1XSsiLSIrUGVbZSY2M3wxMjhdK1BlW2U+PjgmMjU1XSsiLSIrUGVbZT4+MTYmMjU1XStQZVtlPj4yNCYyNTVdK1BlW24mMjU1XStQZVtuPj44JjI1NV0rUGVbbj4+MTYmMjU1XStQZVtuPj4yNCYyNTVdKS50b0xvd2VyQ2FzZSgpfWZ1bmN0aW9uIHVlKHMsdCxlKXtyZXR1cm4gTWF0aC5tYXgodCxNYXRoLm1pbihlLHMpKX1mdW5jdGlvbiBudShzLHQpe3JldHVybihzJXQrdCkldH1mdW5jdGlvbiBybShzLHQsZSxuLGkpe3JldHVybiBuKyhzLXQpKihpLW4pLyhlLXQpfWZ1bmN0aW9uIGFtKHMsdCxlKXtyZXR1cm4gcyE9PXQ/KGUtcykvKHQtcyk6MH1mdW5jdGlvbiBIcyhzLHQsZSl7cmV0dXJuKDEtZSkqcytlKnR9ZnVuY3Rpb24gb20ocyx0LGUsbil7cmV0dXJuIEhzKHMsdCwxLU1hdGguZXhwKC1lKm4pKX1mdW5jdGlvbiBsbShzLHQ9MSl7cmV0dXJuIHQtTWF0aC5hYnMobnUocyx0KjIpLXQpfWZ1bmN0aW9uIGNtKHMsdCxlKXtyZXR1cm4gczw9dD8wOnM+PWU/MToocz0ocy10KS8oZS10KSxzKnMqKDMtMipzKSl9ZnVuY3Rpb24gaG0ocyx0LGUpe3JldHVybiBzPD10PzA6cz49ZT8xOihzPShzLXQpLyhlLXQpLHMqcypzKihzKihzKjYtMTUpKzEwKSl9ZnVuY3Rpb24gdW0ocyx0KXtyZXR1cm4gcytNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqKHQtcysxKSl9ZnVuY3Rpb24gZG0ocyx0KXtyZXR1cm4gcytNYXRoLnJhbmRvbSgpKih0LXMpfWZ1bmN0aW9uIGZtKHMpe3JldHVybiBzKiguNS1NYXRoLnJhbmRvbSgpKX1mdW5jdGlvbiBwbShzKXtzIT09dm9pZCAwJiYocHU9cyk7bGV0IHQ9cHUrPTE4MzE1NjU4MTM7cmV0dXJuIHQ9TWF0aC5pbXVsKHRedD4+PjE1LHR8MSksdF49dCtNYXRoLmltdWwodF50Pj4+Nyx0fDYxKSwoKHRedD4+PjE0KT4+PjApLzQyOTQ5NjcyOTZ9ZnVuY3Rpb24gbW0ocyl7cmV0dXJuIHMqd2l9ZnVuY3Rpb24gZ20ocyl7cmV0dXJuIHMqbXN9ZnVuY3Rpb24gd2Mocyl7cmV0dXJuKHMmcy0xKT09PTAmJnMhPT0wfWZ1bmN0aW9uIF9tKHMpe3JldHVybiBNYXRoLnBvdygyLE1hdGguY2VpbChNYXRoLmxvZyhzKS9NYXRoLkxOMikpfWZ1bmN0aW9uIGthKHMpe3JldHVybiBNYXRoLnBvdygyLE1hdGguZmxvb3IoTWF0aC5sb2cocykvTWF0aC5MTjIpKX1mdW5jdGlvbiB4bShzLHQsZSxuLGkpe2xldCByPU1hdGguY29zLGE9TWF0aC5zaW4sbz1yKGUvMiksbD1hKGUvMiksYz1yKCh0K24pLzIpLGg9YSgodCtuKS8yKSx1PXIoKHQtbikvMiksZD1hKCh0LW4pLzIpLGY9cigobi10KS8yKSxtPWEoKG4tdCkvMik7c3dpdGNoKGkpe2Nhc2UiWFlYIjpzLnNldChvKmgsbCp1LGwqZCxvKmMpO2JyZWFrO2Nhc2UiWVpZIjpzLnNldChsKmQsbypoLGwqdSxvKmMpO2JyZWFrO2Nhc2UiWlhaIjpzLnNldChsKnUsbCpkLG8qaCxvKmMpO2JyZWFrO2Nhc2UiWFpYIjpzLnNldChvKmgsbCptLGwqZixvKmMpO2JyZWFrO2Nhc2UiWVhZIjpzLnNldChsKmYsbypoLGwqbSxvKmMpO2JyZWFrO2Nhc2UiWllaIjpzLnNldChsKm0sbCpmLG8qaCxvKmMpO2JyZWFrO2RlZmF1bHQ6Y29uc29sZS53YXJuKCJUSFJFRS5NYXRoVXRpbHM6IC5zZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyKCkgZW5jb3VudGVyZWQgYW4gdW5rbm93biBvcmRlcjogIitpKX19ZnVuY3Rpb24gemUocyx0KXtzd2l0Y2godC5jb25zdHJ1Y3Rvcil7Y2FzZSBGbG9hdDMyQXJyYXk6cmV0dXJuIHM7Y2FzZSBVaW50MzJBcnJheTpyZXR1cm4gcy80Mjk0OTY3Mjk1O2Nhc2UgVWludDE2QXJyYXk6cmV0dXJuIHMvNjU1MzU7Y2FzZSBVaW50OEFycmF5OnJldHVybiBzLzI1NTtjYXNlIEludDMyQXJyYXk6cmV0dXJuIE1hdGgubWF4KHMvMjE0NzQ4MzY0NywtMSk7Y2FzZSBJbnQxNkFycmF5OnJldHVybiBNYXRoLm1heChzLzMyNzY3LC0xKTtjYXNlIEludDhBcnJheTpyZXR1cm4gTWF0aC5tYXgocy8xMjcsLTEpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGNvbXBvbmVudCB0eXBlLiIpfX1mdW5jdGlvbiBOdChzLHQpe3N3aXRjaCh0LmNvbnN0cnVjdG9yKXtjYXNlIEZsb2F0MzJBcnJheTpyZXR1cm4gcztjYXNlIFVpbnQzMkFycmF5OnJldHVybiBNYXRoLnJvdW5kKHMqNDI5NDk2NzI5NSk7Y2FzZSBVaW50MTZBcnJheTpyZXR1cm4gTWF0aC5yb3VuZChzKjY1NTM1KTtjYXNlIFVpbnQ4QXJyYXk6cmV0dXJuIE1hdGgucm91bmQocyoyNTUpO2Nhc2UgSW50MzJBcnJheTpyZXR1cm4gTWF0aC5yb3VuZChzKjIxNDc0ODM2NDcpO2Nhc2UgSW50MTZBcnJheTpyZXR1cm4gTWF0aC5yb3VuZChzKjMyNzY3KTtjYXNlIEludDhBcnJheTpyZXR1cm4gTWF0aC5yb3VuZChzKjEyNyk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgY29tcG9uZW50IHR5cGUuIil9fXZhciB2bT17REVHMlJBRDp3aSxSQUQyREVHOm1zLGdlbmVyYXRlVVVJRDpZZSxjbGFtcDp1ZSxldWNsaWRlYW5Nb2R1bG86bnUsbWFwTGluZWFyOnJtLGludmVyc2VMZXJwOmFtLGxlcnA6SHMsZGFtcDpvbSxwaW5ncG9uZzpsbSxzbW9vdGhzdGVwOmNtLHNtb290aGVyc3RlcDpobSxyYW5kSW50OnVtLHJhbmRGbG9hdDpkbSxyYW5kRmxvYXRTcHJlYWQ6Zm0sc2VlZGVkUmFuZG9tOnBtLGRlZ1RvUmFkOm1tLHJhZFRvRGVnOmdtLGlzUG93ZXJPZlR3bzp3YyxjZWlsUG93ZXJPZlR3bzpfbSxmbG9vclBvd2VyT2ZUd286a2Esc2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlcjp4bSxub3JtYWxpemU6TnQsZGVub3JtYWxpemU6emV9LFo9Y2xhc3Mgc3tjb25zdHJ1Y3Rvcih0PTAsZT0wKXtzLnByb3RvdHlwZS5pc1ZlY3RvcjI9ITAsdGhpcy54PXQsdGhpcy55PWV9Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXMueH1zZXQgd2lkdGgodCl7dGhpcy54PXR9Z2V0IGhlaWdodCgpe3JldHVybiB0aGlzLnl9c2V0IGhlaWdodCh0KXt0aGlzLnk9dH1zZXQodCxlKXtyZXR1cm4gdGhpcy54PXQsdGhpcy55PWUsdGhpc31zZXRTY2FsYXIodCl7cmV0dXJuIHRoaXMueD10LHRoaXMueT10LHRoaXN9c2V0WCh0KXtyZXR1cm4gdGhpcy54PXQsdGhpc31zZXRZKHQpe3JldHVybiB0aGlzLnk9dCx0aGlzfXNldENvbXBvbmVudCh0LGUpe3N3aXRjaCh0KXtjYXNlIDA6dGhpcy54PWU7YnJlYWs7Y2FzZSAxOnRoaXMueT1lO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICIrdCl9cmV0dXJuIHRoaXN9Z2V0Q29tcG9uZW50KHQpe3N3aXRjaCh0KXtjYXNlIDA6cmV0dXJuIHRoaXMueDtjYXNlIDE6cmV0dXJuIHRoaXMueTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAiK3QpfX1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLngsdGhpcy55KX1jb3B5KHQpe3JldHVybiB0aGlzLng9dC54LHRoaXMueT10LnksdGhpc31hZGQodCl7cmV0dXJuIHRoaXMueCs9dC54LHRoaXMueSs9dC55LHRoaXN9YWRkU2NhbGFyKHQpe3JldHVybiB0aGlzLngrPXQsdGhpcy55Kz10LHRoaXN9YWRkVmVjdG9ycyh0LGUpe3JldHVybiB0aGlzLng9dC54K2UueCx0aGlzLnk9dC55K2UueSx0aGlzfWFkZFNjYWxlZFZlY3Rvcih0LGUpe3JldHVybiB0aGlzLngrPXQueCplLHRoaXMueSs9dC55KmUsdGhpc31zdWIodCl7cmV0dXJuIHRoaXMueC09dC54LHRoaXMueS09dC55LHRoaXN9c3ViU2NhbGFyKHQpe3JldHVybiB0aGlzLngtPXQsdGhpcy55LT10LHRoaXN9c3ViVmVjdG9ycyh0LGUpe3JldHVybiB0aGlzLng9dC54LWUueCx0aGlzLnk9dC55LWUueSx0aGlzfW11bHRpcGx5KHQpe3JldHVybiB0aGlzLngqPXQueCx0aGlzLnkqPXQueSx0aGlzfW11bHRpcGx5U2NhbGFyKHQpe3JldHVybiB0aGlzLngqPXQsdGhpcy55Kj10LHRoaXN9ZGl2aWRlKHQpe3JldHVybiB0aGlzLngvPXQueCx0aGlzLnkvPXQueSx0aGlzfWRpdmlkZVNjYWxhcih0KXtyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcigxL3QpfWFwcGx5TWF0cml4Myh0KXtsZXQgZT10aGlzLngsbj10aGlzLnksaT10LmVsZW1lbnRzO3JldHVybiB0aGlzLng9aVswXSplK2lbM10qbitpWzZdLHRoaXMueT1pWzFdKmUraVs0XSpuK2lbN10sdGhpc31taW4odCl7cmV0dXJuIHRoaXMueD1NYXRoLm1pbih0aGlzLngsdC54KSx0aGlzLnk9TWF0aC5taW4odGhpcy55LHQueSksdGhpc31tYXgodCl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0aGlzLngsdC54KSx0aGlzLnk9TWF0aC5tYXgodGhpcy55LHQueSksdGhpc31jbGFtcCh0LGUpe3JldHVybiB0aGlzLng9TWF0aC5tYXgodC54LE1hdGgubWluKGUueCx0aGlzLngpKSx0aGlzLnk9TWF0aC5tYXgodC55LE1hdGgubWluKGUueSx0aGlzLnkpKSx0aGlzfWNsYW1wU2NhbGFyKHQsZSl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0LE1hdGgubWluKGUsdGhpcy54KSksdGhpcy55PU1hdGgubWF4KHQsTWF0aC5taW4oZSx0aGlzLnkpKSx0aGlzfWNsYW1wTGVuZ3RoKHQsZSl7bGV0IG49dGhpcy5sZW5ndGgoKTtyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIobnx8MSkubXVsdGlwbHlTY2FsYXIoTWF0aC5tYXgodCxNYXRoLm1pbihlLG4pKSl9Zmxvb3IoKXtyZXR1cm4gdGhpcy54PU1hdGguZmxvb3IodGhpcy54KSx0aGlzLnk9TWF0aC5mbG9vcih0aGlzLnkpLHRoaXN9Y2VpbCgpe3JldHVybiB0aGlzLng9TWF0aC5jZWlsKHRoaXMueCksdGhpcy55PU1hdGguY2VpbCh0aGlzLnkpLHRoaXN9cm91bmQoKXtyZXR1cm4gdGhpcy54PU1hdGgucm91bmQodGhpcy54KSx0aGlzLnk9TWF0aC5yb3VuZCh0aGlzLnkpLHRoaXN9cm91bmRUb1plcm8oKXtyZXR1cm4gdGhpcy54PU1hdGgudHJ1bmModGhpcy54KSx0aGlzLnk9TWF0aC50cnVuYyh0aGlzLnkpLHRoaXN9bmVnYXRlKCl7cmV0dXJuIHRoaXMueD0tdGhpcy54LHRoaXMueT0tdGhpcy55LHRoaXN9ZG90KHQpe3JldHVybiB0aGlzLngqdC54K3RoaXMueSp0Lnl9Y3Jvc3ModCl7cmV0dXJuIHRoaXMueCp0LnktdGhpcy55KnQueH1sZW5ndGhTcSgpe3JldHVybiB0aGlzLngqdGhpcy54K3RoaXMueSp0aGlzLnl9bGVuZ3RoKCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLngqdGhpcy54K3RoaXMueSp0aGlzLnkpfW1hbmhhdHRhbkxlbmd0aCgpe3JldHVybiBNYXRoLmFicyh0aGlzLngpK01hdGguYWJzKHRoaXMueSl9bm9ybWFsaXplKCl7cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCl8fDEpfWFuZ2xlKCl7cmV0dXJuIE1hdGguYXRhbjIoLXRoaXMueSwtdGhpcy54KStNYXRoLlBJfWFuZ2xlVG8odCl7bGV0IGU9TWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3EoKSp0Lmxlbmd0aFNxKCkpO2lmKGU9PT0wKXJldHVybiBNYXRoLlBJLzI7bGV0IG49dGhpcy5kb3QodCkvZTtyZXR1cm4gTWF0aC5hY29zKHVlKG4sLTEsMSkpfWRpc3RhbmNlVG8odCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKHQpKX1kaXN0YW5jZVRvU3F1YXJlZCh0KXtsZXQgZT10aGlzLngtdC54LG49dGhpcy55LXQueTtyZXR1cm4gZSplK24qbn1tYW5oYXR0YW5EaXN0YW5jZVRvKHQpe3JldHVybiBNYXRoLmFicyh0aGlzLngtdC54KStNYXRoLmFicyh0aGlzLnktdC55KX1zZXRMZW5ndGgodCl7cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIodCl9bGVycCh0LGUpe3JldHVybiB0aGlzLngrPSh0LngtdGhpcy54KSplLHRoaXMueSs9KHQueS10aGlzLnkpKmUsdGhpc31sZXJwVmVjdG9ycyh0LGUsbil7cmV0dXJuIHRoaXMueD10LngrKGUueC10LngpKm4sdGhpcy55PXQueSsoZS55LXQueSkqbix0aGlzfWVxdWFscyh0KXtyZXR1cm4gdC54PT09dGhpcy54JiZ0Lnk9PT10aGlzLnl9ZnJvbUFycmF5KHQsZT0wKXtyZXR1cm4gdGhpcy54PXRbZV0sdGhpcy55PXRbZSsxXSx0aGlzfXRvQXJyYXkodD1bXSxlPTApe3JldHVybiB0W2VdPXRoaXMueCx0W2UrMV09dGhpcy55LHR9ZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LGUpe3JldHVybiB0aGlzLng9dC5nZXRYKGUpLHRoaXMueT10LmdldFkoZSksdGhpc31yb3RhdGVBcm91bmQodCxlKXtsZXQgbj1NYXRoLmNvcyhlKSxpPU1hdGguc2luKGUpLHI9dGhpcy54LXQueCxhPXRoaXMueS10Lnk7cmV0dXJuIHRoaXMueD1yKm4tYSppK3QueCx0aGlzLnk9cippK2Eqbit0LnksdGhpc31yYW5kb20oKXtyZXR1cm4gdGhpcy54PU1hdGgucmFuZG9tKCksdGhpcy55PU1hdGgucmFuZG9tKCksdGhpc30qW1N5bWJvbC5pdGVyYXRvcl0oKXt5aWVsZCB0aGlzLngseWllbGQgdGhpcy55fX0sa3Q9Y2xhc3Mgc3tjb25zdHJ1Y3Rvcih0LGUsbixpLHIsYSxvLGwsYyl7cy5wcm90b3R5cGUuaXNNYXRyaXgzPSEwLHRoaXMuZWxlbWVudHM9WzEsMCwwLDAsMSwwLDAsMCwxXSx0IT09dm9pZCAwJiZ0aGlzLnNldCh0LGUsbixpLHIsYSxvLGwsYyl9c2V0KHQsZSxuLGkscixhLG8sbCxjKXtsZXQgaD10aGlzLmVsZW1lbnRzO3JldHVybiBoWzBdPXQsaFsxXT1pLGhbMl09byxoWzNdPWUsaFs0XT1yLGhbNV09bCxoWzZdPW4saFs3XT1hLGhbOF09Yyx0aGlzfWlkZW50aXR5KCl7cmV0dXJuIHRoaXMuc2V0KDEsMCwwLDAsMSwwLDAsMCwxKSx0aGlzfWNvcHkodCl7bGV0IGU9dGhpcy5lbGVtZW50cyxuPXQuZWxlbWVudHM7cmV0dXJuIGVbMF09blswXSxlWzFdPW5bMV0sZVsyXT1uWzJdLGVbM109blszXSxlWzRdPW5bNF0sZVs1XT1uWzVdLGVbNl09bls2XSxlWzddPW5bN10sZVs4XT1uWzhdLHRoaXN9ZXh0cmFjdEJhc2lzKHQsZSxuKXtyZXR1cm4gdC5zZXRGcm9tTWF0cml4M0NvbHVtbih0aGlzLDApLGUuc2V0RnJvbU1hdHJpeDNDb2x1bW4odGhpcywxKSxuLnNldEZyb21NYXRyaXgzQ29sdW1uKHRoaXMsMiksdGhpc31zZXRGcm9tTWF0cml4NCh0KXtsZXQgZT10LmVsZW1lbnRzO3JldHVybiB0aGlzLnNldChlWzBdLGVbNF0sZVs4XSxlWzFdLGVbNV0sZVs5XSxlWzJdLGVbNl0sZVsxMF0pLHRoaXN9bXVsdGlwbHkodCl7cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyh0aGlzLHQpfXByZW11bHRpcGx5KHQpe3JldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXModCx0aGlzKX1tdWx0aXBseU1hdHJpY2VzKHQsZSl7bGV0IG49dC5lbGVtZW50cyxpPWUuZWxlbWVudHMscj10aGlzLmVsZW1lbnRzLGE9blswXSxvPW5bM10sbD1uWzZdLGM9blsxXSxoPW5bNF0sdT1uWzddLGQ9blsyXSxmPW5bNV0sbT1uWzhdLF89aVswXSxnPWlbM10scD1pWzZdLHY9aVsxXSx4PWlbNF0sTT1pWzddLEM9aVsyXSxBPWlbNV0sVD1pWzhdO3JldHVybiByWzBdPWEqXytvKnYrbCpDLHJbM109YSpnK28qeCtsKkEscls2XT1hKnArbypNK2wqVCxyWzFdPWMqXytoKnYrdSpDLHJbNF09YypnK2gqeCt1KkEscls3XT1jKnAraCpNK3UqVCxyWzJdPWQqXytmKnYrbSpDLHJbNV09ZCpnK2YqeCttKkEscls4XT1kKnArZipNK20qVCx0aGlzfW11bHRpcGx5U2NhbGFyKHQpe2xldCBlPXRoaXMuZWxlbWVudHM7cmV0dXJuIGVbMF0qPXQsZVszXSo9dCxlWzZdKj10LGVbMV0qPXQsZVs0XSo9dCxlWzddKj10LGVbMl0qPXQsZVs1XSo9dCxlWzhdKj10LHRoaXN9ZGV0ZXJtaW5hbnQoKXtsZXQgdD10aGlzLmVsZW1lbnRzLGU9dFswXSxuPXRbMV0saT10WzJdLHI9dFszXSxhPXRbNF0sbz10WzVdLGw9dFs2XSxjPXRbN10saD10WzhdO3JldHVybiBlKmEqaC1lKm8qYy1uKnIqaCtuKm8qbCtpKnIqYy1pKmEqbH1pbnZlcnQoKXtsZXQgdD10aGlzLmVsZW1lbnRzLGU9dFswXSxuPXRbMV0saT10WzJdLHI9dFszXSxhPXRbNF0sbz10WzVdLGw9dFs2XSxjPXRbN10saD10WzhdLHU9aCphLW8qYyxkPW8qbC1oKnIsZj1jKnItYSpsLG09ZSp1K24qZCtpKmY7aWYobT09PTApcmV0dXJuIHRoaXMuc2V0KDAsMCwwLDAsMCwwLDAsMCwwKTtsZXQgXz0xL207cmV0dXJuIHRbMF09dSpfLHRbMV09KGkqYy1oKm4pKl8sdFsyXT0obypuLWkqYSkqXyx0WzNdPWQqXyx0WzRdPShoKmUtaSpsKSpfLHRbNV09KGkqci1vKmUpKl8sdFs2XT1mKl8sdFs3XT0obipsLWMqZSkqXyx0WzhdPShhKmUtbipyKSpfLHRoaXN9dHJhbnNwb3NlKCl7bGV0IHQsZT10aGlzLmVsZW1lbnRzO3JldHVybiB0PWVbMV0sZVsxXT1lWzNdLGVbM109dCx0PWVbMl0sZVsyXT1lWzZdLGVbNl09dCx0PWVbNV0sZVs1XT1lWzddLGVbN109dCx0aGlzfWdldE5vcm1hbE1hdHJpeCh0KXtyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4NCh0KS5pbnZlcnQoKS50cmFuc3Bvc2UoKX10cmFuc3Bvc2VJbnRvQXJyYXkodCl7bGV0IGU9dGhpcy5lbGVtZW50cztyZXR1cm4gdFswXT1lWzBdLHRbMV09ZVszXSx0WzJdPWVbNl0sdFszXT1lWzFdLHRbNF09ZVs0XSx0WzVdPWVbN10sdFs2XT1lWzJdLHRbN109ZVs1XSx0WzhdPWVbOF0sdGhpc31zZXRVdlRyYW5zZm9ybSh0LGUsbixpLHIsYSxvKXtsZXQgbD1NYXRoLmNvcyhyKSxjPU1hdGguc2luKHIpO3JldHVybiB0aGlzLnNldChuKmwsbipjLC1uKihsKmErYypvKSthK3QsLWkqYyxpKmwsLWkqKC1jKmErbCpvKStvK2UsMCwwLDEpLHRoaXN9c2NhbGUodCxlKXtyZXR1cm4gdGhpcy5wcmVtdWx0aXBseSh1bC5tYWtlU2NhbGUodCxlKSksdGhpc31yb3RhdGUodCl7cmV0dXJuIHRoaXMucHJlbXVsdGlwbHkodWwubWFrZVJvdGF0aW9uKC10KSksdGhpc310cmFuc2xhdGUodCxlKXtyZXR1cm4gdGhpcy5wcmVtdWx0aXBseSh1bC5tYWtlVHJhbnNsYXRpb24odCxlKSksdGhpc31tYWtlVHJhbnNsYXRpb24odCxlKXtyZXR1cm4gdC5pc1ZlY3RvcjI/dGhpcy5zZXQoMSwwLHQueCwwLDEsdC55LDAsMCwxKTp0aGlzLnNldCgxLDAsdCwwLDEsZSwwLDAsMSksdGhpc31tYWtlUm90YXRpb24odCl7bGV0IGU9TWF0aC5jb3ModCksbj1NYXRoLnNpbih0KTtyZXR1cm4gdGhpcy5zZXQoZSwtbiwwLG4sZSwwLDAsMCwxKSx0aGlzfW1ha2VTY2FsZSh0LGUpe3JldHVybiB0aGlzLnNldCh0LDAsMCwwLGUsMCwwLDAsMSksdGhpc31lcXVhbHModCl7bGV0IGU9dGhpcy5lbGVtZW50cyxuPXQuZWxlbWVudHM7Zm9yKGxldCBpPTA7aTw5O2krKylpZihlW2ldIT09bltpXSlyZXR1cm4hMTtyZXR1cm4hMH1mcm9tQXJyYXkodCxlPTApe2ZvcihsZXQgbj0wO248OTtuKyspdGhpcy5lbGVtZW50c1tuXT10W24rZV07cmV0dXJuIHRoaXN9dG9BcnJheSh0PVtdLGU9MCl7bGV0IG49dGhpcy5lbGVtZW50cztyZXR1cm4gdFtlXT1uWzBdLHRbZSsxXT1uWzFdLHRbZSsyXT1uWzJdLHRbZSszXT1uWzNdLHRbZSs0XT1uWzRdLHRbZSs1XT1uWzVdLHRbZSs2XT1uWzZdLHRbZSs3XT1uWzddLHRbZSs4XT1uWzhdLHR9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5mcm9tQXJyYXkodGhpcy5lbGVtZW50cyl9fSx1bD1uZXcga3Q7ZnVuY3Rpb24gWmYocyl7Zm9yKGxldCB0PXMubGVuZ3RoLTE7dD49MDstLXQpaWYoc1t0XT49NjU1MzUpcmV0dXJuITA7cmV0dXJuITF9dmFyIHltPXtJbnQ4QXJyYXksVWludDhBcnJheSxVaW50OENsYW1wZWRBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheX07ZnVuY3Rpb24gbHMocyx0KXtyZXR1cm4gbmV3IHltW3NdKHQpfWZ1bmN0aW9uIHJyKHMpe3JldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiLHMpfWZ1bmN0aW9uIEpmKCl7bGV0IHM9cnIoImNhbnZhcyIpO3JldHVybiBzLnN0eWxlLmRpc3BsYXk9ImJsb2NrIixzfXZhciBtdT17fTtmdW5jdGlvbiBSaShzKXtzIGluIG11fHwobXVbc109ITAsY29uc29sZS53YXJuKHMpKX12YXIgZ3U9bmV3IGt0KCkuc2V0KC44MjI0NjIxLC4xNzc1MzgsMCwuMDMzMTk0MSwuOTY2ODA1OCwwLC4wMTcwODI3LC4wNzIzOTc0LC45MTA1MTk5KSxfdT1uZXcga3QoKS5zZXQoMS4yMjQ5NDAxLC0uMjI0OTQwNCwwLC0uMDQyMDU2OSwxLjA0MjA1NzEsMCwtLjAxOTYzNzYsLS4wNzg2MzYxLDEuMDk4MjczNSksVnI9e1tfbl06e3RyYW5zZmVyOnRyLHByaW1hcmllczplcix0b1JlZmVyZW5jZTpzPT5zLGZyb21SZWZlcmVuY2U6cz0+c30sW3hlXTp7dHJhbnNmZXI6c2UscHJpbWFyaWVzOmVyLHRvUmVmZXJlbmNlOnM9PnMuY29udmVydFNSR0JUb0xpbmVhcigpLGZyb21SZWZlcmVuY2U6cz0+cy5jb252ZXJ0TGluZWFyVG9TUkdCKCl9LFtGcl06e3RyYW5zZmVyOnRyLHByaW1hcmllczpucix0b1JlZmVyZW5jZTpzPT5zLmFwcGx5TWF0cml4MyhfdSksZnJvbVJlZmVyZW5jZTpzPT5zLmFwcGx5TWF0cml4MyhndSl9LFtpbF06e3RyYW5zZmVyOnNlLHByaW1hcmllczpucix0b1JlZmVyZW5jZTpzPT5zLmNvbnZlcnRTUkdCVG9MaW5lYXIoKS5hcHBseU1hdHJpeDMoX3UpLGZyb21SZWZlcmVuY2U6cz0+cy5hcHBseU1hdHJpeDMoZ3UpLmNvbnZlcnRMaW5lYXJUb1NSR0IoKX19LE1tPW5ldyBTZXQoW19uLEZyXSksanQ9e2VuYWJsZWQ6ITAsX3dvcmtpbmdDb2xvclNwYWNlOl9uLGdldCB3b3JraW5nQ29sb3JTcGFjZSgpe3JldHVybiB0aGlzLl93b3JraW5nQ29sb3JTcGFjZX0sc2V0IHdvcmtpbmdDb2xvclNwYWNlKHMpe2lmKCFNbS5oYXMocykpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB3b3JraW5nIGNvbG9yIHNwYWNlLCAiJHtzfSIuYCk7dGhpcy5fd29ya2luZ0NvbG9yU3BhY2U9c30sY29udmVydDpmdW5jdGlvbihzLHQsZSl7aWYodGhpcy5lbmFibGVkPT09ITF8fHQ9PT1lfHwhdHx8IWUpcmV0dXJuIHM7bGV0IG49VnJbdF0udG9SZWZlcmVuY2UsaT1WcltlXS5mcm9tUmVmZXJlbmNlO3JldHVybiBpKG4ocykpfSxmcm9tV29ya2luZ0NvbG9yU3BhY2U6ZnVuY3Rpb24ocyx0KXtyZXR1cm4gdGhpcy5jb252ZXJ0KHMsdGhpcy5fd29ya2luZ0NvbG9yU3BhY2UsdCl9LHRvV29ya2luZ0NvbG9yU3BhY2U6ZnVuY3Rpb24ocyx0KXtyZXR1cm4gdGhpcy5jb252ZXJ0KHMsdCx0aGlzLl93b3JraW5nQ29sb3JTcGFjZSl9LGdldFByaW1hcmllczpmdW5jdGlvbihzKXtyZXR1cm4gVnJbc10ucHJpbWFyaWVzfSxnZXRUcmFuc2ZlcjpmdW5jdGlvbihzKXtyZXR1cm4gcz09PXFlP3RyOlZyW3NdLnRyYW5zZmVyfX07ZnVuY3Rpb24gZHMocyl7cmV0dXJuIHM8LjA0MDQ1P3MqLjA3NzM5OTM4MDg6TWF0aC5wb3cocyouOTQ3ODY3Mjk4NisuMDUyMTMyNzAxNCwyLjQpfWZ1bmN0aW9uIGRsKHMpe3JldHVybiBzPC4wMDMxMzA4P3MqMTIuOTI6MS4wNTUqTWF0aC5wb3cocywuNDE2NjYpLS4wNTV9dmFyIGtpLGFyPWNsYXNze3N0YXRpYyBnZXREYXRhVVJMKHQpe2lmKC9eZGF0YTovaS50ZXN0KHQuc3JjKXx8dHlwZW9mIEhUTUxDYW52YXNFbGVtZW50PiJ1IilyZXR1cm4gdC5zcmM7bGV0IGU7aWYodCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KWU9dDtlbHNle2tpPT09dm9pZCAwJiYoa2k9cnIoImNhbnZhcyIpKSxraS53aWR0aD10LndpZHRoLGtpLmhlaWdodD10LmhlaWdodDtsZXQgbj1raS5nZXRDb250ZXh0KCIyZCIpO3QgaW5zdGFuY2VvZiBJbWFnZURhdGE/bi5wdXRJbWFnZURhdGEodCwwLDApOm4uZHJhd0ltYWdlKHQsMCwwLHQud2lkdGgsdC5oZWlnaHQpLGU9a2l9cmV0dXJuIGUud2lkdGg+MjA0OHx8ZS5oZWlnaHQ+MjA0OD8oY29uc29sZS53YXJuKCJUSFJFRS5JbWFnZVV0aWxzLmdldERhdGFVUkw6IEltYWdlIGNvbnZlcnRlZCB0byBqcGcgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMiLHQpLGUudG9EYXRhVVJMKCJpbWFnZS9qcGVnIiwuNikpOmUudG9EYXRhVVJMKCJpbWFnZS9wbmciKX1zdGF0aWMgc1JHQlRvTGluZWFyKHQpe2lmKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50PCJ1IiYmdCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnR8fHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudDwidSImJnQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudHx8dHlwZW9mIEltYWdlQml0bWFwPCJ1IiYmdCBpbnN0YW5jZW9mIEltYWdlQml0bWFwKXtsZXQgZT1ycigiY2FudmFzIik7ZS53aWR0aD10LndpZHRoLGUuaGVpZ2h0PXQuaGVpZ2h0O2xldCBuPWUuZ2V0Q29udGV4dCgiMmQiKTtuLmRyYXdJbWFnZSh0LDAsMCx0LndpZHRoLHQuaGVpZ2h0KTtsZXQgaT1uLmdldEltYWdlRGF0YSgwLDAsdC53aWR0aCx0LmhlaWdodCkscj1pLmRhdGE7Zm9yKGxldCBhPTA7YTxyLmxlbmd0aDthKyspclthXT1kcyhyW2FdLzI1NSkqMjU1O3JldHVybiBuLnB1dEltYWdlRGF0YShpLDAsMCksZX1lbHNlIGlmKHQuZGF0YSl7bGV0IGU9dC5kYXRhLnNsaWNlKDApO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKWUgaW5zdGFuY2VvZiBVaW50OEFycmF5fHxlIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXk/ZVtuXT1NYXRoLmZsb29yKGRzKGVbbl0vMjU1KSoyNTUpOmVbbl09ZHMoZVtuXSk7cmV0dXJue2RhdGE6ZSx3aWR0aDp0LndpZHRoLGhlaWdodDp0LmhlaWdodH19ZWxzZSByZXR1cm4gY29uc29sZS53YXJuKCJUSFJFRS5JbWFnZVV0aWxzLnNSR0JUb0xpbmVhcigpOiBVbnN1cHBvcnRlZCBpbWFnZSB0eXBlLiBObyBjb2xvciBzcGFjZSBjb252ZXJzaW9uIGFwcGxpZWQuIiksdH19LFNtPTAsUG49Y2xhc3N7Y29uc3RydWN0b3IodD1udWxsKXt0aGlzLmlzU291cmNlPSEwLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJpZCIse3ZhbHVlOlNtKyt9KSx0aGlzLnV1aWQ9WWUoKSx0aGlzLmRhdGE9dCx0aGlzLmRhdGFSZWFkeT0hMCx0aGlzLnZlcnNpb249MH1zZXQgbmVlZHNVcGRhdGUodCl7dD09PSEwJiZ0aGlzLnZlcnNpb24rK310b0pTT04odCl7bGV0IGU9dD09PXZvaWQgMHx8dHlwZW9mIHQ9PSJzdHJpbmciO2lmKCFlJiZ0LmltYWdlc1t0aGlzLnV1aWRdIT09dm9pZCAwKXJldHVybiB0LmltYWdlc1t0aGlzLnV1aWRdO2xldCBuPXt1dWlkOnRoaXMudXVpZCx1cmw6IiJ9LGk9dGhpcy5kYXRhO2lmKGkhPT1udWxsKXtsZXQgcjtpZihBcnJheS5pc0FycmF5KGkpKXtyPVtdO2ZvcihsZXQgYT0wLG89aS5sZW5ndGg7YTxvO2ErKylpW2FdLmlzRGF0YVRleHR1cmU/ci5wdXNoKGZsKGlbYV0uaW1hZ2UpKTpyLnB1c2goZmwoaVthXSkpfWVsc2Ugcj1mbChpKTtuLnVybD1yfXJldHVybiBlfHwodC5pbWFnZXNbdGhpcy51dWlkXT1uKSxufX07ZnVuY3Rpb24gZmwocyl7cmV0dXJuIHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50PCJ1IiYmcyBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnR8fHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudDwidSImJnMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudHx8dHlwZW9mIEltYWdlQml0bWFwPCJ1IiYmcyBpbnN0YW5jZW9mIEltYWdlQml0bWFwP2FyLmdldERhdGFVUkwocyk6cy5kYXRhP3tkYXRhOkFycmF5LmZyb20ocy5kYXRhKSx3aWR0aDpzLndpZHRoLGhlaWdodDpzLmhlaWdodCx0eXBlOnMuZGF0YS5jb25zdHJ1Y3Rvci5uYW1lfTooY29uc29sZS53YXJuKCJUSFJFRS5UZXh0dXJlOiBVbmFibGUgdG8gc2VyaWFsaXplIFRleHR1cmUuIikse30pfXZhciBibT0wLF9lPWNsYXNzIHMgZXh0ZW5kcyBsbntjb25zdHJ1Y3Rvcih0PXMuREVGQVVMVF9JTUFHRSxlPXMuREVGQVVMVF9NQVBQSU5HLG49VWUsaT1VZSxyPW9lLGE9cG4sbz1IZSxsPU5uLGM9cy5ERUZBVUxUX0FOSVNPVFJPUFksaD1xZSl7c3VwZXIoKSx0aGlzLmlzVGV4dHVyZT0hMCxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiaWQiLHt2YWx1ZTpibSsrfSksdGhpcy51dWlkPVllKCksdGhpcy5uYW1lPSIiLHRoaXMuc291cmNlPW5ldyBQbih0KSx0aGlzLm1pcG1hcHM9W10sdGhpcy5tYXBwaW5nPWUsdGhpcy5jaGFubmVsPTAsdGhpcy53cmFwUz1uLHRoaXMud3JhcFQ9aSx0aGlzLm1hZ0ZpbHRlcj1yLHRoaXMubWluRmlsdGVyPWEsdGhpcy5hbmlzb3Ryb3B5PWMsdGhpcy5mb3JtYXQ9byx0aGlzLmludGVybmFsRm9ybWF0PW51bGwsdGhpcy50eXBlPWwsdGhpcy5vZmZzZXQ9bmV3IFooMCwwKSx0aGlzLnJlcGVhdD1uZXcgWigxLDEpLHRoaXMuY2VudGVyPW5ldyBaKDAsMCksdGhpcy5yb3RhdGlvbj0wLHRoaXMubWF0cml4QXV0b1VwZGF0ZT0hMCx0aGlzLm1hdHJpeD1uZXcga3QsdGhpcy5nZW5lcmF0ZU1pcG1hcHM9ITAsdGhpcy5wcmVtdWx0aXBseUFscGhhPSExLHRoaXMuZmxpcFk9ITAsdGhpcy51bnBhY2tBbGlnbm1lbnQ9NCx0eXBlb2YgaD09InN0cmluZyI/dGhpcy5jb2xvclNwYWNlPWg6KFJpKCJUSFJFRS5UZXh0dXJlOiBQcm9wZXJ0eSAuZW5jb2RpbmcgaGFzIGJlZW4gcmVwbGFjZWQgYnkgLmNvbG9yU3BhY2UuIiksdGhpcy5jb2xvclNwYWNlPWg9PT10aT94ZTpxZSksdGhpcy51c2VyRGF0YT17fSx0aGlzLnZlcnNpb249MCx0aGlzLm9uVXBkYXRlPW51bGwsdGhpcy5pc1JlbmRlclRhcmdldFRleHR1cmU9ITEsdGhpcy5uZWVkc1BNUkVNVXBkYXRlPSExfWdldCBpbWFnZSgpe3JldHVybiB0aGlzLnNvdXJjZS5kYXRhfXNldCBpbWFnZSh0PW51bGwpe3RoaXMuc291cmNlLmRhdGE9dH11cGRhdGVNYXRyaXgoKXt0aGlzLm1hdHJpeC5zZXRVdlRyYW5zZm9ybSh0aGlzLm9mZnNldC54LHRoaXMub2Zmc2V0LnksdGhpcy5yZXBlYXQueCx0aGlzLnJlcGVhdC55LHRoaXMucm90YXRpb24sdGhpcy5jZW50ZXIueCx0aGlzLmNlbnRlci55KX1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyl9Y29weSh0KXtyZXR1cm4gdGhpcy5uYW1lPXQubmFtZSx0aGlzLnNvdXJjZT10LnNvdXJjZSx0aGlzLm1pcG1hcHM9dC5taXBtYXBzLnNsaWNlKDApLHRoaXMubWFwcGluZz10Lm1hcHBpbmcsdGhpcy5jaGFubmVsPXQuY2hhbm5lbCx0aGlzLndyYXBTPXQud3JhcFMsdGhpcy53cmFwVD10LndyYXBULHRoaXMubWFnRmlsdGVyPXQubWFnRmlsdGVyLHRoaXMubWluRmlsdGVyPXQubWluRmlsdGVyLHRoaXMuYW5pc290cm9weT10LmFuaXNvdHJvcHksdGhpcy5mb3JtYXQ9dC5mb3JtYXQsdGhpcy5pbnRlcm5hbEZvcm1hdD10LmludGVybmFsRm9ybWF0LHRoaXMudHlwZT10LnR5cGUsdGhpcy5vZmZzZXQuY29weSh0Lm9mZnNldCksdGhpcy5yZXBlYXQuY29weSh0LnJlcGVhdCksdGhpcy5jZW50ZXIuY29weSh0LmNlbnRlciksdGhpcy5yb3RhdGlvbj10LnJvdGF0aW9uLHRoaXMubWF0cml4QXV0b1VwZGF0ZT10Lm1hdHJpeEF1dG9VcGRhdGUsdGhpcy5tYXRyaXguY29weSh0Lm1hdHJpeCksdGhpcy5nZW5lcmF0ZU1pcG1hcHM9dC5nZW5lcmF0ZU1pcG1hcHMsdGhpcy5wcmVtdWx0aXBseUFscGhhPXQucHJlbXVsdGlwbHlBbHBoYSx0aGlzLmZsaXBZPXQuZmxpcFksdGhpcy51bnBhY2tBbGlnbm1lbnQ9dC51bnBhY2tBbGlnbm1lbnQsdGhpcy5jb2xvclNwYWNlPXQuY29sb3JTcGFjZSx0aGlzLnVzZXJEYXRhPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodC51c2VyRGF0YSkpLHRoaXMubmVlZHNVcGRhdGU9ITAsdGhpc310b0pTT04odCl7bGV0IGU9dD09PXZvaWQgMHx8dHlwZW9mIHQ9PSJzdHJpbmciO2lmKCFlJiZ0LnRleHR1cmVzW3RoaXMudXVpZF0hPT12b2lkIDApcmV0dXJuIHQudGV4dHVyZXNbdGhpcy51dWlkXTtsZXQgbj17bWV0YWRhdGE6e3ZlcnNpb246NC42LHR5cGU6IlRleHR1cmUiLGdlbmVyYXRvcjoiVGV4dHVyZS50b0pTT04ifSx1dWlkOnRoaXMudXVpZCxuYW1lOnRoaXMubmFtZSxpbWFnZTp0aGlzLnNvdXJjZS50b0pTT04odCkudXVpZCxtYXBwaW5nOnRoaXMubWFwcGluZyxjaGFubmVsOnRoaXMuY2hhbm5lbCxyZXBlYXQ6W3RoaXMucmVwZWF0LngsdGhpcy5yZXBlYXQueV0sb2Zmc2V0Olt0aGlzLm9mZnNldC54LHRoaXMub2Zmc2V0LnldLGNlbnRlcjpbdGhpcy5jZW50ZXIueCx0aGlzLmNlbnRlci55XSxyb3RhdGlvbjp0aGlzLnJvdGF0aW9uLHdyYXA6W3RoaXMud3JhcFMsdGhpcy53cmFwVF0sZm9ybWF0OnRoaXMuZm9ybWF0LGludGVybmFsRm9ybWF0OnRoaXMuaW50ZXJuYWxGb3JtYXQsdHlwZTp0aGlzLnR5cGUsY29sb3JTcGFjZTp0aGlzLmNvbG9yU3BhY2UsbWluRmlsdGVyOnRoaXMubWluRmlsdGVyLG1hZ0ZpbHRlcjp0aGlzLm1hZ0ZpbHRlcixhbmlzb3Ryb3B5OnRoaXMuYW5pc290cm9weSxmbGlwWTp0aGlzLmZsaXBZLGdlbmVyYXRlTWlwbWFwczp0aGlzLmdlbmVyYXRlTWlwbWFwcyxwcmVtdWx0aXBseUFscGhhOnRoaXMucHJlbXVsdGlwbHlBbHBoYSx1bnBhY2tBbGlnbm1lbnQ6dGhpcy51bnBhY2tBbGlnbm1lbnR9O3JldHVybiBPYmplY3Qua2V5cyh0aGlzLnVzZXJEYXRhKS5sZW5ndGg+MCYmKG4udXNlckRhdGE9dGhpcy51c2VyRGF0YSksZXx8KHQudGV4dHVyZXNbdGhpcy51dWlkXT1uKSxufWRpc3Bvc2UoKXt0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImRpc3Bvc2UifSl9dHJhbnNmb3JtVXYodCl7aWYodGhpcy5tYXBwaW5nIT09dGwpcmV0dXJuIHQ7aWYodC5hcHBseU1hdHJpeDModGhpcy5tYXRyaXgpLHQueDwwfHx0Lng+MSlzd2l0Y2godGhpcy53cmFwUyl7Y2FzZSBKczp0Lng9dC54LU1hdGguZmxvb3IodC54KTticmVhaztjYXNlIFVlOnQueD10Lng8MD8wOjE7YnJlYWs7Y2FzZSAkczpNYXRoLmFicyhNYXRoLmZsb29yKHQueCklMik9PT0xP3QueD1NYXRoLmNlaWwodC54KS10Lng6dC54PXQueC1NYXRoLmZsb29yKHQueCk7YnJlYWt9aWYodC55PDB8fHQueT4xKXN3aXRjaCh0aGlzLndyYXBUKXtjYXNlIEpzOnQueT10LnktTWF0aC5mbG9vcih0LnkpO2JyZWFrO2Nhc2UgVWU6dC55PXQueTwwPzA6MTticmVhaztjYXNlICRzOk1hdGguYWJzKE1hdGguZmxvb3IodC55KSUyKT09PTE/dC55PU1hdGguY2VpbCh0LnkpLXQueTp0Lnk9dC55LU1hdGguZmxvb3IodC55KTticmVha31yZXR1cm4gdGhpcy5mbGlwWSYmKHQueT0xLXQueSksdH1zZXQgbmVlZHNVcGRhdGUodCl7dD09PSEwJiYodGhpcy52ZXJzaW9uKyssdGhpcy5zb3VyY2UubmVlZHNVcGRhdGU9ITApfWdldCBlbmNvZGluZygpe3JldHVybiBSaSgiVEhSRUUuVGV4dHVyZTogUHJvcGVydHkgLmVuY29kaW5nIGhhcyBiZWVuIHJlcGxhY2VkIGJ5IC5jb2xvclNwYWNlLiIpLHRoaXMuY29sb3JTcGFjZT09PXhlP3RpOnR1fXNldCBlbmNvZGluZyh0KXtSaSgiVEhSRUUuVGV4dHVyZTogUHJvcGVydHkgLmVuY29kaW5nIGhhcyBiZWVuIHJlcGxhY2VkIGJ5IC5jb2xvclNwYWNlLiIpLHRoaXMuY29sb3JTcGFjZT10PT09dGk/eGU6cWV9fTtfZS5ERUZBVUxUX0lNQUdFPW51bGw7X2UuREVGQVVMVF9NQVBQSU5HPXRsO19lLkRFRkFVTFRfQU5JU09UUk9QWT0xO3ZhciB0ZT1jbGFzcyBze2NvbnN0cnVjdG9yKHQ9MCxlPTAsbj0wLGk9MSl7cy5wcm90b3R5cGUuaXNWZWN0b3I0PSEwLHRoaXMueD10LHRoaXMueT1lLHRoaXMuej1uLHRoaXMudz1pfWdldCB3aWR0aCgpe3JldHVybiB0aGlzLnp9c2V0IHdpZHRoKHQpe3RoaXMuej10fWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpcy53fXNldCBoZWlnaHQodCl7dGhpcy53PXR9c2V0KHQsZSxuLGkpe3JldHVybiB0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLno9bix0aGlzLnc9aSx0aGlzfXNldFNjYWxhcih0KXtyZXR1cm4gdGhpcy54PXQsdGhpcy55PXQsdGhpcy56PXQsdGhpcy53PXQsdGhpc31zZXRYKHQpe3JldHVybiB0aGlzLng9dCx0aGlzfXNldFkodCl7cmV0dXJuIHRoaXMueT10LHRoaXN9c2V0Wih0KXtyZXR1cm4gdGhpcy56PXQsdGhpc31zZXRXKHQpe3JldHVybiB0aGlzLnc9dCx0aGlzfXNldENvbXBvbmVudCh0LGUpe3N3aXRjaCh0KXtjYXNlIDA6dGhpcy54PWU7YnJlYWs7Y2FzZSAxOnRoaXMueT1lO2JyZWFrO2Nhc2UgMjp0aGlzLno9ZTticmVhaztjYXNlIDM6dGhpcy53PWU7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoImluZGV4IGlzIG91dCBvZiByYW5nZTogIit0KX1yZXR1cm4gdGhpc31nZXRDb21wb25lbnQodCl7c3dpdGNoKHQpe2Nhc2UgMDpyZXR1cm4gdGhpcy54O2Nhc2UgMTpyZXR1cm4gdGhpcy55O2Nhc2UgMjpyZXR1cm4gdGhpcy56O2Nhc2UgMzpyZXR1cm4gdGhpcy53O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICIrdCl9fWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMueCx0aGlzLnksdGhpcy56LHRoaXMudyl9Y29weSh0KXtyZXR1cm4gdGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMuej10LnosdGhpcy53PXQudyE9PXZvaWQgMD90Lnc6MSx0aGlzfWFkZCh0KXtyZXR1cm4gdGhpcy54Kz10LngsdGhpcy55Kz10LnksdGhpcy56Kz10LnosdGhpcy53Kz10LncsdGhpc31hZGRTY2FsYXIodCl7cmV0dXJuIHRoaXMueCs9dCx0aGlzLnkrPXQsdGhpcy56Kz10LHRoaXMudys9dCx0aGlzfWFkZFZlY3RvcnModCxlKXtyZXR1cm4gdGhpcy54PXQueCtlLngsdGhpcy55PXQueStlLnksdGhpcy56PXQueitlLnosdGhpcy53PXQudytlLncsdGhpc31hZGRTY2FsZWRWZWN0b3IodCxlKXtyZXR1cm4gdGhpcy54Kz10LngqZSx0aGlzLnkrPXQueSplLHRoaXMueis9dC56KmUsdGhpcy53Kz10LncqZSx0aGlzfXN1Yih0KXtyZXR1cm4gdGhpcy54LT10LngsdGhpcy55LT10LnksdGhpcy56LT10LnosdGhpcy53LT10LncsdGhpc31zdWJTY2FsYXIodCl7cmV0dXJuIHRoaXMueC09dCx0aGlzLnktPXQsdGhpcy56LT10LHRoaXMudy09dCx0aGlzfXN1YlZlY3RvcnModCxlKXtyZXR1cm4gdGhpcy54PXQueC1lLngsdGhpcy55PXQueS1lLnksdGhpcy56PXQuei1lLnosdGhpcy53PXQudy1lLncsdGhpc31tdWx0aXBseSh0KXtyZXR1cm4gdGhpcy54Kj10LngsdGhpcy55Kj10LnksdGhpcy56Kj10LnosdGhpcy53Kj10LncsdGhpc31tdWx0aXBseVNjYWxhcih0KXtyZXR1cm4gdGhpcy54Kj10LHRoaXMueSo9dCx0aGlzLnoqPXQsdGhpcy53Kj10LHRoaXN9YXBwbHlNYXRyaXg0KHQpe2xldCBlPXRoaXMueCxuPXRoaXMueSxpPXRoaXMueixyPXRoaXMudyxhPXQuZWxlbWVudHM7cmV0dXJuIHRoaXMueD1hWzBdKmUrYVs0XSpuK2FbOF0qaSthWzEyXSpyLHRoaXMueT1hWzFdKmUrYVs1XSpuK2FbOV0qaSthWzEzXSpyLHRoaXMuej1hWzJdKmUrYVs2XSpuK2FbMTBdKmkrYVsxNF0qcix0aGlzLnc9YVszXSplK2FbN10qbithWzExXSppK2FbMTVdKnIsdGhpc31kaXZpZGVTY2FsYXIodCl7cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMS90KX1zZXRBeGlzQW5nbGVGcm9tUXVhdGVybmlvbih0KXt0aGlzLnc9MipNYXRoLmFjb3ModC53KTtsZXQgZT1NYXRoLnNxcnQoMS10LncqdC53KTtyZXR1cm4gZTwxZS00Pyh0aGlzLng9MSx0aGlzLnk9MCx0aGlzLno9MCk6KHRoaXMueD10LngvZSx0aGlzLnk9dC55L2UsdGhpcy56PXQuei9lKSx0aGlzfXNldEF4aXNBbmdsZUZyb21Sb3RhdGlvbk1hdHJpeCh0KXtsZXQgZSxuLGkscixsPXQuZWxlbWVudHMsYz1sWzBdLGg9bFs0XSx1PWxbOF0sZD1sWzFdLGY9bFs1XSxtPWxbOV0sXz1sWzJdLGc9bFs2XSxwPWxbMTBdO2lmKE1hdGguYWJzKGgtZCk8LjAxJiZNYXRoLmFicyh1LV8pPC4wMSYmTWF0aC5hYnMobS1nKTwuMDEpe2lmKE1hdGguYWJzKGgrZCk8LjEmJk1hdGguYWJzKHUrXyk8LjEmJk1hdGguYWJzKG0rZyk8LjEmJk1hdGguYWJzKGMrZitwLTMpPC4xKXJldHVybiB0aGlzLnNldCgxLDAsMCwwKSx0aGlzO2U9TWF0aC5QSTtsZXQgeD0oYysxKS8yLE09KGYrMSkvMixDPShwKzEpLzIsQT0oaCtkKS80LFQ9KHUrXykvNCxVPShtK2cpLzQ7cmV0dXJuIHg+TSYmeD5DP3g8LjAxPyhuPTAsaT0uNzA3MTA2NzgxLHI9LjcwNzEwNjc4MSk6KG49TWF0aC5zcXJ0KHgpLGk9QS9uLHI9VC9uKTpNPkM/TTwuMDE/KG49LjcwNzEwNjc4MSxpPTAscj0uNzA3MTA2NzgxKTooaT1NYXRoLnNxcnQoTSksbj1BL2kscj1VL2kpOkM8LjAxPyhuPS43MDcxMDY3ODEsaT0uNzA3MTA2NzgxLHI9MCk6KHI9TWF0aC5zcXJ0KEMpLG49VC9yLGk9VS9yKSx0aGlzLnNldChuLGkscixlKSx0aGlzfWxldCB2PU1hdGguc3FydCgoZy1tKSooZy1tKSsodS1fKSoodS1fKSsoZC1oKSooZC1oKSk7cmV0dXJuIE1hdGguYWJzKHYpPC4wMDEmJih2PTEpLHRoaXMueD0oZy1tKS92LHRoaXMueT0odS1fKS92LHRoaXMuej0oZC1oKS92LHRoaXMudz1NYXRoLmFjb3MoKGMrZitwLTEpLzIpLHRoaXN9bWluKHQpe3JldHVybiB0aGlzLng9TWF0aC5taW4odGhpcy54LHQueCksdGhpcy55PU1hdGgubWluKHRoaXMueSx0LnkpLHRoaXMuej1NYXRoLm1pbih0aGlzLnosdC56KSx0aGlzLnc9TWF0aC5taW4odGhpcy53LHQudyksdGhpc31tYXgodCl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0aGlzLngsdC54KSx0aGlzLnk9TWF0aC5tYXgodGhpcy55LHQueSksdGhpcy56PU1hdGgubWF4KHRoaXMueix0LnopLHRoaXMudz1NYXRoLm1heCh0aGlzLncsdC53KSx0aGlzfWNsYW1wKHQsZSl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0LngsTWF0aC5taW4oZS54LHRoaXMueCkpLHRoaXMueT1NYXRoLm1heCh0LnksTWF0aC5taW4oZS55LHRoaXMueSkpLHRoaXMuej1NYXRoLm1heCh0LnosTWF0aC5taW4oZS56LHRoaXMueikpLHRoaXMudz1NYXRoLm1heCh0LncsTWF0aC5taW4oZS53LHRoaXMudykpLHRoaXN9Y2xhbXBTY2FsYXIodCxlKXtyZXR1cm4gdGhpcy54PU1hdGgubWF4KHQsTWF0aC5taW4oZSx0aGlzLngpKSx0aGlzLnk9TWF0aC5tYXgodCxNYXRoLm1pbihlLHRoaXMueSkpLHRoaXMuej1NYXRoLm1heCh0LE1hdGgubWluKGUsdGhpcy56KSksdGhpcy53PU1hdGgubWF4KHQsTWF0aC5taW4oZSx0aGlzLncpKSx0aGlzfWNsYW1wTGVuZ3RoKHQsZSl7bGV0IG49dGhpcy5sZW5ndGgoKTtyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIobnx8MSkubXVsdGlwbHlTY2FsYXIoTWF0aC5tYXgodCxNYXRoLm1pbihlLG4pKSl9Zmxvb3IoKXtyZXR1cm4gdGhpcy54PU1hdGguZmxvb3IodGhpcy54KSx0aGlzLnk9TWF0aC5mbG9vcih0aGlzLnkpLHRoaXMuej1NYXRoLmZsb29yKHRoaXMueiksdGhpcy53PU1hdGguZmxvb3IodGhpcy53KSx0aGlzfWNlaWwoKXtyZXR1cm4gdGhpcy54PU1hdGguY2VpbCh0aGlzLngpLHRoaXMueT1NYXRoLmNlaWwodGhpcy55KSx0aGlzLno9TWF0aC5jZWlsKHRoaXMueiksdGhpcy53PU1hdGguY2VpbCh0aGlzLncpLHRoaXN9cm91bmQoKXtyZXR1cm4gdGhpcy54PU1hdGgucm91bmQodGhpcy54KSx0aGlzLnk9TWF0aC5yb3VuZCh0aGlzLnkpLHRoaXMuej1NYXRoLnJvdW5kKHRoaXMueiksdGhpcy53PU1hdGgucm91bmQodGhpcy53KSx0aGlzfXJvdW5kVG9aZXJvKCl7cmV0dXJuIHRoaXMueD1NYXRoLnRydW5jKHRoaXMueCksdGhpcy55PU1hdGgudHJ1bmModGhpcy55KSx0aGlzLno9TWF0aC50cnVuYyh0aGlzLnopLHRoaXMudz1NYXRoLnRydW5jKHRoaXMudyksdGhpc31uZWdhdGUoKXtyZXR1cm4gdGhpcy54PS10aGlzLngsdGhpcy55PS10aGlzLnksdGhpcy56PS10aGlzLnosdGhpcy53PS10aGlzLncsdGhpc31kb3QodCl7cmV0dXJuIHRoaXMueCp0LngrdGhpcy55KnQueSt0aGlzLnoqdC56K3RoaXMudyp0Lnd9bGVuZ3RoU3EoKXtyZXR1cm4gdGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnordGhpcy53KnRoaXMud31sZW5ndGgoKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56K3RoaXMudyp0aGlzLncpfW1hbmhhdHRhbkxlbmd0aCgpe3JldHVybiBNYXRoLmFicyh0aGlzLngpK01hdGguYWJzKHRoaXMueSkrTWF0aC5hYnModGhpcy56KStNYXRoLmFicyh0aGlzLncpfW5vcm1hbGl6ZSgpe3JldHVybiB0aGlzLmRpdmlkZVNjYWxhcih0aGlzLmxlbmd0aCgpfHwxKX1zZXRMZW5ndGgodCl7cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIodCl9bGVycCh0LGUpe3JldHVybiB0aGlzLngrPSh0LngtdGhpcy54KSplLHRoaXMueSs9KHQueS10aGlzLnkpKmUsdGhpcy56Kz0odC56LXRoaXMueikqZSx0aGlzLncrPSh0LnctdGhpcy53KSplLHRoaXN9bGVycFZlY3RvcnModCxlLG4pe3JldHVybiB0aGlzLng9dC54KyhlLngtdC54KSpuLHRoaXMueT10LnkrKGUueS10LnkpKm4sdGhpcy56PXQueisoZS56LXQueikqbix0aGlzLnc9dC53KyhlLnctdC53KSpuLHRoaXN9ZXF1YWxzKHQpe3JldHVybiB0Lng9PT10aGlzLngmJnQueT09PXRoaXMueSYmdC56PT09dGhpcy56JiZ0Lnc9PT10aGlzLnd9ZnJvbUFycmF5KHQsZT0wKXtyZXR1cm4gdGhpcy54PXRbZV0sdGhpcy55PXRbZSsxXSx0aGlzLno9dFtlKzJdLHRoaXMudz10W2UrM10sdGhpc310b0FycmF5KHQ9W10sZT0wKXtyZXR1cm4gdFtlXT10aGlzLngsdFtlKzFdPXRoaXMueSx0W2UrMl09dGhpcy56LHRbZSszXT10aGlzLncsdH1mcm9tQnVmZmVyQXR0cmlidXRlKHQsZSl7cmV0dXJuIHRoaXMueD10LmdldFgoZSksdGhpcy55PXQuZ2V0WShlKSx0aGlzLno9dC5nZXRaKGUpLHRoaXMudz10LmdldFcoZSksdGhpc31yYW5kb20oKXtyZXR1cm4gdGhpcy54PU1hdGgucmFuZG9tKCksdGhpcy55PU1hdGgucmFuZG9tKCksdGhpcy56PU1hdGgucmFuZG9tKCksdGhpcy53PU1hdGgucmFuZG9tKCksdGhpc30qW1N5bWJvbC5pdGVyYXRvcl0oKXt5aWVsZCB0aGlzLngseWllbGQgdGhpcy55LHlpZWxkIHRoaXMueix5aWVsZCB0aGlzLnd9fSxIYT1jbGFzcyBleHRlbmRzIGxue2NvbnN0cnVjdG9yKHQ9MSxlPTEsbj17fSl7c3VwZXIoKSx0aGlzLmlzUmVuZGVyVGFyZ2V0PSEwLHRoaXMud2lkdGg9dCx0aGlzLmhlaWdodD1lLHRoaXMuZGVwdGg9MSx0aGlzLnNjaXNzb3I9bmV3IHRlKDAsMCx0LGUpLHRoaXMuc2Npc3NvclRlc3Q9ITEsdGhpcy52aWV3cG9ydD1uZXcgdGUoMCwwLHQsZSk7bGV0IGk9e3dpZHRoOnQsaGVpZ2h0OmUsZGVwdGg6MX07bi5lbmNvZGluZyE9PXZvaWQgMCYmKFJpKCJUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogb3B0aW9uLmVuY29kaW5nIGhhcyBiZWVuIHJlcGxhY2VkIGJ5IG9wdGlvbi5jb2xvclNwYWNlLiIpLG4uY29sb3JTcGFjZT1uLmVuY29kaW5nPT09dGk/eGU6cWUpLG49T2JqZWN0LmFzc2lnbih7Z2VuZXJhdGVNaXBtYXBzOiExLGludGVybmFsRm9ybWF0Om51bGwsbWluRmlsdGVyOm9lLGRlcHRoQnVmZmVyOiEwLHN0ZW5jaWxCdWZmZXI6ITEsZGVwdGhUZXh0dXJlOm51bGwsc2FtcGxlczowfSxuKSx0aGlzLnRleHR1cmU9bmV3IF9lKGksbi5tYXBwaW5nLG4ud3JhcFMsbi53cmFwVCxuLm1hZ0ZpbHRlcixuLm1pbkZpbHRlcixuLmZvcm1hdCxuLnR5cGUsbi5hbmlzb3Ryb3B5LG4uY29sb3JTcGFjZSksdGhpcy50ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT0hMCx0aGlzLnRleHR1cmUuZmxpcFk9ITEsdGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcz1uLmdlbmVyYXRlTWlwbWFwcyx0aGlzLnRleHR1cmUuaW50ZXJuYWxGb3JtYXQ9bi5pbnRlcm5hbEZvcm1hdCx0aGlzLmRlcHRoQnVmZmVyPW4uZGVwdGhCdWZmZXIsdGhpcy5zdGVuY2lsQnVmZmVyPW4uc3RlbmNpbEJ1ZmZlcix0aGlzLmRlcHRoVGV4dHVyZT1uLmRlcHRoVGV4dHVyZSx0aGlzLnNhbXBsZXM9bi5zYW1wbGVzfXNldFNpemUodCxlLG49MSl7KHRoaXMud2lkdGghPT10fHx0aGlzLmhlaWdodCE9PWV8fHRoaXMuZGVwdGghPT1uKSYmKHRoaXMud2lkdGg9dCx0aGlzLmhlaWdodD1lLHRoaXMuZGVwdGg9bix0aGlzLnRleHR1cmUuaW1hZ2Uud2lkdGg9dCx0aGlzLnRleHR1cmUuaW1hZ2UuaGVpZ2h0PWUsdGhpcy50ZXh0dXJlLmltYWdlLmRlcHRoPW4sdGhpcy5kaXNwb3NlKCkpLHRoaXMudmlld3BvcnQuc2V0KDAsMCx0LGUpLHRoaXMuc2Npc3Nvci5zZXQoMCwwLHQsZSl9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpfWNvcHkodCl7dGhpcy53aWR0aD10LndpZHRoLHRoaXMuaGVpZ2h0PXQuaGVpZ2h0LHRoaXMuZGVwdGg9dC5kZXB0aCx0aGlzLnNjaXNzb3IuY29weSh0LnNjaXNzb3IpLHRoaXMuc2Npc3NvclRlc3Q9dC5zY2lzc29yVGVzdCx0aGlzLnZpZXdwb3J0LmNvcHkodC52aWV3cG9ydCksdGhpcy50ZXh0dXJlPXQudGV4dHVyZS5jbG9uZSgpLHRoaXMudGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmU9ITA7bGV0IGU9T2JqZWN0LmFzc2lnbih7fSx0LnRleHR1cmUuaW1hZ2UpO3JldHVybiB0aGlzLnRleHR1cmUuc291cmNlPW5ldyBQbihlKSx0aGlzLmRlcHRoQnVmZmVyPXQuZGVwdGhCdWZmZXIsdGhpcy5zdGVuY2lsQnVmZmVyPXQuc3RlbmNpbEJ1ZmZlcix0LmRlcHRoVGV4dHVyZSE9PW51bGwmJih0aGlzLmRlcHRoVGV4dHVyZT10LmRlcHRoVGV4dHVyZS5jbG9uZSgpKSx0aGlzLnNhbXBsZXM9dC5zYW1wbGVzLHRoaXN9ZGlzcG9zZSgpe3RoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToiZGlzcG9zZSJ9KX19LFplPWNsYXNzIGV4dGVuZHMgSGF7Y29uc3RydWN0b3IodD0xLGU9MSxuPXt9KXtzdXBlcih0LGUsbiksdGhpcy5pc1dlYkdMUmVuZGVyVGFyZ2V0PSEwfX0sZ3M9Y2xhc3MgZXh0ZW5kcyBfZXtjb25zdHJ1Y3Rvcih0PW51bGwsZT0xLG49MSxpPTEpe3N1cGVyKG51bGwpLHRoaXMuaXNEYXRhQXJyYXlUZXh0dXJlPSEwLHRoaXMuaW1hZ2U9e2RhdGE6dCx3aWR0aDplLGhlaWdodDpuLGRlcHRoOml9LHRoaXMubWFnRmlsdGVyPW1lLHRoaXMubWluRmlsdGVyPW1lLHRoaXMud3JhcFI9VWUsdGhpcy5nZW5lcmF0ZU1pcG1hcHM9ITEsdGhpcy5mbGlwWT0hMSx0aGlzLnVucGFja0FsaWdubWVudD0xfX0sUmM9Y2xhc3MgZXh0ZW5kcyBaZXtjb25zdHJ1Y3Rvcih0PTEsZT0xLG49MSxpPXt9KXtzdXBlcih0LGUsaSksdGhpcy5pc1dlYkdMQXJyYXlSZW5kZXJUYXJnZXQ9ITAsdGhpcy5kZXB0aD1uLHRoaXMudGV4dHVyZT1uZXcgZ3MobnVsbCx0LGUsbiksdGhpcy50ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT0hMH19LG9yPWNsYXNzIGV4dGVuZHMgX2V7Y29uc3RydWN0b3IodD1udWxsLGU9MSxuPTEsaT0xKXtzdXBlcihudWxsKSx0aGlzLmlzRGF0YTNEVGV4dHVyZT0hMCx0aGlzLmltYWdlPXtkYXRhOnQsd2lkdGg6ZSxoZWlnaHQ6bixkZXB0aDppfSx0aGlzLm1hZ0ZpbHRlcj1tZSx0aGlzLm1pbkZpbHRlcj1tZSx0aGlzLndyYXBSPVVlLHRoaXMuZ2VuZXJhdGVNaXBtYXBzPSExLHRoaXMuZmxpcFk9ITEsdGhpcy51bnBhY2tBbGlnbm1lbnQ9MX19LENjPWNsYXNzIGV4dGVuZHMgWmV7Y29uc3RydWN0b3IodD0xLGU9MSxuPTEsaT17fSl7c3VwZXIodCxlLGkpLHRoaXMuaXNXZWJHTDNEUmVuZGVyVGFyZ2V0PSEwLHRoaXMuZGVwdGg9bix0aGlzLnRleHR1cmU9bmV3IG9yKG51bGwsdCxlLG4pLHRoaXMudGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmU9ITB9fSxQYz1jbGFzcyBleHRlbmRzIFple2NvbnN0cnVjdG9yKHQ9MSxlPTEsbj0xLGk9e30pe3N1cGVyKHQsZSxpKSx0aGlzLmlzV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHM9ITA7bGV0IHI9dGhpcy50ZXh0dXJlO3RoaXMudGV4dHVyZT1bXTtmb3IobGV0IGE9MDthPG47YSsrKXRoaXMudGV4dHVyZVthXT1yLmNsb25lKCksdGhpcy50ZXh0dXJlW2FdLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT0hMH1zZXRTaXplKHQsZSxuPTEpe2lmKHRoaXMud2lkdGghPT10fHx0aGlzLmhlaWdodCE9PWV8fHRoaXMuZGVwdGghPT1uKXt0aGlzLndpZHRoPXQsdGhpcy5oZWlnaHQ9ZSx0aGlzLmRlcHRoPW47Zm9yKGxldCBpPTAscj10aGlzLnRleHR1cmUubGVuZ3RoO2k8cjtpKyspdGhpcy50ZXh0dXJlW2ldLmltYWdlLndpZHRoPXQsdGhpcy50ZXh0dXJlW2ldLmltYWdlLmhlaWdodD1lLHRoaXMudGV4dHVyZVtpXS5pbWFnZS5kZXB0aD1uO3RoaXMuZGlzcG9zZSgpfXRoaXMudmlld3BvcnQuc2V0KDAsMCx0LGUpLHRoaXMuc2Npc3Nvci5zZXQoMCwwLHQsZSl9Y29weSh0KXt0aGlzLmRpc3Bvc2UoKSx0aGlzLndpZHRoPXQud2lkdGgsdGhpcy5oZWlnaHQ9dC5oZWlnaHQsdGhpcy5kZXB0aD10LmRlcHRoLHRoaXMuc2Npc3Nvci5jb3B5KHQuc2Npc3NvciksdGhpcy5zY2lzc29yVGVzdD10LnNjaXNzb3JUZXN0LHRoaXMudmlld3BvcnQuY29weSh0LnZpZXdwb3J0KSx0aGlzLmRlcHRoQnVmZmVyPXQuZGVwdGhCdWZmZXIsdGhpcy5zdGVuY2lsQnVmZmVyPXQuc3RlbmNpbEJ1ZmZlcix0LmRlcHRoVGV4dHVyZSE9PW51bGwmJih0aGlzLmRlcHRoVGV4dHVyZT10LmRlcHRoVGV4dHVyZS5jbG9uZSgpKSx0aGlzLnRleHR1cmUubGVuZ3RoPTA7Zm9yKGxldCBlPTAsbj10LnRleHR1cmUubGVuZ3RoO2U8bjtlKyspdGhpcy50ZXh0dXJlW2VdPXQudGV4dHVyZVtlXS5jbG9uZSgpLHRoaXMudGV4dHVyZVtlXS5pc1JlbmRlclRhcmdldFRleHR1cmU9ITA7cmV0dXJuIHRoaXN9fSxEZT1jbGFzc3tjb25zdHJ1Y3Rvcih0PTAsZT0wLG49MCxpPTEpe3RoaXMuaXNRdWF0ZXJuaW9uPSEwLHRoaXMuX3g9dCx0aGlzLl95PWUsdGhpcy5fej1uLHRoaXMuX3c9aX1zdGF0aWMgc2xlcnBGbGF0KHQsZSxuLGkscixhLG8pe2xldCBsPW5baSswXSxjPW5baSsxXSxoPW5baSsyXSx1PW5baSszXSxkPXJbYSswXSxmPXJbYSsxXSxtPXJbYSsyXSxfPXJbYSszXTtpZihvPT09MCl7dFtlKzBdPWwsdFtlKzFdPWMsdFtlKzJdPWgsdFtlKzNdPXU7cmV0dXJufWlmKG89PT0xKXt0W2UrMF09ZCx0W2UrMV09Zix0W2UrMl09bSx0W2UrM109XztyZXR1cm59aWYodSE9PV98fGwhPT1kfHxjIT09Znx8aCE9PW0pe2xldCBnPTEtbyxwPWwqZCtjKmYraCptK3UqXyx2PXA+PTA/MTotMSx4PTEtcCpwO2lmKHg+TnVtYmVyLkVQU0lMT04pe2xldCBDPU1hdGguc3FydCh4KSxBPU1hdGguYXRhbjIoQyxwKnYpO2c9TWF0aC5zaW4oZypBKS9DLG89TWF0aC5zaW4obypBKS9DfWxldCBNPW8qdjtpZihsPWwqZytkKk0sYz1jKmcrZipNLGg9aCpnK20qTSx1PXUqZytfKk0sZz09PTEtbyl7bGV0IEM9MS9NYXRoLnNxcnQobCpsK2MqYytoKmgrdSp1KTtsKj1DLGMqPUMsaCo9Qyx1Kj1DfX10W2VdPWwsdFtlKzFdPWMsdFtlKzJdPWgsdFtlKzNdPXV9c3RhdGljIG11bHRpcGx5UXVhdGVybmlvbnNGbGF0KHQsZSxuLGkscixhKXtsZXQgbz1uW2ldLGw9bltpKzFdLGM9bltpKzJdLGg9bltpKzNdLHU9clthXSxkPXJbYSsxXSxmPXJbYSsyXSxtPXJbYSszXTtyZXR1cm4gdFtlXT1vKm0raCp1K2wqZi1jKmQsdFtlKzFdPWwqbStoKmQrYyp1LW8qZix0W2UrMl09YyptK2gqZitvKmQtbCp1LHRbZSszXT1oKm0tbyp1LWwqZC1jKmYsdH1nZXQgeCgpe3JldHVybiB0aGlzLl94fXNldCB4KHQpe3RoaXMuX3g9dCx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCl9Z2V0IHkoKXtyZXR1cm4gdGhpcy5feX1zZXQgeSh0KXt0aGlzLl95PXQsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfWdldCB6KCl7cmV0dXJuIHRoaXMuX3p9c2V0IHoodCl7dGhpcy5fej10LHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKX1nZXQgdygpe3JldHVybiB0aGlzLl93fXNldCB3KHQpe3RoaXMuX3c9dCx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCl9c2V0KHQsZSxuLGkpe3JldHVybiB0aGlzLl94PXQsdGhpcy5feT1lLHRoaXMuX3o9bix0aGlzLl93PWksdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5feCx0aGlzLl95LHRoaXMuX3osdGhpcy5fdyl9Y29weSh0KXtyZXR1cm4gdGhpcy5feD10LngsdGhpcy5feT10LnksdGhpcy5fej10LnosdGhpcy5fdz10LncsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbUV1bGVyKHQsZT0hMCl7bGV0IG49dC5feCxpPXQuX3kscj10Ll96LGE9dC5fb3JkZXIsbz1NYXRoLmNvcyxsPU1hdGguc2luLGM9byhuLzIpLGg9byhpLzIpLHU9byhyLzIpLGQ9bChuLzIpLGY9bChpLzIpLG09bChyLzIpO3N3aXRjaChhKXtjYXNlIlhZWiI6dGhpcy5feD1kKmgqdStjKmYqbSx0aGlzLl95PWMqZip1LWQqaCptLHRoaXMuX3o9YypoKm0rZCpmKnUsdGhpcy5fdz1jKmgqdS1kKmYqbTticmVhaztjYXNlIllYWiI6dGhpcy5feD1kKmgqdStjKmYqbSx0aGlzLl95PWMqZip1LWQqaCptLHRoaXMuX3o9YypoKm0tZCpmKnUsdGhpcy5fdz1jKmgqdStkKmYqbTticmVhaztjYXNlIlpYWSI6dGhpcy5feD1kKmgqdS1jKmYqbSx0aGlzLl95PWMqZip1K2QqaCptLHRoaXMuX3o9YypoKm0rZCpmKnUsdGhpcy5fdz1jKmgqdS1kKmYqbTticmVhaztjYXNlIlpZWCI6dGhpcy5feD1kKmgqdS1jKmYqbSx0aGlzLl95PWMqZip1K2QqaCptLHRoaXMuX3o9YypoKm0tZCpmKnUsdGhpcy5fdz1jKmgqdStkKmYqbTticmVhaztjYXNlIllaWCI6dGhpcy5feD1kKmgqdStjKmYqbSx0aGlzLl95PWMqZip1K2QqaCptLHRoaXMuX3o9YypoKm0tZCpmKnUsdGhpcy5fdz1jKmgqdS1kKmYqbTticmVhaztjYXNlIlhaWSI6dGhpcy5feD1kKmgqdS1jKmYqbSx0aGlzLl95PWMqZip1LWQqaCptLHRoaXMuX3o9YypoKm0rZCpmKnUsdGhpcy5fdz1jKmgqdStkKmYqbTticmVhaztkZWZhdWx0OmNvbnNvbGUud2FybigiVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICIrYSl9cmV0dXJuIGU9PT0hMCYmdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbUF4aXNBbmdsZSh0LGUpe2xldCBuPWUvMixpPU1hdGguc2luKG4pO3JldHVybiB0aGlzLl94PXQueCppLHRoaXMuX3k9dC55KmksdGhpcy5fej10LnoqaSx0aGlzLl93PU1hdGguY29zKG4pLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfXNldEZyb21Sb3RhdGlvbk1hdHJpeCh0KXtsZXQgZT10LmVsZW1lbnRzLG49ZVswXSxpPWVbNF0scj1lWzhdLGE9ZVsxXSxvPWVbNV0sbD1lWzldLGM9ZVsyXSxoPWVbNl0sdT1lWzEwXSxkPW4rbyt1O2lmKGQ+MCl7bGV0IGY9LjUvTWF0aC5zcXJ0KGQrMSk7dGhpcy5fdz0uMjUvZix0aGlzLl94PShoLWwpKmYsdGhpcy5feT0oci1jKSpmLHRoaXMuX3o9KGEtaSkqZn1lbHNlIGlmKG4+byYmbj51KXtsZXQgZj0yKk1hdGguc3FydCgxK24tby11KTt0aGlzLl93PShoLWwpL2YsdGhpcy5feD0uMjUqZix0aGlzLl95PShpK2EpL2YsdGhpcy5fej0ocitjKS9mfWVsc2UgaWYobz51KXtsZXQgZj0yKk1hdGguc3FydCgxK28tbi11KTt0aGlzLl93PShyLWMpL2YsdGhpcy5feD0oaSthKS9mLHRoaXMuX3k9LjI1KmYsdGhpcy5fej0obCtoKS9mfWVsc2V7bGV0IGY9MipNYXRoLnNxcnQoMSt1LW4tbyk7dGhpcy5fdz0oYS1pKS9mLHRoaXMuX3g9KHIrYykvZix0aGlzLl95PShsK2gpL2YsdGhpcy5fej0uMjUqZn1yZXR1cm4gdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbVVuaXRWZWN0b3JzKHQsZSl7bGV0IG49dC5kb3QoZSkrMTtyZXR1cm4gbjxOdW1iZXIuRVBTSUxPTj8obj0wLE1hdGguYWJzKHQueCk+TWF0aC5hYnModC56KT8odGhpcy5feD0tdC55LHRoaXMuX3k9dC54LHRoaXMuX3o9MCx0aGlzLl93PW4pOih0aGlzLl94PTAsdGhpcy5feT0tdC56LHRoaXMuX3o9dC55LHRoaXMuX3c9bikpOih0aGlzLl94PXQueSplLnotdC56KmUueSx0aGlzLl95PXQueiplLngtdC54KmUueix0aGlzLl96PXQueCplLnktdC55KmUueCx0aGlzLl93PW4pLHRoaXMubm9ybWFsaXplKCl9YW5nbGVUbyh0KXtyZXR1cm4gMipNYXRoLmFjb3MoTWF0aC5hYnModWUodGhpcy5kb3QodCksLTEsMSkpKX1yb3RhdGVUb3dhcmRzKHQsZSl7bGV0IG49dGhpcy5hbmdsZVRvKHQpO2lmKG49PT0wKXJldHVybiB0aGlzO2xldCBpPU1hdGgubWluKDEsZS9uKTtyZXR1cm4gdGhpcy5zbGVycCh0LGkpLHRoaXN9aWRlbnRpdHkoKXtyZXR1cm4gdGhpcy5zZXQoMCwwLDAsMSl9aW52ZXJ0KCl7cmV0dXJuIHRoaXMuY29uanVnYXRlKCl9Y29uanVnYXRlKCl7cmV0dXJuIHRoaXMuX3gqPS0xLHRoaXMuX3kqPS0xLHRoaXMuX3oqPS0xLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfWRvdCh0KXtyZXR1cm4gdGhpcy5feCp0Ll94K3RoaXMuX3kqdC5feSt0aGlzLl96KnQuX3ordGhpcy5fdyp0Ll93fWxlbmd0aFNxKCl7cmV0dXJuIHRoaXMuX3gqdGhpcy5feCt0aGlzLl95KnRoaXMuX3krdGhpcy5feip0aGlzLl96K3RoaXMuX3cqdGhpcy5fd31sZW5ndGgoKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuX3gqdGhpcy5feCt0aGlzLl95KnRoaXMuX3krdGhpcy5feip0aGlzLl96K3RoaXMuX3cqdGhpcy5fdyl9bm9ybWFsaXplKCl7bGV0IHQ9dGhpcy5sZW5ndGgoKTtyZXR1cm4gdD09PTA/KHRoaXMuX3g9MCx0aGlzLl95PTAsdGhpcy5fej0wLHRoaXMuX3c9MSk6KHQ9MS90LHRoaXMuX3g9dGhpcy5feCp0LHRoaXMuX3k9dGhpcy5feSp0LHRoaXMuX3o9dGhpcy5feip0LHRoaXMuX3c9dGhpcy5fdyp0KSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31tdWx0aXBseSh0KXtyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKHRoaXMsdCl9cHJlbXVsdGlwbHkodCl7cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyh0LHRoaXMpfW11bHRpcGx5UXVhdGVybmlvbnModCxlKXtsZXQgbj10Ll94LGk9dC5feSxyPXQuX3osYT10Ll93LG89ZS5feCxsPWUuX3ksYz1lLl96LGg9ZS5fdztyZXR1cm4gdGhpcy5feD1uKmgrYSpvK2kqYy1yKmwsdGhpcy5feT1pKmgrYSpsK3Iqby1uKmMsdGhpcy5fej1yKmgrYSpjK24qbC1pKm8sdGhpcy5fdz1hKmgtbipvLWkqbC1yKmMsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2xlcnAodCxlKXtpZihlPT09MClyZXR1cm4gdGhpcztpZihlPT09MSlyZXR1cm4gdGhpcy5jb3B5KHQpO2xldCBuPXRoaXMuX3gsaT10aGlzLl95LHI9dGhpcy5feixhPXRoaXMuX3csbz1hKnQuX3crbip0Ll94K2kqdC5feStyKnQuX3o7aWYobzwwPyh0aGlzLl93PS10Ll93LHRoaXMuX3g9LXQuX3gsdGhpcy5feT0tdC5feSx0aGlzLl96PS10Ll96LG89LW8pOnRoaXMuY29weSh0KSxvPj0xKXJldHVybiB0aGlzLl93PWEsdGhpcy5feD1uLHRoaXMuX3k9aSx0aGlzLl96PXIsdGhpcztsZXQgbD0xLW8qbztpZihsPD1OdW1iZXIuRVBTSUxPTil7bGV0IGY9MS1lO3JldHVybiB0aGlzLl93PWYqYStlKnRoaXMuX3csdGhpcy5feD1mKm4rZSp0aGlzLl94LHRoaXMuX3k9ZippK2UqdGhpcy5feSx0aGlzLl96PWYqcitlKnRoaXMuX3osdGhpcy5ub3JtYWxpemUoKSx0aGlzfWxldCBjPU1hdGguc3FydChsKSxoPU1hdGguYXRhbjIoYyxvKSx1PU1hdGguc2luKCgxLWUpKmgpL2MsZD1NYXRoLnNpbihlKmgpL2M7cmV0dXJuIHRoaXMuX3c9YSp1K3RoaXMuX3cqZCx0aGlzLl94PW4qdSt0aGlzLl94KmQsdGhpcy5feT1pKnUrdGhpcy5feSpkLHRoaXMuX3o9cip1K3RoaXMuX3oqZCx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31zbGVycFF1YXRlcm5pb25zKHQsZSxuKXtyZXR1cm4gdGhpcy5jb3B5KHQpLnNsZXJwKGUsbil9cmFuZG9tKCl7bGV0IHQ9TWF0aC5yYW5kb20oKSxlPU1hdGguc3FydCgxLXQpLG49TWF0aC5zcXJ0KHQpLGk9MipNYXRoLlBJKk1hdGgucmFuZG9tKCkscj0yKk1hdGguUEkqTWF0aC5yYW5kb20oKTtyZXR1cm4gdGhpcy5zZXQoZSpNYXRoLmNvcyhpKSxuKk1hdGguc2luKHIpLG4qTWF0aC5jb3MociksZSpNYXRoLnNpbihpKSl9ZXF1YWxzKHQpe3JldHVybiB0Ll94PT09dGhpcy5feCYmdC5feT09PXRoaXMuX3kmJnQuX3o9PT10aGlzLl96JiZ0Ll93PT09dGhpcy5fd31mcm9tQXJyYXkodCxlPTApe3JldHVybiB0aGlzLl94PXRbZV0sdGhpcy5feT10W2UrMV0sdGhpcy5fej10W2UrMl0sdGhpcy5fdz10W2UrM10sdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9dG9BcnJheSh0PVtdLGU9MCl7cmV0dXJuIHRbZV09dGhpcy5feCx0W2UrMV09dGhpcy5feSx0W2UrMl09dGhpcy5feix0W2UrM109dGhpcy5fdyx0fWZyb21CdWZmZXJBdHRyaWJ1dGUodCxlKXtyZXR1cm4gdGhpcy5feD10LmdldFgoZSksdGhpcy5feT10LmdldFkoZSksdGhpcy5fej10LmdldFooZSksdGhpcy5fdz10LmdldFcoZSksdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9dG9KU09OKCl7cmV0dXJuIHRoaXMudG9BcnJheSgpfV9vbkNoYW5nZSh0KXtyZXR1cm4gdGhpcy5fb25DaGFuZ2VDYWxsYmFjaz10LHRoaXN9X29uQ2hhbmdlQ2FsbGJhY2soKXt9KltTeW1ib2wuaXRlcmF0b3JdKCl7eWllbGQgdGhpcy5feCx5aWVsZCB0aGlzLl95LHlpZWxkIHRoaXMuX3oseWllbGQgdGhpcy5fd319LFI9Y2xhc3Mgc3tjb25zdHJ1Y3Rvcih0PTAsZT0wLG49MCl7cy5wcm90b3R5cGUuaXNWZWN0b3IzPSEwLHRoaXMueD10LHRoaXMueT1lLHRoaXMuej1ufXNldCh0LGUsbil7cmV0dXJuIG49PT12b2lkIDAmJihuPXRoaXMueiksdGhpcy54PXQsdGhpcy55PWUsdGhpcy56PW4sdGhpc31zZXRTY2FsYXIodCl7cmV0dXJuIHRoaXMueD10LHRoaXMueT10LHRoaXMuej10LHRoaXN9c2V0WCh0KXtyZXR1cm4gdGhpcy54PXQsdGhpc31zZXRZKHQpe3JldHVybiB0aGlzLnk9dCx0aGlzfXNldFoodCl7cmV0dXJuIHRoaXMuej10LHRoaXN9c2V0Q29tcG9uZW50KHQsZSl7c3dpdGNoKHQpe2Nhc2UgMDp0aGlzLng9ZTticmVhaztjYXNlIDE6dGhpcy55PWU7YnJlYWs7Y2FzZSAyOnRoaXMuej1lO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICIrdCl9cmV0dXJuIHRoaXN9Z2V0Q29tcG9uZW50KHQpe3N3aXRjaCh0KXtjYXNlIDA6cmV0dXJuIHRoaXMueDtjYXNlIDE6cmV0dXJuIHRoaXMueTtjYXNlIDI6cmV0dXJuIHRoaXMuejtkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAiK3QpfX1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLngsdGhpcy55LHRoaXMueil9Y29weSh0KXtyZXR1cm4gdGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMuej10LnosdGhpc31hZGQodCl7cmV0dXJuIHRoaXMueCs9dC54LHRoaXMueSs9dC55LHRoaXMueis9dC56LHRoaXN9YWRkU2NhbGFyKHQpe3JldHVybiB0aGlzLngrPXQsdGhpcy55Kz10LHRoaXMueis9dCx0aGlzfWFkZFZlY3RvcnModCxlKXtyZXR1cm4gdGhpcy54PXQueCtlLngsdGhpcy55PXQueStlLnksdGhpcy56PXQueitlLnosdGhpc31hZGRTY2FsZWRWZWN0b3IodCxlKXtyZXR1cm4gdGhpcy54Kz10LngqZSx0aGlzLnkrPXQueSplLHRoaXMueis9dC56KmUsdGhpc31zdWIodCl7cmV0dXJuIHRoaXMueC09dC54LHRoaXMueS09dC55LHRoaXMuei09dC56LHRoaXN9c3ViU2NhbGFyKHQpe3JldHVybiB0aGlzLngtPXQsdGhpcy55LT10LHRoaXMuei09dCx0aGlzfXN1YlZlY3RvcnModCxlKXtyZXR1cm4gdGhpcy54PXQueC1lLngsdGhpcy55PXQueS1lLnksdGhpcy56PXQuei1lLnosdGhpc31tdWx0aXBseSh0KXtyZXR1cm4gdGhpcy54Kj10LngsdGhpcy55Kj10LnksdGhpcy56Kj10LnosdGhpc31tdWx0aXBseVNjYWxhcih0KXtyZXR1cm4gdGhpcy54Kj10LHRoaXMueSo9dCx0aGlzLnoqPXQsdGhpc31tdWx0aXBseVZlY3RvcnModCxlKXtyZXR1cm4gdGhpcy54PXQueCplLngsdGhpcy55PXQueSplLnksdGhpcy56PXQueiplLnosdGhpc31hcHBseUV1bGVyKHQpe3JldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbih4dS5zZXRGcm9tRXVsZXIodCkpfWFwcGx5QXhpc0FuZ2xlKHQsZSl7cmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKHh1LnNldEZyb21BeGlzQW5nbGUodCxlKSl9YXBwbHlNYXRyaXgzKHQpe2xldCBlPXRoaXMueCxuPXRoaXMueSxpPXRoaXMueixyPXQuZWxlbWVudHM7cmV0dXJuIHRoaXMueD1yWzBdKmUrclszXSpuK3JbNl0qaSx0aGlzLnk9clsxXSplK3JbNF0qbityWzddKmksdGhpcy56PXJbMl0qZStyWzVdKm4rcls4XSppLHRoaXN9YXBwbHlOb3JtYWxNYXRyaXgodCl7cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXgzKHQpLm5vcm1hbGl6ZSgpfWFwcGx5TWF0cml4NCh0KXtsZXQgZT10aGlzLngsbj10aGlzLnksaT10aGlzLnoscj10LmVsZW1lbnRzLGE9MS8oclszXSplK3JbN10qbityWzExXSppK3JbMTVdKTtyZXR1cm4gdGhpcy54PShyWzBdKmUrcls0XSpuK3JbOF0qaStyWzEyXSkqYSx0aGlzLnk9KHJbMV0qZStyWzVdKm4rcls5XSppK3JbMTNdKSphLHRoaXMuej0oclsyXSplK3JbNl0qbityWzEwXSppK3JbMTRdKSphLHRoaXN9YXBwbHlRdWF0ZXJuaW9uKHQpe2xldCBlPXRoaXMueCxuPXRoaXMueSxpPXRoaXMueixyPXQueCxhPXQueSxvPXQueixsPXQudyxjPTIqKGEqaS1vKm4pLGg9MioobyplLXIqaSksdT0yKihyKm4tYSplKTtyZXR1cm4gdGhpcy54PWUrbCpjK2EqdS1vKmgsdGhpcy55PW4rbCpoK28qYy1yKnUsdGhpcy56PWkrbCp1K3IqaC1hKmMsdGhpc31wcm9qZWN0KHQpe3JldHVybiB0aGlzLmFwcGx5TWF0cml4NCh0Lm1hdHJpeFdvcmxkSW52ZXJzZSkuYXBwbHlNYXRyaXg0KHQucHJvamVjdGlvbk1hdHJpeCl9dW5wcm9qZWN0KHQpe3JldHVybiB0aGlzLmFwcGx5TWF0cml4NCh0LnByb2plY3Rpb25NYXRyaXhJbnZlcnNlKS5hcHBseU1hdHJpeDQodC5tYXRyaXhXb3JsZCl9dHJhbnNmb3JtRGlyZWN0aW9uKHQpe2xldCBlPXRoaXMueCxuPXRoaXMueSxpPXRoaXMueixyPXQuZWxlbWVudHM7cmV0dXJuIHRoaXMueD1yWzBdKmUrcls0XSpuK3JbOF0qaSx0aGlzLnk9clsxXSplK3JbNV0qbityWzldKmksdGhpcy56PXJbMl0qZStyWzZdKm4rclsxMF0qaSx0aGlzLm5vcm1hbGl6ZSgpfWRpdmlkZSh0KXtyZXR1cm4gdGhpcy54Lz10LngsdGhpcy55Lz10LnksdGhpcy56Lz10LnosdGhpc31kaXZpZGVTY2FsYXIodCl7cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMS90KX1taW4odCl7cmV0dXJuIHRoaXMueD1NYXRoLm1pbih0aGlzLngsdC54KSx0aGlzLnk9TWF0aC5taW4odGhpcy55LHQueSksdGhpcy56PU1hdGgubWluKHRoaXMueix0LnopLHRoaXN9bWF4KHQpe3JldHVybiB0aGlzLng9TWF0aC5tYXgodGhpcy54LHQueCksdGhpcy55PU1hdGgubWF4KHRoaXMueSx0LnkpLHRoaXMuej1NYXRoLm1heCh0aGlzLnosdC56KSx0aGlzfWNsYW1wKHQsZSl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0LngsTWF0aC5taW4oZS54LHRoaXMueCkpLHRoaXMueT1NYXRoLm1heCh0LnksTWF0aC5taW4oZS55LHRoaXMueSkpLHRoaXMuej1NYXRoLm1heCh0LnosTWF0aC5taW4oZS56LHRoaXMueikpLHRoaXN9Y2xhbXBTY2FsYXIodCxlKXtyZXR1cm4gdGhpcy54PU1hdGgubWF4KHQsTWF0aC5taW4oZSx0aGlzLngpKSx0aGlzLnk9TWF0aC5tYXgodCxNYXRoLm1pbihlLHRoaXMueSkpLHRoaXMuej1NYXRoLm1heCh0LE1hdGgubWluKGUsdGhpcy56KSksdGhpc31jbGFtcExlbmd0aCh0LGUpe2xldCBuPXRoaXMubGVuZ3RoKCk7cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKG58fDEpLm11bHRpcGx5U2NhbGFyKE1hdGgubWF4KHQsTWF0aC5taW4oZSxuKSkpfWZsb29yKCl7cmV0dXJuIHRoaXMueD1NYXRoLmZsb29yKHRoaXMueCksdGhpcy55PU1hdGguZmxvb3IodGhpcy55KSx0aGlzLno9TWF0aC5mbG9vcih0aGlzLnopLHRoaXN9Y2VpbCgpe3JldHVybiB0aGlzLng9TWF0aC5jZWlsKHRoaXMueCksdGhpcy55PU1hdGguY2VpbCh0aGlzLnkpLHRoaXMuej1NYXRoLmNlaWwodGhpcy56KSx0aGlzfXJvdW5kKCl7cmV0dXJuIHRoaXMueD1NYXRoLnJvdW5kKHRoaXMueCksdGhpcy55PU1hdGgucm91bmQodGhpcy55KSx0aGlzLno9TWF0aC5yb3VuZCh0aGlzLnopLHRoaXN9cm91bmRUb1plcm8oKXtyZXR1cm4gdGhpcy54PU1hdGgudHJ1bmModGhpcy54KSx0aGlzLnk9TWF0aC50cnVuYyh0aGlzLnkpLHRoaXMuej1NYXRoLnRydW5jKHRoaXMueiksdGhpc31uZWdhdGUoKXtyZXR1cm4gdGhpcy54PS10aGlzLngsdGhpcy55PS10aGlzLnksdGhpcy56PS10aGlzLnosdGhpc31kb3QodCl7cmV0dXJuIHRoaXMueCp0LngrdGhpcy55KnQueSt0aGlzLnoqdC56fWxlbmd0aFNxKCl7cmV0dXJuIHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56fWxlbmd0aCgpe3JldHVybiBNYXRoLnNxcnQodGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnopfW1hbmhhdHRhbkxlbmd0aCgpe3JldHVybiBNYXRoLmFicyh0aGlzLngpK01hdGguYWJzKHRoaXMueSkrTWF0aC5hYnModGhpcy56KX1ub3JtYWxpemUoKXtyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKXx8MSl9c2V0TGVuZ3RoKHQpe3JldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKHQpfWxlcnAodCxlKXtyZXR1cm4gdGhpcy54Kz0odC54LXRoaXMueCkqZSx0aGlzLnkrPSh0LnktdGhpcy55KSplLHRoaXMueis9KHQuei10aGlzLnopKmUsdGhpc31sZXJwVmVjdG9ycyh0LGUsbil7cmV0dXJuIHRoaXMueD10LngrKGUueC10LngpKm4sdGhpcy55PXQueSsoZS55LXQueSkqbix0aGlzLno9dC56KyhlLnotdC56KSpuLHRoaXN9Y3Jvc3ModCl7cmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKHRoaXMsdCl9Y3Jvc3NWZWN0b3JzKHQsZSl7bGV0IG49dC54LGk9dC55LHI9dC56LGE9ZS54LG89ZS55LGw9ZS56O3JldHVybiB0aGlzLng9aSpsLXIqbyx0aGlzLnk9ciphLW4qbCx0aGlzLno9bipvLWkqYSx0aGlzfXByb2plY3RPblZlY3Rvcih0KXtsZXQgZT10Lmxlbmd0aFNxKCk7aWYoZT09PTApcmV0dXJuIHRoaXMuc2V0KDAsMCwwKTtsZXQgbj10LmRvdCh0aGlzKS9lO3JldHVybiB0aGlzLmNvcHkodCkubXVsdGlwbHlTY2FsYXIobil9cHJvamVjdE9uUGxhbmUodCl7cmV0dXJuIHBsLmNvcHkodGhpcykucHJvamVjdE9uVmVjdG9yKHQpLHRoaXMuc3ViKHBsKX1yZWZsZWN0KHQpe3JldHVybiB0aGlzLnN1YihwbC5jb3B5KHQpLm11bHRpcGx5U2NhbGFyKDIqdGhpcy5kb3QodCkpKX1hbmdsZVRvKHQpe2xldCBlPU1hdGguc3FydCh0aGlzLmxlbmd0aFNxKCkqdC5sZW5ndGhTcSgpKTtpZihlPT09MClyZXR1cm4gTWF0aC5QSS8yO2xldCBuPXRoaXMuZG90KHQpL2U7cmV0dXJuIE1hdGguYWNvcyh1ZShuLC0xLDEpKX1kaXN0YW5jZVRvKHQpe3JldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVRvU3F1YXJlZCh0KSl9ZGlzdGFuY2VUb1NxdWFyZWQodCl7bGV0IGU9dGhpcy54LXQueCxuPXRoaXMueS10LnksaT10aGlzLnotdC56O3JldHVybiBlKmUrbipuK2kqaX1tYW5oYXR0YW5EaXN0YW5jZVRvKHQpe3JldHVybiBNYXRoLmFicyh0aGlzLngtdC54KStNYXRoLmFicyh0aGlzLnktdC55KStNYXRoLmFicyh0aGlzLnotdC56KX1zZXRGcm9tU3BoZXJpY2FsKHQpe3JldHVybiB0aGlzLnNldEZyb21TcGhlcmljYWxDb29yZHModC5yYWRpdXMsdC5waGksdC50aGV0YSl9c2V0RnJvbVNwaGVyaWNhbENvb3Jkcyh0LGUsbil7bGV0IGk9TWF0aC5zaW4oZSkqdDtyZXR1cm4gdGhpcy54PWkqTWF0aC5zaW4obiksdGhpcy55PU1hdGguY29zKGUpKnQsdGhpcy56PWkqTWF0aC5jb3MobiksdGhpc31zZXRGcm9tQ3lsaW5kcmljYWwodCl7cmV0dXJuIHRoaXMuc2V0RnJvbUN5bGluZHJpY2FsQ29vcmRzKHQucmFkaXVzLHQudGhldGEsdC55KX1zZXRGcm9tQ3lsaW5kcmljYWxDb29yZHModCxlLG4pe3JldHVybiB0aGlzLng9dCpNYXRoLnNpbihlKSx0aGlzLnk9bix0aGlzLno9dCpNYXRoLmNvcyhlKSx0aGlzfXNldEZyb21NYXRyaXhQb3NpdGlvbih0KXtsZXQgZT10LmVsZW1lbnRzO3JldHVybiB0aGlzLng9ZVsxMl0sdGhpcy55PWVbMTNdLHRoaXMuej1lWzE0XSx0aGlzfXNldEZyb21NYXRyaXhTY2FsZSh0KXtsZXQgZT10aGlzLnNldEZyb21NYXRyaXhDb2x1bW4odCwwKS5sZW5ndGgoKSxuPXRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbih0LDEpLmxlbmd0aCgpLGk9dGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKHQsMikubGVuZ3RoKCk7cmV0dXJuIHRoaXMueD1lLHRoaXMueT1uLHRoaXMuej1pLHRoaXN9c2V0RnJvbU1hdHJpeENvbHVtbih0LGUpe3JldHVybiB0aGlzLmZyb21BcnJheSh0LmVsZW1lbnRzLGUqNCl9c2V0RnJvbU1hdHJpeDNDb2x1bW4odCxlKXtyZXR1cm4gdGhpcy5mcm9tQXJyYXkodC5lbGVtZW50cyxlKjMpfXNldEZyb21FdWxlcih0KXtyZXR1cm4gdGhpcy54PXQuX3gsdGhpcy55PXQuX3ksdGhpcy56PXQuX3osdGhpc31zZXRGcm9tQ29sb3IodCl7cmV0dXJuIHRoaXMueD10LnIsdGhpcy55PXQuZyx0aGlzLno9dC5iLHRoaXN9ZXF1YWxzKHQpe3JldHVybiB0Lng9PT10aGlzLngmJnQueT09PXRoaXMueSYmdC56PT09dGhpcy56fWZyb21BcnJheSh0LGU9MCl7cmV0dXJuIHRoaXMueD10W2VdLHRoaXMueT10W2UrMV0sdGhpcy56PXRbZSsyXSx0aGlzfXRvQXJyYXkodD1bXSxlPTApe3JldHVybiB0W2VdPXRoaXMueCx0W2UrMV09dGhpcy55LHRbZSsyXT10aGlzLnosdH1mcm9tQnVmZmVyQXR0cmlidXRlKHQsZSl7cmV0dXJuIHRoaXMueD10LmdldFgoZSksdGhpcy55PXQuZ2V0WShlKSx0aGlzLno9dC5nZXRaKGUpLHRoaXN9cmFuZG9tKCl7cmV0dXJuIHRoaXMueD1NYXRoLnJhbmRvbSgpLHRoaXMueT1NYXRoLnJhbmRvbSgpLHRoaXMuej1NYXRoLnJhbmRvbSgpLHRoaXN9cmFuZG9tRGlyZWN0aW9uKCl7bGV0IHQ9KE1hdGgucmFuZG9tKCktLjUpKjIsZT1NYXRoLnJhbmRvbSgpKk1hdGguUEkqMixuPU1hdGguc3FydCgxLXQqKjIpO3JldHVybiB0aGlzLng9bipNYXRoLmNvcyhlKSx0aGlzLnk9bipNYXRoLnNpbihlKSx0aGlzLno9dCx0aGlzfSpbU3ltYm9sLml0ZXJhdG9yXSgpe3lpZWxkIHRoaXMueCx5aWVsZCB0aGlzLnkseWllbGQgdGhpcy56fX0scGw9bmV3IFIseHU9bmV3IERlLHdlPWNsYXNze2NvbnN0cnVjdG9yKHQ9bmV3IFIoMS8wLDEvMCwxLzApLGU9bmV3IFIoLTEvMCwtMS8wLC0xLzApKXt0aGlzLmlzQm94Mz0hMCx0aGlzLm1pbj10LHRoaXMubWF4PWV9c2V0KHQsZSl7cmV0dXJuIHRoaXMubWluLmNvcHkodCksdGhpcy5tYXguY29weShlKSx0aGlzfXNldEZyb21BcnJheSh0KXt0aGlzLm1ha2VFbXB0eSgpO2ZvcihsZXQgZT0wLG49dC5sZW5ndGg7ZTxuO2UrPTMpdGhpcy5leHBhbmRCeVBvaW50KHNuLmZyb21BcnJheSh0LGUpKTtyZXR1cm4gdGhpc31zZXRGcm9tQnVmZmVyQXR0cmlidXRlKHQpe3RoaXMubWFrZUVtcHR5KCk7Zm9yKGxldCBlPTAsbj10LmNvdW50O2U8bjtlKyspdGhpcy5leHBhbmRCeVBvaW50KHNuLmZyb21CdWZmZXJBdHRyaWJ1dGUodCxlKSk7cmV0dXJuIHRoaXN9c2V0RnJvbVBvaW50cyh0KXt0aGlzLm1ha2VFbXB0eSgpO2ZvcihsZXQgZT0wLG49dC5sZW5ndGg7ZTxuO2UrKyl0aGlzLmV4cGFuZEJ5UG9pbnQodFtlXSk7cmV0dXJuIHRoaXN9c2V0RnJvbUNlbnRlckFuZFNpemUodCxlKXtsZXQgbj1zbi5jb3B5KGUpLm11bHRpcGx5U2NhbGFyKC41KTtyZXR1cm4gdGhpcy5taW4uY29weSh0KS5zdWIobiksdGhpcy5tYXguY29weSh0KS5hZGQobiksdGhpc31zZXRGcm9tT2JqZWN0KHQsZT0hMSl7cmV0dXJuIHRoaXMubWFrZUVtcHR5KCksdGhpcy5leHBhbmRCeU9iamVjdCh0LGUpfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX1jb3B5KHQpe3JldHVybiB0aGlzLm1pbi5jb3B5KHQubWluKSx0aGlzLm1heC5jb3B5KHQubWF4KSx0aGlzfW1ha2VFbXB0eSgpe3JldHVybiB0aGlzLm1pbi54PXRoaXMubWluLnk9dGhpcy5taW4uej0xLzAsdGhpcy5tYXgueD10aGlzLm1heC55PXRoaXMubWF4Lno9LTEvMCx0aGlzfWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5tYXgueDx0aGlzLm1pbi54fHx0aGlzLm1heC55PHRoaXMubWluLnl8fHRoaXMubWF4Lno8dGhpcy5taW4uen1nZXRDZW50ZXIodCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP3Quc2V0KDAsMCwwKTp0LmFkZFZlY3RvcnModGhpcy5taW4sdGhpcy5tYXgpLm11bHRpcGx5U2NhbGFyKC41KX1nZXRTaXplKHQpe3JldHVybiB0aGlzLmlzRW1wdHkoKT90LnNldCgwLDAsMCk6dC5zdWJWZWN0b3JzKHRoaXMubWF4LHRoaXMubWluKX1leHBhbmRCeVBvaW50KHQpe3JldHVybiB0aGlzLm1pbi5taW4odCksdGhpcy5tYXgubWF4KHQpLHRoaXN9ZXhwYW5kQnlWZWN0b3IodCl7cmV0dXJuIHRoaXMubWluLnN1Yih0KSx0aGlzLm1heC5hZGQodCksdGhpc31leHBhbmRCeVNjYWxhcih0KXtyZXR1cm4gdGhpcy5taW4uYWRkU2NhbGFyKC10KSx0aGlzLm1heC5hZGRTY2FsYXIodCksdGhpc31leHBhbmRCeU9iamVjdCh0LGU9ITEpe3QudXBkYXRlV29ybGRNYXRyaXgoITEsITEpO2xldCBuPXQuZ2VvbWV0cnk7aWYobiE9PXZvaWQgMCl7bGV0IHI9bi5nZXRBdHRyaWJ1dGUoInBvc2l0aW9uIik7aWYoZT09PSEwJiZyIT09dm9pZCAwJiZ0LmlzSW5zdGFuY2VkTWVzaCE9PSEwKWZvcihsZXQgYT0wLG89ci5jb3VudDthPG87YSsrKXQuaXNNZXNoPT09ITA/dC5nZXRWZXJ0ZXhQb3NpdGlvbihhLHNuKTpzbi5mcm9tQnVmZmVyQXR0cmlidXRlKHIsYSksc24uYXBwbHlNYXRyaXg0KHQubWF0cml4V29ybGQpLHRoaXMuZXhwYW5kQnlQb2ludChzbik7ZWxzZSB0LmJvdW5kaW5nQm94IT09dm9pZCAwPyh0LmJvdW5kaW5nQm94PT09bnVsbCYmdC5jb21wdXRlQm91bmRpbmdCb3goKSxrci5jb3B5KHQuYm91bmRpbmdCb3gpKToobi5ib3VuZGluZ0JveD09PW51bGwmJm4uY29tcHV0ZUJvdW5kaW5nQm94KCksa3IuY29weShuLmJvdW5kaW5nQm94KSksa3IuYXBwbHlNYXRyaXg0KHQubWF0cml4V29ybGQpLHRoaXMudW5pb24oa3IpfWxldCBpPXQuY2hpbGRyZW47Zm9yKGxldCByPTAsYT1pLmxlbmd0aDtyPGE7cisrKXRoaXMuZXhwYW5kQnlPYmplY3QoaVtyXSxlKTtyZXR1cm4gdGhpc31jb250YWluc1BvaW50KHQpe3JldHVybiEodC54PHRoaXMubWluLnh8fHQueD50aGlzLm1heC54fHx0Lnk8dGhpcy5taW4ueXx8dC55PnRoaXMubWF4Lnl8fHQuejx0aGlzLm1pbi56fHx0Lno+dGhpcy5tYXgueil9Y29udGFpbnNCb3godCl7cmV0dXJuIHRoaXMubWluLng8PXQubWluLngmJnQubWF4Lng8PXRoaXMubWF4LngmJnRoaXMubWluLnk8PXQubWluLnkmJnQubWF4Lnk8PXRoaXMubWF4LnkmJnRoaXMubWluLno8PXQubWluLnomJnQubWF4Lno8PXRoaXMubWF4Lnp9Z2V0UGFyYW1ldGVyKHQsZSl7cmV0dXJuIGUuc2V0KCh0LngtdGhpcy5taW4ueCkvKHRoaXMubWF4LngtdGhpcy5taW4ueCksKHQueS10aGlzLm1pbi55KS8odGhpcy5tYXgueS10aGlzLm1pbi55KSwodC56LXRoaXMubWluLnopLyh0aGlzLm1heC56LXRoaXMubWluLnopKX1pbnRlcnNlY3RzQm94KHQpe3JldHVybiEodC5tYXgueDx0aGlzLm1pbi54fHx0Lm1pbi54PnRoaXMubWF4Lnh8fHQubWF4Lnk8dGhpcy5taW4ueXx8dC5taW4ueT50aGlzLm1heC55fHx0Lm1heC56PHRoaXMubWluLnp8fHQubWluLno+dGhpcy5tYXgueil9aW50ZXJzZWN0c1NwaGVyZSh0KXtyZXR1cm4gdGhpcy5jbGFtcFBvaW50KHQuY2VudGVyLHNuKSxzbi5kaXN0YW5jZVRvU3F1YXJlZCh0LmNlbnRlcik8PXQucmFkaXVzKnQucmFkaXVzfWludGVyc2VjdHNQbGFuZSh0KXtsZXQgZSxuO3JldHVybiB0Lm5vcm1hbC54PjA/KGU9dC5ub3JtYWwueCp0aGlzLm1pbi54LG49dC5ub3JtYWwueCp0aGlzLm1heC54KTooZT10Lm5vcm1hbC54KnRoaXMubWF4Lngsbj10Lm5vcm1hbC54KnRoaXMubWluLngpLHQubm9ybWFsLnk+MD8oZSs9dC5ub3JtYWwueSp0aGlzLm1pbi55LG4rPXQubm9ybWFsLnkqdGhpcy5tYXgueSk6KGUrPXQubm9ybWFsLnkqdGhpcy5tYXgueSxuKz10Lm5vcm1hbC55KnRoaXMubWluLnkpLHQubm9ybWFsLno+MD8oZSs9dC5ub3JtYWwueip0aGlzLm1pbi56LG4rPXQubm9ybWFsLnoqdGhpcy5tYXgueik6KGUrPXQubm9ybWFsLnoqdGhpcy5tYXgueixuKz10Lm5vcm1hbC56KnRoaXMubWluLnopLGU8PS10LmNvbnN0YW50JiZuPj0tdC5jb25zdGFudH1pbnRlcnNlY3RzVHJpYW5nbGUodCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuITE7dGhpcy5nZXRDZW50ZXIoQ3MpLEhyLnN1YlZlY3RvcnModGhpcy5tYXgsQ3MpLEhpLnN1YlZlY3RvcnModC5hLENzKSxHaS5zdWJWZWN0b3JzKHQuYixDcyksV2kuc3ViVmVjdG9ycyh0LmMsQ3MpLEhuLnN1YlZlY3RvcnMoR2ksSGkpLEduLnN1YlZlY3RvcnMoV2ksR2kpLGNpLnN1YlZlY3RvcnMoSGksV2kpO2xldCBlPVswLC1Ibi56LEhuLnksMCwtR24ueixHbi55LDAsLWNpLnosY2kueSxIbi56LDAsLUhuLngsR24ueiwwLC1Hbi54LGNpLnosMCwtY2kueCwtSG4ueSxIbi54LDAsLUduLnksR24ueCwwLC1jaS55LGNpLngsMF07cmV0dXJuIW1sKGUsSGksR2ksV2ksSHIpfHwoZT1bMSwwLDAsMCwxLDAsMCwwLDFdLCFtbChlLEhpLEdpLFdpLEhyKSk/ITE6KEdyLmNyb3NzVmVjdG9ycyhIbixHbiksZT1bR3IueCxHci55LEdyLnpdLG1sKGUsSGksR2ksV2ksSHIpKX1jbGFtcFBvaW50KHQsZSl7cmV0dXJuIGUuY29weSh0KS5jbGFtcCh0aGlzLm1pbix0aGlzLm1heCl9ZGlzdGFuY2VUb1BvaW50KHQpe3JldHVybiB0aGlzLmNsYW1wUG9pbnQodCxzbikuZGlzdGFuY2VUbyh0KX1nZXRCb3VuZGluZ1NwaGVyZSh0KXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/dC5tYWtlRW1wdHkoKToodGhpcy5nZXRDZW50ZXIodC5jZW50ZXIpLHQucmFkaXVzPXRoaXMuZ2V0U2l6ZShzbikubGVuZ3RoKCkqLjUpLHR9aW50ZXJzZWN0KHQpe3JldHVybiB0aGlzLm1pbi5tYXgodC5taW4pLHRoaXMubWF4Lm1pbih0Lm1heCksdGhpcy5pc0VtcHR5KCkmJnRoaXMubWFrZUVtcHR5KCksdGhpc311bmlvbih0KXtyZXR1cm4gdGhpcy5taW4ubWluKHQubWluKSx0aGlzLm1heC5tYXgodC5tYXgpLHRoaXN9YXBwbHlNYXRyaXg0KHQpe3JldHVybiB0aGlzLmlzRW1wdHkoKT90aGlzOihTblswXS5zZXQodGhpcy5taW4ueCx0aGlzLm1pbi55LHRoaXMubWluLnopLmFwcGx5TWF0cml4NCh0KSxTblsxXS5zZXQodGhpcy5taW4ueCx0aGlzLm1pbi55LHRoaXMubWF4LnopLmFwcGx5TWF0cml4NCh0KSxTblsyXS5zZXQodGhpcy5taW4ueCx0aGlzLm1heC55LHRoaXMubWluLnopLmFwcGx5TWF0cml4NCh0KSxTblszXS5zZXQodGhpcy5taW4ueCx0aGlzLm1heC55LHRoaXMubWF4LnopLmFwcGx5TWF0cml4NCh0KSxTbls0XS5zZXQodGhpcy5tYXgueCx0aGlzLm1pbi55LHRoaXMubWluLnopLmFwcGx5TWF0cml4NCh0KSxTbls1XS5zZXQodGhpcy5tYXgueCx0aGlzLm1pbi55LHRoaXMubWF4LnopLmFwcGx5TWF0cml4NCh0KSxTbls2XS5zZXQodGhpcy5tYXgueCx0aGlzLm1heC55LHRoaXMubWluLnopLmFwcGx5TWF0cml4NCh0KSxTbls3XS5zZXQodGhpcy5tYXgueCx0aGlzLm1heC55LHRoaXMubWF4LnopLmFwcGx5TWF0cml4NCh0KSx0aGlzLnNldEZyb21Qb2ludHMoU24pLHRoaXMpfXRyYW5zbGF0ZSh0KXtyZXR1cm4gdGhpcy5taW4uYWRkKHQpLHRoaXMubWF4LmFkZCh0KSx0aGlzfWVxdWFscyh0KXtyZXR1cm4gdC5taW4uZXF1YWxzKHRoaXMubWluKSYmdC5tYXguZXF1YWxzKHRoaXMubWF4KX19LFNuPVtuZXcgUixuZXcgUixuZXcgUixuZXcgUixuZXcgUixuZXcgUixuZXcgUixuZXcgUl0sc249bmV3IFIsa3I9bmV3IHdlLEhpPW5ldyBSLEdpPW5ldyBSLFdpPW5ldyBSLEhuPW5ldyBSLEduPW5ldyBSLGNpPW5ldyBSLENzPW5ldyBSLEhyPW5ldyBSLEdyPW5ldyBSLGhpPW5ldyBSO2Z1bmN0aW9uIG1sKHMsdCxlLG4saSl7Zm9yKGxldCByPTAsYT1zLmxlbmd0aC0zO3I8PWE7cis9Myl7aGkuZnJvbUFycmF5KHMscik7bGV0IG89aS54Kk1hdGguYWJzKGhpLngpK2kueSpNYXRoLmFicyhoaS55KStpLnoqTWF0aC5hYnMoaGkueiksbD10LmRvdChoaSksYz1lLmRvdChoaSksaD1uLmRvdChoaSk7aWYoTWF0aC5tYXgoLU1hdGgubWF4KGwsYyxoKSxNYXRoLm1pbihsLGMsaCkpPm8pcmV0dXJuITF9cmV0dXJuITB9dmFyIEVtPW5ldyB3ZSxQcz1uZXcgUixnbD1uZXcgUixFZT1jbGFzc3tjb25zdHJ1Y3Rvcih0PW5ldyBSLGU9LTEpe3RoaXMuaXNTcGhlcmU9ITAsdGhpcy5jZW50ZXI9dCx0aGlzLnJhZGl1cz1lfXNldCh0LGUpe3JldHVybiB0aGlzLmNlbnRlci5jb3B5KHQpLHRoaXMucmFkaXVzPWUsdGhpc31zZXRGcm9tUG9pbnRzKHQsZSl7bGV0IG49dGhpcy5jZW50ZXI7ZSE9PXZvaWQgMD9uLmNvcHkoZSk6RW0uc2V0RnJvbVBvaW50cyh0KS5nZXRDZW50ZXIobik7bGV0IGk9MDtmb3IobGV0IHI9MCxhPXQubGVuZ3RoO3I8YTtyKyspaT1NYXRoLm1heChpLG4uZGlzdGFuY2VUb1NxdWFyZWQodFtyXSkpO3JldHVybiB0aGlzLnJhZGl1cz1NYXRoLnNxcnQoaSksdGhpc31jb3B5KHQpe3JldHVybiB0aGlzLmNlbnRlci5jb3B5KHQuY2VudGVyKSx0aGlzLnJhZGl1cz10LnJhZGl1cyx0aGlzfWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5yYWRpdXM8MH1tYWtlRW1wdHkoKXtyZXR1cm4gdGhpcy5jZW50ZXIuc2V0KDAsMCwwKSx0aGlzLnJhZGl1cz0tMSx0aGlzfWNvbnRhaW5zUG9pbnQodCl7cmV0dXJuIHQuZGlzdGFuY2VUb1NxdWFyZWQodGhpcy5jZW50ZXIpPD10aGlzLnJhZGl1cyp0aGlzLnJhZGl1c31kaXN0YW5jZVRvUG9pbnQodCl7cmV0dXJuIHQuZGlzdGFuY2VUbyh0aGlzLmNlbnRlciktdGhpcy5yYWRpdXN9aW50ZXJzZWN0c1NwaGVyZSh0KXtsZXQgZT10aGlzLnJhZGl1cyt0LnJhZGl1cztyZXR1cm4gdC5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQodGhpcy5jZW50ZXIpPD1lKmV9aW50ZXJzZWN0c0JveCh0KXtyZXR1cm4gdC5pbnRlcnNlY3RzU3BoZXJlKHRoaXMpfWludGVyc2VjdHNQbGFuZSh0KXtyZXR1cm4gTWF0aC5hYnModC5kaXN0YW5jZVRvUG9pbnQodGhpcy5jZW50ZXIpKTw9dGhpcy5yYWRpdXN9Y2xhbXBQb2ludCh0LGUpe2xldCBuPXRoaXMuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKHQpO3JldHVybiBlLmNvcHkodCksbj50aGlzLnJhZGl1cyp0aGlzLnJhZGl1cyYmKGUuc3ViKHRoaXMuY2VudGVyKS5ub3JtYWxpemUoKSxlLm11bHRpcGx5U2NhbGFyKHRoaXMucmFkaXVzKS5hZGQodGhpcy5jZW50ZXIpKSxlfWdldEJvdW5kaW5nQm94KHQpe3JldHVybiB0aGlzLmlzRW1wdHkoKT8odC5tYWtlRW1wdHkoKSx0KToodC5zZXQodGhpcy5jZW50ZXIsdGhpcy5jZW50ZXIpLHQuZXhwYW5kQnlTY2FsYXIodGhpcy5yYWRpdXMpLHQpfWFwcGx5TWF0cml4NCh0KXtyZXR1cm4gdGhpcy5jZW50ZXIuYXBwbHlNYXRyaXg0KHQpLHRoaXMucmFkaXVzPXRoaXMucmFkaXVzKnQuZ2V0TWF4U2NhbGVPbkF4aXMoKSx0aGlzfXRyYW5zbGF0ZSh0KXtyZXR1cm4gdGhpcy5jZW50ZXIuYWRkKHQpLHRoaXN9ZXhwYW5kQnlQb2ludCh0KXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5jZW50ZXIuY29weSh0KSx0aGlzLnJhZGl1cz0wLHRoaXM7UHMuc3ViVmVjdG9ycyh0LHRoaXMuY2VudGVyKTtsZXQgZT1Qcy5sZW5ndGhTcSgpO2lmKGU+dGhpcy5yYWRpdXMqdGhpcy5yYWRpdXMpe2xldCBuPU1hdGguc3FydChlKSxpPShuLXRoaXMucmFkaXVzKSouNTt0aGlzLmNlbnRlci5hZGRTY2FsZWRWZWN0b3IoUHMsaS9uKSx0aGlzLnJhZGl1cys9aX1yZXR1cm4gdGhpc311bmlvbih0KXtyZXR1cm4gdC5pc0VtcHR5KCk/dGhpczp0aGlzLmlzRW1wdHkoKT8odGhpcy5jb3B5KHQpLHRoaXMpOih0aGlzLmNlbnRlci5lcXVhbHModC5jZW50ZXIpPT09ITA/dGhpcy5yYWRpdXM9TWF0aC5tYXgodGhpcy5yYWRpdXMsdC5yYWRpdXMpOihnbC5zdWJWZWN0b3JzKHQuY2VudGVyLHRoaXMuY2VudGVyKS5zZXRMZW5ndGgodC5yYWRpdXMpLHRoaXMuZXhwYW5kQnlQb2ludChQcy5jb3B5KHQuY2VudGVyKS5hZGQoZ2wpKSx0aGlzLmV4cGFuZEJ5UG9pbnQoUHMuY29weSh0LmNlbnRlcikuc3ViKGdsKSkpLHRoaXMpfWVxdWFscyh0KXtyZXR1cm4gdC5jZW50ZXIuZXF1YWxzKHRoaXMuY2VudGVyKSYmdC5yYWRpdXM9PT10aGlzLnJhZGl1c31jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyl9fSxibj1uZXcgUixfbD1uZXcgUixXcj1uZXcgUixXbj1uZXcgUix4bD1uZXcgUixYcj1uZXcgUix2bD1uZXcgUixuaT1jbGFzc3tjb25zdHJ1Y3Rvcih0PW5ldyBSLGU9bmV3IFIoMCwwLC0xKSl7dGhpcy5vcmlnaW49dCx0aGlzLmRpcmVjdGlvbj1lfXNldCh0LGUpe3JldHVybiB0aGlzLm9yaWdpbi5jb3B5KHQpLHRoaXMuZGlyZWN0aW9uLmNvcHkoZSksdGhpc31jb3B5KHQpe3JldHVybiB0aGlzLm9yaWdpbi5jb3B5KHQub3JpZ2luKSx0aGlzLmRpcmVjdGlvbi5jb3B5KHQuZGlyZWN0aW9uKSx0aGlzfWF0KHQsZSl7cmV0dXJuIGUuY29weSh0aGlzLm9yaWdpbikuYWRkU2NhbGVkVmVjdG9yKHRoaXMuZGlyZWN0aW9uLHQpfWxvb2tBdCh0KXtyZXR1cm4gdGhpcy5kaXJlY3Rpb24uY29weSh0KS5zdWIodGhpcy5vcmlnaW4pLm5vcm1hbGl6ZSgpLHRoaXN9cmVjYXN0KHQpe3JldHVybiB0aGlzLm9yaWdpbi5jb3B5KHRoaXMuYXQodCxibikpLHRoaXN9Y2xvc2VzdFBvaW50VG9Qb2ludCh0LGUpe2Uuc3ViVmVjdG9ycyh0LHRoaXMub3JpZ2luKTtsZXQgbj1lLmRvdCh0aGlzLmRpcmVjdGlvbik7cmV0dXJuIG48MD9lLmNvcHkodGhpcy5vcmlnaW4pOmUuY29weSh0aGlzLm9yaWdpbikuYWRkU2NhbGVkVmVjdG9yKHRoaXMuZGlyZWN0aW9uLG4pfWRpc3RhbmNlVG9Qb2ludCh0KXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VTcVRvUG9pbnQodCkpfWRpc3RhbmNlU3FUb1BvaW50KHQpe2xldCBlPWJuLnN1YlZlY3RvcnModCx0aGlzLm9yaWdpbikuZG90KHRoaXMuZGlyZWN0aW9uKTtyZXR1cm4gZTwwP3RoaXMub3JpZ2luLmRpc3RhbmNlVG9TcXVhcmVkKHQpOihibi5jb3B5KHRoaXMub3JpZ2luKS5hZGRTY2FsZWRWZWN0b3IodGhpcy5kaXJlY3Rpb24sZSksYm4uZGlzdGFuY2VUb1NxdWFyZWQodCkpfWRpc3RhbmNlU3FUb1NlZ21lbnQodCxlLG4saSl7X2wuY29weSh0KS5hZGQoZSkubXVsdGlwbHlTY2FsYXIoLjUpLFdyLmNvcHkoZSkuc3ViKHQpLm5vcm1hbGl6ZSgpLFduLmNvcHkodGhpcy5vcmlnaW4pLnN1YihfbCk7bGV0IHI9dC5kaXN0YW5jZVRvKGUpKi41LGE9LXRoaXMuZGlyZWN0aW9uLmRvdChXciksbz1Xbi5kb3QodGhpcy5kaXJlY3Rpb24pLGw9LVduLmRvdChXciksYz1Xbi5sZW5ndGhTcSgpLGg9TWF0aC5hYnMoMS1hKmEpLHUsZCxmLG07aWYoaD4wKWlmKHU9YSpsLW8sZD1hKm8tbCxtPXIqaCx1Pj0wKWlmKGQ+PS1tKWlmKGQ8PW0pe2xldCBfPTEvaDt1Kj1fLGQqPV8sZj11Kih1K2EqZCsyKm8pK2QqKGEqdStkKzIqbCkrY31lbHNlIGQ9cix1PU1hdGgubWF4KDAsLShhKmQrbykpLGY9LXUqdStkKihkKzIqbCkrYztlbHNlIGQ9LXIsdT1NYXRoLm1heCgwLC0oYSpkK28pKSxmPS11KnUrZCooZCsyKmwpK2M7ZWxzZSBkPD0tbT8odT1NYXRoLm1heCgwLC0oLWEqcitvKSksZD11PjA/LXI6TWF0aC5taW4oTWF0aC5tYXgoLXIsLWwpLHIpLGY9LXUqdStkKihkKzIqbCkrYyk6ZDw9bT8odT0wLGQ9TWF0aC5taW4oTWF0aC5tYXgoLXIsLWwpLHIpLGY9ZCooZCsyKmwpK2MpOih1PU1hdGgubWF4KDAsLShhKnIrbykpLGQ9dT4wP3I6TWF0aC5taW4oTWF0aC5tYXgoLXIsLWwpLHIpLGY9LXUqdStkKihkKzIqbCkrYyk7ZWxzZSBkPWE+MD8tcjpyLHU9TWF0aC5tYXgoMCwtKGEqZCtvKSksZj0tdSp1K2QqKGQrMipsKStjO3JldHVybiBuJiZuLmNvcHkodGhpcy5vcmlnaW4pLmFkZFNjYWxlZFZlY3Rvcih0aGlzLmRpcmVjdGlvbix1KSxpJiZpLmNvcHkoX2wpLmFkZFNjYWxlZFZlY3RvcihXcixkKSxmfWludGVyc2VjdFNwaGVyZSh0LGUpe2JuLnN1YlZlY3RvcnModC5jZW50ZXIsdGhpcy5vcmlnaW4pO2xldCBuPWJuLmRvdCh0aGlzLmRpcmVjdGlvbiksaT1ibi5kb3QoYm4pLW4qbixyPXQucmFkaXVzKnQucmFkaXVzO2lmKGk+cilyZXR1cm4gbnVsbDtsZXQgYT1NYXRoLnNxcnQoci1pKSxvPW4tYSxsPW4rYTtyZXR1cm4gbDwwP251bGw6bzwwP3RoaXMuYXQobCxlKTp0aGlzLmF0KG8sZSl9aW50ZXJzZWN0c1NwaGVyZSh0KXtyZXR1cm4gdGhpcy5kaXN0YW5jZVNxVG9Qb2ludCh0LmNlbnRlcik8PXQucmFkaXVzKnQucmFkaXVzfWRpc3RhbmNlVG9QbGFuZSh0KXtsZXQgZT10Lm5vcm1hbC5kb3QodGhpcy5kaXJlY3Rpb24pO2lmKGU9PT0wKXJldHVybiB0LmRpc3RhbmNlVG9Qb2ludCh0aGlzLm9yaWdpbik9PT0wPzA6bnVsbDtsZXQgbj0tKHRoaXMub3JpZ2luLmRvdCh0Lm5vcm1hbCkrdC5jb25zdGFudCkvZTtyZXR1cm4gbj49MD9uOm51bGx9aW50ZXJzZWN0UGxhbmUodCxlKXtsZXQgbj10aGlzLmRpc3RhbmNlVG9QbGFuZSh0KTtyZXR1cm4gbj09PW51bGw/bnVsbDp0aGlzLmF0KG4sZSl9aW50ZXJzZWN0c1BsYW5lKHQpe2xldCBlPXQuZGlzdGFuY2VUb1BvaW50KHRoaXMub3JpZ2luKTtyZXR1cm4gZT09PTB8fHQubm9ybWFsLmRvdCh0aGlzLmRpcmVjdGlvbikqZTwwfWludGVyc2VjdEJveCh0LGUpe2xldCBuLGkscixhLG8sbCxjPTEvdGhpcy5kaXJlY3Rpb24ueCxoPTEvdGhpcy5kaXJlY3Rpb24ueSx1PTEvdGhpcy5kaXJlY3Rpb24ueixkPXRoaXMub3JpZ2luO3JldHVybiBjPj0wPyhuPSh0Lm1pbi54LWQueCkqYyxpPSh0Lm1heC54LWQueCkqYyk6KG49KHQubWF4LngtZC54KSpjLGk9KHQubWluLngtZC54KSpjKSxoPj0wPyhyPSh0Lm1pbi55LWQueSkqaCxhPSh0Lm1heC55LWQueSkqaCk6KHI9KHQubWF4LnktZC55KSpoLGE9KHQubWluLnktZC55KSpoKSxuPmF8fHI+aXx8KChyPm58fGlzTmFOKG4pKSYmKG49ciksKGE8aXx8aXNOYU4oaSkpJiYoaT1hKSx1Pj0wPyhvPSh0Lm1pbi56LWQueikqdSxsPSh0Lm1heC56LWQueikqdSk6KG89KHQubWF4LnotZC56KSp1LGw9KHQubWluLnotZC56KSp1KSxuPmx8fG8+aSl8fCgobz5ufHxuIT09bikmJihuPW8pLChsPGl8fGkhPT1pKSYmKGk9bCksaTwwKT9udWxsOnRoaXMuYXQobj49MD9uOmksZSl9aW50ZXJzZWN0c0JveCh0KXtyZXR1cm4gdGhpcy5pbnRlcnNlY3RCb3godCxibikhPT1udWxsfWludGVyc2VjdFRyaWFuZ2xlKHQsZSxuLGkscil7eGwuc3ViVmVjdG9ycyhlLHQpLFhyLnN1YlZlY3RvcnMobix0KSx2bC5jcm9zc1ZlY3RvcnMoeGwsWHIpO2xldCBhPXRoaXMuZGlyZWN0aW9uLmRvdCh2bCksbztpZihhPjApe2lmKGkpcmV0dXJuIG51bGw7bz0xfWVsc2UgaWYoYTwwKW89LTEsYT0tYTtlbHNlIHJldHVybiBudWxsO1duLnN1YlZlY3RvcnModGhpcy5vcmlnaW4sdCk7bGV0IGw9byp0aGlzLmRpcmVjdGlvbi5kb3QoWHIuY3Jvc3NWZWN0b3JzKFduLFhyKSk7aWYobDwwKXJldHVybiBudWxsO2xldCBjPW8qdGhpcy5kaXJlY3Rpb24uZG90KHhsLmNyb3NzKFduKSk7aWYoYzwwfHxsK2M+YSlyZXR1cm4gbnVsbDtsZXQgaD0tbypXbi5kb3QodmwpO3JldHVybiBoPDA/bnVsbDp0aGlzLmF0KGgvYSxyKX1hcHBseU1hdHJpeDQodCl7cmV0dXJuIHRoaXMub3JpZ2luLmFwcGx5TWF0cml4NCh0KSx0aGlzLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24odCksdGhpc31lcXVhbHModCl7cmV0dXJuIHQub3JpZ2luLmVxdWFscyh0aGlzLm9yaWdpbikmJnQuZGlyZWN0aW9uLmVxdWFscyh0aGlzLmRpcmVjdGlvbil9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpfX0sTHQ9Y2xhc3Mgc3tjb25zdHJ1Y3Rvcih0LGUsbixpLHIsYSxvLGwsYyxoLHUsZCxmLG0sXyxnKXtzLnByb3RvdHlwZS5pc01hdHJpeDQ9ITAsdGhpcy5lbGVtZW50cz1bMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMV0sdCE9PXZvaWQgMCYmdGhpcy5zZXQodCxlLG4saSxyLGEsbyxsLGMsaCx1LGQsZixtLF8sZyl9c2V0KHQsZSxuLGkscixhLG8sbCxjLGgsdSxkLGYsbSxfLGcpe2xldCBwPXRoaXMuZWxlbWVudHM7cmV0dXJuIHBbMF09dCxwWzRdPWUscFs4XT1uLHBbMTJdPWkscFsxXT1yLHBbNV09YSxwWzldPW8scFsxM109bCxwWzJdPWMscFs2XT1oLHBbMTBdPXUscFsxNF09ZCxwWzNdPWYscFs3XT1tLHBbMTFdPV8scFsxNV09Zyx0aGlzfWlkZW50aXR5KCl7cmV0dXJuIHRoaXMuc2V0KDEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCwwLDEpLHRoaXN9Y2xvbmUoKXtyZXR1cm4gbmV3IHMoKS5mcm9tQXJyYXkodGhpcy5lbGVtZW50cyl9Y29weSh0KXtsZXQgZT10aGlzLmVsZW1lbnRzLG49dC5lbGVtZW50cztyZXR1cm4gZVswXT1uWzBdLGVbMV09blsxXSxlWzJdPW5bMl0sZVszXT1uWzNdLGVbNF09bls0XSxlWzVdPW5bNV0sZVs2XT1uWzZdLGVbN109bls3XSxlWzhdPW5bOF0sZVs5XT1uWzldLGVbMTBdPW5bMTBdLGVbMTFdPW5bMTFdLGVbMTJdPW5bMTJdLGVbMTNdPW5bMTNdLGVbMTRdPW5bMTRdLGVbMTVdPW5bMTVdLHRoaXN9Y29weVBvc2l0aW9uKHQpe2xldCBlPXRoaXMuZWxlbWVudHMsbj10LmVsZW1lbnRzO3JldHVybiBlWzEyXT1uWzEyXSxlWzEzXT1uWzEzXSxlWzE0XT1uWzE0XSx0aGlzfXNldEZyb21NYXRyaXgzKHQpe2xldCBlPXQuZWxlbWVudHM7cmV0dXJuIHRoaXMuc2V0KGVbMF0sZVszXSxlWzZdLDAsZVsxXSxlWzRdLGVbN10sMCxlWzJdLGVbNV0sZVs4XSwwLDAsMCwwLDEpLHRoaXN9ZXh0cmFjdEJhc2lzKHQsZSxuKXtyZXR1cm4gdC5zZXRGcm9tTWF0cml4Q29sdW1uKHRoaXMsMCksZS5zZXRGcm9tTWF0cml4Q29sdW1uKHRoaXMsMSksbi5zZXRGcm9tTWF0cml4Q29sdW1uKHRoaXMsMiksdGhpc31tYWtlQmFzaXModCxlLG4pe3JldHVybiB0aGlzLnNldCh0LngsZS54LG4ueCwwLHQueSxlLnksbi55LDAsdC56LGUueixuLnosMCwwLDAsMCwxKSx0aGlzfWV4dHJhY3RSb3RhdGlvbih0KXtsZXQgZT10aGlzLmVsZW1lbnRzLG49dC5lbGVtZW50cyxpPTEvWGkuc2V0RnJvbU1hdHJpeENvbHVtbih0LDApLmxlbmd0aCgpLHI9MS9YaS5zZXRGcm9tTWF0cml4Q29sdW1uKHQsMSkubGVuZ3RoKCksYT0xL1hpLnNldEZyb21NYXRyaXhDb2x1bW4odCwyKS5sZW5ndGgoKTtyZXR1cm4gZVswXT1uWzBdKmksZVsxXT1uWzFdKmksZVsyXT1uWzJdKmksZVszXT0wLGVbNF09bls0XSpyLGVbNV09bls1XSpyLGVbNl09bls2XSpyLGVbN109MCxlWzhdPW5bOF0qYSxlWzldPW5bOV0qYSxlWzEwXT1uWzEwXSphLGVbMTFdPTAsZVsxMl09MCxlWzEzXT0wLGVbMTRdPTAsZVsxNV09MSx0aGlzfW1ha2VSb3RhdGlvbkZyb21FdWxlcih0KXtsZXQgZT10aGlzLmVsZW1lbnRzLG49dC54LGk9dC55LHI9dC56LGE9TWF0aC5jb3Mobiksbz1NYXRoLnNpbihuKSxsPU1hdGguY29zKGkpLGM9TWF0aC5zaW4oaSksaD1NYXRoLmNvcyhyKSx1PU1hdGguc2luKHIpO2lmKHQub3JkZXI9PT0iWFlaIil7bGV0IGQ9YSpoLGY9YSp1LG09bypoLF89byp1O2VbMF09bCpoLGVbNF09LWwqdSxlWzhdPWMsZVsxXT1mK20qYyxlWzVdPWQtXypjLGVbOV09LW8qbCxlWzJdPV8tZCpjLGVbNl09bStmKmMsZVsxMF09YSpsfWVsc2UgaWYodC5vcmRlcj09PSJZWFoiKXtsZXQgZD1sKmgsZj1sKnUsbT1jKmgsXz1jKnU7ZVswXT1kK18qbyxlWzRdPW0qby1mLGVbOF09YSpjLGVbMV09YSp1LGVbNV09YSpoLGVbOV09LW8sZVsyXT1mKm8tbSxlWzZdPV8rZCpvLGVbMTBdPWEqbH1lbHNlIGlmKHQub3JkZXI9PT0iWlhZIil7bGV0IGQ9bCpoLGY9bCp1LG09YypoLF89Yyp1O2VbMF09ZC1fKm8sZVs0XT0tYSp1LGVbOF09bStmKm8sZVsxXT1mK20qbyxlWzVdPWEqaCxlWzldPV8tZCpvLGVbMl09LWEqYyxlWzZdPW8sZVsxMF09YSpsfWVsc2UgaWYodC5vcmRlcj09PSJaWVgiKXtsZXQgZD1hKmgsZj1hKnUsbT1vKmgsXz1vKnU7ZVswXT1sKmgsZVs0XT1tKmMtZixlWzhdPWQqYytfLGVbMV09bCp1LGVbNV09XypjK2QsZVs5XT1mKmMtbSxlWzJdPS1jLGVbNl09bypsLGVbMTBdPWEqbH1lbHNlIGlmKHQub3JkZXI9PT0iWVpYIil7bGV0IGQ9YSpsLGY9YSpjLG09bypsLF89bypjO2VbMF09bCpoLGVbNF09Xy1kKnUsZVs4XT1tKnUrZixlWzFdPXUsZVs1XT1hKmgsZVs5XT0tbypoLGVbMl09LWMqaCxlWzZdPWYqdSttLGVbMTBdPWQtXyp1fWVsc2UgaWYodC5vcmRlcj09PSJYWlkiKXtsZXQgZD1hKmwsZj1hKmMsbT1vKmwsXz1vKmM7ZVswXT1sKmgsZVs0XT0tdSxlWzhdPWMqaCxlWzFdPWQqdStfLGVbNV09YSpoLGVbOV09Zip1LW0sZVsyXT1tKnUtZixlWzZdPW8qaCxlWzEwXT1fKnUrZH1yZXR1cm4gZVszXT0wLGVbN109MCxlWzExXT0wLGVbMTJdPTAsZVsxM109MCxlWzE0XT0wLGVbMTVdPTEsdGhpc31tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbih0KXtyZXR1cm4gdGhpcy5jb21wb3NlKEFtLHQsVG0pfWxvb2tBdCh0LGUsbil7bGV0IGk9dGhpcy5lbGVtZW50cztyZXR1cm4gV2Uuc3ViVmVjdG9ycyh0LGUpLFdlLmxlbmd0aFNxKCk9PT0wJiYoV2Uuej0xKSxXZS5ub3JtYWxpemUoKSxYbi5jcm9zc1ZlY3RvcnMobixXZSksWG4ubGVuZ3RoU3EoKT09PTAmJihNYXRoLmFicyhuLnopPT09MT9XZS54Kz0xZS00OldlLnorPTFlLTQsV2Uubm9ybWFsaXplKCksWG4uY3Jvc3NWZWN0b3JzKG4sV2UpKSxYbi5ub3JtYWxpemUoKSxxci5jcm9zc1ZlY3RvcnMoV2UsWG4pLGlbMF09WG4ueCxpWzRdPXFyLngsaVs4XT1XZS54LGlbMV09WG4ueSxpWzVdPXFyLnksaVs5XT1XZS55LGlbMl09WG4ueixpWzZdPXFyLnosaVsxMF09V2Uueix0aGlzfW11bHRpcGx5KHQpe3JldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXModGhpcyx0KX1wcmVtdWx0aXBseSh0KXtyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKHQsdGhpcyl9bXVsdGlwbHlNYXRyaWNlcyh0LGUpe2xldCBuPXQuZWxlbWVudHMsaT1lLmVsZW1lbnRzLHI9dGhpcy5lbGVtZW50cyxhPW5bMF0sbz1uWzRdLGw9bls4XSxjPW5bMTJdLGg9blsxXSx1PW5bNV0sZD1uWzldLGY9blsxM10sbT1uWzJdLF89bls2XSxnPW5bMTBdLHA9blsxNF0sdj1uWzNdLHg9bls3XSxNPW5bMTFdLEM9blsxNV0sQT1pWzBdLFQ9aVs0XSxVPWlbOF0saz1pWzEyXSx5PWlbMV0sdz1pWzVdLEc9aVs5XSxKPWlbMTNdLEk9aVsyXSx6PWlbNl0sRj1pWzEwXSwkPWlbMTRdLHE9aVszXSxXPWlbN10sZXQ9aVsxMV0sUT1pWzE1XTtyZXR1cm4gclswXT1hKkErbyp5K2wqSStjKnEscls0XT1hKlQrbyp3K2wqeitjKlcscls4XT1hKlUrbypHK2wqRitjKmV0LHJbMTJdPWEqaytvKkorbCokK2MqUSxyWzFdPWgqQSt1KnkrZCpJK2YqcSxyWzVdPWgqVCt1KncrZCp6K2YqVyxyWzldPWgqVSt1KkcrZCpGK2YqZXQsclsxM109aCprK3UqSitkKiQrZipRLHJbMl09bSpBK18qeStnKkkrcCpxLHJbNl09bSpUK18qdytnKnorcCpXLHJbMTBdPW0qVStfKkcrZypGK3AqZXQsclsxNF09bSprK18qSitnKiQrcCpRLHJbM109dipBK3gqeStNKkkrQypxLHJbN109dipUK3gqdytNKnorQypXLHJbMTFdPXYqVSt4KkcrTSpGK0MqZXQsclsxNV09diprK3gqSitNKiQrQypRLHRoaXN9bXVsdGlwbHlTY2FsYXIodCl7bGV0IGU9dGhpcy5lbGVtZW50cztyZXR1cm4gZVswXSo9dCxlWzRdKj10LGVbOF0qPXQsZVsxMl0qPXQsZVsxXSo9dCxlWzVdKj10LGVbOV0qPXQsZVsxM10qPXQsZVsyXSo9dCxlWzZdKj10LGVbMTBdKj10LGVbMTRdKj10LGVbM10qPXQsZVs3XSo9dCxlWzExXSo9dCxlWzE1XSo9dCx0aGlzfWRldGVybWluYW50KCl7bGV0IHQ9dGhpcy5lbGVtZW50cyxlPXRbMF0sbj10WzRdLGk9dFs4XSxyPXRbMTJdLGE9dFsxXSxvPXRbNV0sbD10WzldLGM9dFsxM10saD10WzJdLHU9dFs2XSxkPXRbMTBdLGY9dFsxNF0sbT10WzNdLF89dFs3XSxnPXRbMTFdLHA9dFsxNV07cmV0dXJuIG0qKCtyKmwqdS1pKmMqdS1yKm8qZCtuKmMqZCtpKm8qZi1uKmwqZikrXyooK2UqbCpmLWUqYypkK3IqYSpkLWkqYSpmK2kqYypoLXIqbCpoKStnKigrZSpjKnUtZSpvKmYtciphKnUrbiphKmYrcipvKmgtbipjKmgpK3AqKC1pKm8qaC1lKmwqdStlKm8qZCtpKmEqdS1uKmEqZCtuKmwqaCl9dHJhbnNwb3NlKCl7bGV0IHQ9dGhpcy5lbGVtZW50cyxlO3JldHVybiBlPXRbMV0sdFsxXT10WzRdLHRbNF09ZSxlPXRbMl0sdFsyXT10WzhdLHRbOF09ZSxlPXRbNl0sdFs2XT10WzldLHRbOV09ZSxlPXRbM10sdFszXT10WzEyXSx0WzEyXT1lLGU9dFs3XSx0WzddPXRbMTNdLHRbMTNdPWUsZT10WzExXSx0WzExXT10WzE0XSx0WzE0XT1lLHRoaXN9c2V0UG9zaXRpb24odCxlLG4pe2xldCBpPXRoaXMuZWxlbWVudHM7cmV0dXJuIHQuaXNWZWN0b3IzPyhpWzEyXT10LngsaVsxM109dC55LGlbMTRdPXQueik6KGlbMTJdPXQsaVsxM109ZSxpWzE0XT1uKSx0aGlzfWludmVydCgpe2xldCB0PXRoaXMuZWxlbWVudHMsZT10WzBdLG49dFsxXSxpPXRbMl0scj10WzNdLGE9dFs0XSxvPXRbNV0sbD10WzZdLGM9dFs3XSxoPXRbOF0sdT10WzldLGQ9dFsxMF0sZj10WzExXSxtPXRbMTJdLF89dFsxM10sZz10WzE0XSxwPXRbMTVdLHY9dSpnKmMtXypkKmMrXypsKmYtbypnKmYtdSpsKnArbypkKnAseD1tKmQqYy1oKmcqYy1tKmwqZithKmcqZitoKmwqcC1hKmQqcCxNPWgqXypjLW0qdSpjK20qbypmLWEqXypmLWgqbypwK2EqdSpwLEM9bSp1KmwtaCpfKmwtbSpvKmQrYSpfKmQraCpvKmctYSp1KmcsQT1lKnYrbip4K2kqTStyKkM7aWYoQT09PTApcmV0dXJuIHRoaXMuc2V0KDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDApO2xldCBUPTEvQTtyZXR1cm4gdFswXT12KlQsdFsxXT0oXypkKnItdSpnKnItXyppKmYrbipnKmYrdSppKnAtbipkKnApKlQsdFsyXT0obypnKnItXypsKnIrXyppKmMtbipnKmMtbyppKnArbipsKnApKlQsdFszXT0odSpsKnItbypkKnItdSppKmMrbipkKmMrbyppKmYtbipsKmYpKlQsdFs0XT14KlQsdFs1XT0oaCpnKnItbSpkKnIrbSppKmYtZSpnKmYtaCppKnArZSpkKnApKlQsdFs2XT0obSpsKnItYSpnKnItbSppKmMrZSpnKmMrYSppKnAtZSpsKnApKlQsdFs3XT0oYSpkKnItaCpsKnIraCppKmMtZSpkKmMtYSppKmYrZSpsKmYpKlQsdFs4XT1NKlQsdFs5XT0obSp1KnItaCpfKnItbSpuKmYrZSpfKmYraCpuKnAtZSp1KnApKlQsdFsxMF09KGEqXypyLW0qbypyK20qbipjLWUqXypjLWEqbipwK2UqbypwKSpULHRbMTFdPShoKm8qci1hKnUqci1oKm4qYytlKnUqYythKm4qZi1lKm8qZikqVCx0WzEyXT1DKlQsdFsxM109KGgqXyppLW0qdSppK20qbipkLWUqXypkLWgqbipnK2UqdSpnKSpULHRbMTRdPShtKm8qaS1hKl8qaS1tKm4qbCtlKl8qbCthKm4qZy1lKm8qZykqVCx0WzE1XT0oYSp1KmktaCpvKmkraCpuKmwtZSp1KmwtYSpuKmQrZSpvKmQpKlQsdGhpc31zY2FsZSh0KXtsZXQgZT10aGlzLmVsZW1lbnRzLG49dC54LGk9dC55LHI9dC56O3JldHVybiBlWzBdKj1uLGVbNF0qPWksZVs4XSo9cixlWzFdKj1uLGVbNV0qPWksZVs5XSo9cixlWzJdKj1uLGVbNl0qPWksZVsxMF0qPXIsZVszXSo9bixlWzddKj1pLGVbMTFdKj1yLHRoaXN9Z2V0TWF4U2NhbGVPbkF4aXMoKXtsZXQgdD10aGlzLmVsZW1lbnRzLGU9dFswXSp0WzBdK3RbMV0qdFsxXSt0WzJdKnRbMl0sbj10WzRdKnRbNF0rdFs1XSp0WzVdK3RbNl0qdFs2XSxpPXRbOF0qdFs4XSt0WzldKnRbOV0rdFsxMF0qdFsxMF07cmV0dXJuIE1hdGguc3FydChNYXRoLm1heChlLG4saSkpfW1ha2VUcmFuc2xhdGlvbih0LGUsbil7cmV0dXJuIHQuaXNWZWN0b3IzP3RoaXMuc2V0KDEsMCwwLHQueCwwLDEsMCx0LnksMCwwLDEsdC56LDAsMCwwLDEpOnRoaXMuc2V0KDEsMCwwLHQsMCwxLDAsZSwwLDAsMSxuLDAsMCwwLDEpLHRoaXN9bWFrZVJvdGF0aW9uWCh0KXtsZXQgZT1NYXRoLmNvcyh0KSxuPU1hdGguc2luKHQpO3JldHVybiB0aGlzLnNldCgxLDAsMCwwLDAsZSwtbiwwLDAsbixlLDAsMCwwLDAsMSksdGhpc31tYWtlUm90YXRpb25ZKHQpe2xldCBlPU1hdGguY29zKHQpLG49TWF0aC5zaW4odCk7cmV0dXJuIHRoaXMuc2V0KGUsMCxuLDAsMCwxLDAsMCwtbiwwLGUsMCwwLDAsMCwxKSx0aGlzfW1ha2VSb3RhdGlvbloodCl7bGV0IGU9TWF0aC5jb3ModCksbj1NYXRoLnNpbih0KTtyZXR1cm4gdGhpcy5zZXQoZSwtbiwwLDAsbixlLDAsMCwwLDAsMSwwLDAsMCwwLDEpLHRoaXN9bWFrZVJvdGF0aW9uQXhpcyh0LGUpe2xldCBuPU1hdGguY29zKGUpLGk9TWF0aC5zaW4oZSkscj0xLW4sYT10Lngsbz10LnksbD10LnosYz1yKmEsaD1yKm87cmV0dXJuIHRoaXMuc2V0KGMqYStuLGMqby1pKmwsYypsK2kqbywwLGMqbytpKmwsaCpvK24saCpsLWkqYSwwLGMqbC1pKm8saCpsK2kqYSxyKmwqbCtuLDAsMCwwLDAsMSksdGhpc31tYWtlU2NhbGUodCxlLG4pe3JldHVybiB0aGlzLnNldCh0LDAsMCwwLDAsZSwwLDAsMCwwLG4sMCwwLDAsMCwxKSx0aGlzfW1ha2VTaGVhcih0LGUsbixpLHIsYSl7cmV0dXJuIHRoaXMuc2V0KDEsbixyLDAsdCwxLGEsMCxlLGksMSwwLDAsMCwwLDEpLHRoaXN9Y29tcG9zZSh0LGUsbil7bGV0IGk9dGhpcy5lbGVtZW50cyxyPWUuX3gsYT1lLl95LG89ZS5feixsPWUuX3csYz1yK3IsaD1hK2EsdT1vK28sZD1yKmMsZj1yKmgsbT1yKnUsXz1hKmgsZz1hKnUscD1vKnUsdj1sKmMseD1sKmgsTT1sKnUsQz1uLngsQT1uLnksVD1uLno7cmV0dXJuIGlbMF09KDEtKF8rcCkpKkMsaVsxXT0oZitNKSpDLGlbMl09KG0teCkqQyxpWzNdPTAsaVs0XT0oZi1NKSpBLGlbNV09KDEtKGQrcCkpKkEsaVs2XT0oZyt2KSpBLGlbN109MCxpWzhdPShtK3gpKlQsaVs5XT0oZy12KSpULGlbMTBdPSgxLShkK18pKSpULGlbMTFdPTAsaVsxMl09dC54LGlbMTNdPXQueSxpWzE0XT10LnosaVsxNV09MSx0aGlzfWRlY29tcG9zZSh0LGUsbil7bGV0IGk9dGhpcy5lbGVtZW50cyxyPVhpLnNldChpWzBdLGlbMV0saVsyXSkubGVuZ3RoKCksYT1YaS5zZXQoaVs0XSxpWzVdLGlbNl0pLmxlbmd0aCgpLG89WGkuc2V0KGlbOF0saVs5XSxpWzEwXSkubGVuZ3RoKCk7dGhpcy5kZXRlcm1pbmFudCgpPDAmJihyPS1yKSx0Lng9aVsxMl0sdC55PWlbMTNdLHQuej1pWzE0XSxybi5jb3B5KHRoaXMpO2xldCBjPTEvcixoPTEvYSx1PTEvbztyZXR1cm4gcm4uZWxlbWVudHNbMF0qPWMscm4uZWxlbWVudHNbMV0qPWMscm4uZWxlbWVudHNbMl0qPWMscm4uZWxlbWVudHNbNF0qPWgscm4uZWxlbWVudHNbNV0qPWgscm4uZWxlbWVudHNbNl0qPWgscm4uZWxlbWVudHNbOF0qPXUscm4uZWxlbWVudHNbOV0qPXUscm4uZWxlbWVudHNbMTBdKj11LGUuc2V0RnJvbVJvdGF0aW9uTWF0cml4KHJuKSxuLng9cixuLnk9YSxuLno9byx0aGlzfW1ha2VQZXJzcGVjdGl2ZSh0LGUsbixpLHIsYSxvPW1uKXtsZXQgbD10aGlzLmVsZW1lbnRzLGM9MipyLyhlLXQpLGg9MipyLyhuLWkpLHU9KGUrdCkvKGUtdCksZD0obitpKS8obi1pKSxmLG07aWYobz09PW1uKWY9LShhK3IpLyhhLXIpLG09LTIqYSpyLyhhLXIpO2Vsc2UgaWYobz09PXNyKWY9LWEvKGEtciksbT0tYSpyLyhhLXIpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCJUSFJFRS5NYXRyaXg0Lm1ha2VQZXJzcGVjdGl2ZSgpOiBJbnZhbGlkIGNvb3JkaW5hdGUgc3lzdGVtOiAiK28pO3JldHVybiBsWzBdPWMsbFs0XT0wLGxbOF09dSxsWzEyXT0wLGxbMV09MCxsWzVdPWgsbFs5XT1kLGxbMTNdPTAsbFsyXT0wLGxbNl09MCxsWzEwXT1mLGxbMTRdPW0sbFszXT0wLGxbN109MCxsWzExXT0tMSxsWzE1XT0wLHRoaXN9bWFrZU9ydGhvZ3JhcGhpYyh0LGUsbixpLHIsYSxvPW1uKXtsZXQgbD10aGlzLmVsZW1lbnRzLGM9MS8oZS10KSxoPTEvKG4taSksdT0xLyhhLXIpLGQ9KGUrdCkqYyxmPShuK2kpKmgsbSxfO2lmKG89PT1tbiltPShhK3IpKnUsXz0tMip1O2Vsc2UgaWYobz09PXNyKW09cip1LF89LTEqdTtlbHNlIHRocm93IG5ldyBFcnJvcigiVEhSRUUuTWF0cml4NC5tYWtlT3J0aG9ncmFwaGljKCk6IEludmFsaWQgY29vcmRpbmF0ZSBzeXN0ZW06ICIrbyk7cmV0dXJuIGxbMF09MipjLGxbNF09MCxsWzhdPTAsbFsxMl09LWQsbFsxXT0wLGxbNV09MipoLGxbOV09MCxsWzEzXT0tZixsWzJdPTAsbFs2XT0wLGxbMTBdPV8sbFsxNF09LW0sbFszXT0wLGxbN109MCxsWzExXT0wLGxbMTVdPTEsdGhpc31lcXVhbHModCl7bGV0IGU9dGhpcy5lbGVtZW50cyxuPXQuZWxlbWVudHM7Zm9yKGxldCBpPTA7aTwxNjtpKyspaWYoZVtpXSE9PW5baV0pcmV0dXJuITE7cmV0dXJuITB9ZnJvbUFycmF5KHQsZT0wKXtmb3IobGV0IG49MDtuPDE2O24rKyl0aGlzLmVsZW1lbnRzW25dPXRbbitlXTtyZXR1cm4gdGhpc310b0FycmF5KHQ9W10sZT0wKXtsZXQgbj10aGlzLmVsZW1lbnRzO3JldHVybiB0W2VdPW5bMF0sdFtlKzFdPW5bMV0sdFtlKzJdPW5bMl0sdFtlKzNdPW5bM10sdFtlKzRdPW5bNF0sdFtlKzVdPW5bNV0sdFtlKzZdPW5bNl0sdFtlKzddPW5bN10sdFtlKzhdPW5bOF0sdFtlKzldPW5bOV0sdFtlKzEwXT1uWzEwXSx0W2UrMTFdPW5bMTFdLHRbZSsxMl09blsxMl0sdFtlKzEzXT1uWzEzXSx0W2UrMTRdPW5bMTRdLHRbZSsxNV09blsxNV0sdH19LFhpPW5ldyBSLHJuPW5ldyBMdCxBbT1uZXcgUigwLDAsMCksVG09bmV3IFIoMSwxLDEpLFhuPW5ldyBSLHFyPW5ldyBSLFdlPW5ldyBSLHZ1PW5ldyBMdCx5dT1uZXcgRGUsbHI9Y2xhc3Mgc3tjb25zdHJ1Y3Rvcih0PTAsZT0wLG49MCxpPXMuREVGQVVMVF9PUkRFUil7dGhpcy5pc0V1bGVyPSEwLHRoaXMuX3g9dCx0aGlzLl95PWUsdGhpcy5fej1uLHRoaXMuX29yZGVyPWl9Z2V0IHgoKXtyZXR1cm4gdGhpcy5feH1zZXQgeCh0KXt0aGlzLl94PXQsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfWdldCB5KCl7cmV0dXJuIHRoaXMuX3l9c2V0IHkodCl7dGhpcy5feT10LHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKX1nZXQgeigpe3JldHVybiB0aGlzLl96fXNldCB6KHQpe3RoaXMuX3o9dCx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCl9Z2V0IG9yZGVyKCl7cmV0dXJuIHRoaXMuX29yZGVyfXNldCBvcmRlcih0KXt0aGlzLl9vcmRlcj10LHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKX1zZXQodCxlLG4saT10aGlzLl9vcmRlcil7cmV0dXJuIHRoaXMuX3g9dCx0aGlzLl95PWUsdGhpcy5fej1uLHRoaXMuX29yZGVyPWksdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5feCx0aGlzLl95LHRoaXMuX3osdGhpcy5fb3JkZXIpfWNvcHkodCl7cmV0dXJuIHRoaXMuX3g9dC5feCx0aGlzLl95PXQuX3ksdGhpcy5fej10Ll96LHRoaXMuX29yZGVyPXQuX29yZGVyLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfXNldEZyb21Sb3RhdGlvbk1hdHJpeCh0LGU9dGhpcy5fb3JkZXIsbj0hMCl7bGV0IGk9dC5lbGVtZW50cyxyPWlbMF0sYT1pWzRdLG89aVs4XSxsPWlbMV0sYz1pWzVdLGg9aVs5XSx1PWlbMl0sZD1pWzZdLGY9aVsxMF07c3dpdGNoKGUpe2Nhc2UiWFlaIjp0aGlzLl95PU1hdGguYXNpbih1ZShvLC0xLDEpKSxNYXRoLmFicyhvKTwuOTk5OTk5OT8odGhpcy5feD1NYXRoLmF0YW4yKC1oLGYpLHRoaXMuX3o9TWF0aC5hdGFuMigtYSxyKSk6KHRoaXMuX3g9TWF0aC5hdGFuMihkLGMpLHRoaXMuX3o9MCk7YnJlYWs7Y2FzZSJZWFoiOnRoaXMuX3g9TWF0aC5hc2luKC11ZShoLC0xLDEpKSxNYXRoLmFicyhoKTwuOTk5OTk5OT8odGhpcy5feT1NYXRoLmF0YW4yKG8sZiksdGhpcy5fej1NYXRoLmF0YW4yKGwsYykpOih0aGlzLl95PU1hdGguYXRhbjIoLXUsciksdGhpcy5fej0wKTticmVhaztjYXNlIlpYWSI6dGhpcy5feD1NYXRoLmFzaW4odWUoZCwtMSwxKSksTWF0aC5hYnMoZCk8Ljk5OTk5OTk/KHRoaXMuX3k9TWF0aC5hdGFuMigtdSxmKSx0aGlzLl96PU1hdGguYXRhbjIoLWEsYykpOih0aGlzLl95PTAsdGhpcy5fej1NYXRoLmF0YW4yKGwscikpO2JyZWFrO2Nhc2UiWllYIjp0aGlzLl95PU1hdGguYXNpbigtdWUodSwtMSwxKSksTWF0aC5hYnModSk8Ljk5OTk5OTk/KHRoaXMuX3g9TWF0aC5hdGFuMihkLGYpLHRoaXMuX3o9TWF0aC5hdGFuMihsLHIpKToodGhpcy5feD0wLHRoaXMuX3o9TWF0aC5hdGFuMigtYSxjKSk7YnJlYWs7Y2FzZSJZWlgiOnRoaXMuX3o9TWF0aC5hc2luKHVlKGwsLTEsMSkpLE1hdGguYWJzKGwpPC45OTk5OTk5Pyh0aGlzLl94PU1hdGguYXRhbjIoLWgsYyksdGhpcy5feT1NYXRoLmF0YW4yKC11LHIpKToodGhpcy5feD0wLHRoaXMuX3k9TWF0aC5hdGFuMihvLGYpKTticmVhaztjYXNlIlhaWSI6dGhpcy5fej1NYXRoLmFzaW4oLXVlKGEsLTEsMSkpLE1hdGguYWJzKGEpPC45OTk5OTk5Pyh0aGlzLl94PU1hdGguYXRhbjIoZCxjKSx0aGlzLl95PU1hdGguYXRhbjIobyxyKSk6KHRoaXMuX3g9TWF0aC5hdGFuMigtaCxmKSx0aGlzLl95PTApO2JyZWFrO2RlZmF1bHQ6Y29uc29sZS53YXJuKCJUSFJFRS5FdWxlcjogLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICIrZSl9cmV0dXJuIHRoaXMuX29yZGVyPWUsbj09PSEwJiZ0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31zZXRGcm9tUXVhdGVybmlvbih0LGUsbil7cmV0dXJuIHZ1Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHQpLHRoaXMuc2V0RnJvbVJvdGF0aW9uTWF0cml4KHZ1LGUsbil9c2V0RnJvbVZlY3RvcjModCxlPXRoaXMuX29yZGVyKXtyZXR1cm4gdGhpcy5zZXQodC54LHQueSx0LnosZSl9cmVvcmRlcih0KXtyZXR1cm4geXUuc2V0RnJvbUV1bGVyKHRoaXMpLHRoaXMuc2V0RnJvbVF1YXRlcm5pb24oeXUsdCl9ZXF1YWxzKHQpe3JldHVybiB0Ll94PT09dGhpcy5feCYmdC5feT09PXRoaXMuX3kmJnQuX3o9PT10aGlzLl96JiZ0Ll9vcmRlcj09PXRoaXMuX29yZGVyfWZyb21BcnJheSh0KXtyZXR1cm4gdGhpcy5feD10WzBdLHRoaXMuX3k9dFsxXSx0aGlzLl96PXRbMl0sdFszXSE9PXZvaWQgMCYmKHRoaXMuX29yZGVyPXRbM10pLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfXRvQXJyYXkodD1bXSxlPTApe3JldHVybiB0W2VdPXRoaXMuX3gsdFtlKzFdPXRoaXMuX3ksdFtlKzJdPXRoaXMuX3osdFtlKzNdPXRoaXMuX29yZGVyLHR9X29uQ2hhbmdlKHQpe3JldHVybiB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrPXQsdGhpc31fb25DaGFuZ2VDYWxsYmFjaygpe30qW1N5bWJvbC5pdGVyYXRvcl0oKXt5aWVsZCB0aGlzLl94LHlpZWxkIHRoaXMuX3kseWllbGQgdGhpcy5feix5aWVsZCB0aGlzLl9vcmRlcn19O2xyLkRFRkFVTFRfT1JERVI9IlhZWiI7dmFyIF9zPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5tYXNrPTF9c2V0KHQpe3RoaXMubWFzaz0oMTw8dHwwKT4+PjB9ZW5hYmxlKHQpe3RoaXMubWFza3w9MTw8dHwwfWVuYWJsZUFsbCgpe3RoaXMubWFzaz0tMX10b2dnbGUodCl7dGhpcy5tYXNrXj0xPDx0fDB9ZGlzYWJsZSh0KXt0aGlzLm1hc2smPX4oMTw8dHwwKX1kaXNhYmxlQWxsKCl7dGhpcy5tYXNrPTB9dGVzdCh0KXtyZXR1cm4odGhpcy5tYXNrJnQubWFzaykhPT0wfWlzRW5hYmxlZCh0KXtyZXR1cm4odGhpcy5tYXNrJigxPDx0fDApKSE9PTB9fSx3bT0wLE11PW5ldyBSLHFpPW5ldyBEZSxFbj1uZXcgTHQsWXI9bmV3IFIsTHM9bmV3IFIsUm09bmV3IFIsQ209bmV3IERlLFN1PW5ldyBSKDEsMCwwKSxidT1uZXcgUigwLDEsMCksRXU9bmV3IFIoMCwwLDEpLFBtPXt0eXBlOiJhZGRlZCJ9LExtPXt0eXBlOiJyZW1vdmVkIn0sSnQ9Y2xhc3MgcyBleHRlbmRzIGxue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLmlzT2JqZWN0M0Q9ITAsT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImlkIix7dmFsdWU6d20rK30pLHRoaXMudXVpZD1ZZSgpLHRoaXMubmFtZT0iIix0aGlzLnR5cGU9Ik9iamVjdDNEIix0aGlzLnBhcmVudD1udWxsLHRoaXMuY2hpbGRyZW49W10sdGhpcy51cD1zLkRFRkFVTFRfVVAuY2xvbmUoKTtsZXQgdD1uZXcgUixlPW5ldyBscixuPW5ldyBEZSxpPW5ldyBSKDEsMSwxKTtmdW5jdGlvbiByKCl7bi5zZXRGcm9tRXVsZXIoZSwhMSl9ZnVuY3Rpb24gYSgpe2Uuc2V0RnJvbVF1YXRlcm5pb24obix2b2lkIDAsITEpfWUuX29uQ2hhbmdlKHIpLG4uX29uQ2hhbmdlKGEpLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMse3Bvc2l0aW9uOntjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTp0fSxyb3RhdGlvbjp7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6ZX0scXVhdGVybmlvbjp7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6bn0sc2NhbGU6e2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLHZhbHVlOml9LG1vZGVsVmlld01hdHJpeDp7dmFsdWU6bmV3IEx0fSxub3JtYWxNYXRyaXg6e3ZhbHVlOm5ldyBrdH19KSx0aGlzLm1hdHJpeD1uZXcgTHQsdGhpcy5tYXRyaXhXb3JsZD1uZXcgTHQsdGhpcy5tYXRyaXhBdXRvVXBkYXRlPXMuREVGQVVMVF9NQVRSSVhfQVVUT19VUERBVEUsdGhpcy5tYXRyaXhXb3JsZEF1dG9VcGRhdGU9cy5ERUZBVUxUX01BVFJJWF9XT1JMRF9BVVRPX1VQREFURSx0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ITEsdGhpcy5sYXllcnM9bmV3IF9zLHRoaXMudmlzaWJsZT0hMCx0aGlzLmNhc3RTaGFkb3c9ITEsdGhpcy5yZWNlaXZlU2hhZG93PSExLHRoaXMuZnJ1c3R1bUN1bGxlZD0hMCx0aGlzLnJlbmRlck9yZGVyPTAsdGhpcy5hbmltYXRpb25zPVtdLHRoaXMudXNlckRhdGE9e319b25CZWZvcmVTaGFkb3coKXt9b25BZnRlclNoYWRvdygpe31vbkJlZm9yZVJlbmRlcigpe31vbkFmdGVyUmVuZGVyKCl7fWFwcGx5TWF0cml4NCh0KXt0aGlzLm1hdHJpeEF1dG9VcGRhdGUmJnRoaXMudXBkYXRlTWF0cml4KCksdGhpcy5tYXRyaXgucHJlbXVsdGlwbHkodCksdGhpcy5tYXRyaXguZGVjb21wb3NlKHRoaXMucG9zaXRpb24sdGhpcy5xdWF0ZXJuaW9uLHRoaXMuc2NhbGUpfWFwcGx5UXVhdGVybmlvbih0KXtyZXR1cm4gdGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KHQpLHRoaXN9c2V0Um90YXRpb25Gcm9tQXhpc0FuZ2xlKHQsZSl7dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUodCxlKX1zZXRSb3RhdGlvbkZyb21FdWxlcih0KXt0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKHQsITApfXNldFJvdGF0aW9uRnJvbU1hdHJpeCh0KXt0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KHQpfXNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24odCl7dGhpcy5xdWF0ZXJuaW9uLmNvcHkodCl9cm90YXRlT25BeGlzKHQsZSl7cmV0dXJuIHFpLnNldEZyb21BeGlzQW5nbGUodCxlKSx0aGlzLnF1YXRlcm5pb24ubXVsdGlwbHkocWkpLHRoaXN9cm90YXRlT25Xb3JsZEF4aXModCxlKXtyZXR1cm4gcWkuc2V0RnJvbUF4aXNBbmdsZSh0LGUpLHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseShxaSksdGhpc31yb3RhdGVYKHQpe3JldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyhTdSx0KX1yb3RhdGVZKHQpe3JldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyhidSx0KX1yb3RhdGVaKHQpe3JldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyhFdSx0KX10cmFuc2xhdGVPbkF4aXModCxlKXtyZXR1cm4gTXUuY29weSh0KS5hcHBseVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uKSx0aGlzLnBvc2l0aW9uLmFkZChNdS5tdWx0aXBseVNjYWxhcihlKSksdGhpc310cmFuc2xhdGVYKHQpe3JldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyhTdSx0KX10cmFuc2xhdGVZKHQpe3JldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyhidSx0KX10cmFuc2xhdGVaKHQpe3JldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyhFdSx0KX1sb2NhbFRvV29ybGQodCl7cmV0dXJuIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoITAsITEpLHQuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpfXdvcmxkVG9Mb2NhbCh0KXtyZXR1cm4gdGhpcy51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSksdC5hcHBseU1hdHJpeDQoRW4uY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKSl9bG9va0F0KHQsZSxuKXt0LmlzVmVjdG9yMz9Zci5jb3B5KHQpOllyLnNldCh0LGUsbik7bGV0IGk9dGhpcy5wYXJlbnQ7dGhpcy51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSksTHMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubWF0cml4V29ybGQpLHRoaXMuaXNDYW1lcmF8fHRoaXMuaXNMaWdodD9Fbi5sb29rQXQoTHMsWXIsdGhpcy51cCk6RW4ubG9va0F0KFlyLExzLHRoaXMudXApLHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoRW4pLGkmJihFbi5leHRyYWN0Um90YXRpb24oaS5tYXRyaXhXb3JsZCkscWkuc2V0RnJvbVJvdGF0aW9uTWF0cml4KEVuKSx0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkocWkuaW52ZXJ0KCkpKX1hZGQodCl7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IobGV0IGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXRoaXMuYWRkKGFyZ3VtZW50c1tlXSk7cmV0dXJuIHRoaXN9cmV0dXJuIHQ9PT10aGlzPyhjb25zb2xlLmVycm9yKCJUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBjYW4ndCBiZSBhZGRlZCBhcyBhIGNoaWxkIG9mIGl0c2VsZi4iLHQpLHRoaXMpOih0JiZ0LmlzT2JqZWN0M0Q/KHQucGFyZW50IT09bnVsbCYmdC5wYXJlbnQucmVtb3ZlKHQpLHQucGFyZW50PXRoaXMsdGhpcy5jaGlsZHJlbi5wdXNoKHQpLHQuZGlzcGF0Y2hFdmVudChQbSkpOmNvbnNvbGUuZXJyb3IoIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5PYmplY3QzRC4iLHQpLHRoaXMpfXJlbW92ZSh0KXtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2ZvcihsZXQgbj0wO248YXJndW1lbnRzLmxlbmd0aDtuKyspdGhpcy5yZW1vdmUoYXJndW1lbnRzW25dKTtyZXR1cm4gdGhpc31sZXQgZT10aGlzLmNoaWxkcmVuLmluZGV4T2YodCk7cmV0dXJuIGUhPT0tMSYmKHQucGFyZW50PW51bGwsdGhpcy5jaGlsZHJlbi5zcGxpY2UoZSwxKSx0LmRpc3BhdGNoRXZlbnQoTG0pKSx0aGlzfXJlbW92ZUZyb21QYXJlbnQoKXtsZXQgdD10aGlzLnBhcmVudDtyZXR1cm4gdCE9PW51bGwmJnQucmVtb3ZlKHRoaXMpLHRoaXN9Y2xlYXIoKXtyZXR1cm4gdGhpcy5yZW1vdmUoLi4udGhpcy5jaGlsZHJlbil9YXR0YWNoKHQpe3JldHVybiB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSxFbi5jb3B5KHRoaXMubWF0cml4V29ybGQpLmludmVydCgpLHQucGFyZW50IT09bnVsbCYmKHQucGFyZW50LnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSxFbi5tdWx0aXBseSh0LnBhcmVudC5tYXRyaXhXb3JsZCkpLHQuYXBwbHlNYXRyaXg0KEVuKSx0aGlzLmFkZCh0KSx0LnVwZGF0ZVdvcmxkTWF0cml4KCExLCEwKSx0aGlzfWdldE9iamVjdEJ5SWQodCl7cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSgiaWQiLHQpfWdldE9iamVjdEJ5TmFtZSh0KXtyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCJuYW1lIix0KX1nZXRPYmplY3RCeVByb3BlcnR5KHQsZSl7aWYodGhpc1t0XT09PWUpcmV0dXJuIHRoaXM7Zm9yKGxldCBuPTAsaT10aGlzLmNoaWxkcmVuLmxlbmd0aDtuPGk7bisrKXtsZXQgYT10aGlzLmNoaWxkcmVuW25dLmdldE9iamVjdEJ5UHJvcGVydHkodCxlKTtpZihhIT09dm9pZCAwKXJldHVybiBhfX1nZXRPYmplY3RzQnlQcm9wZXJ0eSh0LGUsbj1bXSl7dGhpc1t0XT09PWUmJm4ucHVzaCh0aGlzKTtsZXQgaT10aGlzLmNoaWxkcmVuO2ZvcihsZXQgcj0wLGE9aS5sZW5ndGg7cjxhO3IrKylpW3JdLmdldE9iamVjdHNCeVByb3BlcnR5KHQsZSxuKTtyZXR1cm4gbn1nZXRXb3JsZFBvc2l0aW9uKHQpe3JldHVybiB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSx0LnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLm1hdHJpeFdvcmxkKX1nZXRXb3JsZFF1YXRlcm5pb24odCl7cmV0dXJuIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoITAsITEpLHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKExzLHQsUm0pLHR9Z2V0V29ybGRTY2FsZSh0KXtyZXR1cm4gdGhpcy51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSksdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoTHMsQ20sdCksdH1nZXRXb3JsZERpcmVjdGlvbih0KXt0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKTtsZXQgZT10aGlzLm1hdHJpeFdvcmxkLmVsZW1lbnRzO3JldHVybiB0LnNldChlWzhdLGVbOV0sZVsxMF0pLm5vcm1hbGl6ZSgpfXJheWNhc3QoKXt9dHJhdmVyc2UodCl7dCh0aGlzKTtsZXQgZT10aGlzLmNoaWxkcmVuO2ZvcihsZXQgbj0wLGk9ZS5sZW5ndGg7bjxpO24rKyllW25dLnRyYXZlcnNlKHQpfXRyYXZlcnNlVmlzaWJsZSh0KXtpZih0aGlzLnZpc2libGU9PT0hMSlyZXR1cm47dCh0aGlzKTtsZXQgZT10aGlzLmNoaWxkcmVuO2ZvcihsZXQgbj0wLGk9ZS5sZW5ndGg7bjxpO24rKyllW25dLnRyYXZlcnNlVmlzaWJsZSh0KX10cmF2ZXJzZUFuY2VzdG9ycyh0KXtsZXQgZT10aGlzLnBhcmVudDtlIT09bnVsbCYmKHQoZSksZS50cmF2ZXJzZUFuY2VzdG9ycyh0KSl9dXBkYXRlTWF0cml4KCl7dGhpcy5tYXRyaXguY29tcG9zZSh0aGlzLnBvc2l0aW9uLHRoaXMucXVhdGVybmlvbix0aGlzLnNjYWxlKSx0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ITB9dXBkYXRlTWF0cml4V29ybGQodCl7dGhpcy5tYXRyaXhBdXRvVXBkYXRlJiZ0aGlzLnVwZGF0ZU1hdHJpeCgpLCh0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGV8fHQpJiYodGhpcy5wYXJlbnQ9PT1udWxsP3RoaXMubWF0cml4V29ybGQuY29weSh0aGlzLm1hdHJpeCk6dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLHRoaXMubWF0cml4KSx0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ITEsdD0hMCk7bGV0IGU9dGhpcy5jaGlsZHJlbjtmb3IobGV0IG49MCxpPWUubGVuZ3RoO248aTtuKyspe2xldCByPWVbbl07KHIubWF0cml4V29ybGRBdXRvVXBkYXRlPT09ITB8fHQ9PT0hMCkmJnIudXBkYXRlTWF0cml4V29ybGQodCl9fXVwZGF0ZVdvcmxkTWF0cml4KHQsZSl7bGV0IG49dGhpcy5wYXJlbnQ7aWYodD09PSEwJiZuIT09bnVsbCYmbi5tYXRyaXhXb3JsZEF1dG9VcGRhdGU9PT0hMCYmbi51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSksdGhpcy5tYXRyaXhBdXRvVXBkYXRlJiZ0aGlzLnVwZGF0ZU1hdHJpeCgpLHRoaXMucGFyZW50PT09bnVsbD90aGlzLm1hdHJpeFdvcmxkLmNvcHkodGhpcy5tYXRyaXgpOnRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyh0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCx0aGlzLm1hdHJpeCksZT09PSEwKXtsZXQgaT10aGlzLmNoaWxkcmVuO2ZvcihsZXQgcj0wLGE9aS5sZW5ndGg7cjxhO3IrKyl7bGV0IG89aVtyXTtvLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZT09PSEwJiZvLnVwZGF0ZVdvcmxkTWF0cml4KCExLCEwKX19fXRvSlNPTih0KXtsZXQgZT10PT09dm9pZCAwfHx0eXBlb2YgdD09InN0cmluZyIsbj17fTtlJiYodD17Z2VvbWV0cmllczp7fSxtYXRlcmlhbHM6e30sdGV4dHVyZXM6e30saW1hZ2VzOnt9LHNoYXBlczp7fSxza2VsZXRvbnM6e30sYW5pbWF0aW9uczp7fSxub2Rlczp7fX0sbi5tZXRhZGF0YT17dmVyc2lvbjo0LjYsdHlwZToiT2JqZWN0IixnZW5lcmF0b3I6Ik9iamVjdDNELnRvSlNPTiJ9KTtsZXQgaT17fTtpLnV1aWQ9dGhpcy51dWlkLGkudHlwZT10aGlzLnR5cGUsdGhpcy5uYW1lIT09IiImJihpLm5hbWU9dGhpcy5uYW1lKSx0aGlzLmNhc3RTaGFkb3c9PT0hMCYmKGkuY2FzdFNoYWRvdz0hMCksdGhpcy5yZWNlaXZlU2hhZG93PT09ITAmJihpLnJlY2VpdmVTaGFkb3c9ITApLHRoaXMudmlzaWJsZT09PSExJiYoaS52aXNpYmxlPSExKSx0aGlzLmZydXN0dW1DdWxsZWQ9PT0hMSYmKGkuZnJ1c3R1bUN1bGxlZD0hMSksdGhpcy5yZW5kZXJPcmRlciE9PTAmJihpLnJlbmRlck9yZGVyPXRoaXMucmVuZGVyT3JkZXIpLE9iamVjdC5rZXlzKHRoaXMudXNlckRhdGEpLmxlbmd0aD4wJiYoaS51c2VyRGF0YT10aGlzLnVzZXJEYXRhKSxpLmxheWVycz10aGlzLmxheWVycy5tYXNrLGkubWF0cml4PXRoaXMubWF0cml4LnRvQXJyYXkoKSxpLnVwPXRoaXMudXAudG9BcnJheSgpLHRoaXMubWF0cml4QXV0b1VwZGF0ZT09PSExJiYoaS5tYXRyaXhBdXRvVXBkYXRlPSExKSx0aGlzLmlzSW5zdGFuY2VkTWVzaCYmKGkudHlwZT0iSW5zdGFuY2VkTWVzaCIsaS5jb3VudD10aGlzLmNvdW50LGkuaW5zdGFuY2VNYXRyaXg9dGhpcy5pbnN0YW5jZU1hdHJpeC50b0pTT04oKSx0aGlzLmluc3RhbmNlQ29sb3IhPT1udWxsJiYoaS5pbnN0YW5jZUNvbG9yPXRoaXMuaW5zdGFuY2VDb2xvci50b0pTT04oKSkpLHRoaXMuaXNCYXRjaGVkTWVzaCYmKGkudHlwZT0iQmF0Y2hlZE1lc2giLGkucGVyT2JqZWN0RnJ1c3R1bUN1bGxlZD10aGlzLnBlck9iamVjdEZydXN0dW1DdWxsZWQsaS5zb3J0T2JqZWN0cz10aGlzLnNvcnRPYmplY3RzLGkuZHJhd1Jhbmdlcz10aGlzLl9kcmF3UmFuZ2VzLGkucmVzZXJ2ZWRSYW5nZXM9dGhpcy5fcmVzZXJ2ZWRSYW5nZXMsaS52aXNpYmlsaXR5PXRoaXMuX3Zpc2liaWxpdHksaS5hY3RpdmU9dGhpcy5fYWN0aXZlLGkuYm91bmRzPXRoaXMuX2JvdW5kcy5tYXAobz0+KHtib3hJbml0aWFsaXplZDpvLmJveEluaXRpYWxpemVkLGJveE1pbjpvLmJveC5taW4udG9BcnJheSgpLGJveE1heDpvLmJveC5tYXgudG9BcnJheSgpLHNwaGVyZUluaXRpYWxpemVkOm8uc3BoZXJlSW5pdGlhbGl6ZWQsc3BoZXJlUmFkaXVzOm8uc3BoZXJlLnJhZGl1cyxzcGhlcmVDZW50ZXI6by5zcGhlcmUuY2VudGVyLnRvQXJyYXkoKX0pKSxpLm1heEdlb21ldHJ5Q291bnQ9dGhpcy5fbWF4R2VvbWV0cnlDb3VudCxpLm1heFZlcnRleENvdW50PXRoaXMuX21heFZlcnRleENvdW50LGkubWF4SW5kZXhDb3VudD10aGlzLl9tYXhJbmRleENvdW50LGkuZ2VvbWV0cnlJbml0aWFsaXplZD10aGlzLl9nZW9tZXRyeUluaXRpYWxpemVkLGkuZ2VvbWV0cnlDb3VudD10aGlzLl9nZW9tZXRyeUNvdW50LGkubWF0cmljZXNUZXh0dXJlPXRoaXMuX21hdHJpY2VzVGV4dHVyZS50b0pTT04odCksdGhpcy5ib3VuZGluZ1NwaGVyZSE9PW51bGwmJihpLmJvdW5kaW5nU3BoZXJlPXtjZW50ZXI6aS5ib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLHJhZGl1czppLmJvdW5kaW5nU3BoZXJlLnJhZGl1c30pLHRoaXMuYm91bmRpbmdCb3ghPT1udWxsJiYoaS5ib3VuZGluZ0JveD17bWluOmkuYm91bmRpbmdCb3gubWluLnRvQXJyYXkoKSxtYXg6aS5ib3VuZGluZ0JveC5tYXgudG9BcnJheSgpfSkpO2Z1bmN0aW9uIHIobyxsKXtyZXR1cm4gb1tsLnV1aWRdPT09dm9pZCAwJiYob1tsLnV1aWRdPWwudG9KU09OKHQpKSxsLnV1aWR9aWYodGhpcy5pc1NjZW5lKXRoaXMuYmFja2dyb3VuZCYmKHRoaXMuYmFja2dyb3VuZC5pc0NvbG9yP2kuYmFja2dyb3VuZD10aGlzLmJhY2tncm91bmQudG9KU09OKCk6dGhpcy5iYWNrZ3JvdW5kLmlzVGV4dHVyZSYmKGkuYmFja2dyb3VuZD10aGlzLmJhY2tncm91bmQudG9KU09OKHQpLnV1aWQpKSx0aGlzLmVudmlyb25tZW50JiZ0aGlzLmVudmlyb25tZW50LmlzVGV4dHVyZSYmdGhpcy5lbnZpcm9ubWVudC5pc1JlbmRlclRhcmdldFRleHR1cmUhPT0hMCYmKGkuZW52aXJvbm1lbnQ9dGhpcy5lbnZpcm9ubWVudC50b0pTT04odCkudXVpZCk7ZWxzZSBpZih0aGlzLmlzTWVzaHx8dGhpcy5pc0xpbmV8fHRoaXMuaXNQb2ludHMpe2kuZ2VvbWV0cnk9cih0Lmdlb21ldHJpZXMsdGhpcy5nZW9tZXRyeSk7bGV0IG89dGhpcy5nZW9tZXRyeS5wYXJhbWV0ZXJzO2lmKG8hPT12b2lkIDAmJm8uc2hhcGVzIT09dm9pZCAwKXtsZXQgbD1vLnNoYXBlcztpZihBcnJheS5pc0FycmF5KGwpKWZvcihsZXQgYz0wLGg9bC5sZW5ndGg7YzxoO2MrKyl7bGV0IHU9bFtjXTtyKHQuc2hhcGVzLHUpfWVsc2Ugcih0LnNoYXBlcyxsKX19aWYodGhpcy5pc1NraW5uZWRNZXNoJiYoaS5iaW5kTW9kZT10aGlzLmJpbmRNb2RlLGkuYmluZE1hdHJpeD10aGlzLmJpbmRNYXRyaXgudG9BcnJheSgpLHRoaXMuc2tlbGV0b24hPT12b2lkIDAmJihyKHQuc2tlbGV0b25zLHRoaXMuc2tlbGV0b24pLGkuc2tlbGV0b249dGhpcy5za2VsZXRvbi51dWlkKSksdGhpcy5tYXRlcmlhbCE9PXZvaWQgMClpZihBcnJheS5pc0FycmF5KHRoaXMubWF0ZXJpYWwpKXtsZXQgbz1bXTtmb3IobGV0IGw9MCxjPXRoaXMubWF0ZXJpYWwubGVuZ3RoO2w8YztsKyspby5wdXNoKHIodC5tYXRlcmlhbHMsdGhpcy5tYXRlcmlhbFtsXSkpO2kubWF0ZXJpYWw9b31lbHNlIGkubWF0ZXJpYWw9cih0Lm1hdGVyaWFscyx0aGlzLm1hdGVyaWFsKTtpZih0aGlzLmNoaWxkcmVuLmxlbmd0aD4wKXtpLmNoaWxkcmVuPVtdO2ZvcihsZXQgbz0wO288dGhpcy5jaGlsZHJlbi5sZW5ndGg7bysrKWkuY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW29dLnRvSlNPTih0KS5vYmplY3QpfWlmKHRoaXMuYW5pbWF0aW9ucy5sZW5ndGg+MCl7aS5hbmltYXRpb25zPVtdO2ZvcihsZXQgbz0wO288dGhpcy5hbmltYXRpb25zLmxlbmd0aDtvKyspe2xldCBsPXRoaXMuYW5pbWF0aW9uc1tvXTtpLmFuaW1hdGlvbnMucHVzaChyKHQuYW5pbWF0aW9ucyxsKSl9fWlmKGUpe2xldCBvPWEodC5nZW9tZXRyaWVzKSxsPWEodC5tYXRlcmlhbHMpLGM9YSh0LnRleHR1cmVzKSxoPWEodC5pbWFnZXMpLHU9YSh0LnNoYXBlcyksZD1hKHQuc2tlbGV0b25zKSxmPWEodC5hbmltYXRpb25zKSxtPWEodC5ub2Rlcyk7by5sZW5ndGg+MCYmKG4uZ2VvbWV0cmllcz1vKSxsLmxlbmd0aD4wJiYobi5tYXRlcmlhbHM9bCksYy5sZW5ndGg+MCYmKG4udGV4dHVyZXM9YyksaC5sZW5ndGg+MCYmKG4uaW1hZ2VzPWgpLHUubGVuZ3RoPjAmJihuLnNoYXBlcz11KSxkLmxlbmd0aD4wJiYobi5za2VsZXRvbnM9ZCksZi5sZW5ndGg+MCYmKG4uYW5pbWF0aW9ucz1mKSxtLmxlbmd0aD4wJiYobi5ub2Rlcz1tKX1yZXR1cm4gbi5vYmplY3Q9aSxuO2Z1bmN0aW9uIGEobyl7bGV0IGw9W107Zm9yKGxldCBjIGluIG8pe2xldCBoPW9bY107ZGVsZXRlIGgubWV0YWRhdGEsbC5wdXNoKGgpfXJldHVybiBsfX1jbG9uZSh0KXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMsdCl9Y29weSh0LGU9ITApe2lmKHRoaXMubmFtZT10Lm5hbWUsdGhpcy51cC5jb3B5KHQudXApLHRoaXMucG9zaXRpb24uY29weSh0LnBvc2l0aW9uKSx0aGlzLnJvdGF0aW9uLm9yZGVyPXQucm90YXRpb24ub3JkZXIsdGhpcy5xdWF0ZXJuaW9uLmNvcHkodC5xdWF0ZXJuaW9uKSx0aGlzLnNjYWxlLmNvcHkodC5zY2FsZSksdGhpcy5tYXRyaXguY29weSh0Lm1hdHJpeCksdGhpcy5tYXRyaXhXb3JsZC5jb3B5KHQubWF0cml4V29ybGQpLHRoaXMubWF0cml4QXV0b1VwZGF0ZT10Lm1hdHJpeEF1dG9VcGRhdGUsdGhpcy5tYXRyaXhXb3JsZEF1dG9VcGRhdGU9dC5tYXRyaXhXb3JsZEF1dG9VcGRhdGUsdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPXQubWF0cml4V29ybGROZWVkc1VwZGF0ZSx0aGlzLmxheWVycy5tYXNrPXQubGF5ZXJzLm1hc2ssdGhpcy52aXNpYmxlPXQudmlzaWJsZSx0aGlzLmNhc3RTaGFkb3c9dC5jYXN0U2hhZG93LHRoaXMucmVjZWl2ZVNoYWRvdz10LnJlY2VpdmVTaGFkb3csdGhpcy5mcnVzdHVtQ3VsbGVkPXQuZnJ1c3R1bUN1bGxlZCx0aGlzLnJlbmRlck9yZGVyPXQucmVuZGVyT3JkZXIsdGhpcy5hbmltYXRpb25zPXQuYW5pbWF0aW9ucy5zbGljZSgpLHRoaXMudXNlckRhdGE9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0LnVzZXJEYXRhKSksZT09PSEwKWZvcihsZXQgbj0wO248dC5jaGlsZHJlbi5sZW5ndGg7bisrKXtsZXQgaT10LmNoaWxkcmVuW25dO3RoaXMuYWRkKGkuY2xvbmUoKSl9cmV0dXJuIHRoaXN9fTtKdC5ERUZBVUxUX1VQPW5ldyBSKDAsMSwwKTtKdC5ERUZBVUxUX01BVFJJWF9BVVRPX1VQREFURT0hMDtKdC5ERUZBVUxUX01BVFJJWF9XT1JMRF9BVVRPX1VQREFURT0hMDt2YXIgYW49bmV3IFIsQW49bmV3IFIseWw9bmV3IFIsVG49bmV3IFIsWWk9bmV3IFIsWmk9bmV3IFIsQXU9bmV3IFIsTWw9bmV3IFIsU2w9bmV3IFIsYmw9bmV3IFIsTG49Y2xhc3Mgc3tjb25zdHJ1Y3Rvcih0PW5ldyBSLGU9bmV3IFIsbj1uZXcgUil7dGhpcy5hPXQsdGhpcy5iPWUsdGhpcy5jPW59c3RhdGljIGdldE5vcm1hbCh0LGUsbixpKXtpLnN1YlZlY3RvcnMobixlKSxhbi5zdWJWZWN0b3JzKHQsZSksaS5jcm9zcyhhbik7bGV0IHI9aS5sZW5ndGhTcSgpO3JldHVybiByPjA/aS5tdWx0aXBseVNjYWxhcigxL01hdGguc3FydChyKSk6aS5zZXQoMCwwLDApfXN0YXRpYyBnZXRCYXJ5Y29vcmQodCxlLG4saSxyKXthbi5zdWJWZWN0b3JzKGksZSksQW4uc3ViVmVjdG9ycyhuLGUpLHlsLnN1YlZlY3RvcnModCxlKTtsZXQgYT1hbi5kb3QoYW4pLG89YW4uZG90KEFuKSxsPWFuLmRvdCh5bCksYz1Bbi5kb3QoQW4pLGg9QW4uZG90KHlsKSx1PWEqYy1vKm87aWYodT09PTApcmV0dXJuIHIuc2V0KDAsMCwwKSxudWxsO2xldCBkPTEvdSxmPShjKmwtbypoKSpkLG09KGEqaC1vKmwpKmQ7cmV0dXJuIHIuc2V0KDEtZi1tLG0sZil9c3RhdGljIGNvbnRhaW5zUG9pbnQodCxlLG4saSl7cmV0dXJuIHRoaXMuZ2V0QmFyeWNvb3JkKHQsZSxuLGksVG4pPT09bnVsbD8hMTpUbi54Pj0wJiZUbi55Pj0wJiZUbi54K1RuLnk8PTF9c3RhdGljIGdldEludGVycG9sYXRpb24odCxlLG4saSxyLGEsbyxsKXtyZXR1cm4gdGhpcy5nZXRCYXJ5Y29vcmQodCxlLG4saSxUbik9PT1udWxsPyhsLng9MCxsLnk9MCwieiJpbiBsJiYobC56PTApLCJ3ImluIGwmJihsLnc9MCksbnVsbCk6KGwuc2V0U2NhbGFyKDApLGwuYWRkU2NhbGVkVmVjdG9yKHIsVG4ueCksbC5hZGRTY2FsZWRWZWN0b3IoYSxUbi55KSxsLmFkZFNjYWxlZFZlY3RvcihvLFRuLnopLGwpfXN0YXRpYyBpc0Zyb250RmFjaW5nKHQsZSxuLGkpe3JldHVybiBhbi5zdWJWZWN0b3JzKG4sZSksQW4uc3ViVmVjdG9ycyh0LGUpLGFuLmNyb3NzKEFuKS5kb3QoaSk8MH1zZXQodCxlLG4pe3JldHVybiB0aGlzLmEuY29weSh0KSx0aGlzLmIuY29weShlKSx0aGlzLmMuY29weShuKSx0aGlzfXNldEZyb21Qb2ludHNBbmRJbmRpY2VzKHQsZSxuLGkpe3JldHVybiB0aGlzLmEuY29weSh0W2VdKSx0aGlzLmIuY29weSh0W25dKSx0aGlzLmMuY29weSh0W2ldKSx0aGlzfXNldEZyb21BdHRyaWJ1dGVBbmRJbmRpY2VzKHQsZSxuLGkpe3JldHVybiB0aGlzLmEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LGUpLHRoaXMuYi5mcm9tQnVmZmVyQXR0cmlidXRlKHQsbiksdGhpcy5jLmZyb21CdWZmZXJBdHRyaWJ1dGUodCxpKSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX1jb3B5KHQpe3JldHVybiB0aGlzLmEuY29weSh0LmEpLHRoaXMuYi5jb3B5KHQuYiksdGhpcy5jLmNvcHkodC5jKSx0aGlzfWdldEFyZWEoKXtyZXR1cm4gYW4uc3ViVmVjdG9ycyh0aGlzLmMsdGhpcy5iKSxBbi5zdWJWZWN0b3JzKHRoaXMuYSx0aGlzLmIpLGFuLmNyb3NzKEFuKS5sZW5ndGgoKSouNX1nZXRNaWRwb2ludCh0KXtyZXR1cm4gdC5hZGRWZWN0b3JzKHRoaXMuYSx0aGlzLmIpLmFkZCh0aGlzLmMpLm11bHRpcGx5U2NhbGFyKDEvMyl9Z2V0Tm9ybWFsKHQpe3JldHVybiBzLmdldE5vcm1hbCh0aGlzLmEsdGhpcy5iLHRoaXMuYyx0KX1nZXRQbGFuZSh0KXtyZXR1cm4gdC5zZXRGcm9tQ29wbGFuYXJQb2ludHModGhpcy5hLHRoaXMuYix0aGlzLmMpfWdldEJhcnljb29yZCh0LGUpe3JldHVybiBzLmdldEJhcnljb29yZCh0LHRoaXMuYSx0aGlzLmIsdGhpcy5jLGUpfWdldEludGVycG9sYXRpb24odCxlLG4saSxyKXtyZXR1cm4gcy5nZXRJbnRlcnBvbGF0aW9uKHQsdGhpcy5hLHRoaXMuYix0aGlzLmMsZSxuLGkscil9Y29udGFpbnNQb2ludCh0KXtyZXR1cm4gcy5jb250YWluc1BvaW50KHQsdGhpcy5hLHRoaXMuYix0aGlzLmMpfWlzRnJvbnRGYWNpbmcodCl7cmV0dXJuIHMuaXNGcm9udEZhY2luZyh0aGlzLmEsdGhpcy5iLHRoaXMuYyx0KX1pbnRlcnNlY3RzQm94KHQpe3JldHVybiB0LmludGVyc2VjdHNUcmlhbmdsZSh0aGlzKX1jbG9zZXN0UG9pbnRUb1BvaW50KHQsZSl7bGV0IG49dGhpcy5hLGk9dGhpcy5iLHI9dGhpcy5jLGEsbztZaS5zdWJWZWN0b3JzKGksbiksWmkuc3ViVmVjdG9ycyhyLG4pLE1sLnN1YlZlY3RvcnModCxuKTtsZXQgbD1ZaS5kb3QoTWwpLGM9WmkuZG90KE1sKTtpZihsPD0wJiZjPD0wKXJldHVybiBlLmNvcHkobik7U2wuc3ViVmVjdG9ycyh0LGkpO2xldCBoPVlpLmRvdChTbCksdT1aaS5kb3QoU2wpO2lmKGg+PTAmJnU8PWgpcmV0dXJuIGUuY29weShpKTtsZXQgZD1sKnUtaCpjO2lmKGQ8PTAmJmw+PTAmJmg8PTApcmV0dXJuIGE9bC8obC1oKSxlLmNvcHkobikuYWRkU2NhbGVkVmVjdG9yKFlpLGEpO2JsLnN1YlZlY3RvcnModCxyKTtsZXQgZj1ZaS5kb3QoYmwpLG09WmkuZG90KGJsKTtpZihtPj0wJiZmPD1tKXJldHVybiBlLmNvcHkocik7bGV0IF89ZipjLWwqbTtpZihfPD0wJiZjPj0wJiZtPD0wKXJldHVybiBvPWMvKGMtbSksZS5jb3B5KG4pLmFkZFNjYWxlZFZlY3RvcihaaSxvKTtsZXQgZz1oKm0tZip1O2lmKGc8PTAmJnUtaD49MCYmZi1tPj0wKXJldHVybiBBdS5zdWJWZWN0b3JzKHIsaSksbz0odS1oKS8odS1oKyhmLW0pKSxlLmNvcHkoaSkuYWRkU2NhbGVkVmVjdG9yKEF1LG8pO2xldCBwPTEvKGcrXytkKTtyZXR1cm4gYT1fKnAsbz1kKnAsZS5jb3B5KG4pLmFkZFNjYWxlZFZlY3RvcihZaSxhKS5hZGRTY2FsZWRWZWN0b3IoWmksbyl9ZXF1YWxzKHQpe3JldHVybiB0LmEuZXF1YWxzKHRoaXMuYSkmJnQuYi5lcXVhbHModGhpcy5iKSYmdC5jLmVxdWFscyh0aGlzLmMpfX0sJGY9e2FsaWNlYmx1ZToxNTc5MjM4MyxhbnRpcXVld2hpdGU6MTY0NDQzNzUsYXF1YTo2NTUzNSxhcXVhbWFyaW5lOjgzODg1NjQsYXp1cmU6MTU3OTQxNzUsYmVpZ2U6MTYxMTkyNjAsYmlzcXVlOjE2NzcwMjQ0LGJsYWNrOjAsYmxhbmNoZWRhbG1vbmQ6MTY3NzIwNDUsYmx1ZToyNTUsYmx1ZXZpb2xldDo5MDU1MjAyLGJyb3duOjEwODI0MjM0LGJ1cmx5d29vZDoxNDU5NjIzMSxjYWRldGJsdWU6NjI2NjUyOCxjaGFydHJldXNlOjgzODgzNTIsY2hvY29sYXRlOjEzNzg5NDcwLGNvcmFsOjE2NzQ0MjcyLGNvcm5mbG93ZXJibHVlOjY1OTE5ODEsY29ybnNpbGs6MTY3NzUzODgsY3JpbXNvbjoxNDQyMzEwMCxjeWFuOjY1NTM1LGRhcmtibHVlOjEzOSxkYXJrY3lhbjozNTcyMyxkYXJrZ29sZGVucm9kOjEyMDkyOTM5LGRhcmtncmF5OjExMTE5MDE3LGRhcmtncmVlbjoyNTYwMCxkYXJrZ3JleToxMTExOTAxNyxkYXJra2hha2k6MTI0MzMyNTksZGFya21hZ2VudGE6OTEwOTY0MyxkYXJrb2xpdmVncmVlbjo1NTk3OTk5LGRhcmtvcmFuZ2U6MTY3NDc1MjAsZGFya29yY2hpZDoxMDA0MDAxMixkYXJrcmVkOjkxMDk1MDQsZGFya3NhbG1vbjoxNTMwODQxMCxkYXJrc2VhZ3JlZW46OTQxOTkxOSxkYXJrc2xhdGVibHVlOjQ3MzQzNDcsZGFya3NsYXRlZ3JheTozMTAwNDk1LGRhcmtzbGF0ZWdyZXk6MzEwMDQ5NSxkYXJrdHVycXVvaXNlOjUyOTQ1LGRhcmt2aW9sZXQ6OTY5OTUzOSxkZWVwcGluazoxNjcxNjk0NyxkZWVwc2t5Ymx1ZTo0OTE1MSxkaW1ncmF5OjY5MDgyNjUsZGltZ3JleTo2OTA4MjY1LGRvZGdlcmJsdWU6MjAwMzE5OSxmaXJlYnJpY2s6MTE2NzQxNDYsZmxvcmFsd2hpdGU6MTY3NzU5MjAsZm9yZXN0Z3JlZW46MjI2Mzg0MixmdWNoc2lhOjE2NzExOTM1LGdhaW5zYm9ybzoxNDQ3NDQ2MCxnaG9zdHdoaXRlOjE2MzE2NjcxLGdvbGQ6MTY3NjY3MjAsZ29sZGVucm9kOjE0MzI5MTIwLGdyYXk6ODQyMTUwNCxncmVlbjozMjc2OCxncmVlbnllbGxvdzoxMTQwMzA1NSxncmV5Ojg0MjE1MDQsaG9uZXlkZXc6MTU3OTQxNjAsaG90cGluazoxNjczODc0MCxpbmRpYW5yZWQ6MTM0NTg1MjQsaW5kaWdvOjQ5MTUzMzAsaXZvcnk6MTY3NzcyMDAsa2hha2k6MTU3ODc2NjAsbGF2ZW5kZXI6MTUxMzI0MTAsbGF2ZW5kZXJibHVzaDoxNjc3MzM2NSxsYXduZ3JlZW46ODE5MDk3NixsZW1vbmNoaWZmb246MTY3NzU4ODUsbGlnaHRibHVlOjExMzkzMjU0LGxpZ2h0Y29yYWw6MTU3NjE1MzYsbGlnaHRjeWFuOjE0NzQ1NTk5LGxpZ2h0Z29sZGVucm9keWVsbG93OjE2NDQ4MjEwLGxpZ2h0Z3JheToxMzg4MjMyMyxsaWdodGdyZWVuOjk0OTgyNTYsbGlnaHRncmV5OjEzODgyMzIzLGxpZ2h0cGluazoxNjc1ODQ2NSxsaWdodHNhbG1vbjoxNjc1Mjc2MixsaWdodHNlYWdyZWVuOjIxNDI4OTAsbGlnaHRza3libHVlOjg5MDAzNDYsbGlnaHRzbGF0ZWdyYXk6NzgzMzc1MyxsaWdodHNsYXRlZ3JleTo3ODMzNzUzLGxpZ2h0c3RlZWxibHVlOjExNTg0NzM0LGxpZ2h0eWVsbG93OjE2Nzc3MTg0LGxpbWU6NjUyODAsbGltZWdyZWVuOjMzMjkzMzAsbGluZW46MTY0NDU2NzAsbWFnZW50YToxNjcxMTkzNSxtYXJvb246ODM4ODYwOCxtZWRpdW1hcXVhbWFyaW5lOjY3MzczMjIsbWVkaXVtYmx1ZToyMDUsbWVkaXVtb3JjaGlkOjEyMjExNjY3LG1lZGl1bXB1cnBsZTo5NjYyNjgzLG1lZGl1bXNlYWdyZWVuOjM5NzgwOTcsbWVkaXVtc2xhdGVibHVlOjgwODc3OTAsbWVkaXVtc3ByaW5nZ3JlZW46NjQxNTQsbWVkaXVtdHVycXVvaXNlOjQ3NzIzMDAsbWVkaXVtdmlvbGV0cmVkOjEzMDQ3MTczLG1pZG5pZ2h0Ymx1ZToxNjQ0OTEyLG1pbnRjcmVhbToxNjEyMTg1MCxtaXN0eXJvc2U6MTY3NzAyNzMsbW9jY2FzaW46MTY3NzAyMjksbmF2YWpvd2hpdGU6MTY3Njg2ODUsbmF2eToxMjgsb2xkbGFjZToxNjY0MzU1OCxvbGl2ZTo4NDIxMzc2LG9saXZlZHJhYjo3MDQ4NzM5LG9yYW5nZToxNjc1MzkyMCxvcmFuZ2VyZWQ6MTY3MjkzNDQsb3JjaGlkOjE0MzE1NzM0LHBhbGVnb2xkZW5yb2Q6MTU2NTcxMzAscGFsZWdyZWVuOjEwMDI1ODgwLHBhbGV0dXJxdW9pc2U6MTE1Mjk5NjYscGFsZXZpb2xldHJlZDoxNDM4MTIwMyxwYXBheWF3aGlwOjE2NzczMDc3LHBlYWNocHVmZjoxNjc2NzY3MyxwZXJ1OjEzNDY4OTkxLHBpbms6MTY3NjEwMzUscGx1bToxNDUyNDYzNyxwb3dkZXJibHVlOjExNTkxOTEwLHB1cnBsZTo4Mzg4NzM2LHJlYmVjY2FwdXJwbGU6NjY5Nzg4MSxyZWQ6MTY3MTE2ODAscm9zeWJyb3duOjEyMzU3NTE5LHJveWFsYmx1ZTo0Mjg2OTQ1LHNhZGRsZWJyb3duOjkxMjcxODcsc2FsbW9uOjE2NDE2ODgyLHNhbmR5YnJvd246MTYwMzI4NjQsc2VhZ3JlZW46MzA1MDMyNyxzZWFzaGVsbDoxNjc3NDYzOCxzaWVubmE6MTA1MDY3OTcsc2lsdmVyOjEyNjMyMjU2LHNreWJsdWU6ODkwMDMzMSxzbGF0ZWJsdWU6Njk3MDA2MSxzbGF0ZWdyYXk6NzM3Mjk0NCxzbGF0ZWdyZXk6NzM3Mjk0NCxzbm93OjE2Nzc1OTMwLHNwcmluZ2dyZWVuOjY1NDA3LHN0ZWVsYmx1ZTo0NjIwOTgwLHRhbjoxMzgwODc4MCx0ZWFsOjMyODk2LHRoaXN0bGU6MTQyMDQ4ODgsdG9tYXRvOjE2NzM3MDk1LHR1cnF1b2lzZTo0MjUxODU2LHZpb2xldDoxNTYzMTA4Nix3aGVhdDoxNjExMzMzMSx3aGl0ZToxNjc3NzIxNSx3aGl0ZXNtb2tlOjE2MTE5Mjg1LHllbGxvdzoxNjc3Njk2MCx5ZWxsb3dncmVlbjoxMDE0NTA3NH0scW49e2g6MCxzOjAsbDowfSxacj17aDowLHM6MCxsOjB9O2Z1bmN0aW9uIEVsKHMsdCxlKXtyZXR1cm4gZTwwJiYoZSs9MSksZT4xJiYoZS09MSksZTwxLzY/cysodC1zKSo2KmU6ZTwxLzI/dDplPDIvMz9zKyh0LXMpKjYqKDIvMy1lKTpzfXZhciB1dD1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUsbil7cmV0dXJuIHRoaXMuaXNDb2xvcj0hMCx0aGlzLnI9MSx0aGlzLmc9MSx0aGlzLmI9MSx0aGlzLnNldCh0LGUsbil9c2V0KHQsZSxuKXtpZihlPT09dm9pZCAwJiZuPT09dm9pZCAwKXtsZXQgaT10O2kmJmkuaXNDb2xvcj90aGlzLmNvcHkoaSk6dHlwZW9mIGk9PSJudW1iZXIiP3RoaXMuc2V0SGV4KGkpOnR5cGVvZiBpPT0ic3RyaW5nIiYmdGhpcy5zZXRTdHlsZShpKX1lbHNlIHRoaXMuc2V0UkdCKHQsZSxuKTtyZXR1cm4gdGhpc31zZXRTY2FsYXIodCl7cmV0dXJuIHRoaXMucj10LHRoaXMuZz10LHRoaXMuYj10LHRoaXN9c2V0SGV4KHQsZT14ZSl7cmV0dXJuIHQ9TWF0aC5mbG9vcih0KSx0aGlzLnI9KHQ+PjE2JjI1NSkvMjU1LHRoaXMuZz0odD4+OCYyNTUpLzI1NSx0aGlzLmI9KHQmMjU1KS8yNTUsanQudG9Xb3JraW5nQ29sb3JTcGFjZSh0aGlzLGUpLHRoaXN9c2V0UkdCKHQsZSxuLGk9anQud29ya2luZ0NvbG9yU3BhY2Upe3JldHVybiB0aGlzLnI9dCx0aGlzLmc9ZSx0aGlzLmI9bixqdC50b1dvcmtpbmdDb2xvclNwYWNlKHRoaXMsaSksdGhpc31zZXRIU0wodCxlLG4saT1qdC53b3JraW5nQ29sb3JTcGFjZSl7aWYodD1udSh0LDEpLGU9dWUoZSwwLDEpLG49dWUobiwwLDEpLGU9PT0wKXRoaXMucj10aGlzLmc9dGhpcy5iPW47ZWxzZXtsZXQgcj1uPD0uNT9uKigxK2UpOm4rZS1uKmUsYT0yKm4tcjt0aGlzLnI9RWwoYSxyLHQrMS8zKSx0aGlzLmc9RWwoYSxyLHQpLHRoaXMuYj1FbChhLHIsdC0xLzMpfXJldHVybiBqdC50b1dvcmtpbmdDb2xvclNwYWNlKHRoaXMsaSksdGhpc31zZXRTdHlsZSh0LGU9eGUpe2Z1bmN0aW9uIG4ocil7ciE9PXZvaWQgMCYmcGFyc2VGbG9hdChyKTwxJiZjb25zb2xlLndhcm4oIlRIUkVFLkNvbG9yOiBBbHBoYSBjb21wb25lbnQgb2YgIit0KyIgd2lsbCBiZSBpZ25vcmVkLiIpfWxldCBpO2lmKGk9L14oXHcrKVwoKFteXCldKilcKS8uZXhlYyh0KSl7bGV0IHIsYT1pWzFdLG89aVsyXTtzd2l0Y2goYSl7Y2FzZSJyZ2IiOmNhc2UicmdiYSI6aWYocj0vXlxzKihcZCspXHMqLFxzKihcZCspXHMqLFxzKihcZCspXHMqKD86LFxzKihcZCpcLj9cZCspXHMqKT8kLy5leGVjKG8pKXJldHVybiBuKHJbNF0pLHRoaXMuc2V0UkdCKE1hdGgubWluKDI1NSxwYXJzZUludChyWzFdLDEwKSkvMjU1LE1hdGgubWluKDI1NSxwYXJzZUludChyWzJdLDEwKSkvMjU1LE1hdGgubWluKDI1NSxwYXJzZUludChyWzNdLDEwKSkvMjU1LGUpO2lmKHI9L15ccyooXGQrKVwlXHMqLFxzKihcZCspXCVccyosXHMqKFxkKylcJVxzKig/OixccyooXGQqXC4/XGQrKVxzKik/JC8uZXhlYyhvKSlyZXR1cm4gbihyWzRdKSx0aGlzLnNldFJHQihNYXRoLm1pbigxMDAscGFyc2VJbnQoclsxXSwxMCkpLzEwMCxNYXRoLm1pbigxMDAscGFyc2VJbnQoclsyXSwxMCkpLzEwMCxNYXRoLm1pbigxMDAscGFyc2VJbnQoclszXSwxMCkpLzEwMCxlKTticmVhaztjYXNlImhzbCI6Y2FzZSJoc2xhIjppZihyPS9eXHMqKFxkKlwuP1xkKylccyosXHMqKFxkKlwuP1xkKylcJVxzKixccyooXGQqXC4/XGQrKVwlXHMqKD86LFxzKihcZCpcLj9cZCspXHMqKT8kLy5leGVjKG8pKXJldHVybiBuKHJbNF0pLHRoaXMuc2V0SFNMKHBhcnNlRmxvYXQoclsxXSkvMzYwLHBhcnNlRmxvYXQoclsyXSkvMTAwLHBhcnNlRmxvYXQoclszXSkvMTAwLGUpO2JyZWFrO2RlZmF1bHQ6Y29uc29sZS53YXJuKCJUSFJFRS5Db2xvcjogVW5rbm93biBjb2xvciBtb2RlbCAiK3QpfX1lbHNlIGlmKGk9L15cIyhbQS1GYS1mXGRdKykkLy5leGVjKHQpKXtsZXQgcj1pWzFdLGE9ci5sZW5ndGg7aWYoYT09PTMpcmV0dXJuIHRoaXMuc2V0UkdCKHBhcnNlSW50KHIuY2hhckF0KDApLDE2KS8xNSxwYXJzZUludChyLmNoYXJBdCgxKSwxNikvMTUscGFyc2VJbnQoci5jaGFyQXQoMiksMTYpLzE1LGUpO2lmKGE9PT02KXJldHVybiB0aGlzLnNldEhleChwYXJzZUludChyLDE2KSxlKTtjb25zb2xlLndhcm4oIlRIUkVFLkNvbG9yOiBJbnZhbGlkIGhleCBjb2xvciAiK3QpfWVsc2UgaWYodCYmdC5sZW5ndGg+MClyZXR1cm4gdGhpcy5zZXRDb2xvck5hbWUodCxlKTtyZXR1cm4gdGhpc31zZXRDb2xvck5hbWUodCxlPXhlKXtsZXQgbj0kZlt0LnRvTG93ZXJDYXNlKCldO3JldHVybiBuIT09dm9pZCAwP3RoaXMuc2V0SGV4KG4sZSk6Y29uc29sZS53YXJuKCJUSFJFRS5Db2xvcjogVW5rbm93biBjb2xvciAiK3QpLHRoaXN9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5yLHRoaXMuZyx0aGlzLmIpfWNvcHkodCl7cmV0dXJuIHRoaXMucj10LnIsdGhpcy5nPXQuZyx0aGlzLmI9dC5iLHRoaXN9Y29weVNSR0JUb0xpbmVhcih0KXtyZXR1cm4gdGhpcy5yPWRzKHQuciksdGhpcy5nPWRzKHQuZyksdGhpcy5iPWRzKHQuYiksdGhpc31jb3B5TGluZWFyVG9TUkdCKHQpe3JldHVybiB0aGlzLnI9ZGwodC5yKSx0aGlzLmc9ZGwodC5nKSx0aGlzLmI9ZGwodC5iKSx0aGlzfWNvbnZlcnRTUkdCVG9MaW5lYXIoKXtyZXR1cm4gdGhpcy5jb3B5U1JHQlRvTGluZWFyKHRoaXMpLHRoaXN9Y29udmVydExpbmVhclRvU1JHQigpe3JldHVybiB0aGlzLmNvcHlMaW5lYXJUb1NSR0IodGhpcyksdGhpc31nZXRIZXgodD14ZSl7cmV0dXJuIGp0LmZyb21Xb3JraW5nQ29sb3JTcGFjZShMZS5jb3B5KHRoaXMpLHQpLE1hdGgucm91bmQodWUoTGUucioyNTUsMCwyNTUpKSo2NTUzNitNYXRoLnJvdW5kKHVlKExlLmcqMjU1LDAsMjU1KSkqMjU2K01hdGgucm91bmQodWUoTGUuYioyNTUsMCwyNTUpKX1nZXRIZXhTdHJpbmcodD14ZSl7cmV0dXJuKCIwMDAwMDAiK3RoaXMuZ2V0SGV4KHQpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTYpfWdldEhTTCh0LGU9anQud29ya2luZ0NvbG9yU3BhY2Upe2p0LmZyb21Xb3JraW5nQ29sb3JTcGFjZShMZS5jb3B5KHRoaXMpLGUpO2xldCBuPUxlLnIsaT1MZS5nLHI9TGUuYixhPU1hdGgubWF4KG4saSxyKSxvPU1hdGgubWluKG4saSxyKSxsLGMsaD0obythKS8yO2lmKG89PT1hKWw9MCxjPTA7ZWxzZXtsZXQgdT1hLW87c3dpdGNoKGM9aDw9LjU/dS8oYStvKTp1LygyLWEtbyksYSl7Y2FzZSBuOmw9KGktcikvdSsoaTxyPzY6MCk7YnJlYWs7Y2FzZSBpOmw9KHItbikvdSsyO2JyZWFrO2Nhc2UgcjpsPShuLWkpL3UrNDticmVha31sLz02fXJldHVybiB0Lmg9bCx0LnM9Yyx0Lmw9aCx0fWdldFJHQih0LGU9anQud29ya2luZ0NvbG9yU3BhY2Upe3JldHVybiBqdC5mcm9tV29ya2luZ0NvbG9yU3BhY2UoTGUuY29weSh0aGlzKSxlKSx0LnI9TGUucix0Lmc9TGUuZyx0LmI9TGUuYix0fWdldFN0eWxlKHQ9eGUpe2p0LmZyb21Xb3JraW5nQ29sb3JTcGFjZShMZS5jb3B5KHRoaXMpLHQpO2xldCBlPUxlLnIsbj1MZS5nLGk9TGUuYjtyZXR1cm4gdCE9PXhlP2Bjb2xvcigke3R9ICR7ZS50b0ZpeGVkKDMpfSAke24udG9GaXhlZCgzKX0gJHtpLnRvRml4ZWQoMyl9KWA6YHJnYigke01hdGgucm91bmQoZSoyNTUpfSwke01hdGgucm91bmQobioyNTUpfSwke01hdGgucm91bmQoaSoyNTUpfSlgfW9mZnNldEhTTCh0LGUsbil7cmV0dXJuIHRoaXMuZ2V0SFNMKHFuKSx0aGlzLnNldEhTTChxbi5oK3QscW4ucytlLHFuLmwrbil9YWRkKHQpe3JldHVybiB0aGlzLnIrPXQucix0aGlzLmcrPXQuZyx0aGlzLmIrPXQuYix0aGlzfWFkZENvbG9ycyh0LGUpe3JldHVybiB0aGlzLnI9dC5yK2Uucix0aGlzLmc9dC5nK2UuZyx0aGlzLmI9dC5iK2UuYix0aGlzfWFkZFNjYWxhcih0KXtyZXR1cm4gdGhpcy5yKz10LHRoaXMuZys9dCx0aGlzLmIrPXQsdGhpc31zdWIodCl7cmV0dXJuIHRoaXMucj1NYXRoLm1heCgwLHRoaXMuci10LnIpLHRoaXMuZz1NYXRoLm1heCgwLHRoaXMuZy10LmcpLHRoaXMuYj1NYXRoLm1heCgwLHRoaXMuYi10LmIpLHRoaXN9bXVsdGlwbHkodCl7cmV0dXJuIHRoaXMucio9dC5yLHRoaXMuZyo9dC5nLHRoaXMuYio9dC5iLHRoaXN9bXVsdGlwbHlTY2FsYXIodCl7cmV0dXJuIHRoaXMucio9dCx0aGlzLmcqPXQsdGhpcy5iKj10LHRoaXN9bGVycCh0LGUpe3JldHVybiB0aGlzLnIrPSh0LnItdGhpcy5yKSplLHRoaXMuZys9KHQuZy10aGlzLmcpKmUsdGhpcy5iKz0odC5iLXRoaXMuYikqZSx0aGlzfWxlcnBDb2xvcnModCxlLG4pe3JldHVybiB0aGlzLnI9dC5yKyhlLnItdC5yKSpuLHRoaXMuZz10LmcrKGUuZy10LmcpKm4sdGhpcy5iPXQuYisoZS5iLXQuYikqbix0aGlzfWxlcnBIU0wodCxlKXt0aGlzLmdldEhTTChxbiksdC5nZXRIU0woWnIpO2xldCBuPUhzKHFuLmgsWnIuaCxlKSxpPUhzKHFuLnMsWnIucyxlKSxyPUhzKHFuLmwsWnIubCxlKTtyZXR1cm4gdGhpcy5zZXRIU0wobixpLHIpLHRoaXN9c2V0RnJvbVZlY3RvcjModCl7cmV0dXJuIHRoaXMucj10LngsdGhpcy5nPXQueSx0aGlzLmI9dC56LHRoaXN9YXBwbHlNYXRyaXgzKHQpe2xldCBlPXRoaXMucixuPXRoaXMuZyxpPXRoaXMuYixyPXQuZWxlbWVudHM7cmV0dXJuIHRoaXMucj1yWzBdKmUrclszXSpuK3JbNl0qaSx0aGlzLmc9clsxXSplK3JbNF0qbityWzddKmksdGhpcy5iPXJbMl0qZStyWzVdKm4rcls4XSppLHRoaXN9ZXF1YWxzKHQpe3JldHVybiB0LnI9PT10aGlzLnImJnQuZz09PXRoaXMuZyYmdC5iPT09dGhpcy5ifWZyb21BcnJheSh0LGU9MCl7cmV0dXJuIHRoaXMucj10W2VdLHRoaXMuZz10W2UrMV0sdGhpcy5iPXRbZSsyXSx0aGlzfXRvQXJyYXkodD1bXSxlPTApe3JldHVybiB0W2VdPXRoaXMucix0W2UrMV09dGhpcy5nLHRbZSsyXT10aGlzLmIsdH1mcm9tQnVmZmVyQXR0cmlidXRlKHQsZSl7cmV0dXJuIHRoaXMucj10LmdldFgoZSksdGhpcy5nPXQuZ2V0WShlKSx0aGlzLmI9dC5nZXRaKGUpLHRoaXN9dG9KU09OKCl7cmV0dXJuIHRoaXMuZ2V0SGV4KCl9KltTeW1ib2wuaXRlcmF0b3JdKCl7eWllbGQgdGhpcy5yLHlpZWxkIHRoaXMuZyx5aWVsZCB0aGlzLmJ9fSxMZT1uZXcgdXQ7dXQuTkFNRVM9JGY7dmFyIEltPTAsQWU9Y2xhc3MgZXh0ZW5kcyBsbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5pc01hdGVyaWFsPSEwLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJpZCIse3ZhbHVlOkltKyt9KSx0aGlzLnV1aWQ9WWUoKSx0aGlzLm5hbWU9IiIsdGhpcy50eXBlPSJNYXRlcmlhbCIsdGhpcy5ibGVuZGluZz1UaSx0aGlzLnNpZGU9Qm4sdGhpcy52ZXJ0ZXhDb2xvcnM9ITEsdGhpcy5vcGFjaXR5PTEsdGhpcy50cmFuc3BhcmVudD0hMSx0aGlzLmFscGhhSGFzaD0hMSx0aGlzLmJsZW5kU3JjPUZhLHRoaXMuYmxlbmREc3Q9QmEsdGhpcy5ibGVuZEVxdWF0aW9uPSRuLHRoaXMuYmxlbmRTcmNBbHBoYT1udWxsLHRoaXMuYmxlbmREc3RBbHBoYT1udWxsLHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhPW51bGwsdGhpcy5ibGVuZENvbG9yPW5ldyB1dCgwLDAsMCksdGhpcy5ibGVuZEFscGhhPTAsdGhpcy5kZXB0aEZ1bmM9cXMsdGhpcy5kZXB0aFRlc3Q9ITAsdGhpcy5kZXB0aFdyaXRlPSEwLHRoaXMuc3RlbmNpbFdyaXRlTWFzaz0yNTUsdGhpcy5zdGVuY2lsRnVuYz1BYyx0aGlzLnN0ZW5jaWxSZWY9MCx0aGlzLnN0ZW5jaWxGdW5jTWFzaz0yNTUsdGhpcy5zdGVuY2lsRmFpbD12aSx0aGlzLnN0ZW5jaWxaRmFpbD12aSx0aGlzLnN0ZW5jaWxaUGFzcz12aSx0aGlzLnN0ZW5jaWxXcml0ZT0hMSx0aGlzLmNsaXBwaW5nUGxhbmVzPW51bGwsdGhpcy5jbGlwSW50ZXJzZWN0aW9uPSExLHRoaXMuY2xpcFNoYWRvd3M9ITEsdGhpcy5zaGFkb3dTaWRlPW51bGwsdGhpcy5jb2xvcldyaXRlPSEwLHRoaXMucHJlY2lzaW9uPW51bGwsdGhpcy5wb2x5Z29uT2Zmc2V0PSExLHRoaXMucG9seWdvbk9mZnNldEZhY3Rvcj0wLHRoaXMucG9seWdvbk9mZnNldFVuaXRzPTAsdGhpcy5kaXRoZXJpbmc9ITEsdGhpcy5hbHBoYVRvQ292ZXJhZ2U9ITEsdGhpcy5wcmVtdWx0aXBsaWVkQWxwaGE9ITEsdGhpcy5mb3JjZVNpbmdsZVBhc3M9ITEsdGhpcy52aXNpYmxlPSEwLHRoaXMudG9uZU1hcHBlZD0hMCx0aGlzLnVzZXJEYXRhPXt9LHRoaXMudmVyc2lvbj0wLHRoaXMuX2FscGhhVGVzdD0wfWdldCBhbHBoYVRlc3QoKXtyZXR1cm4gdGhpcy5fYWxwaGFUZXN0fXNldCBhbHBoYVRlc3QodCl7dGhpcy5fYWxwaGFUZXN0PjAhPXQ+MCYmdGhpcy52ZXJzaW9uKyssdGhpcy5fYWxwaGFUZXN0PXR9b25CdWlsZCgpe31vbkJlZm9yZVJlbmRlcigpe31vbkJlZm9yZUNvbXBpbGUoKXt9Y3VzdG9tUHJvZ3JhbUNhY2hlS2V5KCl7cmV0dXJuIHRoaXMub25CZWZvcmVDb21waWxlLnRvU3RyaW5nKCl9c2V0VmFsdWVzKHQpe2lmKHQhPT12b2lkIDApZm9yKGxldCBlIGluIHQpe2xldCBuPXRbZV07aWYobj09PXZvaWQgMCl7Y29uc29sZS53YXJuKGBUSFJFRS5NYXRlcmlhbDogcGFyYW1ldGVyICcke2V9JyBoYXMgdmFsdWUgb2YgdW5kZWZpbmVkLmApO2NvbnRpbnVlfWxldCBpPXRoaXNbZV07aWYoaT09PXZvaWQgMCl7Y29uc29sZS53YXJuKGBUSFJFRS5NYXRlcmlhbDogJyR7ZX0nIGlzIG5vdCBhIHByb3BlcnR5IG9mIFRIUkVFLiR7dGhpcy50eXBlfS5gKTtjb250aW51ZX1pJiZpLmlzQ29sb3I/aS5zZXQobik6aSYmaS5pc1ZlY3RvcjMmJm4mJm4uaXNWZWN0b3IzP2kuY29weShuKTp0aGlzW2VdPW59fXRvSlNPTih0KXtsZXQgZT10PT09dm9pZCAwfHx0eXBlb2YgdD09InN0cmluZyI7ZSYmKHQ9e3RleHR1cmVzOnt9LGltYWdlczp7fX0pO2xldCBuPXttZXRhZGF0YTp7dmVyc2lvbjo0LjYsdHlwZToiTWF0ZXJpYWwiLGdlbmVyYXRvcjoiTWF0ZXJpYWwudG9KU09OIn19O24udXVpZD10aGlzLnV1aWQsbi50eXBlPXRoaXMudHlwZSx0aGlzLm5hbWUhPT0iIiYmKG4ubmFtZT10aGlzLm5hbWUpLHRoaXMuY29sb3ImJnRoaXMuY29sb3IuaXNDb2xvciYmKG4uY29sb3I9dGhpcy5jb2xvci5nZXRIZXgoKSksdGhpcy5yb3VnaG5lc3MhPT12b2lkIDAmJihuLnJvdWdobmVzcz10aGlzLnJvdWdobmVzcyksdGhpcy5tZXRhbG5lc3MhPT12b2lkIDAmJihuLm1ldGFsbmVzcz10aGlzLm1ldGFsbmVzcyksdGhpcy5zaGVlbiE9PXZvaWQgMCYmKG4uc2hlZW49dGhpcy5zaGVlbiksdGhpcy5zaGVlbkNvbG9yJiZ0aGlzLnNoZWVuQ29sb3IuaXNDb2xvciYmKG4uc2hlZW5Db2xvcj10aGlzLnNoZWVuQ29sb3IuZ2V0SGV4KCkpLHRoaXMuc2hlZW5Sb3VnaG5lc3MhPT12b2lkIDAmJihuLnNoZWVuUm91Z2huZXNzPXRoaXMuc2hlZW5Sb3VnaG5lc3MpLHRoaXMuZW1pc3NpdmUmJnRoaXMuZW1pc3NpdmUuaXNDb2xvciYmKG4uZW1pc3NpdmU9dGhpcy5lbWlzc2l2ZS5nZXRIZXgoKSksdGhpcy5lbWlzc2l2ZUludGVuc2l0eSYmdGhpcy5lbWlzc2l2ZUludGVuc2l0eSE9PTEmJihuLmVtaXNzaXZlSW50ZW5zaXR5PXRoaXMuZW1pc3NpdmVJbnRlbnNpdHkpLHRoaXMuc3BlY3VsYXImJnRoaXMuc3BlY3VsYXIuaXNDb2xvciYmKG4uc3BlY3VsYXI9dGhpcy5zcGVjdWxhci5nZXRIZXgoKSksdGhpcy5zcGVjdWxhckludGVuc2l0eSE9PXZvaWQgMCYmKG4uc3BlY3VsYXJJbnRlbnNpdHk9dGhpcy5zcGVjdWxhckludGVuc2l0eSksdGhpcy5zcGVjdWxhckNvbG9yJiZ0aGlzLnNwZWN1bGFyQ29sb3IuaXNDb2xvciYmKG4uc3BlY3VsYXJDb2xvcj10aGlzLnNwZWN1bGFyQ29sb3IuZ2V0SGV4KCkpLHRoaXMuc2hpbmluZXNzIT09dm9pZCAwJiYobi5zaGluaW5lc3M9dGhpcy5zaGluaW5lc3MpLHRoaXMuY2xlYXJjb2F0IT09dm9pZCAwJiYobi5jbGVhcmNvYXQ9dGhpcy5jbGVhcmNvYXQpLHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzIT09dm9pZCAwJiYobi5jbGVhcmNvYXRSb3VnaG5lc3M9dGhpcy5jbGVhcmNvYXRSb3VnaG5lc3MpLHRoaXMuY2xlYXJjb2F0TWFwJiZ0aGlzLmNsZWFyY29hdE1hcC5pc1RleHR1cmUmJihuLmNsZWFyY29hdE1hcD10aGlzLmNsZWFyY29hdE1hcC50b0pTT04odCkudXVpZCksdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAmJnRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwLmlzVGV4dHVyZSYmKG4uY2xlYXJjb2F0Um91Z2huZXNzTWFwPXRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwLnRvSlNPTih0KS51dWlkKSx0aGlzLmNsZWFyY29hdE5vcm1hbE1hcCYmdGhpcy5jbGVhcmNvYXROb3JtYWxNYXAuaXNUZXh0dXJlJiYobi5jbGVhcmNvYXROb3JtYWxNYXA9dGhpcy5jbGVhcmNvYXROb3JtYWxNYXAudG9KU09OKHQpLnV1aWQsbi5jbGVhcmNvYXROb3JtYWxTY2FsZT10aGlzLmNsZWFyY29hdE5vcm1hbFNjYWxlLnRvQXJyYXkoKSksdGhpcy5pcmlkZXNjZW5jZSE9PXZvaWQgMCYmKG4uaXJpZGVzY2VuY2U9dGhpcy5pcmlkZXNjZW5jZSksdGhpcy5pcmlkZXNjZW5jZUlPUiE9PXZvaWQgMCYmKG4uaXJpZGVzY2VuY2VJT1I9dGhpcy5pcmlkZXNjZW5jZUlPUiksdGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlIT09dm9pZCAwJiYobi5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlPXRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSksdGhpcy5pcmlkZXNjZW5jZU1hcCYmdGhpcy5pcmlkZXNjZW5jZU1hcC5pc1RleHR1cmUmJihuLmlyaWRlc2NlbmNlTWFwPXRoaXMuaXJpZGVzY2VuY2VNYXAudG9KU09OKHQpLnV1aWQpLHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAmJnRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAuaXNUZXh0dXJlJiYobi5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcD10aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLnRvSlNPTih0KS51dWlkKSx0aGlzLmFuaXNvdHJvcHkhPT12b2lkIDAmJihuLmFuaXNvdHJvcHk9dGhpcy5hbmlzb3Ryb3B5KSx0aGlzLmFuaXNvdHJvcHlSb3RhdGlvbiE9PXZvaWQgMCYmKG4uYW5pc290cm9weVJvdGF0aW9uPXRoaXMuYW5pc290cm9weVJvdGF0aW9uKSx0aGlzLmFuaXNvdHJvcHlNYXAmJnRoaXMuYW5pc290cm9weU1hcC5pc1RleHR1cmUmJihuLmFuaXNvdHJvcHlNYXA9dGhpcy5hbmlzb3Ryb3B5TWFwLnRvSlNPTih0KS51dWlkKSx0aGlzLm1hcCYmdGhpcy5tYXAuaXNUZXh0dXJlJiYobi5tYXA9dGhpcy5tYXAudG9KU09OKHQpLnV1aWQpLHRoaXMubWF0Y2FwJiZ0aGlzLm1hdGNhcC5pc1RleHR1cmUmJihuLm1hdGNhcD10aGlzLm1hdGNhcC50b0pTT04odCkudXVpZCksdGhpcy5hbHBoYU1hcCYmdGhpcy5hbHBoYU1hcC5pc1RleHR1cmUmJihuLmFscGhhTWFwPXRoaXMuYWxwaGFNYXAudG9KU09OKHQpLnV1aWQpLHRoaXMubGlnaHRNYXAmJnRoaXMubGlnaHRNYXAuaXNUZXh0dXJlJiYobi5saWdodE1hcD10aGlzLmxpZ2h0TWFwLnRvSlNPTih0KS51dWlkLG4ubGlnaHRNYXBJbnRlbnNpdHk9dGhpcy5saWdodE1hcEludGVuc2l0eSksdGhpcy5hb01hcCYmdGhpcy5hb01hcC5pc1RleHR1cmUmJihuLmFvTWFwPXRoaXMuYW9NYXAudG9KU09OKHQpLnV1aWQsbi5hb01hcEludGVuc2l0eT10aGlzLmFvTWFwSW50ZW5zaXR5KSx0aGlzLmJ1bXBNYXAmJnRoaXMuYnVtcE1hcC5pc1RleHR1cmUmJihuLmJ1bXBNYXA9dGhpcy5idW1wTWFwLnRvSlNPTih0KS51dWlkLG4uYnVtcFNjYWxlPXRoaXMuYnVtcFNjYWxlKSx0aGlzLm5vcm1hbE1hcCYmdGhpcy5ub3JtYWxNYXAuaXNUZXh0dXJlJiYobi5ub3JtYWxNYXA9dGhpcy5ub3JtYWxNYXAudG9KU09OKHQpLnV1aWQsbi5ub3JtYWxNYXBUeXBlPXRoaXMubm9ybWFsTWFwVHlwZSxuLm5vcm1hbFNjYWxlPXRoaXMubm9ybWFsU2NhbGUudG9BcnJheSgpKSx0aGlzLmRpc3BsYWNlbWVudE1hcCYmdGhpcy5kaXNwbGFjZW1lbnRNYXAuaXNUZXh0dXJlJiYobi5kaXNwbGFjZW1lbnRNYXA9dGhpcy5kaXNwbGFjZW1lbnRNYXAudG9KU09OKHQpLnV1aWQsbi5kaXNwbGFjZW1lbnRTY2FsZT10aGlzLmRpc3BsYWNlbWVudFNjYWxlLG4uZGlzcGxhY2VtZW50Qmlhcz10aGlzLmRpc3BsYWNlbWVudEJpYXMpLHRoaXMucm91Z2huZXNzTWFwJiZ0aGlzLnJvdWdobmVzc01hcC5pc1RleHR1cmUmJihuLnJvdWdobmVzc01hcD10aGlzLnJvdWdobmVzc01hcC50b0pTT04odCkudXVpZCksdGhpcy5tZXRhbG5lc3NNYXAmJnRoaXMubWV0YWxuZXNzTWFwLmlzVGV4dHVyZSYmKG4ubWV0YWxuZXNzTWFwPXRoaXMubWV0YWxuZXNzTWFwLnRvSlNPTih0KS51dWlkKSx0aGlzLmVtaXNzaXZlTWFwJiZ0aGlzLmVtaXNzaXZlTWFwLmlzVGV4dHVyZSYmKG4uZW1pc3NpdmVNYXA9dGhpcy5lbWlzc2l2ZU1hcC50b0pTT04odCkudXVpZCksdGhpcy5zcGVjdWxhck1hcCYmdGhpcy5zcGVjdWxhck1hcC5pc1RleHR1cmUmJihuLnNwZWN1bGFyTWFwPXRoaXMuc3BlY3VsYXJNYXAudG9KU09OKHQpLnV1aWQpLHRoaXMuc3BlY3VsYXJJbnRlbnNpdHlNYXAmJnRoaXMuc3BlY3VsYXJJbnRlbnNpdHlNYXAuaXNUZXh0dXJlJiYobi5zcGVjdWxhckludGVuc2l0eU1hcD10aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwLnRvSlNPTih0KS51dWlkKSx0aGlzLnNwZWN1bGFyQ29sb3JNYXAmJnRoaXMuc3BlY3VsYXJDb2xvck1hcC5pc1RleHR1cmUmJihuLnNwZWN1bGFyQ29sb3JNYXA9dGhpcy5zcGVjdWxhckNvbG9yTWFwLnRvSlNPTih0KS51dWlkKSx0aGlzLmVudk1hcCYmdGhpcy5lbnZNYXAuaXNUZXh0dXJlJiYobi5lbnZNYXA9dGhpcy5lbnZNYXAudG9KU09OKHQpLnV1aWQsdGhpcy5jb21iaW5lIT09dm9pZCAwJiYobi5jb21iaW5lPXRoaXMuY29tYmluZSkpLHRoaXMuZW52TWFwSW50ZW5zaXR5IT09dm9pZCAwJiYobi5lbnZNYXBJbnRlbnNpdHk9dGhpcy5lbnZNYXBJbnRlbnNpdHkpLHRoaXMucmVmbGVjdGl2aXR5IT09dm9pZCAwJiYobi5yZWZsZWN0aXZpdHk9dGhpcy5yZWZsZWN0aXZpdHkpLHRoaXMucmVmcmFjdGlvblJhdGlvIT09dm9pZCAwJiYobi5yZWZyYWN0aW9uUmF0aW89dGhpcy5yZWZyYWN0aW9uUmF0aW8pLHRoaXMuZ3JhZGllbnRNYXAmJnRoaXMuZ3JhZGllbnRNYXAuaXNUZXh0dXJlJiYobi5ncmFkaWVudE1hcD10aGlzLmdyYWRpZW50TWFwLnRvSlNPTih0KS51dWlkKSx0aGlzLnRyYW5zbWlzc2lvbiE9PXZvaWQgMCYmKG4udHJhbnNtaXNzaW9uPXRoaXMudHJhbnNtaXNzaW9uKSx0aGlzLnRyYW5zbWlzc2lvbk1hcCYmdGhpcy50cmFuc21pc3Npb25NYXAuaXNUZXh0dXJlJiYobi50cmFuc21pc3Npb25NYXA9dGhpcy50cmFuc21pc3Npb25NYXAudG9KU09OKHQpLnV1aWQpLHRoaXMudGhpY2tuZXNzIT09dm9pZCAwJiYobi50aGlja25lc3M9dGhpcy50aGlja25lc3MpLHRoaXMudGhpY2tuZXNzTWFwJiZ0aGlzLnRoaWNrbmVzc01hcC5pc1RleHR1cmUmJihuLnRoaWNrbmVzc01hcD10aGlzLnRoaWNrbmVzc01hcC50b0pTT04odCkudXVpZCksdGhpcy5hdHRlbnVhdGlvbkRpc3RhbmNlIT09dm9pZCAwJiZ0aGlzLmF0dGVudWF0aW9uRGlzdGFuY2UhPT0xLzAmJihuLmF0dGVudWF0aW9uRGlzdGFuY2U9dGhpcy5hdHRlbnVhdGlvbkRpc3RhbmNlKSx0aGlzLmF0dGVudWF0aW9uQ29sb3IhPT12b2lkIDAmJihuLmF0dGVudWF0aW9uQ29sb3I9dGhpcy5hdHRlbnVhdGlvbkNvbG9yLmdldEhleCgpKSx0aGlzLnNpemUhPT12b2lkIDAmJihuLnNpemU9dGhpcy5zaXplKSx0aGlzLnNoYWRvd1NpZGUhPT1udWxsJiYobi5zaGFkb3dTaWRlPXRoaXMuc2hhZG93U2lkZSksdGhpcy5zaXplQXR0ZW51YXRpb24hPT12b2lkIDAmJihuLnNpemVBdHRlbnVhdGlvbj10aGlzLnNpemVBdHRlbnVhdGlvbiksdGhpcy5ibGVuZGluZyE9PVRpJiYobi5ibGVuZGluZz10aGlzLmJsZW5kaW5nKSx0aGlzLnNpZGUhPT1CbiYmKG4uc2lkZT10aGlzLnNpZGUpLHRoaXMudmVydGV4Q29sb3JzPT09ITAmJihuLnZlcnRleENvbG9ycz0hMCksdGhpcy5vcGFjaXR5PDEmJihuLm9wYWNpdHk9dGhpcy5vcGFjaXR5KSx0aGlzLnRyYW5zcGFyZW50PT09ITAmJihuLnRyYW5zcGFyZW50PSEwKSx0aGlzLmJsZW5kU3JjIT09RmEmJihuLmJsZW5kU3JjPXRoaXMuYmxlbmRTcmMpLHRoaXMuYmxlbmREc3QhPT1CYSYmKG4uYmxlbmREc3Q9dGhpcy5ibGVuZERzdCksdGhpcy5ibGVuZEVxdWF0aW9uIT09JG4mJihuLmJsZW5kRXF1YXRpb249dGhpcy5ibGVuZEVxdWF0aW9uKSx0aGlzLmJsZW5kU3JjQWxwaGEhPT1udWxsJiYobi5ibGVuZFNyY0FscGhhPXRoaXMuYmxlbmRTcmNBbHBoYSksdGhpcy5ibGVuZERzdEFscGhhIT09bnVsbCYmKG4uYmxlbmREc3RBbHBoYT10aGlzLmJsZW5kRHN0QWxwaGEpLHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhIT09bnVsbCYmKG4uYmxlbmRFcXVhdGlvbkFscGhhPXRoaXMuYmxlbmRFcXVhdGlvbkFscGhhKSx0aGlzLmJsZW5kQ29sb3ImJnRoaXMuYmxlbmRDb2xvci5pc0NvbG9yJiYobi5ibGVuZENvbG9yPXRoaXMuYmxlbmRDb2xvci5nZXRIZXgoKSksdGhpcy5ibGVuZEFscGhhIT09MCYmKG4uYmxlbmRBbHBoYT10aGlzLmJsZW5kQWxwaGEpLHRoaXMuZGVwdGhGdW5jIT09cXMmJihuLmRlcHRoRnVuYz10aGlzLmRlcHRoRnVuYyksdGhpcy5kZXB0aFRlc3Q9PT0hMSYmKG4uZGVwdGhUZXN0PXRoaXMuZGVwdGhUZXN0KSx0aGlzLmRlcHRoV3JpdGU9PT0hMSYmKG4uZGVwdGhXcml0ZT10aGlzLmRlcHRoV3JpdGUpLHRoaXMuY29sb3JXcml0ZT09PSExJiYobi5jb2xvcldyaXRlPXRoaXMuY29sb3JXcml0ZSksdGhpcy5zdGVuY2lsV3JpdGVNYXNrIT09MjU1JiYobi5zdGVuY2lsV3JpdGVNYXNrPXRoaXMuc3RlbmNpbFdyaXRlTWFzayksdGhpcy5zdGVuY2lsRnVuYyE9PUFjJiYobi5zdGVuY2lsRnVuYz10aGlzLnN0ZW5jaWxGdW5jKSx0aGlzLnN0ZW5jaWxSZWYhPT0wJiYobi5zdGVuY2lsUmVmPXRoaXMuc3RlbmNpbFJlZiksdGhpcy5zdGVuY2lsRnVuY01hc2shPT0yNTUmJihuLnN0ZW5jaWxGdW5jTWFzaz10aGlzLnN0ZW5jaWxGdW5jTWFzayksdGhpcy5zdGVuY2lsRmFpbCE9PXZpJiYobi5zdGVuY2lsRmFpbD10aGlzLnN0ZW5jaWxGYWlsKSx0aGlzLnN0ZW5jaWxaRmFpbCE9PXZpJiYobi5zdGVuY2lsWkZhaWw9dGhpcy5zdGVuY2lsWkZhaWwpLHRoaXMuc3RlbmNpbFpQYXNzIT09dmkmJihuLnN0ZW5jaWxaUGFzcz10aGlzLnN0ZW5jaWxaUGFzcyksdGhpcy5zdGVuY2lsV3JpdGU9PT0hMCYmKG4uc3RlbmNpbFdyaXRlPXRoaXMuc3RlbmNpbFdyaXRlKSx0aGlzLnJvdGF0aW9uIT09dm9pZCAwJiZ0aGlzLnJvdGF0aW9uIT09MCYmKG4ucm90YXRpb249dGhpcy5yb3RhdGlvbiksdGhpcy5wb2x5Z29uT2Zmc2V0PT09ITAmJihuLnBvbHlnb25PZmZzZXQ9ITApLHRoaXMucG9seWdvbk9mZnNldEZhY3RvciE9PTAmJihuLnBvbHlnb25PZmZzZXRGYWN0b3I9dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yKSx0aGlzLnBvbHlnb25PZmZzZXRVbml0cyE9PTAmJihuLnBvbHlnb25PZmZzZXRVbml0cz10aGlzLnBvbHlnb25PZmZzZXRVbml0cyksdGhpcy5saW5ld2lkdGghPT12b2lkIDAmJnRoaXMubGluZXdpZHRoIT09MSYmKG4ubGluZXdpZHRoPXRoaXMubGluZXdpZHRoKSx0aGlzLmRhc2hTaXplIT09dm9pZCAwJiYobi5kYXNoU2l6ZT10aGlzLmRhc2hTaXplKSx0aGlzLmdhcFNpemUhPT12b2lkIDAmJihuLmdhcFNpemU9dGhpcy5nYXBTaXplKSx0aGlzLnNjYWxlIT09dm9pZCAwJiYobi5zY2FsZT10aGlzLnNjYWxlKSx0aGlzLmRpdGhlcmluZz09PSEwJiYobi5kaXRoZXJpbmc9ITApLHRoaXMuYWxwaGFUZXN0PjAmJihuLmFscGhhVGVzdD10aGlzLmFscGhhVGVzdCksdGhpcy5hbHBoYUhhc2g9PT0hMCYmKG4uYWxwaGFIYXNoPSEwKSx0aGlzLmFscGhhVG9Db3ZlcmFnZT09PSEwJiYobi5hbHBoYVRvQ292ZXJhZ2U9ITApLHRoaXMucHJlbXVsdGlwbGllZEFscGhhPT09ITAmJihuLnByZW11bHRpcGxpZWRBbHBoYT0hMCksdGhpcy5mb3JjZVNpbmdsZVBhc3M9PT0hMCYmKG4uZm9yY2VTaW5nbGVQYXNzPSEwKSx0aGlzLndpcmVmcmFtZT09PSEwJiYobi53aXJlZnJhbWU9ITApLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPjEmJihuLndpcmVmcmFtZUxpbmV3aWR0aD10aGlzLndpcmVmcmFtZUxpbmV3aWR0aCksdGhpcy53aXJlZnJhbWVMaW5lY2FwIT09InJvdW5kIiYmKG4ud2lyZWZyYW1lTGluZWNhcD10aGlzLndpcmVmcmFtZUxpbmVjYXApLHRoaXMud2lyZWZyYW1lTGluZWpvaW4hPT0icm91bmQiJiYobi53aXJlZnJhbWVMaW5lam9pbj10aGlzLndpcmVmcmFtZUxpbmVqb2luKSx0aGlzLmZsYXRTaGFkaW5nPT09ITAmJihuLmZsYXRTaGFkaW5nPSEwKSx0aGlzLnZpc2libGU9PT0hMSYmKG4udmlzaWJsZT0hMSksdGhpcy50b25lTWFwcGVkPT09ITEmJihuLnRvbmVNYXBwZWQ9ITEpLHRoaXMuZm9nPT09ITEmJihuLmZvZz0hMSksT2JqZWN0LmtleXModGhpcy51c2VyRGF0YSkubGVuZ3RoPjAmJihuLnVzZXJEYXRhPXRoaXMudXNlckRhdGEpO2Z1bmN0aW9uIGkocil7bGV0IGE9W107Zm9yKGxldCBvIGluIHIpe2xldCBsPXJbb107ZGVsZXRlIGwubWV0YWRhdGEsYS5wdXNoKGwpfXJldHVybiBhfWlmKGUpe2xldCByPWkodC50ZXh0dXJlcyksYT1pKHQuaW1hZ2VzKTtyLmxlbmd0aD4wJiYobi50ZXh0dXJlcz1yKSxhLmxlbmd0aD4wJiYobi5pbWFnZXM9YSl9cmV0dXJuIG59Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpfWNvcHkodCl7dGhpcy5uYW1lPXQubmFtZSx0aGlzLmJsZW5kaW5nPXQuYmxlbmRpbmcsdGhpcy5zaWRlPXQuc2lkZSx0aGlzLnZlcnRleENvbG9ycz10LnZlcnRleENvbG9ycyx0aGlzLm9wYWNpdHk9dC5vcGFjaXR5LHRoaXMudHJhbnNwYXJlbnQ9dC50cmFuc3BhcmVudCx0aGlzLmJsZW5kU3JjPXQuYmxlbmRTcmMsdGhpcy5ibGVuZERzdD10LmJsZW5kRHN0LHRoaXMuYmxlbmRFcXVhdGlvbj10LmJsZW5kRXF1YXRpb24sdGhpcy5ibGVuZFNyY0FscGhhPXQuYmxlbmRTcmNBbHBoYSx0aGlzLmJsZW5kRHN0QWxwaGE9dC5ibGVuZERzdEFscGhhLHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhPXQuYmxlbmRFcXVhdGlvbkFscGhhLHRoaXMuYmxlbmRDb2xvci5jb3B5KHQuYmxlbmRDb2xvciksdGhpcy5ibGVuZEFscGhhPXQuYmxlbmRBbHBoYSx0aGlzLmRlcHRoRnVuYz10LmRlcHRoRnVuYyx0aGlzLmRlcHRoVGVzdD10LmRlcHRoVGVzdCx0aGlzLmRlcHRoV3JpdGU9dC5kZXB0aFdyaXRlLHRoaXMuc3RlbmNpbFdyaXRlTWFzaz10LnN0ZW5jaWxXcml0ZU1hc2ssdGhpcy5zdGVuY2lsRnVuYz10LnN0ZW5jaWxGdW5jLHRoaXMuc3RlbmNpbFJlZj10LnN0ZW5jaWxSZWYsdGhpcy5zdGVuY2lsRnVuY01hc2s9dC5zdGVuY2lsRnVuY01hc2ssdGhpcy5zdGVuY2lsRmFpbD10LnN0ZW5jaWxGYWlsLHRoaXMuc3RlbmNpbFpGYWlsPXQuc3RlbmNpbFpGYWlsLHRoaXMuc3RlbmNpbFpQYXNzPXQuc3RlbmNpbFpQYXNzLHRoaXMuc3RlbmNpbFdyaXRlPXQuc3RlbmNpbFdyaXRlO2xldCBlPXQuY2xpcHBpbmdQbGFuZXMsbj1udWxsO2lmKGUhPT1udWxsKXtsZXQgaT1lLmxlbmd0aDtuPW5ldyBBcnJheShpKTtmb3IobGV0IHI9MDtyIT09aTsrK3IpbltyXT1lW3JdLmNsb25lKCl9cmV0dXJuIHRoaXMuY2xpcHBpbmdQbGFuZXM9bix0aGlzLmNsaXBJbnRlcnNlY3Rpb249dC5jbGlwSW50ZXJzZWN0aW9uLHRoaXMuY2xpcFNoYWRvd3M9dC5jbGlwU2hhZG93cyx0aGlzLnNoYWRvd1NpZGU9dC5zaGFkb3dTaWRlLHRoaXMuY29sb3JXcml0ZT10LmNvbG9yV3JpdGUsdGhpcy5wcmVjaXNpb249dC5wcmVjaXNpb24sdGhpcy5wb2x5Z29uT2Zmc2V0PXQucG9seWdvbk9mZnNldCx0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3I9dC5wb2x5Z29uT2Zmc2V0RmFjdG9yLHRoaXMucG9seWdvbk9mZnNldFVuaXRzPXQucG9seWdvbk9mZnNldFVuaXRzLHRoaXMuZGl0aGVyaW5nPXQuZGl0aGVyaW5nLHRoaXMuYWxwaGFUZXN0PXQuYWxwaGFUZXN0LHRoaXMuYWxwaGFIYXNoPXQuYWxwaGFIYXNoLHRoaXMuYWxwaGFUb0NvdmVyYWdlPXQuYWxwaGFUb0NvdmVyYWdlLHRoaXMucHJlbXVsdGlwbGllZEFscGhhPXQucHJlbXVsdGlwbGllZEFscGhhLHRoaXMuZm9yY2VTaW5nbGVQYXNzPXQuZm9yY2VTaW5nbGVQYXNzLHRoaXMudmlzaWJsZT10LnZpc2libGUsdGhpcy50b25lTWFwcGVkPXQudG9uZU1hcHBlZCx0aGlzLnVzZXJEYXRhPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodC51c2VyRGF0YSkpLHRoaXN9ZGlzcG9zZSgpe3RoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToiZGlzcG9zZSJ9KX1zZXQgbmVlZHNVcGRhdGUodCl7dD09PSEwJiZ0aGlzLnZlcnNpb24rK319LHhuPWNsYXNzIGV4dGVuZHMgQWV7Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLmlzTWVzaEJhc2ljTWF0ZXJpYWw9ITAsdGhpcy50eXBlPSJNZXNoQmFzaWNNYXRlcmlhbCIsdGhpcy5jb2xvcj1uZXcgdXQoMTY3NzcyMTUpLHRoaXMubWFwPW51bGwsdGhpcy5saWdodE1hcD1udWxsLHRoaXMubGlnaHRNYXBJbnRlbnNpdHk9MSx0aGlzLmFvTWFwPW51bGwsdGhpcy5hb01hcEludGVuc2l0eT0xLHRoaXMuc3BlY3VsYXJNYXA9bnVsbCx0aGlzLmFscGhhTWFwPW51bGwsdGhpcy5lbnZNYXA9bnVsbCx0aGlzLmNvbWJpbmU9T3IsdGhpcy5yZWZsZWN0aXZpdHk9MSx0aGlzLnJlZnJhY3Rpb25SYXRpbz0uOTgsdGhpcy53aXJlZnJhbWU9ITEsdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg9MSx0aGlzLndpcmVmcmFtZUxpbmVjYXA9InJvdW5kIix0aGlzLndpcmVmcmFtZUxpbmVqb2luPSJyb3VuZCIsdGhpcy5mb2c9ITAsdGhpcy5zZXRWYWx1ZXModCl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLmNvbG9yLmNvcHkodC5jb2xvciksdGhpcy5tYXA9dC5tYXAsdGhpcy5saWdodE1hcD10LmxpZ2h0TWFwLHRoaXMubGlnaHRNYXBJbnRlbnNpdHk9dC5saWdodE1hcEludGVuc2l0eSx0aGlzLmFvTWFwPXQuYW9NYXAsdGhpcy5hb01hcEludGVuc2l0eT10LmFvTWFwSW50ZW5zaXR5LHRoaXMuc3BlY3VsYXJNYXA9dC5zcGVjdWxhck1hcCx0aGlzLmFscGhhTWFwPXQuYWxwaGFNYXAsdGhpcy5lbnZNYXA9dC5lbnZNYXAsdGhpcy5jb21iaW5lPXQuY29tYmluZSx0aGlzLnJlZmxlY3Rpdml0eT10LnJlZmxlY3Rpdml0eSx0aGlzLnJlZnJhY3Rpb25SYXRpbz10LnJlZnJhY3Rpb25SYXRpbyx0aGlzLndpcmVmcmFtZT10LndpcmVmcmFtZSx0aGlzLndpcmVmcmFtZUxpbmV3aWR0aD10LndpcmVmcmFtZUxpbmV3aWR0aCx0aGlzLndpcmVmcmFtZUxpbmVjYXA9dC53aXJlZnJhbWVMaW5lY2FwLHRoaXMud2lyZWZyYW1lTGluZWpvaW49dC53aXJlZnJhbWVMaW5lam9pbix0aGlzLmZvZz10LmZvZyx0aGlzfX0sUm49VW0oKTtmdW5jdGlvbiBVbSgpe2xldCBzPW5ldyBBcnJheUJ1ZmZlcig0KSx0PW5ldyBGbG9hdDMyQXJyYXkocyksZT1uZXcgVWludDMyQXJyYXkocyksbj1uZXcgVWludDMyQXJyYXkoNTEyKSxpPW5ldyBVaW50MzJBcnJheSg1MTIpO2ZvcihsZXQgbD0wO2w8MjU2OysrbCl7bGV0IGM9bC0xMjc7YzwtMjc/KG5bbF09MCxuW2x8MjU2XT0zMjc2OCxpW2xdPTI0LGlbbHwyNTZdPTI0KTpjPC0xND8obltsXT0xMDI0Pj4tYy0xNCxuW2x8MjU2XT0xMDI0Pj4tYy0xNHwzMjc2OCxpW2xdPS1jLTEsaVtsfDI1Nl09LWMtMSk6Yzw9MTU/KG5bbF09YysxNTw8MTAsbltsfDI1Nl09YysxNTw8MTB8MzI3NjgsaVtsXT0xMyxpW2x8MjU2XT0xMyk6YzwxMjg/KG5bbF09MzE3NDQsbltsfDI1Nl09NjQ1MTIsaVtsXT0yNCxpW2x8MjU2XT0yNCk6KG5bbF09MzE3NDQsbltsfDI1Nl09NjQ1MTIsaVtsXT0xMyxpW2x8MjU2XT0xMyl9bGV0IHI9bmV3IFVpbnQzMkFycmF5KDIwNDgpLGE9bmV3IFVpbnQzMkFycmF5KDY0KSxvPW5ldyBVaW50MzJBcnJheSg2NCk7Zm9yKGxldCBsPTE7bDwxMDI0OysrbCl7bGV0IGM9bDw8MTMsaD0wO2Zvcig7IShjJjgzODg2MDgpOyljPDw9MSxoLT04Mzg4NjA4O2MmPS04Mzg4NjA5LGgrPTk0NzkxMjcwNCxyW2xdPWN8aH1mb3IobGV0IGw9MTAyNDtsPDIwNDg7KytsKXJbbF09OTM5NTI0MDk2KyhsLTEwMjQ8PDEzKTtmb3IobGV0IGw9MTtsPDMxOysrbClhW2xdPWw8PDIzO2FbMzFdPTExOTk1NzA5NDQsYVszMl09MjE0NzQ4MzY0ODtmb3IobGV0IGw9MzM7bDw2MzsrK2wpYVtsXT0yMTQ3NDgzNjQ4KyhsLTMyPDwyMyk7YVs2M109MzM0NzA1NDU5Mjtmb3IobGV0IGw9MTtsPDY0OysrbClsIT09MzImJihvW2xdPTEwMjQpO3JldHVybntmbG9hdFZpZXc6dCx1aW50MzJWaWV3OmUsYmFzZVRhYmxlOm4sc2hpZnRUYWJsZTppLG1hbnRpc3NhVGFibGU6cixleHBvbmVudFRhYmxlOmEsb2Zmc2V0VGFibGU6b319ZnVuY3Rpb24ga2Uocyl7TWF0aC5hYnMocyk+NjU1MDQmJmNvbnNvbGUud2FybigiVEhSRUUuRGF0YVV0aWxzLnRvSGFsZkZsb2F0KCk6IFZhbHVlIG91dCBvZiByYW5nZS4iKSxzPXVlKHMsLTY1NTA0LDY1NTA0KSxSbi5mbG9hdFZpZXdbMF09cztsZXQgdD1Sbi51aW50MzJWaWV3WzBdLGU9dD4+MjMmNTExO3JldHVybiBSbi5iYXNlVGFibGVbZV0rKCh0JjgzODg2MDcpPj5Sbi5zaGlmdFRhYmxlW2VdKX1mdW5jdGlvbiBWcyhzKXtsZXQgdD1zPj4xMDtyZXR1cm4gUm4udWludDMyVmlld1swXT1Sbi5tYW50aXNzYVRhYmxlW1JuLm9mZnNldFRhYmxlW3RdKyhzJjEwMjMpXStSbi5leHBvbmVudFRhYmxlW3RdLFJuLmZsb2F0Vmlld1swXX12YXIgRG09e3RvSGFsZkZsb2F0OmtlLGZyb21IYWxmRmxvYXQ6VnN9LGdlPW5ldyBSLEpyPW5ldyBaLFp0PWNsYXNze2NvbnN0cnVjdG9yKHQsZSxuPSExKXtpZihBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBUeXBlRXJyb3IoIlRIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogYXJyYXkgc2hvdWxkIGJlIGEgVHlwZWQgQXJyYXkuIik7dGhpcy5pc0J1ZmZlckF0dHJpYnV0ZT0hMCx0aGlzLm5hbWU9IiIsdGhpcy5hcnJheT10LHRoaXMuaXRlbVNpemU9ZSx0aGlzLmNvdW50PXQhPT12b2lkIDA/dC5sZW5ndGgvZTowLHRoaXMubm9ybWFsaXplZD1uLHRoaXMudXNhZ2U9aXIsdGhpcy5fdXBkYXRlUmFuZ2U9e29mZnNldDowLGNvdW50Oi0xfSx0aGlzLnVwZGF0ZVJhbmdlcz1bXSx0aGlzLmdwdVR5cGU9ZW4sdGhpcy52ZXJzaW9uPTB9b25VcGxvYWRDYWxsYmFjaygpe31zZXQgbmVlZHNVcGRhdGUodCl7dD09PSEwJiZ0aGlzLnZlcnNpb24rK31nZXQgdXBkYXRlUmFuZ2UoKXtyZXR1cm4gUmkoIlRIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogdXBkYXRlUmFuZ2UoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gcjE2OS4gVXNlIGFkZFVwZGF0ZVJhbmdlKCkgaW5zdGVhZC4iKSx0aGlzLl91cGRhdGVSYW5nZX1zZXRVc2FnZSh0KXtyZXR1cm4gdGhpcy51c2FnZT10LHRoaXN9YWRkVXBkYXRlUmFuZ2UodCxlKXt0aGlzLnVwZGF0ZVJhbmdlcy5wdXNoKHtzdGFydDp0LGNvdW50OmV9KX1jbGVhclVwZGF0ZVJhbmdlcygpe3RoaXMudXBkYXRlUmFuZ2VzLmxlbmd0aD0wfWNvcHkodCl7cmV0dXJuIHRoaXMubmFtZT10Lm5hbWUsdGhpcy5hcnJheT1uZXcgdC5hcnJheS5jb25zdHJ1Y3Rvcih0LmFycmF5KSx0aGlzLml0ZW1TaXplPXQuaXRlbVNpemUsdGhpcy5jb3VudD10LmNvdW50LHRoaXMubm9ybWFsaXplZD10Lm5vcm1hbGl6ZWQsdGhpcy51c2FnZT10LnVzYWdlLHRoaXMuZ3B1VHlwZT10LmdwdVR5cGUsdGhpc31jb3B5QXQodCxlLG4pe3QqPXRoaXMuaXRlbVNpemUsbio9ZS5pdGVtU2l6ZTtmb3IobGV0IGk9MCxyPXRoaXMuaXRlbVNpemU7aTxyO2krKyl0aGlzLmFycmF5W3QraV09ZS5hcnJheVtuK2ldO3JldHVybiB0aGlzfWNvcHlBcnJheSh0KXtyZXR1cm4gdGhpcy5hcnJheS5zZXQodCksdGhpc31hcHBseU1hdHJpeDModCl7aWYodGhpcy5pdGVtU2l6ZT09PTIpZm9yKGxldCBlPTAsbj10aGlzLmNvdW50O2U8bjtlKyspSnIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0aGlzLGUpLEpyLmFwcGx5TWF0cml4Myh0KSx0aGlzLnNldFhZKGUsSnIueCxKci55KTtlbHNlIGlmKHRoaXMuaXRlbVNpemU9PT0zKWZvcihsZXQgZT0wLG49dGhpcy5jb3VudDtlPG47ZSsrKWdlLmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcyxlKSxnZS5hcHBseU1hdHJpeDModCksdGhpcy5zZXRYWVooZSxnZS54LGdlLnksZ2Uueik7cmV0dXJuIHRoaXN9YXBwbHlNYXRyaXg0KHQpe2ZvcihsZXQgZT0wLG49dGhpcy5jb3VudDtlPG47ZSsrKWdlLmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcyxlKSxnZS5hcHBseU1hdHJpeDQodCksdGhpcy5zZXRYWVooZSxnZS54LGdlLnksZ2Uueik7cmV0dXJuIHRoaXN9YXBwbHlOb3JtYWxNYXRyaXgodCl7Zm9yKGxldCBlPTAsbj10aGlzLmNvdW50O2U8bjtlKyspZ2UuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0aGlzLGUpLGdlLmFwcGx5Tm9ybWFsTWF0cml4KHQpLHRoaXMuc2V0WFlaKGUsZ2UueCxnZS55LGdlLnopO3JldHVybiB0aGlzfXRyYW5zZm9ybURpcmVjdGlvbih0KXtmb3IobGV0IGU9MCxuPXRoaXMuY291bnQ7ZTxuO2UrKylnZS5mcm9tQnVmZmVyQXR0cmlidXRlKHRoaXMsZSksZ2UudHJhbnNmb3JtRGlyZWN0aW9uKHQpLHRoaXMuc2V0WFlaKGUsZ2UueCxnZS55LGdlLnopO3JldHVybiB0aGlzfXNldCh0LGU9MCl7cmV0dXJuIHRoaXMuYXJyYXkuc2V0KHQsZSksdGhpc31nZXRDb21wb25lbnQodCxlKXtsZXQgbj10aGlzLmFycmF5W3QqdGhpcy5pdGVtU2l6ZStlXTtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYobj16ZShuLHRoaXMuYXJyYXkpKSxufXNldENvbXBvbmVudCh0LGUsbil7cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKG49TnQobix0aGlzLmFycmF5KSksdGhpcy5hcnJheVt0KnRoaXMuaXRlbVNpemUrZV09bix0aGlzfWdldFgodCl7bGV0IGU9dGhpcy5hcnJheVt0KnRoaXMuaXRlbVNpemVdO3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihlPXplKGUsdGhpcy5hcnJheSkpLGV9c2V0WCh0LGUpe3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihlPU50KGUsdGhpcy5hcnJheSkpLHRoaXMuYXJyYXlbdCp0aGlzLml0ZW1TaXplXT1lLHRoaXN9Z2V0WSh0KXtsZXQgZT10aGlzLmFycmF5W3QqdGhpcy5pdGVtU2l6ZSsxXTtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYoZT16ZShlLHRoaXMuYXJyYXkpKSxlfXNldFkodCxlKXtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYoZT1OdChlLHRoaXMuYXJyYXkpKSx0aGlzLmFycmF5W3QqdGhpcy5pdGVtU2l6ZSsxXT1lLHRoaXN9Z2V0Wih0KXtsZXQgZT10aGlzLmFycmF5W3QqdGhpcy5pdGVtU2l6ZSsyXTtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYoZT16ZShlLHRoaXMuYXJyYXkpKSxlfXNldFoodCxlKXtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYoZT1OdChlLHRoaXMuYXJyYXkpKSx0aGlzLmFycmF5W3QqdGhpcy5pdGVtU2l6ZSsyXT1lLHRoaXN9Z2V0Vyh0KXtsZXQgZT10aGlzLmFycmF5W3QqdGhpcy5pdGVtU2l6ZSszXTtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYoZT16ZShlLHRoaXMuYXJyYXkpKSxlfXNldFcodCxlKXtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYoZT1OdChlLHRoaXMuYXJyYXkpKSx0aGlzLmFycmF5W3QqdGhpcy5pdGVtU2l6ZSszXT1lLHRoaXN9c2V0WFkodCxlLG4pe3JldHVybiB0Kj10aGlzLml0ZW1TaXplLHRoaXMubm9ybWFsaXplZCYmKGU9TnQoZSx0aGlzLmFycmF5KSxuPU50KG4sdGhpcy5hcnJheSkpLHRoaXMuYXJyYXlbdCswXT1lLHRoaXMuYXJyYXlbdCsxXT1uLHRoaXN9c2V0WFlaKHQsZSxuLGkpe3JldHVybiB0Kj10aGlzLml0ZW1TaXplLHRoaXMubm9ybWFsaXplZCYmKGU9TnQoZSx0aGlzLmFycmF5KSxuPU50KG4sdGhpcy5hcnJheSksaT1OdChpLHRoaXMuYXJyYXkpKSx0aGlzLmFycmF5W3QrMF09ZSx0aGlzLmFycmF5W3QrMV09bix0aGlzLmFycmF5W3QrMl09aSx0aGlzfXNldFhZWlcodCxlLG4saSxyKXtyZXR1cm4gdCo9dGhpcy5pdGVtU2l6ZSx0aGlzLm5vcm1hbGl6ZWQmJihlPU50KGUsdGhpcy5hcnJheSksbj1OdChuLHRoaXMuYXJyYXkpLGk9TnQoaSx0aGlzLmFycmF5KSxyPU50KHIsdGhpcy5hcnJheSkpLHRoaXMuYXJyYXlbdCswXT1lLHRoaXMuYXJyYXlbdCsxXT1uLHRoaXMuYXJyYXlbdCsyXT1pLHRoaXMuYXJyYXlbdCszXT1yLHRoaXN9b25VcGxvYWQodCl7cmV0dXJuIHRoaXMub25VcGxvYWRDYWxsYmFjaz10LHRoaXN9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5hcnJheSx0aGlzLml0ZW1TaXplKS5jb3B5KHRoaXMpfXRvSlNPTigpe2xldCB0PXtpdGVtU2l6ZTp0aGlzLml0ZW1TaXplLHR5cGU6dGhpcy5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLGFycmF5OkFycmF5LmZyb20odGhpcy5hcnJheSksbm9ybWFsaXplZDp0aGlzLm5vcm1hbGl6ZWR9O3JldHVybiB0aGlzLm5hbWUhPT0iIiYmKHQubmFtZT10aGlzLm5hbWUpLHRoaXMudXNhZ2UhPT1pciYmKHQudXNhZ2U9dGhpcy51c2FnZSksdH19LExjPWNsYXNzIGV4dGVuZHMgWnR7Y29uc3RydWN0b3IodCxlLG4pe3N1cGVyKG5ldyBJbnQ4QXJyYXkodCksZSxuKX19LEljPWNsYXNzIGV4dGVuZHMgWnR7Y29uc3RydWN0b3IodCxlLG4pe3N1cGVyKG5ldyBVaW50OEFycmF5KHQpLGUsbil9fSxVYz1jbGFzcyBleHRlbmRzIFp0e2NvbnN0cnVjdG9yKHQsZSxuKXtzdXBlcihuZXcgVWludDhDbGFtcGVkQXJyYXkodCksZSxuKX19LERjPWNsYXNzIGV4dGVuZHMgWnR7Y29uc3RydWN0b3IodCxlLG4pe3N1cGVyKG5ldyBJbnQxNkFycmF5KHQpLGUsbil9fSxjcj1jbGFzcyBleHRlbmRzIFp0e2NvbnN0cnVjdG9yKHQsZSxuKXtzdXBlcihuZXcgVWludDE2QXJyYXkodCksZSxuKX19LE5jPWNsYXNzIGV4dGVuZHMgWnR7Y29uc3RydWN0b3IodCxlLG4pe3N1cGVyKG5ldyBJbnQzMkFycmF5KHQpLGUsbil9fSxocj1jbGFzcyBleHRlbmRzIFp0e2NvbnN0cnVjdG9yKHQsZSxuKXtzdXBlcihuZXcgVWludDMyQXJyYXkodCksZSxuKX19LE9jPWNsYXNzIGV4dGVuZHMgWnR7Y29uc3RydWN0b3IodCxlLG4pe3N1cGVyKG5ldyBVaW50MTZBcnJheSh0KSxlLG4pLHRoaXMuaXNGbG9hdDE2QnVmZmVyQXR0cmlidXRlPSEwfWdldFgodCl7bGV0IGU9VnModGhpcy5hcnJheVt0KnRoaXMuaXRlbVNpemVdKTtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYoZT16ZShlLHRoaXMuYXJyYXkpKSxlfXNldFgodCxlKXtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYoZT1OdChlLHRoaXMuYXJyYXkpKSx0aGlzLmFycmF5W3QqdGhpcy5pdGVtU2l6ZV09a2UoZSksdGhpc31nZXRZKHQpe2xldCBlPVZzKHRoaXMuYXJyYXlbdCp0aGlzLml0ZW1TaXplKzFdKTtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYoZT16ZShlLHRoaXMuYXJyYXkpKSxlfXNldFkodCxlKXtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYoZT1OdChlLHRoaXMuYXJyYXkpKSx0aGlzLmFycmF5W3QqdGhpcy5pdGVtU2l6ZSsxXT1rZShlKSx0aGlzfWdldFoodCl7bGV0IGU9VnModGhpcy5hcnJheVt0KnRoaXMuaXRlbVNpemUrMl0pO3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihlPXplKGUsdGhpcy5hcnJheSkpLGV9c2V0Wih0LGUpe3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihlPU50KGUsdGhpcy5hcnJheSkpLHRoaXMuYXJyYXlbdCp0aGlzLml0ZW1TaXplKzJdPWtlKGUpLHRoaXN9Z2V0Vyh0KXtsZXQgZT1Wcyh0aGlzLmFycmF5W3QqdGhpcy5pdGVtU2l6ZSszXSk7cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKGU9emUoZSx0aGlzLmFycmF5KSksZX1zZXRXKHQsZSl7cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKGU9TnQoZSx0aGlzLmFycmF5KSksdGhpcy5hcnJheVt0KnRoaXMuaXRlbVNpemUrM109a2UoZSksdGhpc31zZXRYWSh0LGUsbil7cmV0dXJuIHQqPXRoaXMuaXRlbVNpemUsdGhpcy5ub3JtYWxpemVkJiYoZT1OdChlLHRoaXMuYXJyYXkpLG49TnQobix0aGlzLmFycmF5KSksdGhpcy5hcnJheVt0KzBdPWtlKGUpLHRoaXMuYXJyYXlbdCsxXT1rZShuKSx0aGlzfXNldFhZWih0LGUsbixpKXtyZXR1cm4gdCo9dGhpcy5pdGVtU2l6ZSx0aGlzLm5vcm1hbGl6ZWQmJihlPU50KGUsdGhpcy5hcnJheSksbj1OdChuLHRoaXMuYXJyYXkpLGk9TnQoaSx0aGlzLmFycmF5KSksdGhpcy5hcnJheVt0KzBdPWtlKGUpLHRoaXMuYXJyYXlbdCsxXT1rZShuKSx0aGlzLmFycmF5W3QrMl09a2UoaSksdGhpc31zZXRYWVpXKHQsZSxuLGkscil7cmV0dXJuIHQqPXRoaXMuaXRlbVNpemUsdGhpcy5ub3JtYWxpemVkJiYoZT1OdChlLHRoaXMuYXJyYXkpLG49TnQobix0aGlzLmFycmF5KSxpPU50KGksdGhpcy5hcnJheSkscj1OdChyLHRoaXMuYXJyYXkpKSx0aGlzLmFycmF5W3QrMF09a2UoZSksdGhpcy5hcnJheVt0KzFdPWtlKG4pLHRoaXMuYXJyYXlbdCsyXT1rZShpKSx0aGlzLmFycmF5W3QrM109a2UociksdGhpc319LGd0PWNsYXNzIGV4dGVuZHMgWnR7Y29uc3RydWN0b3IodCxlLG4pe3N1cGVyKG5ldyBGbG9hdDMyQXJyYXkodCksZSxuKX19LEZjPWNsYXNzIGV4dGVuZHMgWnR7Y29uc3RydWN0b3IodCxlLG4pe3N1cGVyKG5ldyBGbG9hdDY0QXJyYXkodCksZSxuKX19LE5tPTAsdG49bmV3IEx0LEFsPW5ldyBKdCxKaT1uZXcgUixYZT1uZXcgd2UsSXM9bmV3IHdlLGJlPW5ldyBSLEh0PWNsYXNzIHMgZXh0ZW5kcyBsbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5pc0J1ZmZlckdlb21ldHJ5PSEwLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJpZCIse3ZhbHVlOk5tKyt9KSx0aGlzLnV1aWQ9WWUoKSx0aGlzLm5hbWU9IiIsdGhpcy50eXBlPSJCdWZmZXJHZW9tZXRyeSIsdGhpcy5pbmRleD1udWxsLHRoaXMuYXR0cmlidXRlcz17fSx0aGlzLm1vcnBoQXR0cmlidXRlcz17fSx0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPSExLHRoaXMuZ3JvdXBzPVtdLHRoaXMuYm91bmRpbmdCb3g9bnVsbCx0aGlzLmJvdW5kaW5nU3BoZXJlPW51bGwsdGhpcy5kcmF3UmFuZ2U9e3N0YXJ0OjAsY291bnQ6MS8wfSx0aGlzLnVzZXJEYXRhPXt9fWdldEluZGV4KCl7cmV0dXJuIHRoaXMuaW5kZXh9c2V0SW5kZXgodCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodCk/dGhpcy5pbmRleD1uZXcoWmYodCk/aHI6Y3IpKHQsMSk6dGhpcy5pbmRleD10LHRoaXN9Z2V0QXR0cmlidXRlKHQpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXNbdF19c2V0QXR0cmlidXRlKHQsZSl7cmV0dXJuIHRoaXMuYXR0cmlidXRlc1t0XT1lLHRoaXN9ZGVsZXRlQXR0cmlidXRlKHQpe3JldHVybiBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW3RdLHRoaXN9aGFzQXR0cmlidXRlKHQpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXNbdF0hPT12b2lkIDB9YWRkR3JvdXAodCxlLG49MCl7dGhpcy5ncm91cHMucHVzaCh7c3RhcnQ6dCxjb3VudDplLG1hdGVyaWFsSW5kZXg6bn0pfWNsZWFyR3JvdXBzKCl7dGhpcy5ncm91cHM9W119c2V0RHJhd1JhbmdlKHQsZSl7dGhpcy5kcmF3UmFuZ2Uuc3RhcnQ9dCx0aGlzLmRyYXdSYW5nZS5jb3VudD1lfWFwcGx5TWF0cml4NCh0KXtsZXQgZT10aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247ZSE9PXZvaWQgMCYmKGUuYXBwbHlNYXRyaXg0KHQpLGUubmVlZHNVcGRhdGU9ITApO2xldCBuPXRoaXMuYXR0cmlidXRlcy5ub3JtYWw7aWYobiE9PXZvaWQgMCl7bGV0IHI9bmV3IGt0KCkuZ2V0Tm9ybWFsTWF0cml4KHQpO24uYXBwbHlOb3JtYWxNYXRyaXgociksbi5uZWVkc1VwZGF0ZT0hMH1sZXQgaT10aGlzLmF0dHJpYnV0ZXMudGFuZ2VudDtyZXR1cm4gaSE9PXZvaWQgMCYmKGkudHJhbnNmb3JtRGlyZWN0aW9uKHQpLGkubmVlZHNVcGRhdGU9ITApLHRoaXMuYm91bmRpbmdCb3ghPT1udWxsJiZ0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpLHRoaXMuYm91bmRpbmdTcGhlcmUhPT1udWxsJiZ0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpLHRoaXN9YXBwbHlRdWF0ZXJuaW9uKHQpe3JldHVybiB0bi5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbih0KSx0aGlzLmFwcGx5TWF0cml4NCh0biksdGhpc31yb3RhdGVYKHQpe3JldHVybiB0bi5tYWtlUm90YXRpb25YKHQpLHRoaXMuYXBwbHlNYXRyaXg0KHRuKSx0aGlzfXJvdGF0ZVkodCl7cmV0dXJuIHRuLm1ha2VSb3RhdGlvblkodCksdGhpcy5hcHBseU1hdHJpeDQodG4pLHRoaXN9cm90YXRlWih0KXtyZXR1cm4gdG4ubWFrZVJvdGF0aW9uWih0KSx0aGlzLmFwcGx5TWF0cml4NCh0biksdGhpc310cmFuc2xhdGUodCxlLG4pe3JldHVybiB0bi5tYWtlVHJhbnNsYXRpb24odCxlLG4pLHRoaXMuYXBwbHlNYXRyaXg0KHRuKSx0aGlzfXNjYWxlKHQsZSxuKXtyZXR1cm4gdG4ubWFrZVNjYWxlKHQsZSxuKSx0aGlzLmFwcGx5TWF0cml4NCh0biksdGhpc31sb29rQXQodCl7cmV0dXJuIEFsLmxvb2tBdCh0KSxBbC51cGRhdGVNYXRyaXgoKSx0aGlzLmFwcGx5TWF0cml4NChBbC5tYXRyaXgpLHRoaXN9Y2VudGVyKCl7cmV0dXJuIHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCksdGhpcy5ib3VuZGluZ0JveC5nZXRDZW50ZXIoSmkpLm5lZ2F0ZSgpLHRoaXMudHJhbnNsYXRlKEppLngsSmkueSxKaS56KSx0aGlzfXNldEZyb21Qb2ludHModCl7bGV0IGU9W107Zm9yKGxldCBuPTAsaT10Lmxlbmd0aDtuPGk7bisrKXtsZXQgcj10W25dO2UucHVzaChyLngsci55LHIuenx8MCl9cmV0dXJuIHRoaXMuc2V0QXR0cmlidXRlKCJwb3NpdGlvbiIsbmV3IGd0KGUsMykpLHRoaXN9Y29tcHV0ZUJvdW5kaW5nQm94KCl7dGhpcy5ib3VuZGluZ0JveD09PW51bGwmJih0aGlzLmJvdW5kaW5nQm94PW5ldyB3ZSk7bGV0IHQ9dGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLGU9dGhpcy5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247aWYodCYmdC5pc0dMQnVmZmVyQXR0cmlidXRlKXtjb25zb2xlLmVycm9yKCdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTogR0xCdWZmZXJBdHRyaWJ1dGUgcmVxdWlyZXMgYSBtYW51YWwgYm91bmRpbmcgYm94LiBBbHRlcm5hdGl2ZWx5IHNldCAibWVzaC5mcnVzdHVtQ3VsbGVkIiB0byAiZmFsc2UiLicsdGhpcyksdGhpcy5ib3VuZGluZ0JveC5zZXQobmV3IFIoLTEvMCwtMS8wLC0xLzApLG5ldyBSKDEvMCwxLzAsMS8wKSk7cmV0dXJufWlmKHQhPT12b2lkIDApe2lmKHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSh0KSxlKWZvcihsZXQgbj0wLGk9ZS5sZW5ndGg7bjxpO24rKyl7bGV0IHI9ZVtuXTtYZS5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKHIpLHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU/KGJlLmFkZFZlY3RvcnModGhpcy5ib3VuZGluZ0JveC5taW4sWGUubWluKSx0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoYmUpLGJlLmFkZFZlY3RvcnModGhpcy5ib3VuZGluZ0JveC5tYXgsWGUubWF4KSx0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoYmUpKToodGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KFhlLm1pbiksdGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KFhlLm1heCkpfX1lbHNlIHRoaXMuYm91bmRpbmdCb3gubWFrZUVtcHR5KCk7KGlzTmFOKHRoaXMuYm91bmRpbmdCb3gubWluLngpfHxpc05hTih0aGlzLmJvdW5kaW5nQm94Lm1pbi55KXx8aXNOYU4odGhpcy5ib3VuZGluZ0JveC5taW4ueikpJiZjb25zb2xlLmVycm9yKCdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTogQ29tcHV0ZWQgbWluL21heCBoYXZlIE5hTiB2YWx1ZXMuIFRoZSAicG9zaXRpb24iIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsdGhpcyl9Y29tcHV0ZUJvdW5kaW5nU3BoZXJlKCl7dGhpcy5ib3VuZGluZ1NwaGVyZT09PW51bGwmJih0aGlzLmJvdW5kaW5nU3BoZXJlPW5ldyBFZSk7bGV0IHQ9dGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLGU9dGhpcy5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247aWYodCYmdC5pc0dMQnVmZmVyQXR0cmlidXRlKXtjb25zb2xlLmVycm9yKCdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogR0xCdWZmZXJBdHRyaWJ1dGUgcmVxdWlyZXMgYSBtYW51YWwgYm91bmRpbmcgc3BoZXJlLiBBbHRlcm5hdGl2ZWx5IHNldCAibWVzaC5mcnVzdHVtQ3VsbGVkIiB0byAiZmFsc2UiLicsdGhpcyksdGhpcy5ib3VuZGluZ1NwaGVyZS5zZXQobmV3IFIsMS8wKTtyZXR1cm59aWYodCl7bGV0IG49dGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7aWYoWGUuc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSh0KSxlKWZvcihsZXQgcj0wLGE9ZS5sZW5ndGg7cjxhO3IrKyl7bGV0IG89ZVtyXTtJcy5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKG8pLHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU/KGJlLmFkZFZlY3RvcnMoWGUubWluLElzLm1pbiksWGUuZXhwYW5kQnlQb2ludChiZSksYmUuYWRkVmVjdG9ycyhYZS5tYXgsSXMubWF4KSxYZS5leHBhbmRCeVBvaW50KGJlKSk6KFhlLmV4cGFuZEJ5UG9pbnQoSXMubWluKSxYZS5leHBhbmRCeVBvaW50KElzLm1heCkpfVhlLmdldENlbnRlcihuKTtsZXQgaT0wO2ZvcihsZXQgcj0wLGE9dC5jb3VudDtyPGE7cisrKWJlLmZyb21CdWZmZXJBdHRyaWJ1dGUodCxyKSxpPU1hdGgubWF4KGksbi5kaXN0YW5jZVRvU3F1YXJlZChiZSkpO2lmKGUpZm9yKGxldCByPTAsYT1lLmxlbmd0aDtyPGE7cisrKXtsZXQgbz1lW3JdLGw9dGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZTtmb3IobGV0IGM9MCxoPW8uY291bnQ7YzxoO2MrKyliZS5mcm9tQnVmZmVyQXR0cmlidXRlKG8sYyksbCYmKEppLmZyb21CdWZmZXJBdHRyaWJ1dGUodCxjKSxiZS5hZGQoSmkpKSxpPU1hdGgubWF4KGksbi5kaXN0YW5jZVRvU3F1YXJlZChiZSkpfXRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzPU1hdGguc3FydChpKSxpc05hTih0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cykmJmNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBDb21wdXRlZCByYWRpdXMgaXMgTmFOLiBUaGUgInBvc2l0aW9uIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nLHRoaXMpfX1jb21wdXRlVGFuZ2VudHMoKXtsZXQgdD10aGlzLmluZGV4LGU9dGhpcy5hdHRyaWJ1dGVzO2lmKHQ9PT1udWxsfHxlLnBvc2l0aW9uPT09dm9pZCAwfHxlLm5vcm1hbD09PXZvaWQgMHx8ZS51dj09PXZvaWQgMCl7Y29uc29sZS5lcnJvcigiVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBmYWlsZWQuIE1pc3NpbmcgcmVxdWlyZWQgYXR0cmlidXRlcyAoaW5kZXgsIHBvc2l0aW9uLCBub3JtYWwgb3IgdXYpIik7cmV0dXJufWxldCBuPXQuYXJyYXksaT1lLnBvc2l0aW9uLmFycmF5LHI9ZS5ub3JtYWwuYXJyYXksYT1lLnV2LmFycmF5LG89aS5sZW5ndGgvMzt0aGlzLmhhc0F0dHJpYnV0ZSgidGFuZ2VudCIpPT09ITEmJnRoaXMuc2V0QXR0cmlidXRlKCJ0YW5nZW50IixuZXcgWnQobmV3IEZsb2F0MzJBcnJheSg0Km8pLDQpKTtsZXQgbD10aGlzLmdldEF0dHJpYnV0ZSgidGFuZ2VudCIpLmFycmF5LGM9W10saD1bXTtmb3IobGV0IHk9MDt5PG87eSsrKWNbeV09bmV3IFIsaFt5XT1uZXcgUjtsZXQgdT1uZXcgUixkPW5ldyBSLGY9bmV3IFIsbT1uZXcgWixfPW5ldyBaLGc9bmV3IFoscD1uZXcgUix2PW5ldyBSO2Z1bmN0aW9uIHgoeSx3LEcpe3UuZnJvbUFycmF5KGkseSozKSxkLmZyb21BcnJheShpLHcqMyksZi5mcm9tQXJyYXkoaSxHKjMpLG0uZnJvbUFycmF5KGEseSoyKSxfLmZyb21BcnJheShhLHcqMiksZy5mcm9tQXJyYXkoYSxHKjIpLGQuc3ViKHUpLGYuc3ViKHUpLF8uc3ViKG0pLGcuc3ViKG0pO2xldCBKPTEvKF8ueCpnLnktZy54Kl8ueSk7aXNGaW5pdGUoSikmJihwLmNvcHkoZCkubXVsdGlwbHlTY2FsYXIoZy55KS5hZGRTY2FsZWRWZWN0b3IoZiwtXy55KS5tdWx0aXBseVNjYWxhcihKKSx2LmNvcHkoZikubXVsdGlwbHlTY2FsYXIoXy54KS5hZGRTY2FsZWRWZWN0b3IoZCwtZy54KS5tdWx0aXBseVNjYWxhcihKKSxjW3ldLmFkZChwKSxjW3ddLmFkZChwKSxjW0ddLmFkZChwKSxoW3ldLmFkZCh2KSxoW3ddLmFkZCh2KSxoW0ddLmFkZCh2KSl9bGV0IE09dGhpcy5ncm91cHM7TS5sZW5ndGg9PT0wJiYoTT1be3N0YXJ0OjAsY291bnQ6bi5sZW5ndGh9XSk7Zm9yKGxldCB5PTAsdz1NLmxlbmd0aDt5PHc7Kyt5KXtsZXQgRz1NW3ldLEo9Ry5zdGFydCxJPUcuY291bnQ7Zm9yKGxldCB6PUosRj1KK0k7ejxGO3orPTMpeChuW3orMF0sblt6KzFdLG5beisyXSl9bGV0IEM9bmV3IFIsQT1uZXcgUixUPW5ldyBSLFU9bmV3IFI7ZnVuY3Rpb24gayh5KXtULmZyb21BcnJheShyLHkqMyksVS5jb3B5KFQpO2xldCB3PWNbeV07Qy5jb3B5KHcpLEMuc3ViKFQubXVsdGlwbHlTY2FsYXIoVC5kb3QodykpKS5ub3JtYWxpemUoKSxBLmNyb3NzVmVjdG9ycyhVLHcpO2xldCBKPUEuZG90KGhbeV0pPDA/LTE6MTtsW3kqNF09Qy54LGxbeSo0KzFdPUMueSxsW3kqNCsyXT1DLnosbFt5KjQrM109Sn1mb3IobGV0IHk9MCx3PU0ubGVuZ3RoO3k8dzsrK3kpe2xldCBHPU1beV0sSj1HLnN0YXJ0LEk9Ry5jb3VudDtmb3IobGV0IHo9SixGPUorSTt6PEY7eis9MylrKG5beiswXSksayhuW3orMV0pLGsoblt6KzJdKX19Y29tcHV0ZVZlcnRleE5vcm1hbHMoKXtsZXQgdD10aGlzLmluZGV4LGU9dGhpcy5nZXRBdHRyaWJ1dGUoInBvc2l0aW9uIik7aWYoZSE9PXZvaWQgMCl7bGV0IG49dGhpcy5nZXRBdHRyaWJ1dGUoIm5vcm1hbCIpO2lmKG49PT12b2lkIDApbj1uZXcgWnQobmV3IEZsb2F0MzJBcnJheShlLmNvdW50KjMpLDMpLHRoaXMuc2V0QXR0cmlidXRlKCJub3JtYWwiLG4pO2Vsc2UgZm9yKGxldCBkPTAsZj1uLmNvdW50O2Q8ZjtkKyspbi5zZXRYWVooZCwwLDAsMCk7bGV0IGk9bmV3IFIscj1uZXcgUixhPW5ldyBSLG89bmV3IFIsbD1uZXcgUixjPW5ldyBSLGg9bmV3IFIsdT1uZXcgUjtpZih0KWZvcihsZXQgZD0wLGY9dC5jb3VudDtkPGY7ZCs9Myl7bGV0IG09dC5nZXRYKGQrMCksXz10LmdldFgoZCsxKSxnPXQuZ2V0WChkKzIpO2kuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLG0pLHIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLF8pLGEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLGcpLGguc3ViVmVjdG9ycyhhLHIpLHUuc3ViVmVjdG9ycyhpLHIpLGguY3Jvc3ModSksby5mcm9tQnVmZmVyQXR0cmlidXRlKG4sbSksbC5mcm9tQnVmZmVyQXR0cmlidXRlKG4sXyksYy5mcm9tQnVmZmVyQXR0cmlidXRlKG4sZyksby5hZGQoaCksbC5hZGQoaCksYy5hZGQoaCksbi5zZXRYWVoobSxvLngsby55LG8ueiksbi5zZXRYWVooXyxsLngsbC55LGwueiksbi5zZXRYWVooZyxjLngsYy55LGMueil9ZWxzZSBmb3IobGV0IGQ9MCxmPWUuY291bnQ7ZDxmO2QrPTMpaS5mcm9tQnVmZmVyQXR0cmlidXRlKGUsZCswKSxyLmZyb21CdWZmZXJBdHRyaWJ1dGUoZSxkKzEpLGEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLGQrMiksaC5zdWJWZWN0b3JzKGEsciksdS5zdWJWZWN0b3JzKGksciksaC5jcm9zcyh1KSxuLnNldFhZWihkKzAsaC54LGgueSxoLnopLG4uc2V0WFlaKGQrMSxoLngsaC55LGgueiksbi5zZXRYWVooZCsyLGgueCxoLnksaC56KTt0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKSxuLm5lZWRzVXBkYXRlPSEwfX1ub3JtYWxpemVOb3JtYWxzKCl7bGV0IHQ9dGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtmb3IobGV0IGU9MCxuPXQuY291bnQ7ZTxuO2UrKyliZS5mcm9tQnVmZmVyQXR0cmlidXRlKHQsZSksYmUubm9ybWFsaXplKCksdC5zZXRYWVooZSxiZS54LGJlLnksYmUueil9dG9Ob25JbmRleGVkKCl7ZnVuY3Rpb24gdChvLGwpe2xldCBjPW8uYXJyYXksaD1vLml0ZW1TaXplLHU9by5ub3JtYWxpemVkLGQ9bmV3IGMuY29uc3RydWN0b3IobC5sZW5ndGgqaCksZj0wLG09MDtmb3IobGV0IF89MCxnPWwubGVuZ3RoO188ZztfKyspe28uaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZT9mPWxbX10qby5kYXRhLnN0cmlkZStvLm9mZnNldDpmPWxbX10qaDtmb3IobGV0IHA9MDtwPGg7cCsrKWRbbSsrXT1jW2YrK119cmV0dXJuIG5ldyBadChkLGgsdSl9aWYodGhpcy5pbmRleD09PW51bGwpcmV0dXJuIGNvbnNvbGUud2FybigiVEhSRUUuQnVmZmVyR2VvbWV0cnkudG9Ob25JbmRleGVkKCk6IEJ1ZmZlckdlb21ldHJ5IGlzIGFscmVhZHkgbm9uLWluZGV4ZWQuIiksdGhpcztsZXQgZT1uZXcgcyxuPXRoaXMuaW5kZXguYXJyYXksaT10aGlzLmF0dHJpYnV0ZXM7Zm9yKGxldCBvIGluIGkpe2xldCBsPWlbb10sYz10KGwsbik7ZS5zZXRBdHRyaWJ1dGUobyxjKX1sZXQgcj10aGlzLm1vcnBoQXR0cmlidXRlcztmb3IobGV0IG8gaW4gcil7bGV0IGw9W10sYz1yW29dO2ZvcihsZXQgaD0wLHU9Yy5sZW5ndGg7aDx1O2grKyl7bGV0IGQ9Y1toXSxmPXQoZCxuKTtsLnB1c2goZil9ZS5tb3JwaEF0dHJpYnV0ZXNbb109bH1lLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPXRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU7bGV0IGE9dGhpcy5ncm91cHM7Zm9yKGxldCBvPTAsbD1hLmxlbmd0aDtvPGw7bysrKXtsZXQgYz1hW29dO2UuYWRkR3JvdXAoYy5zdGFydCxjLmNvdW50LGMubWF0ZXJpYWxJbmRleCl9cmV0dXJuIGV9dG9KU09OKCl7bGV0IHQ9e21ldGFkYXRhOnt2ZXJzaW9uOjQuNix0eXBlOiJCdWZmZXJHZW9tZXRyeSIsZ2VuZXJhdG9yOiJCdWZmZXJHZW9tZXRyeS50b0pTT04ifX07aWYodC51dWlkPXRoaXMudXVpZCx0LnR5cGU9dGhpcy50eXBlLHRoaXMubmFtZSE9PSIiJiYodC5uYW1lPXRoaXMubmFtZSksT2JqZWN0LmtleXModGhpcy51c2VyRGF0YSkubGVuZ3RoPjAmJih0LnVzZXJEYXRhPXRoaXMudXNlckRhdGEpLHRoaXMucGFyYW1ldGVycyE9PXZvaWQgMCl7bGV0IGw9dGhpcy5wYXJhbWV0ZXJzO2ZvcihsZXQgYyBpbiBsKWxbY10hPT12b2lkIDAmJih0W2NdPWxbY10pO3JldHVybiB0fXQuZGF0YT17YXR0cmlidXRlczp7fX07bGV0IGU9dGhpcy5pbmRleDtlIT09bnVsbCYmKHQuZGF0YS5pbmRleD17dHlwZTplLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsYXJyYXk6QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZS5hcnJheSl9KTtsZXQgbj10aGlzLmF0dHJpYnV0ZXM7Zm9yKGxldCBsIGluIG4pe2xldCBjPW5bbF07dC5kYXRhLmF0dHJpYnV0ZXNbbF09Yy50b0pTT04odC5kYXRhKX1sZXQgaT17fSxyPSExO2ZvcihsZXQgbCBpbiB0aGlzLm1vcnBoQXR0cmlidXRlcyl7bGV0IGM9dGhpcy5tb3JwaEF0dHJpYnV0ZXNbbF0saD1bXTtmb3IobGV0IHU9MCxkPWMubGVuZ3RoO3U8ZDt1Kyspe2xldCBmPWNbdV07aC5wdXNoKGYudG9KU09OKHQuZGF0YSkpfWgubGVuZ3RoPjAmJihpW2xdPWgscj0hMCl9ciYmKHQuZGF0YS5tb3JwaEF0dHJpYnV0ZXM9aSx0LmRhdGEubW9ycGhUYXJnZXRzUmVsYXRpdmU9dGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZSk7bGV0IGE9dGhpcy5ncm91cHM7YS5sZW5ndGg+MCYmKHQuZGF0YS5ncm91cHM9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhKSkpO2xldCBvPXRoaXMuYm91bmRpbmdTcGhlcmU7cmV0dXJuIG8hPT1udWxsJiYodC5kYXRhLmJvdW5kaW5nU3BoZXJlPXtjZW50ZXI6by5jZW50ZXIudG9BcnJheSgpLHJhZGl1czpvLnJhZGl1c30pLHR9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpfWNvcHkodCl7dGhpcy5pbmRleD1udWxsLHRoaXMuYXR0cmlidXRlcz17fSx0aGlzLm1vcnBoQXR0cmlidXRlcz17fSx0aGlzLmdyb3Vwcz1bXSx0aGlzLmJvdW5kaW5nQm94PW51bGwsdGhpcy5ib3VuZGluZ1NwaGVyZT1udWxsO2xldCBlPXt9O3RoaXMubmFtZT10Lm5hbWU7bGV0IG49dC5pbmRleDtuIT09bnVsbCYmdGhpcy5zZXRJbmRleChuLmNsb25lKGUpKTtsZXQgaT10LmF0dHJpYnV0ZXM7Zm9yKGxldCBjIGluIGkpe2xldCBoPWlbY107dGhpcy5zZXRBdHRyaWJ1dGUoYyxoLmNsb25lKGUpKX1sZXQgcj10Lm1vcnBoQXR0cmlidXRlcztmb3IobGV0IGMgaW4gcil7bGV0IGg9W10sdT1yW2NdO2ZvcihsZXQgZD0wLGY9dS5sZW5ndGg7ZDxmO2QrKyloLnB1c2godVtkXS5jbG9uZShlKSk7dGhpcy5tb3JwaEF0dHJpYnV0ZXNbY109aH10aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPXQubW9ycGhUYXJnZXRzUmVsYXRpdmU7bGV0IGE9dC5ncm91cHM7Zm9yKGxldCBjPTAsaD1hLmxlbmd0aDtjPGg7YysrKXtsZXQgdT1hW2NdO3RoaXMuYWRkR3JvdXAodS5zdGFydCx1LmNvdW50LHUubWF0ZXJpYWxJbmRleCl9bGV0IG89dC5ib3VuZGluZ0JveDtvIT09bnVsbCYmKHRoaXMuYm91bmRpbmdCb3g9by5jbG9uZSgpKTtsZXQgbD10LmJvdW5kaW5nU3BoZXJlO3JldHVybiBsIT09bnVsbCYmKHRoaXMuYm91bmRpbmdTcGhlcmU9bC5jbG9uZSgpKSx0aGlzLmRyYXdSYW5nZS5zdGFydD10LmRyYXdSYW5nZS5zdGFydCx0aGlzLmRyYXdSYW5nZS5jb3VudD10LmRyYXdSYW5nZS5jb3VudCx0aGlzLnVzZXJEYXRhPXQudXNlckRhdGEsdGhpc31kaXNwb3NlKCl7dGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJkaXNwb3NlIn0pfX0sVHU9bmV3IEx0LHVpPW5ldyBuaSwkcj1uZXcgRWUsd3U9bmV3IFIsJGk9bmV3IFIsS2k9bmV3IFIsUWk9bmV3IFIsVGw9bmV3IFIsS3I9bmV3IFIsUXI9bmV3IFosanI9bmV3IFosdGE9bmV3IFosUnU9bmV3IFIsQ3U9bmV3IFIsUHU9bmV3IFIsZWE9bmV3IFIsbmE9bmV3IFIsZGU9Y2xhc3MgZXh0ZW5kcyBKdHtjb25zdHJ1Y3Rvcih0PW5ldyBIdCxlPW5ldyB4bil7c3VwZXIoKSx0aGlzLmlzTWVzaD0hMCx0aGlzLnR5cGU9Ik1lc2giLHRoaXMuZ2VvbWV0cnk9dCx0aGlzLm1hdGVyaWFsPWUsdGhpcy51cGRhdGVNb3JwaFRhcmdldHMoKX1jb3B5KHQsZSl7cmV0dXJuIHN1cGVyLmNvcHkodCxlKSx0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyE9PXZvaWQgMCYmKHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzPXQubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnNsaWNlKCkpLHQubW9ycGhUYXJnZXREaWN0aW9uYXJ5IT09dm9pZCAwJiYodGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnk9T2JqZWN0LmFzc2lnbih7fSx0Lm1vcnBoVGFyZ2V0RGljdGlvbmFyeSkpLHRoaXMubWF0ZXJpYWw9QXJyYXkuaXNBcnJheSh0Lm1hdGVyaWFsKT90Lm1hdGVyaWFsLnNsaWNlKCk6dC5tYXRlcmlhbCx0aGlzLmdlb21ldHJ5PXQuZ2VvbWV0cnksdGhpc311cGRhdGVNb3JwaFRhcmdldHMoKXtsZXQgZT10aGlzLmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyxuPU9iamVjdC5rZXlzKGUpO2lmKG4ubGVuZ3RoPjApe2xldCBpPWVbblswXV07aWYoaSE9PXZvaWQgMCl7dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXM9W10sdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnk9e307Zm9yKGxldCByPTAsYT1pLmxlbmd0aDtyPGE7cisrKXtsZXQgbz1pW3JdLm5hbWV8fFN0cmluZyhyKTt0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5wdXNoKDApLHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5W29dPXJ9fX19Z2V0VmVydGV4UG9zaXRpb24odCxlKXtsZXQgbj10aGlzLmdlb21ldHJ5LGk9bi5hdHRyaWJ1dGVzLnBvc2l0aW9uLHI9bi5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24sYT1uLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO2UuZnJvbUJ1ZmZlckF0dHJpYnV0ZShpLHQpO2xldCBvPXRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzO2lmKHImJm8pe0tyLnNldCgwLDAsMCk7Zm9yKGxldCBsPTAsYz1yLmxlbmd0aDtsPGM7bCsrKXtsZXQgaD1vW2xdLHU9cltsXTtoIT09MCYmKFRsLmZyb21CdWZmZXJBdHRyaWJ1dGUodSx0KSxhP0tyLmFkZFNjYWxlZFZlY3RvcihUbCxoKTpLci5hZGRTY2FsZWRWZWN0b3IoVGwuc3ViKGUpLGgpKX1lLmFkZChLcil9cmV0dXJuIGV9cmF5Y2FzdCh0LGUpe2xldCBuPXRoaXMuZ2VvbWV0cnksaT10aGlzLm1hdGVyaWFsLHI9dGhpcy5tYXRyaXhXb3JsZDtpIT09dm9pZCAwJiYobi5ib3VuZGluZ1NwaGVyZT09PW51bGwmJm4uY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCksJHIuY29weShuLmJvdW5kaW5nU3BoZXJlKSwkci5hcHBseU1hdHJpeDQociksdWkuY29weSh0LnJheSkucmVjYXN0KHQubmVhciksISgkci5jb250YWluc1BvaW50KHVpLm9yaWdpbik9PT0hMSYmKHVpLmludGVyc2VjdFNwaGVyZSgkcix3dSk9PT1udWxsfHx1aS5vcmlnaW4uZGlzdGFuY2VUb1NxdWFyZWQod3UpPih0LmZhci10Lm5lYXIpKioyKSkmJihUdS5jb3B5KHIpLmludmVydCgpLHVpLmNvcHkodC5yYXkpLmFwcGx5TWF0cml4NChUdSksIShuLmJvdW5kaW5nQm94IT09bnVsbCYmdWkuaW50ZXJzZWN0c0JveChuLmJvdW5kaW5nQm94KT09PSExKSYmdGhpcy5fY29tcHV0ZUludGVyc2VjdGlvbnModCxlLHVpKSkpfV9jb21wdXRlSW50ZXJzZWN0aW9ucyh0LGUsbil7bGV0IGkscj10aGlzLmdlb21ldHJ5LGE9dGhpcy5tYXRlcmlhbCxvPXIuaW5kZXgsbD1yLmF0dHJpYnV0ZXMucG9zaXRpb24sYz1yLmF0dHJpYnV0ZXMudXYsaD1yLmF0dHJpYnV0ZXMudXYxLHU9ci5hdHRyaWJ1dGVzLm5vcm1hbCxkPXIuZ3JvdXBzLGY9ci5kcmF3UmFuZ2U7aWYobyE9PW51bGwpaWYoQXJyYXkuaXNBcnJheShhKSlmb3IobGV0IG09MCxfPWQubGVuZ3RoO208XzttKyspe2xldCBnPWRbbV0scD1hW2cubWF0ZXJpYWxJbmRleF0sdj1NYXRoLm1heChnLnN0YXJ0LGYuc3RhcnQpLHg9TWF0aC5taW4oby5jb3VudCxNYXRoLm1pbihnLnN0YXJ0K2cuY291bnQsZi5zdGFydCtmLmNvdW50KSk7Zm9yKGxldCBNPXYsQz14O008QztNKz0zKXtsZXQgQT1vLmdldFgoTSksVD1vLmdldFgoTSsxKSxVPW8uZ2V0WChNKzIpO2k9aWEodGhpcyxwLHQsbixjLGgsdSxBLFQsVSksaSYmKGkuZmFjZUluZGV4PU1hdGguZmxvb3IoTS8zKSxpLmZhY2UubWF0ZXJpYWxJbmRleD1nLm1hdGVyaWFsSW5kZXgsZS5wdXNoKGkpKX19ZWxzZXtsZXQgbT1NYXRoLm1heCgwLGYuc3RhcnQpLF89TWF0aC5taW4oby5jb3VudCxmLnN0YXJ0K2YuY291bnQpO2ZvcihsZXQgZz1tLHA9XztnPHA7Zys9Myl7bGV0IHY9by5nZXRYKGcpLHg9by5nZXRYKGcrMSksTT1vLmdldFgoZysyKTtpPWlhKHRoaXMsYSx0LG4sYyxoLHUsdix4LE0pLGkmJihpLmZhY2VJbmRleD1NYXRoLmZsb29yKGcvMyksZS5wdXNoKGkpKX19ZWxzZSBpZihsIT09dm9pZCAwKWlmKEFycmF5LmlzQXJyYXkoYSkpZm9yKGxldCBtPTAsXz1kLmxlbmd0aDttPF87bSsrKXtsZXQgZz1kW21dLHA9YVtnLm1hdGVyaWFsSW5kZXhdLHY9TWF0aC5tYXgoZy5zdGFydCxmLnN0YXJ0KSx4PU1hdGgubWluKGwuY291bnQsTWF0aC5taW4oZy5zdGFydCtnLmNvdW50LGYuc3RhcnQrZi5jb3VudCkpO2ZvcihsZXQgTT12LEM9eDtNPEM7TSs9Myl7bGV0IEE9TSxUPU0rMSxVPU0rMjtpPWlhKHRoaXMscCx0LG4sYyxoLHUsQSxULFUpLGkmJihpLmZhY2VJbmRleD1NYXRoLmZsb29yKE0vMyksaS5mYWNlLm1hdGVyaWFsSW5kZXg9Zy5tYXRlcmlhbEluZGV4LGUucHVzaChpKSl9fWVsc2V7bGV0IG09TWF0aC5tYXgoMCxmLnN0YXJ0KSxfPU1hdGgubWluKGwuY291bnQsZi5zdGFydCtmLmNvdW50KTtmb3IobGV0IGc9bSxwPV87ZzxwO2crPTMpe2xldCB2PWcseD1nKzEsTT1nKzI7aT1pYSh0aGlzLGEsdCxuLGMsaCx1LHYseCxNKSxpJiYoaS5mYWNlSW5kZXg9TWF0aC5mbG9vcihnLzMpLGUucHVzaChpKSl9fX19O2Z1bmN0aW9uIE9tKHMsdCxlLG4saSxyLGEsbyl7bGV0IGw7aWYodC5zaWRlPT09VmU/bD1uLmludGVyc2VjdFRyaWFuZ2xlKGEscixpLCEwLG8pOmw9bi5pbnRlcnNlY3RUcmlhbmdsZShpLHIsYSx0LnNpZGU9PT1CbixvKSxsPT09bnVsbClyZXR1cm4gbnVsbDtuYS5jb3B5KG8pLG5hLmFwcGx5TWF0cml4NChzLm1hdHJpeFdvcmxkKTtsZXQgYz1lLnJheS5vcmlnaW4uZGlzdGFuY2VUbyhuYSk7cmV0dXJuIGM8ZS5uZWFyfHxjPmUuZmFyP251bGw6e2Rpc3RhbmNlOmMscG9pbnQ6bmEuY2xvbmUoKSxvYmplY3Q6c319ZnVuY3Rpb24gaWEocyx0LGUsbixpLHIsYSxvLGwsYyl7cy5nZXRWZXJ0ZXhQb3NpdGlvbihvLCRpKSxzLmdldFZlcnRleFBvc2l0aW9uKGwsS2kpLHMuZ2V0VmVydGV4UG9zaXRpb24oYyxRaSk7bGV0IGg9T20ocyx0LGUsbiwkaSxLaSxRaSxlYSk7aWYoaCl7aSYmKFFyLmZyb21CdWZmZXJBdHRyaWJ1dGUoaSxvKSxqci5mcm9tQnVmZmVyQXR0cmlidXRlKGksbCksdGEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShpLGMpLGgudXY9TG4uZ2V0SW50ZXJwb2xhdGlvbihlYSwkaSxLaSxRaSxRcixqcix0YSxuZXcgWikpLHImJihRci5mcm9tQnVmZmVyQXR0cmlidXRlKHIsbyksanIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShyLGwpLHRhLmZyb21CdWZmZXJBdHRyaWJ1dGUocixjKSxoLnV2MT1Mbi5nZXRJbnRlcnBvbGF0aW9uKGVhLCRpLEtpLFFpLFFyLGpyLHRhLG5ldyBaKSxoLnV2Mj1oLnV2MSksYSYmKFJ1LmZyb21CdWZmZXJBdHRyaWJ1dGUoYSxvKSxDdS5mcm9tQnVmZmVyQXR0cmlidXRlKGEsbCksUHUuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhLGMpLGgubm9ybWFsPUxuLmdldEludGVycG9sYXRpb24oZWEsJGksS2ksUWksUnUsQ3UsUHUsbmV3IFIpLGgubm9ybWFsLmRvdChuLmRpcmVjdGlvbik+MCYmaC5ub3JtYWwubXVsdGlwbHlTY2FsYXIoLTEpKTtsZXQgdT17YTpvLGI6bCxjLG5vcm1hbDpuZXcgUixtYXRlcmlhbEluZGV4OjB9O0xuLmdldE5vcm1hbCgkaSxLaSxRaSx1Lm5vcm1hbCksaC5mYWNlPXV9cmV0dXJuIGh9dmFyIFBpPWNsYXNzIHMgZXh0ZW5kcyBIdHtjb25zdHJ1Y3Rvcih0PTEsZT0xLG49MSxpPTEscj0xLGE9MSl7c3VwZXIoKSx0aGlzLnR5cGU9IkJveEdlb21ldHJ5Iix0aGlzLnBhcmFtZXRlcnM9e3dpZHRoOnQsaGVpZ2h0OmUsZGVwdGg6bix3aWR0aFNlZ21lbnRzOmksaGVpZ2h0U2VnbWVudHM6cixkZXB0aFNlZ21lbnRzOmF9O2xldCBvPXRoaXM7aT1NYXRoLmZsb29yKGkpLHI9TWF0aC5mbG9vcihyKSxhPU1hdGguZmxvb3IoYSk7bGV0IGw9W10sYz1bXSxoPVtdLHU9W10sZD0wLGY9MDttKCJ6IiwieSIsIngiLC0xLC0xLG4sZSx0LGEsciwwKSxtKCJ6IiwieSIsIngiLDEsLTEsbixlLC10LGEsciwxKSxtKCJ4IiwieiIsInkiLDEsMSx0LG4sZSxpLGEsMiksbSgieCIsInoiLCJ5IiwxLC0xLHQsbiwtZSxpLGEsMyksbSgieCIsInkiLCJ6IiwxLC0xLHQsZSxuLGksciw0KSxtKCJ4IiwieSIsInoiLC0xLC0xLHQsZSwtbixpLHIsNSksdGhpcy5zZXRJbmRleChsKSx0aGlzLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBndChjLDMpKSx0aGlzLnNldEF0dHJpYnV0ZSgibm9ybWFsIixuZXcgZ3QoaCwzKSksdGhpcy5zZXRBdHRyaWJ1dGUoInV2IixuZXcgZ3QodSwyKSk7ZnVuY3Rpb24gbShfLGcscCx2LHgsTSxDLEEsVCxVLGspe2xldCB5PU0vVCx3PUMvVSxHPU0vMixKPUMvMixJPUEvMix6PVQrMSxGPVUrMSwkPTAscT0wLFc9bmV3IFI7Zm9yKGxldCBldD0wO2V0PEY7ZXQrKyl7bGV0IFE9ZXQqdy1KO2ZvcihsZXQgZnQ9MDtmdDx6O2Z0Kyspe2xldCBQdD1mdCp5LUc7V1tfXT1QdCp2LFdbZ109USp4LFdbcF09SSxjLnB1c2goVy54LFcueSxXLnopLFdbX109MCxXW2ddPTAsV1twXT1BPjA/MTotMSxoLnB1c2goVy54LFcueSxXLnopLHUucHVzaChmdC9UKSx1LnB1c2goMS1ldC9VKSwkKz0xfX1mb3IobGV0IGV0PTA7ZXQ8VTtldCsrKWZvcihsZXQgUT0wO1E8VDtRKyspe2xldCBmdD1kK1EreipldCxQdD1kK1EreiooZXQrMSksSD1kKyhRKzEpK3oqKGV0KzEpLGl0PWQrKFErMSkreipldDtsLnB1c2goZnQsUHQsaXQpLGwucHVzaChQdCxILGl0KSxxKz02fW8uYWRkR3JvdXAoZixxLGspLGYrPXEsZCs9JH19Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLnBhcmFtZXRlcnM9T2JqZWN0LmFzc2lnbih7fSx0LnBhcmFtZXRlcnMpLHRoaXN9c3RhdGljIGZyb21KU09OKHQpe3JldHVybiBuZXcgcyh0LndpZHRoLHQuaGVpZ2h0LHQuZGVwdGgsdC53aWR0aFNlZ21lbnRzLHQuaGVpZ2h0U2VnbWVudHMsdC5kZXB0aFNlZ21lbnRzKX19O2Z1bmN0aW9uIHhzKHMpe2xldCB0PXt9O2ZvcihsZXQgZSBpbiBzKXt0W2VdPXt9O2ZvcihsZXQgbiBpbiBzW2VdKXtsZXQgaT1zW2VdW25dO2kmJihpLmlzQ29sb3J8fGkuaXNNYXRyaXgzfHxpLmlzTWF0cml4NHx8aS5pc1ZlY3RvcjJ8fGkuaXNWZWN0b3IzfHxpLmlzVmVjdG9yNHx8aS5pc1RleHR1cmV8fGkuaXNRdWF0ZXJuaW9uKT9pLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT8oY29uc29sZS53YXJuKCJVbmlmb3Jtc1V0aWxzOiBUZXh0dXJlcyBvZiByZW5kZXIgdGFyZ2V0cyBjYW5ub3QgYmUgY2xvbmVkIHZpYSBjbG9uZVVuaWZvcm1zKCkgb3IgbWVyZ2VVbmlmb3JtcygpLiIpLHRbZV1bbl09bnVsbCk6dFtlXVtuXT1pLmNsb25lKCk6QXJyYXkuaXNBcnJheShpKT90W2VdW25dPWkuc2xpY2UoKTp0W2VdW25dPWl9fXJldHVybiB0fWZ1bmN0aW9uIEJlKHMpe2xldCB0PXt9O2ZvcihsZXQgZT0wO2U8cy5sZW5ndGg7ZSsrKXtsZXQgbj14cyhzW2VdKTtmb3IobGV0IGkgaW4gbil0W2ldPW5baV19cmV0dXJuIHR9ZnVuY3Rpb24gRm0ocyl7bGV0IHQ9W107Zm9yKGxldCBlPTA7ZTxzLmxlbmd0aDtlKyspdC5wdXNoKHNbZV0uY2xvbmUoKSk7cmV0dXJuIHR9ZnVuY3Rpb24gS2Yocyl7cmV0dXJuIHMuZ2V0UmVuZGVyVGFyZ2V0KCk9PT1udWxsP3Mub3V0cHV0Q29sb3JTcGFjZTpqdC53b3JraW5nQ29sb3JTcGFjZX12YXIgUWY9e2Nsb25lOnhzLG1lcmdlOkJlfSxCbT1gdm9pZCBtYWluKCkgewoJZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApOwp9YCx6bT1gdm9pZCBtYWluKCkgewoJZ2xfRnJhZ0NvbG9yID0gdmVjNCggMS4wLCAwLjAsIDAuMCwgMS4wICk7Cn1gLEplPWNsYXNzIGV4dGVuZHMgQWV7Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLmlzU2hhZGVyTWF0ZXJpYWw9ITAsdGhpcy50eXBlPSJTaGFkZXJNYXRlcmlhbCIsdGhpcy5kZWZpbmVzPXt9LHRoaXMudW5pZm9ybXM9e30sdGhpcy51bmlmb3Jtc0dyb3Vwcz1bXSx0aGlzLnZlcnRleFNoYWRlcj1CbSx0aGlzLmZyYWdtZW50U2hhZGVyPXptLHRoaXMubGluZXdpZHRoPTEsdGhpcy53aXJlZnJhbWU9ITEsdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg9MSx0aGlzLmZvZz0hMSx0aGlzLmxpZ2h0cz0hMSx0aGlzLmNsaXBwaW5nPSExLHRoaXMuZm9yY2VTaW5nbGVQYXNzPSEwLHRoaXMuZXh0ZW5zaW9ucz17ZGVyaXZhdGl2ZXM6ITEsZnJhZ0RlcHRoOiExLGRyYXdCdWZmZXJzOiExLHNoYWRlclRleHR1cmVMT0Q6ITEsY2xpcEN1bGxEaXN0YW5jZTohMSxtdWx0aURyYXc6ITF9LHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcz17Y29sb3I6WzEsMSwxXSx1djpbMCwwXSx1djE6WzAsMF19LHRoaXMuaW5kZXgwQXR0cmlidXRlTmFtZT12b2lkIDAsdGhpcy51bmlmb3Jtc05lZWRVcGRhdGU9ITEsdGhpcy5nbHNsVmVyc2lvbj1udWxsLHQhPT12b2lkIDAmJnRoaXMuc2V0VmFsdWVzKHQpfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5mcmFnbWVudFNoYWRlcj10LmZyYWdtZW50U2hhZGVyLHRoaXMudmVydGV4U2hhZGVyPXQudmVydGV4U2hhZGVyLHRoaXMudW5pZm9ybXM9eHModC51bmlmb3JtcyksdGhpcy51bmlmb3Jtc0dyb3Vwcz1GbSh0LnVuaWZvcm1zR3JvdXBzKSx0aGlzLmRlZmluZXM9T2JqZWN0LmFzc2lnbih7fSx0LmRlZmluZXMpLHRoaXMud2lyZWZyYW1lPXQud2lyZWZyYW1lLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPXQud2lyZWZyYW1lTGluZXdpZHRoLHRoaXMuZm9nPXQuZm9nLHRoaXMubGlnaHRzPXQubGlnaHRzLHRoaXMuY2xpcHBpbmc9dC5jbGlwcGluZyx0aGlzLmV4dGVuc2lvbnM9T2JqZWN0LmFzc2lnbih7fSx0LmV4dGVuc2lvbnMpLHRoaXMuZ2xzbFZlcnNpb249dC5nbHNsVmVyc2lvbix0aGlzfXRvSlNPTih0KXtsZXQgZT1zdXBlci50b0pTT04odCk7ZS5nbHNsVmVyc2lvbj10aGlzLmdsc2xWZXJzaW9uLGUudW5pZm9ybXM9e307Zm9yKGxldCBpIGluIHRoaXMudW5pZm9ybXMpe2xldCBhPXRoaXMudW5pZm9ybXNbaV0udmFsdWU7YSYmYS5pc1RleHR1cmU/ZS51bmlmb3Jtc1tpXT17dHlwZToidCIsdmFsdWU6YS50b0pTT04odCkudXVpZH06YSYmYS5pc0NvbG9yP2UudW5pZm9ybXNbaV09e3R5cGU6ImMiLHZhbHVlOmEuZ2V0SGV4KCl9OmEmJmEuaXNWZWN0b3IyP2UudW5pZm9ybXNbaV09e3R5cGU6InYyIix2YWx1ZTphLnRvQXJyYXkoKX06YSYmYS5pc1ZlY3RvcjM/ZS51bmlmb3Jtc1tpXT17dHlwZToidjMiLHZhbHVlOmEudG9BcnJheSgpfTphJiZhLmlzVmVjdG9yND9lLnVuaWZvcm1zW2ldPXt0eXBlOiJ2NCIsdmFsdWU6YS50b0FycmF5KCl9OmEmJmEuaXNNYXRyaXgzP2UudW5pZm9ybXNbaV09e3R5cGU6Im0zIix2YWx1ZTphLnRvQXJyYXkoKX06YSYmYS5pc01hdHJpeDQ/ZS51bmlmb3Jtc1tpXT17dHlwZToibTQiLHZhbHVlOmEudG9BcnJheSgpfTplLnVuaWZvcm1zW2ldPXt2YWx1ZTphfX1PYmplY3Qua2V5cyh0aGlzLmRlZmluZXMpLmxlbmd0aD4wJiYoZS5kZWZpbmVzPXRoaXMuZGVmaW5lcyksZS52ZXJ0ZXhTaGFkZXI9dGhpcy52ZXJ0ZXhTaGFkZXIsZS5mcmFnbWVudFNoYWRlcj10aGlzLmZyYWdtZW50U2hhZGVyLGUubGlnaHRzPXRoaXMubGlnaHRzLGUuY2xpcHBpbmc9dGhpcy5jbGlwcGluZztsZXQgbj17fTtmb3IobGV0IGkgaW4gdGhpcy5leHRlbnNpb25zKXRoaXMuZXh0ZW5zaW9uc1tpXT09PSEwJiYobltpXT0hMCk7cmV0dXJuIE9iamVjdC5rZXlzKG4pLmxlbmd0aD4wJiYoZS5leHRlbnNpb25zPW4pLGV9fSx2cz1jbGFzcyBleHRlbmRzIEp0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLmlzQ2FtZXJhPSEwLHRoaXMudHlwZT0iQ2FtZXJhIix0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZT1uZXcgTHQsdGhpcy5wcm9qZWN0aW9uTWF0cml4PW5ldyBMdCx0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlPW5ldyBMdCx0aGlzLmNvb3JkaW5hdGVTeXN0ZW09bW59Y29weSh0LGUpe3JldHVybiBzdXBlci5jb3B5KHQsZSksdGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSh0Lm1hdHJpeFdvcmxkSW52ZXJzZSksdGhpcy5wcm9qZWN0aW9uTWF0cml4LmNvcHkodC5wcm9qZWN0aW9uTWF0cml4KSx0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLmNvcHkodC5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSksdGhpcy5jb29yZGluYXRlU3lzdGVtPXQuY29vcmRpbmF0ZVN5c3RlbSx0aGlzfWdldFdvcmxkRGlyZWN0aW9uKHQpe3JldHVybiBzdXBlci5nZXRXb3JsZERpcmVjdGlvbih0KS5uZWdhdGUoKX11cGRhdGVNYXRyaXhXb3JsZCh0KXtzdXBlci51cGRhdGVNYXRyaXhXb3JsZCh0KSx0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KHRoaXMubWF0cml4V29ybGQpLmludmVydCgpfXVwZGF0ZVdvcmxkTWF0cml4KHQsZSl7c3VwZXIudXBkYXRlV29ybGRNYXRyaXgodCxlKSx0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KHRoaXMubWF0cml4V29ybGQpLmludmVydCgpfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX19LFluPW5ldyBSLEx1PW5ldyBaLEl1PW5ldyBaLHZlPWNsYXNzIGV4dGVuZHMgdnN7Y29uc3RydWN0b3IodD01MCxlPTEsbj0uMSxpPTJlMyl7c3VwZXIoKSx0aGlzLmlzUGVyc3BlY3RpdmVDYW1lcmE9ITAsdGhpcy50eXBlPSJQZXJzcGVjdGl2ZUNhbWVyYSIsdGhpcy5mb3Y9dCx0aGlzLnpvb209MSx0aGlzLm5lYXI9bix0aGlzLmZhcj1pLHRoaXMuZm9jdXM9MTAsdGhpcy5hc3BlY3Q9ZSx0aGlzLnZpZXc9bnVsbCx0aGlzLmZpbG1HYXVnZT0zNSx0aGlzLmZpbG1PZmZzZXQ9MCx0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKX1jb3B5KHQsZSl7cmV0dXJuIHN1cGVyLmNvcHkodCxlKSx0aGlzLmZvdj10LmZvdix0aGlzLnpvb209dC56b29tLHRoaXMubmVhcj10Lm5lYXIsdGhpcy5mYXI9dC5mYXIsdGhpcy5mb2N1cz10LmZvY3VzLHRoaXMuYXNwZWN0PXQuYXNwZWN0LHRoaXMudmlldz10LnZpZXc9PT1udWxsP251bGw6T2JqZWN0LmFzc2lnbih7fSx0LnZpZXcpLHRoaXMuZmlsbUdhdWdlPXQuZmlsbUdhdWdlLHRoaXMuZmlsbU9mZnNldD10LmZpbG1PZmZzZXQsdGhpc31zZXRGb2NhbExlbmd0aCh0KXtsZXQgZT0uNSp0aGlzLmdldEZpbG1IZWlnaHQoKS90O3RoaXMuZm92PW1zKjIqTWF0aC5hdGFuKGUpLHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpfWdldEZvY2FsTGVuZ3RoKCl7bGV0IHQ9TWF0aC50YW4od2kqLjUqdGhpcy5mb3YpO3JldHVybiAuNSp0aGlzLmdldEZpbG1IZWlnaHQoKS90fWdldEVmZmVjdGl2ZUZPVigpe3JldHVybiBtcyoyKk1hdGguYXRhbihNYXRoLnRhbih3aSouNSp0aGlzLmZvdikvdGhpcy56b29tKX1nZXRGaWxtV2lkdGgoKXtyZXR1cm4gdGhpcy5maWxtR2F1Z2UqTWF0aC5taW4odGhpcy5hc3BlY3QsMSl9Z2V0RmlsbUhlaWdodCgpe3JldHVybiB0aGlzLmZpbG1HYXVnZS9NYXRoLm1heCh0aGlzLmFzcGVjdCwxKX1nZXRWaWV3Qm91bmRzKHQsZSxuKXtZbi5zZXQoLTEsLTEsLjUpLmFwcGx5TWF0cml4NCh0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlKSxlLnNldChZbi54LFluLnkpLm11bHRpcGx5U2NhbGFyKC10L1luLnopLFluLnNldCgxLDEsLjUpLmFwcGx5TWF0cml4NCh0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlKSxuLnNldChZbi54LFluLnkpLm11bHRpcGx5U2NhbGFyKC10L1luLnopfWdldFZpZXdTaXplKHQsZSl7cmV0dXJuIHRoaXMuZ2V0Vmlld0JvdW5kcyh0LEx1LEl1KSxlLnN1YlZlY3RvcnMoSXUsTHUpfXNldFZpZXdPZmZzZXQodCxlLG4saSxyLGEpe3RoaXMuYXNwZWN0PXQvZSx0aGlzLnZpZXc9PT1udWxsJiYodGhpcy52aWV3PXtlbmFibGVkOiEwLGZ1bGxXaWR0aDoxLGZ1bGxIZWlnaHQ6MSxvZmZzZXRYOjAsb2Zmc2V0WTowLHdpZHRoOjEsaGVpZ2h0OjF9KSx0aGlzLnZpZXcuZW5hYmxlZD0hMCx0aGlzLnZpZXcuZnVsbFdpZHRoPXQsdGhpcy52aWV3LmZ1bGxIZWlnaHQ9ZSx0aGlzLnZpZXcub2Zmc2V0WD1uLHRoaXMudmlldy5vZmZzZXRZPWksdGhpcy52aWV3LndpZHRoPXIsdGhpcy52aWV3LmhlaWdodD1hLHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpfWNsZWFyVmlld09mZnNldCgpe3RoaXMudmlldyE9PW51bGwmJih0aGlzLnZpZXcuZW5hYmxlZD0hMSksdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9dXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpe2xldCB0PXRoaXMubmVhcixlPXQqTWF0aC50YW4od2kqLjUqdGhpcy5mb3YpL3RoaXMuem9vbSxuPTIqZSxpPXRoaXMuYXNwZWN0Km4scj0tLjUqaSxhPXRoaXMudmlldztpZih0aGlzLnZpZXchPT1udWxsJiZ0aGlzLnZpZXcuZW5hYmxlZCl7bGV0IGw9YS5mdWxsV2lkdGgsYz1hLmZ1bGxIZWlnaHQ7cis9YS5vZmZzZXRYKmkvbCxlLT1hLm9mZnNldFkqbi9jLGkqPWEud2lkdGgvbCxuKj1hLmhlaWdodC9jfWxldCBvPXRoaXMuZmlsbU9mZnNldDtvIT09MCYmKHIrPXQqby90aGlzLmdldEZpbG1XaWR0aCgpKSx0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZVBlcnNwZWN0aXZlKHIscitpLGUsZS1uLHQsdGhpcy5mYXIsdGhpcy5jb29yZGluYXRlU3lzdGVtKSx0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLmNvcHkodGhpcy5wcm9qZWN0aW9uTWF0cml4KS5pbnZlcnQoKX10b0pTT04odCl7bGV0IGU9c3VwZXIudG9KU09OKHQpO3JldHVybiBlLm9iamVjdC5mb3Y9dGhpcy5mb3YsZS5vYmplY3Quem9vbT10aGlzLnpvb20sZS5vYmplY3QubmVhcj10aGlzLm5lYXIsZS5vYmplY3QuZmFyPXRoaXMuZmFyLGUub2JqZWN0LmZvY3VzPXRoaXMuZm9jdXMsZS5vYmplY3QuYXNwZWN0PXRoaXMuYXNwZWN0LHRoaXMudmlldyE9PW51bGwmJihlLm9iamVjdC52aWV3PU9iamVjdC5hc3NpZ24oe30sdGhpcy52aWV3KSksZS5vYmplY3QuZmlsbUdhdWdlPXRoaXMuZmlsbUdhdWdlLGUub2JqZWN0LmZpbG1PZmZzZXQ9dGhpcy5maWxtT2Zmc2V0LGV9fSxqaT0tOTAsdHM9MSxHYT1jbGFzcyBleHRlbmRzIEp0e2NvbnN0cnVjdG9yKHQsZSxuKXtzdXBlcigpLHRoaXMudHlwZT0iQ3ViZUNhbWVyYSIsdGhpcy5yZW5kZXJUYXJnZXQ9bix0aGlzLmNvb3JkaW5hdGVTeXN0ZW09bnVsbCx0aGlzLmFjdGl2ZU1pcG1hcExldmVsPTA7bGV0IGk9bmV3IHZlKGppLHRzLHQsZSk7aS5sYXllcnM9dGhpcy5sYXllcnMsdGhpcy5hZGQoaSk7bGV0IHI9bmV3IHZlKGppLHRzLHQsZSk7ci5sYXllcnM9dGhpcy5sYXllcnMsdGhpcy5hZGQocik7bGV0IGE9bmV3IHZlKGppLHRzLHQsZSk7YS5sYXllcnM9dGhpcy5sYXllcnMsdGhpcy5hZGQoYSk7bGV0IG89bmV3IHZlKGppLHRzLHQsZSk7by5sYXllcnM9dGhpcy5sYXllcnMsdGhpcy5hZGQobyk7bGV0IGw9bmV3IHZlKGppLHRzLHQsZSk7bC5sYXllcnM9dGhpcy5sYXllcnMsdGhpcy5hZGQobCk7bGV0IGM9bmV3IHZlKGppLHRzLHQsZSk7Yy5sYXllcnM9dGhpcy5sYXllcnMsdGhpcy5hZGQoYyl9dXBkYXRlQ29vcmRpbmF0ZVN5c3RlbSgpe2xldCB0PXRoaXMuY29vcmRpbmF0ZVN5c3RlbSxlPXRoaXMuY2hpbGRyZW4uY29uY2F0KCksW24saSxyLGEsbyxsXT1lO2ZvcihsZXQgYyBvZiBlKXRoaXMucmVtb3ZlKGMpO2lmKHQ9PT1tbiluLnVwLnNldCgwLDEsMCksbi5sb29rQXQoMSwwLDApLGkudXAuc2V0KDAsMSwwKSxpLmxvb2tBdCgtMSwwLDApLHIudXAuc2V0KDAsMCwtMSksci5sb29rQXQoMCwxLDApLGEudXAuc2V0KDAsMCwxKSxhLmxvb2tBdCgwLC0xLDApLG8udXAuc2V0KDAsMSwwKSxvLmxvb2tBdCgwLDAsMSksbC51cC5zZXQoMCwxLDApLGwubG9va0F0KDAsMCwtMSk7ZWxzZSBpZih0PT09c3Ipbi51cC5zZXQoMCwtMSwwKSxuLmxvb2tBdCgtMSwwLDApLGkudXAuc2V0KDAsLTEsMCksaS5sb29rQXQoMSwwLDApLHIudXAuc2V0KDAsMCwxKSxyLmxvb2tBdCgwLDEsMCksYS51cC5zZXQoMCwwLC0xKSxhLmxvb2tBdCgwLC0xLDApLG8udXAuc2V0KDAsLTEsMCksby5sb29rQXQoMCwwLDEpLGwudXAuc2V0KDAsLTEsMCksbC5sb29rQXQoMCwwLC0xKTtlbHNlIHRocm93IG5ldyBFcnJvcigiVEhSRUUuQ3ViZUNhbWVyYS51cGRhdGVDb29yZGluYXRlU3lzdGVtKCk6IEludmFsaWQgY29vcmRpbmF0ZSBzeXN0ZW06ICIrdCk7Zm9yKGxldCBjIG9mIGUpdGhpcy5hZGQoYyksYy51cGRhdGVNYXRyaXhXb3JsZCgpfXVwZGF0ZSh0LGUpe3RoaXMucGFyZW50PT09bnVsbCYmdGhpcy51cGRhdGVNYXRyaXhXb3JsZCgpO2xldHtyZW5kZXJUYXJnZXQ6bixhY3RpdmVNaXBtYXBMZXZlbDppfT10aGlzO3RoaXMuY29vcmRpbmF0ZVN5c3RlbSE9PXQuY29vcmRpbmF0ZVN5c3RlbSYmKHRoaXMuY29vcmRpbmF0ZVN5c3RlbT10LmNvb3JkaW5hdGVTeXN0ZW0sdGhpcy51cGRhdGVDb29yZGluYXRlU3lzdGVtKCkpO2xldFtyLGEsbyxsLGMsaF09dGhpcy5jaGlsZHJlbix1PXQuZ2V0UmVuZGVyVGFyZ2V0KCksZD10LmdldEFjdGl2ZUN1YmVGYWNlKCksZj10LmdldEFjdGl2ZU1pcG1hcExldmVsKCksbT10LnhyLmVuYWJsZWQ7dC54ci5lbmFibGVkPSExO2xldCBfPW4udGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7bi50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcz0hMSx0LnNldFJlbmRlclRhcmdldChuLDAsaSksdC5yZW5kZXIoZSxyKSx0LnNldFJlbmRlclRhcmdldChuLDEsaSksdC5yZW5kZXIoZSxhKSx0LnNldFJlbmRlclRhcmdldChuLDIsaSksdC5yZW5kZXIoZSxvKSx0LnNldFJlbmRlclRhcmdldChuLDMsaSksdC5yZW5kZXIoZSxsKSx0LnNldFJlbmRlclRhcmdldChuLDQsaSksdC5yZW5kZXIoZSxjKSxuLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzPV8sdC5zZXRSZW5kZXJUYXJnZXQobiw1LGkpLHQucmVuZGVyKGUsaCksdC5zZXRSZW5kZXJUYXJnZXQodSxkLGYpLHQueHIuZW5hYmxlZD1tLG4udGV4dHVyZS5uZWVkc1BNUkVNVXBkYXRlPSEwfX0sTGk9Y2xhc3MgZXh0ZW5kcyBfZXtjb25zdHJ1Y3Rvcih0LGUsbixpLHIsYSxvLGwsYyxoKXt0PXQhPT12b2lkIDA/dDpbXSxlPWUhPT12b2lkIDA/ZTp6bixzdXBlcih0LGUsbixpLHIsYSxvLGwsYyxoKSx0aGlzLmlzQ3ViZVRleHR1cmU9ITAsdGhpcy5mbGlwWT0hMX1nZXQgaW1hZ2VzKCl7cmV0dXJuIHRoaXMuaW1hZ2V9c2V0IGltYWdlcyh0KXt0aGlzLmltYWdlPXR9fSxXYT1jbGFzcyBleHRlbmRzIFple2NvbnN0cnVjdG9yKHQ9MSxlPXt9KXtzdXBlcih0LHQsZSksdGhpcy5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldD0hMDtsZXQgbj17d2lkdGg6dCxoZWlnaHQ6dCxkZXB0aDoxfSxpPVtuLG4sbixuLG4sbl07ZS5lbmNvZGluZyE9PXZvaWQgMCYmKFJpKCJUSFJFRS5XZWJHTEN1YmVSZW5kZXJUYXJnZXQ6IG9wdGlvbi5lbmNvZGluZyBoYXMgYmVlbiByZXBsYWNlZCBieSBvcHRpb24uY29sb3JTcGFjZS4iKSxlLmNvbG9yU3BhY2U9ZS5lbmNvZGluZz09PXRpP3hlOnFlKSx0aGlzLnRleHR1cmU9bmV3IExpKGksZS5tYXBwaW5nLGUud3JhcFMsZS53cmFwVCxlLm1hZ0ZpbHRlcixlLm1pbkZpbHRlcixlLmZvcm1hdCxlLnR5cGUsZS5hbmlzb3Ryb3B5LGUuY29sb3JTcGFjZSksdGhpcy50ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT0hMCx0aGlzLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzPWUuZ2VuZXJhdGVNaXBtYXBzIT09dm9pZCAwP2UuZ2VuZXJhdGVNaXBtYXBzOiExLHRoaXMudGV4dHVyZS5taW5GaWx0ZXI9ZS5taW5GaWx0ZXIhPT12b2lkIDA/ZS5taW5GaWx0ZXI6b2V9ZnJvbUVxdWlyZWN0YW5ndWxhclRleHR1cmUodCxlKXt0aGlzLnRleHR1cmUudHlwZT1lLnR5cGUsdGhpcy50ZXh0dXJlLmNvbG9yU3BhY2U9ZS5jb2xvclNwYWNlLHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM9ZS5nZW5lcmF0ZU1pcG1hcHMsdGhpcy50ZXh0dXJlLm1pbkZpbHRlcj1lLm1pbkZpbHRlcix0aGlzLnRleHR1cmUubWFnRmlsdGVyPWUubWFnRmlsdGVyO2xldCBuPXt1bmlmb3Jtczp7dEVxdWlyZWN0Ont2YWx1ZTpudWxsfX0sdmVydGV4U2hhZGVyOmAKCgkJCQl2YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uOwoKCQkJCXZlYzMgdHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7CgoJCQkJCXJldHVybiBub3JtYWxpemUoICggbWF0cml4ICogdmVjNCggZGlyLCAwLjAgKSApLnh5eiApOwoKCQkJCX0KCgkJCQl2b2lkIG1haW4oKSB7CgoJCQkJCXZXb3JsZERpcmVjdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7CgoJCQkJCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkJCQkJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PgoKCQkJCX0KCQkJYCxmcmFnbWVudFNoYWRlcjpgCgoJCQkJdW5pZm9ybSBzYW1wbGVyMkQgdEVxdWlyZWN0OwoKCQkJCXZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247CgoJCQkJI2luY2x1ZGUgPGNvbW1vbj4KCgkJCQl2b2lkIG1haW4oKSB7CgoJCQkJCXZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2V29ybGREaXJlY3Rpb24gKTsKCgkJCQkJdmVjMiBzYW1wbGVVViA9IGVxdWlyZWN0VXYoIGRpcmVjdGlvbiApOwoKCQkJCQlnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHRFcXVpcmVjdCwgc2FtcGxlVVYgKTsKCgkJCQl9CgkJCWB9LGk9bmV3IFBpKDUsNSw1KSxyPW5ldyBKZSh7bmFtZToiQ3ViZW1hcEZyb21FcXVpcmVjdCIsdW5pZm9ybXM6eHMobi51bmlmb3JtcyksdmVydGV4U2hhZGVyOm4udmVydGV4U2hhZGVyLGZyYWdtZW50U2hhZGVyOm4uZnJhZ21lbnRTaGFkZXIsc2lkZTpWZSxibGVuZGluZzpVbn0pO3IudW5pZm9ybXMudEVxdWlyZWN0LnZhbHVlPWU7bGV0IGE9bmV3IGRlKGksciksbz1lLm1pbkZpbHRlcjtyZXR1cm4gZS5taW5GaWx0ZXI9PT1wbiYmKGUubWluRmlsdGVyPW9lKSxuZXcgR2EoMSwxMCx0aGlzKS51cGRhdGUodCxhKSxlLm1pbkZpbHRlcj1vLGEuZ2VvbWV0cnkuZGlzcG9zZSgpLGEubWF0ZXJpYWwuZGlzcG9zZSgpLHRoaXN9Y2xlYXIodCxlLG4saSl7bGV0IHI9dC5nZXRSZW5kZXJUYXJnZXQoKTtmb3IobGV0IGE9MDthPDY7YSsrKXQuc2V0UmVuZGVyVGFyZ2V0KHRoaXMsYSksdC5jbGVhcihlLG4saSk7dC5zZXRSZW5kZXJUYXJnZXQocil9fSx3bD1uZXcgUixWbT1uZXcgUixrbT1uZXcga3QsZG49Y2xhc3N7Y29uc3RydWN0b3IodD1uZXcgUigxLDAsMCksZT0wKXt0aGlzLmlzUGxhbmU9ITAsdGhpcy5ub3JtYWw9dCx0aGlzLmNvbnN0YW50PWV9c2V0KHQsZSl7cmV0dXJuIHRoaXMubm9ybWFsLmNvcHkodCksdGhpcy5jb25zdGFudD1lLHRoaXN9c2V0Q29tcG9uZW50cyh0LGUsbixpKXtyZXR1cm4gdGhpcy5ub3JtYWwuc2V0KHQsZSxuKSx0aGlzLmNvbnN0YW50PWksdGhpc31zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCh0LGUpe3JldHVybiB0aGlzLm5vcm1hbC5jb3B5KHQpLHRoaXMuY29uc3RhbnQ9LWUuZG90KHRoaXMubm9ybWFsKSx0aGlzfXNldEZyb21Db3BsYW5hclBvaW50cyh0LGUsbil7bGV0IGk9d2wuc3ViVmVjdG9ycyhuLGUpLmNyb3NzKFZtLnN1YlZlY3RvcnModCxlKSkubm9ybWFsaXplKCk7cmV0dXJuIHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoaSx0KSx0aGlzfWNvcHkodCl7cmV0dXJuIHRoaXMubm9ybWFsLmNvcHkodC5ub3JtYWwpLHRoaXMuY29uc3RhbnQ9dC5jb25zdGFudCx0aGlzfW5vcm1hbGl6ZSgpe2xldCB0PTEvdGhpcy5ub3JtYWwubGVuZ3RoKCk7cmV0dXJuIHRoaXMubm9ybWFsLm11bHRpcGx5U2NhbGFyKHQpLHRoaXMuY29uc3RhbnQqPXQsdGhpc31uZWdhdGUoKXtyZXR1cm4gdGhpcy5jb25zdGFudCo9LTEsdGhpcy5ub3JtYWwubmVnYXRlKCksdGhpc31kaXN0YW5jZVRvUG9pbnQodCl7cmV0dXJuIHRoaXMubm9ybWFsLmRvdCh0KSt0aGlzLmNvbnN0YW50fWRpc3RhbmNlVG9TcGhlcmUodCl7cmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KHQuY2VudGVyKS10LnJhZGl1c31wcm9qZWN0UG9pbnQodCxlKXtyZXR1cm4gZS5jb3B5KHQpLmFkZFNjYWxlZFZlY3Rvcih0aGlzLm5vcm1hbCwtdGhpcy5kaXN0YW5jZVRvUG9pbnQodCkpfWludGVyc2VjdExpbmUodCxlKXtsZXQgbj10LmRlbHRhKHdsKSxpPXRoaXMubm9ybWFsLmRvdChuKTtpZihpPT09MClyZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQodC5zdGFydCk9PT0wP2UuY29weSh0LnN0YXJ0KTpudWxsO2xldCByPS0odC5zdGFydC5kb3QodGhpcy5ub3JtYWwpK3RoaXMuY29uc3RhbnQpL2k7cmV0dXJuIHI8MHx8cj4xP251bGw6ZS5jb3B5KHQuc3RhcnQpLmFkZFNjYWxlZFZlY3RvcihuLHIpfWludGVyc2VjdHNMaW5lKHQpe2xldCBlPXRoaXMuZGlzdGFuY2VUb1BvaW50KHQuc3RhcnQpLG49dGhpcy5kaXN0YW5jZVRvUG9pbnQodC5lbmQpO3JldHVybiBlPDAmJm4+MHx8bjwwJiZlPjB9aW50ZXJzZWN0c0JveCh0KXtyZXR1cm4gdC5pbnRlcnNlY3RzUGxhbmUodGhpcyl9aW50ZXJzZWN0c1NwaGVyZSh0KXtyZXR1cm4gdC5pbnRlcnNlY3RzUGxhbmUodGhpcyl9Y29wbGFuYXJQb2ludCh0KXtyZXR1cm4gdC5jb3B5KHRoaXMubm9ybWFsKS5tdWx0aXBseVNjYWxhcigtdGhpcy5jb25zdGFudCl9YXBwbHlNYXRyaXg0KHQsZSl7bGV0IG49ZXx8a20uZ2V0Tm9ybWFsTWF0cml4KHQpLGk9dGhpcy5jb3BsYW5hclBvaW50KHdsKS5hcHBseU1hdHJpeDQodCkscj10aGlzLm5vcm1hbC5hcHBseU1hdHJpeDMobikubm9ybWFsaXplKCk7cmV0dXJuIHRoaXMuY29uc3RhbnQ9LWkuZG90KHIpLHRoaXN9dHJhbnNsYXRlKHQpe3JldHVybiB0aGlzLmNvbnN0YW50LT10LmRvdCh0aGlzLm5vcm1hbCksdGhpc31lcXVhbHModCl7cmV0dXJuIHQubm9ybWFsLmVxdWFscyh0aGlzLm5vcm1hbCkmJnQuY29uc3RhbnQ9PT10aGlzLmNvbnN0YW50fWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX19LGRpPW5ldyBFZSxzYT1uZXcgUixJaT1jbGFzc3tjb25zdHJ1Y3Rvcih0PW5ldyBkbixlPW5ldyBkbixuPW5ldyBkbixpPW5ldyBkbixyPW5ldyBkbixhPW5ldyBkbil7dGhpcy5wbGFuZXM9W3QsZSxuLGkscixhXX1zZXQodCxlLG4saSxyLGEpe2xldCBvPXRoaXMucGxhbmVzO3JldHVybiBvWzBdLmNvcHkodCksb1sxXS5jb3B5KGUpLG9bMl0uY29weShuKSxvWzNdLmNvcHkoaSksb1s0XS5jb3B5KHIpLG9bNV0uY29weShhKSx0aGlzfWNvcHkodCl7bGV0IGU9dGhpcy5wbGFuZXM7Zm9yKGxldCBuPTA7bjw2O24rKyllW25dLmNvcHkodC5wbGFuZXNbbl0pO3JldHVybiB0aGlzfXNldEZyb21Qcm9qZWN0aW9uTWF0cml4KHQsZT1tbil7bGV0IG49dGhpcy5wbGFuZXMsaT10LmVsZW1lbnRzLHI9aVswXSxhPWlbMV0sbz1pWzJdLGw9aVszXSxjPWlbNF0saD1pWzVdLHU9aVs2XSxkPWlbN10sZj1pWzhdLG09aVs5XSxfPWlbMTBdLGc9aVsxMV0scD1pWzEyXSx2PWlbMTNdLHg9aVsxNF0sTT1pWzE1XTtpZihuWzBdLnNldENvbXBvbmVudHMobC1yLGQtYyxnLWYsTS1wKS5ub3JtYWxpemUoKSxuWzFdLnNldENvbXBvbmVudHMobCtyLGQrYyxnK2YsTStwKS5ub3JtYWxpemUoKSxuWzJdLnNldENvbXBvbmVudHMobCthLGQraCxnK20sTSt2KS5ub3JtYWxpemUoKSxuWzNdLnNldENvbXBvbmVudHMobC1hLGQtaCxnLW0sTS12KS5ub3JtYWxpemUoKSxuWzRdLnNldENvbXBvbmVudHMobC1vLGQtdSxnLV8sTS14KS5ub3JtYWxpemUoKSxlPT09bW4pbls1XS5zZXRDb21wb25lbnRzKGwrbyxkK3UsZytfLE0reCkubm9ybWFsaXplKCk7ZWxzZSBpZihlPT09c3Ipbls1XS5zZXRDb21wb25lbnRzKG8sdSxfLHgpLm5vcm1hbGl6ZSgpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCJUSFJFRS5GcnVzdHVtLnNldEZyb21Qcm9qZWN0aW9uTWF0cml4KCk6IEludmFsaWQgY29vcmRpbmF0ZSBzeXN0ZW06ICIrZSk7cmV0dXJuIHRoaXN9aW50ZXJzZWN0c09iamVjdCh0KXtpZih0LmJvdW5kaW5nU3BoZXJlIT09dm9pZCAwKXQuYm91bmRpbmdTcGhlcmU9PT1udWxsJiZ0LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpLGRpLmNvcHkodC5ib3VuZGluZ1NwaGVyZSkuYXBwbHlNYXRyaXg0KHQubWF0cml4V29ybGQpO2Vsc2V7bGV0IGU9dC5nZW9tZXRyeTtlLmJvdW5kaW5nU3BoZXJlPT09bnVsbCYmZS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKSxkaS5jb3B5KGUuYm91bmRpbmdTcGhlcmUpLmFwcGx5TWF0cml4NCh0Lm1hdHJpeFdvcmxkKX1yZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKGRpKX1pbnRlcnNlY3RzU3ByaXRlKHQpe3JldHVybiBkaS5jZW50ZXIuc2V0KDAsMCwwKSxkaS5yYWRpdXM9LjcwNzEwNjc4MTE4NjU0NzYsZGkuYXBwbHlNYXRyaXg0KHQubWF0cml4V29ybGQpLHRoaXMuaW50ZXJzZWN0c1NwaGVyZShkaSl9aW50ZXJzZWN0c1NwaGVyZSh0KXtsZXQgZT10aGlzLnBsYW5lcyxuPXQuY2VudGVyLGk9LXQucmFkaXVzO2ZvcihsZXQgcj0wO3I8NjtyKyspaWYoZVtyXS5kaXN0YW5jZVRvUG9pbnQobik8aSlyZXR1cm4hMTtyZXR1cm4hMH1pbnRlcnNlY3RzQm94KHQpe2xldCBlPXRoaXMucGxhbmVzO2ZvcihsZXQgbj0wO248NjtuKyspe2xldCBpPWVbbl07aWYoc2EueD1pLm5vcm1hbC54PjA/dC5tYXgueDp0Lm1pbi54LHNhLnk9aS5ub3JtYWwueT4wP3QubWF4Lnk6dC5taW4ueSxzYS56PWkubm9ybWFsLno+MD90Lm1heC56OnQubWluLnosaS5kaXN0YW5jZVRvUG9pbnQoc2EpPDApcmV0dXJuITF9cmV0dXJuITB9Y29udGFpbnNQb2ludCh0KXtsZXQgZT10aGlzLnBsYW5lcztmb3IobGV0IG49MDtuPDY7bisrKWlmKGVbbl0uZGlzdGFuY2VUb1BvaW50KHQpPDApcmV0dXJuITE7cmV0dXJuITB9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpfX07ZnVuY3Rpb24gamYoKXtsZXQgcz1udWxsLHQ9ITEsZT1udWxsLG49bnVsbDtmdW5jdGlvbiBpKHIsYSl7ZShyLGEpLG49cy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaSl9cmV0dXJue3N0YXJ0OmZ1bmN0aW9uKCl7dCE9PSEwJiZlIT09bnVsbCYmKG49cy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaSksdD0hMCl9LHN0b3A6ZnVuY3Rpb24oKXtzLmNhbmNlbEFuaW1hdGlvbkZyYW1lKG4pLHQ9ITF9LHNldEFuaW1hdGlvbkxvb3A6ZnVuY3Rpb24ocil7ZT1yfSxzZXRDb250ZXh0OmZ1bmN0aW9uKHIpe3M9cn19fWZ1bmN0aW9uIEhtKHMsdCl7bGV0IGU9dC5pc1dlYkdMMixuPW5ldyBXZWFrTWFwO2Z1bmN0aW9uIGkoYyxoKXtsZXQgdT1jLmFycmF5LGQ9Yy51c2FnZSxmPXUuYnl0ZUxlbmd0aCxtPXMuY3JlYXRlQnVmZmVyKCk7cy5iaW5kQnVmZmVyKGgsbSkscy5idWZmZXJEYXRhKGgsdSxkKSxjLm9uVXBsb2FkQ2FsbGJhY2soKTtsZXQgXztpZih1IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KV89cy5GTE9BVDtlbHNlIGlmKHUgaW5zdGFuY2VvZiBVaW50MTZBcnJheSlpZihjLmlzRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSlpZihlKV89cy5IQUxGX0ZMT0FUO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCJUSFJFRS5XZWJHTEF0dHJpYnV0ZXM6IFVzYWdlIG9mIEZsb2F0MTZCdWZmZXJBdHRyaWJ1dGUgcmVxdWlyZXMgV2ViR0wyLiIpO2Vsc2UgXz1zLlVOU0lHTkVEX1NIT1JUO2Vsc2UgaWYodSBpbnN0YW5jZW9mIEludDE2QXJyYXkpXz1zLlNIT1JUO2Vsc2UgaWYodSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KV89cy5VTlNJR05FRF9JTlQ7ZWxzZSBpZih1IGluc3RhbmNlb2YgSW50MzJBcnJheSlfPXMuSU5UO2Vsc2UgaWYodSBpbnN0YW5jZW9mIEludDhBcnJheSlfPXMuQllURTtlbHNlIGlmKHUgaW5zdGFuY2VvZiBVaW50OEFycmF5KV89cy5VTlNJR05FRF9CWVRFO2Vsc2UgaWYodSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KV89cy5VTlNJR05FRF9CWVRFO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCJUSFJFRS5XZWJHTEF0dHJpYnV0ZXM6IFVuc3VwcG9ydGVkIGJ1ZmZlciBkYXRhIGZvcm1hdDogIit1KTtyZXR1cm57YnVmZmVyOm0sdHlwZTpfLGJ5dGVzUGVyRWxlbWVudDp1LkJZVEVTX1BFUl9FTEVNRU5ULHZlcnNpb246Yy52ZXJzaW9uLHNpemU6Zn19ZnVuY3Rpb24gcihjLGgsdSl7bGV0IGQ9aC5hcnJheSxmPWguX3VwZGF0ZVJhbmdlLG09aC51cGRhdGVSYW5nZXM7aWYocy5iaW5kQnVmZmVyKHUsYyksZi5jb3VudD09PS0xJiZtLmxlbmd0aD09PTAmJnMuYnVmZmVyU3ViRGF0YSh1LDAsZCksbS5sZW5ndGghPT0wKXtmb3IobGV0IF89MCxnPW0ubGVuZ3RoO188ZztfKyspe2xldCBwPW1bX107ZT9zLmJ1ZmZlclN1YkRhdGEodSxwLnN0YXJ0KmQuQllURVNfUEVSX0VMRU1FTlQsZCxwLnN0YXJ0LHAuY291bnQpOnMuYnVmZmVyU3ViRGF0YSh1LHAuc3RhcnQqZC5CWVRFU19QRVJfRUxFTUVOVCxkLnN1YmFycmF5KHAuc3RhcnQscC5zdGFydCtwLmNvdW50KSl9aC5jbGVhclVwZGF0ZVJhbmdlcygpfWYuY291bnQhPT0tMSYmKGU/cy5idWZmZXJTdWJEYXRhKHUsZi5vZmZzZXQqZC5CWVRFU19QRVJfRUxFTUVOVCxkLGYub2Zmc2V0LGYuY291bnQpOnMuYnVmZmVyU3ViRGF0YSh1LGYub2Zmc2V0KmQuQllURVNfUEVSX0VMRU1FTlQsZC5zdWJhcnJheShmLm9mZnNldCxmLm9mZnNldCtmLmNvdW50KSksZi5jb3VudD0tMSksaC5vblVwbG9hZENhbGxiYWNrKCl9ZnVuY3Rpb24gYShjKXtyZXR1cm4gYy5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlJiYoYz1jLmRhdGEpLG4uZ2V0KGMpfWZ1bmN0aW9uIG8oYyl7Yy5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlJiYoYz1jLmRhdGEpO2xldCBoPW4uZ2V0KGMpO2gmJihzLmRlbGV0ZUJ1ZmZlcihoLmJ1ZmZlciksbi5kZWxldGUoYykpfWZ1bmN0aW9uIGwoYyxoKXtpZihjLmlzR0xCdWZmZXJBdHRyaWJ1dGUpe2xldCBkPW4uZ2V0KGMpOyghZHx8ZC52ZXJzaW9uPGMudmVyc2lvbikmJm4uc2V0KGMse2J1ZmZlcjpjLmJ1ZmZlcix0eXBlOmMudHlwZSxieXRlc1BlckVsZW1lbnQ6Yy5lbGVtZW50U2l6ZSx2ZXJzaW9uOmMudmVyc2lvbn0pO3JldHVybn1jLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUmJihjPWMuZGF0YSk7bGV0IHU9bi5nZXQoYyk7aWYodT09PXZvaWQgMCluLnNldChjLGkoYyxoKSk7ZWxzZSBpZih1LnZlcnNpb248Yy52ZXJzaW9uKXtpZih1LnNpemUhPT1jLmFycmF5LmJ5dGVMZW5ndGgpdGhyb3cgbmV3IEVycm9yKCJUSFJFRS5XZWJHTEF0dHJpYnV0ZXM6IFRoZSBzaXplIG9mIHRoZSBidWZmZXIgYXR0cmlidXRlJ3MgYXJyYXkgYnVmZmVyIGRvZXMgbm90IG1hdGNoIHRoZSBvcmlnaW5hbCBzaXplLiBSZXNpemluZyBidWZmZXIgYXR0cmlidXRlcyBpcyBub3Qgc3VwcG9ydGVkLiIpO3IodS5idWZmZXIsYyxoKSx1LnZlcnNpb249Yy52ZXJzaW9ufX1yZXR1cm57Z2V0OmEscmVtb3ZlOm8sdXBkYXRlOmx9fXZhciB5cz1jbGFzcyBzIGV4dGVuZHMgSHR7Y29uc3RydWN0b3IodD0xLGU9MSxuPTEsaT0xKXtzdXBlcigpLHRoaXMudHlwZT0iUGxhbmVHZW9tZXRyeSIsdGhpcy5wYXJhbWV0ZXJzPXt3aWR0aDp0LGhlaWdodDplLHdpZHRoU2VnbWVudHM6bixoZWlnaHRTZWdtZW50czppfTtsZXQgcj10LzIsYT1lLzIsbz1NYXRoLmZsb29yKG4pLGw9TWF0aC5mbG9vcihpKSxjPW8rMSxoPWwrMSx1PXQvbyxkPWUvbCxmPVtdLG09W10sXz1bXSxnPVtdO2ZvcihsZXQgcD0wO3A8aDtwKyspe2xldCB2PXAqZC1hO2ZvcihsZXQgeD0wO3g8Yzt4Kyspe2xldCBNPXgqdS1yO20ucHVzaChNLC12LDApLF8ucHVzaCgwLDAsMSksZy5wdXNoKHgvbyksZy5wdXNoKDEtcC9sKX19Zm9yKGxldCBwPTA7cDxsO3ArKylmb3IobGV0IHY9MDt2PG87disrKXtsZXQgeD12K2MqcCxNPXYrYyoocCsxKSxDPXYrMStjKihwKzEpLEE9disxK2MqcDtmLnB1c2goeCxNLEEpLGYucHVzaChNLEMsQSl9dGhpcy5zZXRJbmRleChmKSx0aGlzLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBndChtLDMpKSx0aGlzLnNldEF0dHJpYnV0ZSgibm9ybWFsIixuZXcgZ3QoXywzKSksdGhpcy5zZXRBdHRyaWJ1dGUoInV2IixuZXcgZ3QoZywyKSl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLnBhcmFtZXRlcnM9T2JqZWN0LmFzc2lnbih7fSx0LnBhcmFtZXRlcnMpLHRoaXN9c3RhdGljIGZyb21KU09OKHQpe3JldHVybiBuZXcgcyh0LndpZHRoLHQuaGVpZ2h0LHQud2lkdGhTZWdtZW50cyx0LmhlaWdodFNlZ21lbnRzKX19LEdtPWAjaWZkZWYgVVNFX0FMUEhBSEFTSAoJaWYgKCBkaWZmdXNlQ29sb3IuYSA8IGdldEFscGhhSGFzaFRocmVzaG9sZCggdlBvc2l0aW9uICkgKSBkaXNjYXJkOwojZW5kaWZgLFdtPWAjaWZkZWYgVVNFX0FMUEhBSEFTSAoJY29uc3QgZmxvYXQgQUxQSEFfSEFTSF9TQ0FMRSA9IDAuMDU7CglmbG9hdCBoYXNoMkQoIHZlYzIgdmFsdWUgKSB7CgkJcmV0dXJuIGZyYWN0KCAxLjBlNCAqIHNpbiggMTcuMCAqIHZhbHVlLnggKyAwLjEgKiB2YWx1ZS55ICkgKiAoIDAuMSArIGFicyggc2luKCAxMy4wICogdmFsdWUueSArIHZhbHVlLnggKSApICkgKTsKCX0KCWZsb2F0IGhhc2gzRCggdmVjMyB2YWx1ZSApIHsKCQlyZXR1cm4gaGFzaDJEKCB2ZWMyKCBoYXNoMkQoIHZhbHVlLnh5ICksIHZhbHVlLnogKSApOwoJfQoJZmxvYXQgZ2V0QWxwaGFIYXNoVGhyZXNob2xkKCB2ZWMzIHBvc2l0aW9uICkgewoJCWZsb2F0IG1heERlcml2ID0gbWF4KAoJCQlsZW5ndGgoIGRGZHgoIHBvc2l0aW9uLnh5eiApICksCgkJCWxlbmd0aCggZEZkeSggcG9zaXRpb24ueHl6ICkgKQoJCSk7CgkJZmxvYXQgcGl4U2NhbGUgPSAxLjAgLyAoIEFMUEhBX0hBU0hfU0NBTEUgKiBtYXhEZXJpdiApOwoJCXZlYzIgcGl4U2NhbGVzID0gdmVjMigKCQkJZXhwMiggZmxvb3IoIGxvZzIoIHBpeFNjYWxlICkgKSApLAoJCQlleHAyKCBjZWlsKCBsb2cyKCBwaXhTY2FsZSApICkgKQoJCSk7CgkJdmVjMiBhbHBoYSA9IHZlYzIoCgkJCWhhc2gzRCggZmxvb3IoIHBpeFNjYWxlcy54ICogcG9zaXRpb24ueHl6ICkgKSwKCQkJaGFzaDNEKCBmbG9vciggcGl4U2NhbGVzLnkgKiBwb3NpdGlvbi54eXogKSApCgkJKTsKCQlmbG9hdCBsZXJwRmFjdG9yID0gZnJhY3QoIGxvZzIoIHBpeFNjYWxlICkgKTsKCQlmbG9hdCB4ID0gKCAxLjAgLSBsZXJwRmFjdG9yICkgKiBhbHBoYS54ICsgbGVycEZhY3RvciAqIGFscGhhLnk7CgkJZmxvYXQgYSA9IG1pbiggbGVycEZhY3RvciwgMS4wIC0gbGVycEZhY3RvciApOwoJCXZlYzMgY2FzZXMgPSB2ZWMzKAoJCQl4ICogeCAvICggMi4wICogYSAqICggMS4wIC0gYSApICksCgkJCSggeCAtIDAuNSAqIGEgKSAvICggMS4wIC0gYSApLAoJCQkxLjAgLSAoICggMS4wIC0geCApICogKCAxLjAgLSB4ICkgLyAoIDIuMCAqIGEgKiAoIDEuMCAtIGEgKSApICkKCQkpOwoJCWZsb2F0IHRocmVzaG9sZCA9ICggeCA8ICggMS4wIC0gYSApICkKCQkJPyAoICggeCA8IGEgKSA/IGNhc2VzLnggOiBjYXNlcy55ICkKCQkJOiBjYXNlcy56OwoJCXJldHVybiBjbGFtcCggdGhyZXNob2xkICwgMS4wZS02LCAxLjAgKTsKCX0KI2VuZGlmYCxYbT1gI2lmZGVmIFVTRV9BTFBIQU1BUAoJZGlmZnVzZUNvbG9yLmEgKj0gdGV4dHVyZTJEKCBhbHBoYU1hcCwgdkFscGhhTWFwVXYgKS5nOwojZW5kaWZgLHFtPWAjaWZkZWYgVVNFX0FMUEhBTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBhbHBoYU1hcDsKI2VuZGlmYCxZbT1gI2lmZGVmIFVTRV9BTFBIQVRFU1QKCSNpZmRlZiBBTFBIQV9UT19DT1ZFUkFHRQoJZGlmZnVzZUNvbG9yLmEgPSBzbW9vdGhzdGVwKCBhbHBoYVRlc3QsIGFscGhhVGVzdCArIGZ3aWR0aCggZGlmZnVzZUNvbG9yLmEgKSwgZGlmZnVzZUNvbG9yLmEgKTsKCWlmICggZGlmZnVzZUNvbG9yLmEgPT0gMC4wICkgZGlzY2FyZDsKCSNlbHNlCglpZiAoIGRpZmZ1c2VDb2xvci5hIDwgYWxwaGFUZXN0ICkgZGlzY2FyZDsKCSNlbmRpZgojZW5kaWZgLFptPWAjaWZkZWYgVVNFX0FMUEhBVEVTVAoJdW5pZm9ybSBmbG9hdCBhbHBoYVRlc3Q7CiNlbmRpZmAsSm09YCNpZmRlZiBVU0VfQU9NQVAKCWZsb2F0IGFtYmllbnRPY2NsdXNpb24gPSAoIHRleHR1cmUyRCggYW9NYXAsIHZBb01hcFV2ICkuciAtIDEuMCApICogYW9NYXBJbnRlbnNpdHkgKyAxLjA7CglyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKj0gYW1iaWVudE9jY2x1c2lvbjsKCSNpZiBkZWZpbmVkKCBVU0VfQ0xFQVJDT0FUICkgCgkJY2xlYXJjb2F0U3BlY3VsYXJJbmRpcmVjdCAqPSBhbWJpZW50T2NjbHVzaW9uOwoJI2VuZGlmCgkjaWYgZGVmaW5lZCggVVNFX1NIRUVOICkgCgkJc2hlZW5TcGVjdWxhckluZGlyZWN0ICo9IGFtYmllbnRPY2NsdXNpb247CgkjZW5kaWYKCSNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggU1RBTkRBUkQgKQoJCWZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnlOb3JtYWwsIGdlb21ldHJ5Vmlld0RpciApICk7CgkJcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciAqPSBjb21wdXRlU3BlY3VsYXJPY2NsdXNpb24oIGRvdE5WLCBhbWJpZW50T2NjbHVzaW9uLCBtYXRlcmlhbC5yb3VnaG5lc3MgKTsKCSNlbmRpZgojZW5kaWZgLCRtPWAjaWZkZWYgVVNFX0FPTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBhb01hcDsKCXVuaWZvcm0gZmxvYXQgYW9NYXBJbnRlbnNpdHk7CiNlbmRpZmAsS209YCNpZmRlZiBVU0VfQkFUQ0hJTkcKCWF0dHJpYnV0ZSBmbG9hdCBiYXRjaElkOwoJdW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgYmF0Y2hpbmdUZXh0dXJlOwoJbWF0NCBnZXRCYXRjaGluZ01hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHsKCQlpbnQgc2l6ZSA9IHRleHR1cmVTaXplKCBiYXRjaGluZ1RleHR1cmUsIDAgKS54OwoJCWludCBqID0gaW50KCBpICkgKiA0OwoJCWludCB4ID0gaiAlIHNpemU7CgkJaW50IHkgPSBqIC8gc2l6ZTsKCQl2ZWM0IHYxID0gdGV4ZWxGZXRjaCggYmF0Y2hpbmdUZXh0dXJlLCBpdmVjMiggeCwgeSApLCAwICk7CgkJdmVjNCB2MiA9IHRleGVsRmV0Y2goIGJhdGNoaW5nVGV4dHVyZSwgaXZlYzIoIHggKyAxLCB5ICksIDAgKTsKCQl2ZWM0IHYzID0gdGV4ZWxGZXRjaCggYmF0Y2hpbmdUZXh0dXJlLCBpdmVjMiggeCArIDIsIHkgKSwgMCApOwoJCXZlYzQgdjQgPSB0ZXhlbEZldGNoKCBiYXRjaGluZ1RleHR1cmUsIGl2ZWMyKCB4ICsgMywgeSApLCAwICk7CgkJcmV0dXJuIG1hdDQoIHYxLCB2MiwgdjMsIHY0ICk7Cgl9CiNlbmRpZmAsUW09YCNpZmRlZiBVU0VfQkFUQ0hJTkcKCW1hdDQgYmF0Y2hpbmdNYXRyaXggPSBnZXRCYXRjaGluZ01hdHJpeCggYmF0Y2hJZCApOwojZW5kaWZgLGptPWB2ZWMzIHRyYW5zZm9ybWVkID0gdmVjMyggcG9zaXRpb24gKTsKI2lmZGVmIFVTRV9BTFBIQUhBU0gKCXZQb3NpdGlvbiA9IHZlYzMoIHBvc2l0aW9uICk7CiNlbmRpZmAsdGc9YHZlYzMgb2JqZWN0Tm9ybWFsID0gdmVjMyggbm9ybWFsICk7CiNpZmRlZiBVU0VfVEFOR0VOVAoJdmVjMyBvYmplY3RUYW5nZW50ID0gdmVjMyggdGFuZ2VudC54eXogKTsKI2VuZGlmYCxlZz1gZmxvYXQgR19CbGlublBob25nX0ltcGxpY2l0KCApIHsKCXJldHVybiAwLjI1Owp9CmZsb2F0IERfQmxpbm5QaG9uZyggY29uc3QgaW4gZmxvYXQgc2hpbmluZXNzLCBjb25zdCBpbiBmbG9hdCBkb3ROSCApIHsKCXJldHVybiBSRUNJUFJPQ0FMX1BJICogKCBzaGluaW5lc3MgKiAwLjUgKyAxLjAgKSAqIHBvdyggZG90TkgsIHNoaW5pbmVzcyApOwp9CnZlYzMgQlJERl9CbGlublBob25nKCBjb25zdCBpbiB2ZWMzIGxpZ2h0RGlyLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNoaW5pbmVzcyApIHsKCXZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7CglmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgaGFsZkRpciApICk7CglmbG9hdCBkb3RWSCA9IHNhdHVyYXRlKCBkb3QoIHZpZXdEaXIsIGhhbGZEaXIgKSApOwoJdmVjMyBGID0gRl9TY2hsaWNrKCBzcGVjdWxhckNvbG9yLCAxLjAsIGRvdFZIICk7CglmbG9hdCBHID0gR19CbGlublBob25nX0ltcGxpY2l0KCApOwoJZmxvYXQgRCA9IERfQmxpbm5QaG9uZyggc2hpbmluZXNzLCBkb3ROSCApOwoJcmV0dXJuIEYgKiAoIEcgKiBEICk7Cn0gLy8gdmFsaWRhdGVkYCxuZz1gI2lmZGVmIFVTRV9JUklERVNDRU5DRQoJY29uc3QgbWF0MyBYWVpfVE9fUkVDNzA5ID0gbWF0MygKCQkgMy4yNDA0NTQyLCAtMC45NjkyNjYwLCAgMC4wNTU2NDM0LAoJCS0xLjUzNzEzODUsICAxLjg3NjAxMDgsIC0wLjIwNDAyNTksCgkJLTAuNDk4NTMxNCwgIDAuMDQxNTU2MCwgIDEuMDU3MjI1MgoJKTsKCXZlYzMgRnJlc25lbDBUb0lvciggdmVjMyBmcmVzbmVsMCApIHsKCQl2ZWMzIHNxcnRGMCA9IHNxcnQoIGZyZXNuZWwwICk7CgkJcmV0dXJuICggdmVjMyggMS4wICkgKyBzcXJ0RjAgKSAvICggdmVjMyggMS4wICkgLSBzcXJ0RjAgKTsKCX0KCXZlYzMgSW9yVG9GcmVzbmVsMCggdmVjMyB0cmFuc21pdHRlZElvciwgZmxvYXQgaW5jaWRlbnRJb3IgKSB7CgkJcmV0dXJuIHBvdzIoICggdHJhbnNtaXR0ZWRJb3IgLSB2ZWMzKCBpbmNpZGVudElvciApICkgLyAoIHRyYW5zbWl0dGVkSW9yICsgdmVjMyggaW5jaWRlbnRJb3IgKSApICk7Cgl9CglmbG9hdCBJb3JUb0ZyZXNuZWwwKCBmbG9hdCB0cmFuc21pdHRlZElvciwgZmxvYXQgaW5jaWRlbnRJb3IgKSB7CgkJcmV0dXJuIHBvdzIoICggdHJhbnNtaXR0ZWRJb3IgLSBpbmNpZGVudElvciApIC8gKCB0cmFuc21pdHRlZElvciArIGluY2lkZW50SW9yICkpOwoJfQoJdmVjMyBldmFsU2Vuc2l0aXZpdHkoIGZsb2F0IE9QRCwgdmVjMyBzaGlmdCApIHsKCQlmbG9hdCBwaGFzZSA9IDIuMCAqIFBJICogT1BEICogMS4wZS05OwoJCXZlYzMgdmFsID0gdmVjMyggNS40ODU2ZS0xMywgNC40MjAxZS0xMywgNS4yNDgxZS0xMyApOwoJCXZlYzMgcG9zID0gdmVjMyggMS42ODEwZSswNiwgMS43OTUzZSswNiwgMi4yMDg0ZSswNiApOwoJCXZlYzMgdmFyID0gdmVjMyggNC4zMjc4ZSswOSwgOS4zMDQ2ZSswOSwgNi42MTIxZSswOSApOwoJCXZlYzMgeHl6ID0gdmFsICogc3FydCggMi4wICogUEkgKiB2YXIgKSAqIGNvcyggcG9zICogcGhhc2UgKyBzaGlmdCApICogZXhwKCAtIHBvdzIoIHBoYXNlICkgKiB2YXIgKTsKCQl4eXoueCArPSA5Ljc0NzBlLTE0ICogc3FydCggMi4wICogUEkgKiA0LjUyODJlKzA5ICkgKiBjb3MoIDIuMjM5OWUrMDYgKiBwaGFzZSArIHNoaWZ0WyAwIF0gKSAqIGV4cCggLSA0LjUyODJlKzA5ICogcG93MiggcGhhc2UgKSApOwoJCXh5eiAvPSAxLjA2ODVlLTc7CgkJdmVjMyByZ2IgPSBYWVpfVE9fUkVDNzA5ICogeHl6OwoJCXJldHVybiByZ2I7Cgl9Cgl2ZWMzIGV2YWxJcmlkZXNjZW5jZSggZmxvYXQgb3V0c2lkZUlPUiwgZmxvYXQgZXRhMiwgZmxvYXQgY29zVGhldGExLCBmbG9hdCB0aGluRmlsbVRoaWNrbmVzcywgdmVjMyBiYXNlRjAgKSB7CgkJdmVjMyBJOwoJCWZsb2F0IGlyaWRlc2NlbmNlSU9SID0gbWl4KCBvdXRzaWRlSU9SLCBldGEyLCBzbW9vdGhzdGVwKCAwLjAsIDAuMDMsIHRoaW5GaWxtVGhpY2tuZXNzICkgKTsKCQlmbG9hdCBzaW5UaGV0YTJTcSA9IHBvdzIoIG91dHNpZGVJT1IgLyBpcmlkZXNjZW5jZUlPUiApICogKCAxLjAgLSBwb3cyKCBjb3NUaGV0YTEgKSApOwoJCWZsb2F0IGNvc1RoZXRhMlNxID0gMS4wIC0gc2luVGhldGEyU3E7CgkJaWYgKCBjb3NUaGV0YTJTcSA8IDAuMCApIHsKCQkJcmV0dXJuIHZlYzMoIDEuMCApOwoJCX0KCQlmbG9hdCBjb3NUaGV0YTIgPSBzcXJ0KCBjb3NUaGV0YTJTcSApOwoJCWZsb2F0IFIwID0gSW9yVG9GcmVzbmVsMCggaXJpZGVzY2VuY2VJT1IsIG91dHNpZGVJT1IgKTsKCQlmbG9hdCBSMTIgPSBGX1NjaGxpY2soIFIwLCAxLjAsIGNvc1RoZXRhMSApOwoJCWZsb2F0IFQxMjEgPSAxLjAgLSBSMTI7CgkJZmxvYXQgcGhpMTIgPSAwLjA7CgkJaWYgKCBpcmlkZXNjZW5jZUlPUiA8IG91dHNpZGVJT1IgKSBwaGkxMiA9IFBJOwoJCWZsb2F0IHBoaTIxID0gUEkgLSBwaGkxMjsKCQl2ZWMzIGJhc2VJT1IgPSBGcmVzbmVsMFRvSW9yKCBjbGFtcCggYmFzZUYwLCAwLjAsIDAuOTk5OSApICk7CQl2ZWMzIFIxID0gSW9yVG9GcmVzbmVsMCggYmFzZUlPUiwgaXJpZGVzY2VuY2VJT1IgKTsKCQl2ZWMzIFIyMyA9IEZfU2NobGljayggUjEsIDEuMCwgY29zVGhldGEyICk7CgkJdmVjMyBwaGkyMyA9IHZlYzMoIDAuMCApOwoJCWlmICggYmFzZUlPUlsgMCBdIDwgaXJpZGVzY2VuY2VJT1IgKSBwaGkyM1sgMCBdID0gUEk7CgkJaWYgKCBiYXNlSU9SWyAxIF0gPCBpcmlkZXNjZW5jZUlPUiApIHBoaTIzWyAxIF0gPSBQSTsKCQlpZiAoIGJhc2VJT1JbIDIgXSA8IGlyaWRlc2NlbmNlSU9SICkgcGhpMjNbIDIgXSA9IFBJOwoJCWZsb2F0IE9QRCA9IDIuMCAqIGlyaWRlc2NlbmNlSU9SICogdGhpbkZpbG1UaGlja25lc3MgKiBjb3NUaGV0YTI7CgkJdmVjMyBwaGkgPSB2ZWMzKCBwaGkyMSApICsgcGhpMjM7CgkJdmVjMyBSMTIzID0gY2xhbXAoIFIxMiAqIFIyMywgMWUtNSwgMC45OTk5ICk7CgkJdmVjMyByMTIzID0gc3FydCggUjEyMyApOwoJCXZlYzMgUnMgPSBwb3cyKCBUMTIxICkgKiBSMjMgLyAoIHZlYzMoIDEuMCApIC0gUjEyMyApOwoJCXZlYzMgQzAgPSBSMTIgKyBSczsKCQlJID0gQzA7CgkJdmVjMyBDbSA9IFJzIC0gVDEyMTsKCQlmb3IgKCBpbnQgbSA9IDE7IG0gPD0gMjsgKysgbSApIHsKCQkJQ20gKj0gcjEyMzsKCQkJdmVjMyBTbSA9IDIuMCAqIGV2YWxTZW5zaXRpdml0eSggZmxvYXQoIG0gKSAqIE9QRCwgZmxvYXQoIG0gKSAqIHBoaSApOwoJCQlJICs9IENtICogU207CgkJfQoJCXJldHVybiBtYXgoIEksIHZlYzMoIDAuMCApICk7Cgl9CiNlbmRpZmAsaWc9YCNpZmRlZiBVU0VfQlVNUE1BUAoJdW5pZm9ybSBzYW1wbGVyMkQgYnVtcE1hcDsKCXVuaWZvcm0gZmxvYXQgYnVtcFNjYWxlOwoJdmVjMiBkSGR4eV9md2QoKSB7CgkJdmVjMiBkU1RkeCA9IGRGZHgoIHZCdW1wTWFwVXYgKTsKCQl2ZWMyIGRTVGR5ID0gZEZkeSggdkJ1bXBNYXBVdiApOwoJCWZsb2F0IEhsbCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdkJ1bXBNYXBVdiApLng7CgkJZmxvYXQgZEJ4ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2QnVtcE1hcFV2ICsgZFNUZHggKS54IC0gSGxsOwoJCWZsb2F0IGRCeSA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdkJ1bXBNYXBVdiArIGRTVGR5ICkueCAtIEhsbDsKCQlyZXR1cm4gdmVjMiggZEJ4LCBkQnkgKTsKCX0KCXZlYzMgcGVydHVyYk5vcm1hbEFyYiggdmVjMyBzdXJmX3BvcywgdmVjMyBzdXJmX25vcm0sIHZlYzIgZEhkeHksIGZsb2F0IGZhY2VEaXJlY3Rpb24gKSB7CgkJdmVjMyB2U2lnbWFYID0gbm9ybWFsaXplKCBkRmR4KCBzdXJmX3Bvcy54eXogKSApOwoJCXZlYzMgdlNpZ21hWSA9IG5vcm1hbGl6ZSggZEZkeSggc3VyZl9wb3MueHl6ICkgKTsKCQl2ZWMzIHZOID0gc3VyZl9ub3JtOwoJCXZlYzMgUjEgPSBjcm9zcyggdlNpZ21hWSwgdk4gKTsKCQl2ZWMzIFIyID0gY3Jvc3MoIHZOLCB2U2lnbWFYICk7CgkJZmxvYXQgZkRldCA9IGRvdCggdlNpZ21hWCwgUjEgKSAqIGZhY2VEaXJlY3Rpb247CgkJdmVjMyB2R3JhZCA9IHNpZ24oIGZEZXQgKSAqICggZEhkeHkueCAqIFIxICsgZEhkeHkueSAqIFIyICk7CgkJcmV0dXJuIG5vcm1hbGl6ZSggYWJzKCBmRGV0ICkgKiBzdXJmX25vcm0gLSB2R3JhZCApOwoJfQojZW5kaWZgLHNnPWAjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDAKCXZlYzQgcGxhbmU7CgkjaWZkZWYgQUxQSEFfVE9fQ09WRVJBR0UKCQlmbG9hdCBkaXN0YW5jZVRvUGxhbmUsIGRpc3RhbmNlR3JhZGllbnQ7CgkJZmxvYXQgY2xpcE9wYWNpdHkgPSAxLjA7CgkJI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydAoJCWZvciAoIGludCBpID0gMDsgaSA8IFVOSU9OX0NMSVBQSU5HX1BMQU5FUzsgaSArKyApIHsKCQkJcGxhbmUgPSBjbGlwcGluZ1BsYW5lc1sgaSBdOwoJCQlkaXN0YW5jZVRvUGxhbmUgPSAtIGRvdCggdkNsaXBQb3NpdGlvbiwgcGxhbmUueHl6ICkgKyBwbGFuZS53OwoJCQlkaXN0YW5jZUdyYWRpZW50ID0gZndpZHRoKCBkaXN0YW5jZVRvUGxhbmUgKSAvIDIuMDsKCQkJY2xpcE9wYWNpdHkgKj0gc21vb3Roc3RlcCggLSBkaXN0YW5jZUdyYWRpZW50LCBkaXN0YW5jZUdyYWRpZW50LCBkaXN0YW5jZVRvUGxhbmUgKTsKCQkJaWYgKCBjbGlwT3BhY2l0eSA9PSAwLjAgKSBkaXNjYXJkOwoJCX0KCQkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAoJCSNpZiBVTklPTl9DTElQUElOR19QTEFORVMgPCBOVU1fQ0xJUFBJTkdfUExBTkVTCgkJCWZsb2F0IHVuaW9uQ2xpcE9wYWNpdHkgPSAxLjA7CgkJCSNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnQKCQkJZm9yICggaW50IGkgPSBVTklPTl9DTElQUElOR19QTEFORVM7IGkgPCBOVU1fQ0xJUFBJTkdfUExBTkVTOyBpICsrICkgewoJCQkJcGxhbmUgPSBjbGlwcGluZ1BsYW5lc1sgaSBdOwoJCQkJZGlzdGFuY2VUb1BsYW5lID0gLSBkb3QoIHZDbGlwUG9zaXRpb24sIHBsYW5lLnh5eiApICsgcGxhbmUudzsKCQkJCWRpc3RhbmNlR3JhZGllbnQgPSBmd2lkdGgoIGRpc3RhbmNlVG9QbGFuZSApIC8gMi4wOwoJCQkJdW5pb25DbGlwT3BhY2l0eSAqPSAxLjAgLSBzbW9vdGhzdGVwKCAtIGRpc3RhbmNlR3JhZGllbnQsIGRpc3RhbmNlR3JhZGllbnQsIGRpc3RhbmNlVG9QbGFuZSApOwoJCQl9CgkJCSNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kCgkJCWNsaXBPcGFjaXR5ICo9IDEuMCAtIHVuaW9uQ2xpcE9wYWNpdHk7CgkJI2VuZGlmCgkJZGlmZnVzZUNvbG9yLmEgKj0gY2xpcE9wYWNpdHk7CgkJaWYgKCBkaWZmdXNlQ29sb3IuYSA9PSAwLjAgKSBkaXNjYXJkOwoJI2Vsc2UKCQkjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0CgkJZm9yICggaW50IGkgPSAwOyBpIDwgVU5JT05fQ0xJUFBJTkdfUExBTkVTOyBpICsrICkgewoJCQlwbGFuZSA9IGNsaXBwaW5nUGxhbmVzWyBpIF07CgkJCWlmICggZG90KCB2Q2xpcFBvc2l0aW9uLCBwbGFuZS54eXogKSA+IHBsYW5lLncgKSBkaXNjYXJkOwoJCX0KCQkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAoJCSNpZiBVTklPTl9DTElQUElOR19QTEFORVMgPCBOVU1fQ0xJUFBJTkdfUExBTkVTCgkJCWJvb2wgY2xpcHBlZCA9IHRydWU7CgkJCSNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnQKCQkJZm9yICggaW50IGkgPSBVTklPTl9DTElQUElOR19QTEFORVM7IGkgPCBOVU1fQ0xJUFBJTkdfUExBTkVTOyBpICsrICkgewoJCQkJcGxhbmUgPSBjbGlwcGluZ1BsYW5lc1sgaSBdOwoJCQkJY2xpcHBlZCA9ICggZG90KCB2Q2xpcFBvc2l0aW9uLCBwbGFuZS54eXogKSA+IHBsYW5lLncgKSAmJiBjbGlwcGVkOwoJCQl9CgkJCSNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kCgkJCWlmICggY2xpcHBlZCApIGRpc2NhcmQ7CgkJI2VuZGlmCgkjZW5kaWYKI2VuZGlmYCxyZz1gI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwCgl2YXJ5aW5nIHZlYzMgdkNsaXBQb3NpdGlvbjsKCXVuaWZvcm0gdmVjNCBjbGlwcGluZ1BsYW5lc1sgTlVNX0NMSVBQSU5HX1BMQU5FUyBdOwojZW5kaWZgLGFnPWAjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDAKCXZhcnlpbmcgdmVjMyB2Q2xpcFBvc2l0aW9uOwojZW5kaWZgLG9nPWAjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDAKCXZDbGlwUG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6OwojZW5kaWZgLGxnPWAjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBICkKCWRpZmZ1c2VDb2xvciAqPSB2Q29sb3I7CiNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApCglkaWZmdXNlQ29sb3IucmdiICo9IHZDb2xvcjsKI2VuZGlmYCxjZz1gI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApCgl2YXJ5aW5nIHZlYzQgdkNvbG9yOwojZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKQoJdmFyeWluZyB2ZWMzIHZDb2xvcjsKI2VuZGlmYCxoZz1gI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApCgl2YXJ5aW5nIHZlYzQgdkNvbG9yOwojZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKSB8fCBkZWZpbmVkKCBVU0VfSU5TVEFOQ0lOR19DT0xPUiApCgl2YXJ5aW5nIHZlYzMgdkNvbG9yOwojZW5kaWZgLHVnPWAjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBICkKCXZDb2xvciA9IHZlYzQoIDEuMCApOwojZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKSB8fCBkZWZpbmVkKCBVU0VfSU5TVEFOQ0lOR19DT0xPUiApCgl2Q29sb3IgPSB2ZWMzKCAxLjAgKTsKI2VuZGlmCiNpZmRlZiBVU0VfQ09MT1IKCXZDb2xvciAqPSBjb2xvcjsKI2VuZGlmCiNpZmRlZiBVU0VfSU5TVEFOQ0lOR19DT0xPUgoJdkNvbG9yLnh5eiAqPSBpbnN0YW5jZUNvbG9yLnh5ejsKI2VuZGlmYCxkZz1gI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU4OTc5MwojZGVmaW5lIFBJMiA2LjI4MzE4NTMwNzE3OTU4NgojZGVmaW5lIFBJX0hBTEYgMS41NzA3OTYzMjY3OTQ4OTY2CiNkZWZpbmUgUkVDSVBST0NBTF9QSSAwLjMxODMwOTg4NjE4Mzc5MDcKI2RlZmluZSBSRUNJUFJPQ0FMX1BJMiAwLjE1OTE1NDk0MzA5MTg5NTM1CiNkZWZpbmUgRVBTSUxPTiAxZS02CiNpZm5kZWYgc2F0dXJhdGUKI2RlZmluZSBzYXR1cmF0ZSggYSApIGNsYW1wKCBhLCAwLjAsIDEuMCApCiNlbmRpZgojZGVmaW5lIHdoaXRlQ29tcGxlbWVudCggYSApICggMS4wIC0gc2F0dXJhdGUoIGEgKSApCmZsb2F0IHBvdzIoIGNvbnN0IGluIGZsb2F0IHggKSB7IHJldHVybiB4Kng7IH0KdmVjMyBwb3cyKCBjb25zdCBpbiB2ZWMzIHggKSB7IHJldHVybiB4Kng7IH0KZmxvYXQgcG93MyggY29uc3QgaW4gZmxvYXQgeCApIHsgcmV0dXJuIHgqeCp4OyB9CmZsb2F0IHBvdzQoIGNvbnN0IGluIGZsb2F0IHggKSB7IGZsb2F0IHgyID0geCp4OyByZXR1cm4geDIqeDI7IH0KZmxvYXQgbWF4MyggY29uc3QgaW4gdmVjMyB2ICkgeyByZXR1cm4gbWF4KCBtYXgoIHYueCwgdi55ICksIHYueiApOyB9CmZsb2F0IGF2ZXJhZ2UoIGNvbnN0IGluIHZlYzMgdiApIHsgcmV0dXJuIGRvdCggdiwgdmVjMyggMC4zMzMzMzMzICkgKTsgfQpoaWdocCBmbG9hdCByYW5kKCBjb25zdCBpbiB2ZWMyIHV2ICkgewoJY29uc3QgaGlnaHAgZmxvYXQgYSA9IDEyLjk4OTgsIGIgPSA3OC4yMzMsIGMgPSA0Mzc1OC41NDUzOwoJaGlnaHAgZmxvYXQgZHQgPSBkb3QoIHV2Lnh5LCB2ZWMyKCBhLGIgKSApLCBzbiA9IG1vZCggZHQsIFBJICk7CglyZXR1cm4gZnJhY3QoIHNpbiggc24gKSAqIGMgKTsKfQojaWZkZWYgSElHSF9QUkVDSVNJT04KCWZsb2F0IHByZWNpc2lvblNhZmVMZW5ndGgoIHZlYzMgdiApIHsgcmV0dXJuIGxlbmd0aCggdiApOyB9CiNlbHNlCglmbG9hdCBwcmVjaXNpb25TYWZlTGVuZ3RoKCB2ZWMzIHYgKSB7CgkJZmxvYXQgbWF4Q29tcG9uZW50ID0gbWF4MyggYWJzKCB2ICkgKTsKCQlyZXR1cm4gbGVuZ3RoKCB2IC8gbWF4Q29tcG9uZW50ICkgKiBtYXhDb21wb25lbnQ7Cgl9CiNlbmRpZgpzdHJ1Y3QgSW5jaWRlbnRMaWdodCB7Cgl2ZWMzIGNvbG9yOwoJdmVjMyBkaXJlY3Rpb247Cglib29sIHZpc2libGU7Cn07CnN0cnVjdCBSZWZsZWN0ZWRMaWdodCB7Cgl2ZWMzIGRpcmVjdERpZmZ1c2U7Cgl2ZWMzIGRpcmVjdFNwZWN1bGFyOwoJdmVjMyBpbmRpcmVjdERpZmZ1c2U7Cgl2ZWMzIGluZGlyZWN0U3BlY3VsYXI7Cn07CiNpZmRlZiBVU0VfQUxQSEFIQVNICgl2YXJ5aW5nIHZlYzMgdlBvc2l0aW9uOwojZW5kaWYKdmVjMyB0cmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHsKCXJldHVybiBub3JtYWxpemUoICggbWF0cml4ICogdmVjNCggZGlyLCAwLjAgKSApLnh5eiApOwp9CnZlYzMgaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBkaXIsIGluIG1hdDQgbWF0cml4ICkgewoJcmV0dXJuIG5vcm1hbGl6ZSggKCB2ZWM0KCBkaXIsIDAuMCApICogbWF0cml4ICkueHl6ICk7Cn0KbWF0MyB0cmFuc3Bvc2VNYXQzKCBjb25zdCBpbiBtYXQzIG0gKSB7CgltYXQzIHRtcDsKCXRtcFsgMCBdID0gdmVjMyggbVsgMCBdLngsIG1bIDEgXS54LCBtWyAyIF0ueCApOwoJdG1wWyAxIF0gPSB2ZWMzKCBtWyAwIF0ueSwgbVsgMSBdLnksIG1bIDIgXS55ICk7Cgl0bXBbIDIgXSA9IHZlYzMoIG1bIDAgXS56LCBtWyAxIF0ueiwgbVsgMiBdLnogKTsKCXJldHVybiB0bXA7Cn0KZmxvYXQgbHVtaW5hbmNlKCBjb25zdCBpbiB2ZWMzIHJnYiApIHsKCWNvbnN0IHZlYzMgd2VpZ2h0cyA9IHZlYzMoIDAuMjEyNjcyOSwgMC43MTUxNTIyLCAwLjA3MjE3NTAgKTsKCXJldHVybiBkb3QoIHdlaWdodHMsIHJnYiApOwp9CmJvb2wgaXNQZXJzcGVjdGl2ZU1hdHJpeCggbWF0NCBtICkgewoJcmV0dXJuIG1bIDIgXVsgMyBdID09IC0gMS4wOwp9CnZlYzIgZXF1aXJlY3RVdiggaW4gdmVjMyBkaXIgKSB7CglmbG9hdCB1ID0gYXRhbiggZGlyLnosIGRpci54ICkgKiBSRUNJUFJPQ0FMX1BJMiArIDAuNTsKCWZsb2F0IHYgPSBhc2luKCBjbGFtcCggZGlyLnksIC0gMS4wLCAxLjAgKSApICogUkVDSVBST0NBTF9QSSArIDAuNTsKCXJldHVybiB2ZWMyKCB1LCB2ICk7Cn0KdmVjMyBCUkRGX0xhbWJlcnQoIGNvbnN0IGluIHZlYzMgZGlmZnVzZUNvbG9yICkgewoJcmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiBkaWZmdXNlQ29sb3I7Cn0KdmVjMyBGX1NjaGxpY2soIGNvbnN0IGluIHZlYzMgZjAsIGNvbnN0IGluIGZsb2F0IGY5MCwgY29uc3QgaW4gZmxvYXQgZG90VkggKSB7CglmbG9hdCBmcmVzbmVsID0gZXhwMiggKCAtIDUuNTU0NzMgKiBkb3RWSCAtIDYuOTgzMTYgKSAqIGRvdFZIICk7CglyZXR1cm4gZjAgKiAoIDEuMCAtIGZyZXNuZWwgKSArICggZjkwICogZnJlc25lbCApOwp9CmZsb2F0IEZfU2NobGljayggY29uc3QgaW4gZmxvYXQgZjAsIGNvbnN0IGluIGZsb2F0IGY5MCwgY29uc3QgaW4gZmxvYXQgZG90VkggKSB7CglmbG9hdCBmcmVzbmVsID0gZXhwMiggKCAtIDUuNTU0NzMgKiBkb3RWSCAtIDYuOTgzMTYgKSAqIGRvdFZIICk7CglyZXR1cm4gZjAgKiAoIDEuMCAtIGZyZXNuZWwgKSArICggZjkwICogZnJlc25lbCApOwp9IC8vIHZhbGlkYXRlZGAsZmc9YCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFX1VWCgkjZGVmaW5lIGN1YmVVVl9taW5NaXBMZXZlbCA0LjAKCSNkZWZpbmUgY3ViZVVWX21pblRpbGVTaXplIDE2LjAKCWZsb2F0IGdldEZhY2UoIHZlYzMgZGlyZWN0aW9uICkgewoJCXZlYzMgYWJzRGlyZWN0aW9uID0gYWJzKCBkaXJlY3Rpb24gKTsKCQlmbG9hdCBmYWNlID0gLSAxLjA7CgkJaWYgKCBhYnNEaXJlY3Rpb24ueCA+IGFic0RpcmVjdGlvbi56ICkgewoJCQlpZiAoIGFic0RpcmVjdGlvbi54ID4gYWJzRGlyZWN0aW9uLnkgKQoJCQkJZmFjZSA9IGRpcmVjdGlvbi54ID4gMC4wID8gMC4wIDogMy4wOwoJCQllbHNlCgkJCQlmYWNlID0gZGlyZWN0aW9uLnkgPiAwLjAgPyAxLjAgOiA0LjA7CgkJfSBlbHNlIHsKCQkJaWYgKCBhYnNEaXJlY3Rpb24ueiA+IGFic0RpcmVjdGlvbi55ICkKCQkJCWZhY2UgPSBkaXJlY3Rpb24ueiA+IDAuMCA/IDIuMCA6IDUuMDsKCQkJZWxzZQoJCQkJZmFjZSA9IGRpcmVjdGlvbi55ID4gMC4wID8gMS4wIDogNC4wOwoJCX0KCQlyZXR1cm4gZmFjZTsKCX0KCXZlYzIgZ2V0VVYoIHZlYzMgZGlyZWN0aW9uLCBmbG9hdCBmYWNlICkgewoJCXZlYzIgdXY7CgkJaWYgKCBmYWNlID09IDAuMCApIHsKCQkJdXYgPSB2ZWMyKCBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnkgKSAvIGFicyggZGlyZWN0aW9uLnggKTsKCQl9IGVsc2UgaWYgKCBmYWNlID09IDEuMCApIHsKCQkJdXYgPSB2ZWMyKCAtIGRpcmVjdGlvbi54LCAtIGRpcmVjdGlvbi56ICkgLyBhYnMoIGRpcmVjdGlvbi55ICk7CgkJfSBlbHNlIGlmICggZmFjZSA9PSAyLjAgKSB7CgkJCXV2ID0gdmVjMiggLSBkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnkgKSAvIGFicyggZGlyZWN0aW9uLnogKTsKCQl9IGVsc2UgaWYgKCBmYWNlID09IDMuMCApIHsKCQkJdXYgPSB2ZWMyKCAtIGRpcmVjdGlvbi56LCBkaXJlY3Rpb24ueSApIC8gYWJzKCBkaXJlY3Rpb24ueCApOwoJCX0gZWxzZSBpZiAoIGZhY2UgPT0gNC4wICkgewoJCQl1diA9IHZlYzIoIC0gZGlyZWN0aW9uLngsIGRpcmVjdGlvbi56ICkgLyBhYnMoIGRpcmVjdGlvbi55ICk7CgkJfSBlbHNlIHsKCQkJdXYgPSB2ZWMyKCBkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnkgKSAvIGFicyggZGlyZWN0aW9uLnogKTsKCQl9CgkJcmV0dXJuIDAuNSAqICggdXYgKyAxLjAgKTsKCX0KCXZlYzMgYmlsaW5lYXJDdWJlVVYoIHNhbXBsZXIyRCBlbnZNYXAsIHZlYzMgZGlyZWN0aW9uLCBmbG9hdCBtaXBJbnQgKSB7CgkJZmxvYXQgZmFjZSA9IGdldEZhY2UoIGRpcmVjdGlvbiApOwoJCWZsb2F0IGZpbHRlckludCA9IG1heCggY3ViZVVWX21pbk1pcExldmVsIC0gbWlwSW50LCAwLjAgKTsKCQltaXBJbnQgPSBtYXgoIG1pcEludCwgY3ViZVVWX21pbk1pcExldmVsICk7CgkJZmxvYXQgZmFjZVNpemUgPSBleHAyKCBtaXBJbnQgKTsKCQloaWdocCB2ZWMyIHV2ID0gZ2V0VVYoIGRpcmVjdGlvbiwgZmFjZSApICogKCBmYWNlU2l6ZSAtIDIuMCApICsgMS4wOwoJCWlmICggZmFjZSA+IDIuMCApIHsKCQkJdXYueSArPSBmYWNlU2l6ZTsKCQkJZmFjZSAtPSAzLjA7CgkJfQoJCXV2LnggKz0gZmFjZSAqIGZhY2VTaXplOwoJCXV2LnggKz0gZmlsdGVySW50ICogMy4wICogY3ViZVVWX21pblRpbGVTaXplOwoJCXV2LnkgKz0gNC4wICogKCBleHAyKCBDVUJFVVZfTUFYX01JUCApIC0gZmFjZVNpemUgKTsKCQl1di54ICo9IENVQkVVVl9URVhFTF9XSURUSDsKCQl1di55ICo9IENVQkVVVl9URVhFTF9IRUlHSFQ7CgkJI2lmZGVmIHRleHR1cmUyREdyYWRFWFQKCQkJcmV0dXJuIHRleHR1cmUyREdyYWRFWFQoIGVudk1hcCwgdXYsIHZlYzIoIDAuMCApLCB2ZWMyKCAwLjAgKSApLnJnYjsKCQkjZWxzZQoJCQlyZXR1cm4gdGV4dHVyZTJEKCBlbnZNYXAsIHV2ICkucmdiOwoJCSNlbmRpZgoJfQoJI2RlZmluZSBjdWJlVVZfcjAgMS4wCgkjZGVmaW5lIGN1YmVVVl9tMCAtIDIuMAoJI2RlZmluZSBjdWJlVVZfcjEgMC44CgkjZGVmaW5lIGN1YmVVVl9tMSAtIDEuMAoJI2RlZmluZSBjdWJlVVZfcjQgMC40CgkjZGVmaW5lIGN1YmVVVl9tNCAyLjAKCSNkZWZpbmUgY3ViZVVWX3I1IDAuMzA1CgkjZGVmaW5lIGN1YmVVVl9tNSAzLjAKCSNkZWZpbmUgY3ViZVVWX3I2IDAuMjEKCSNkZWZpbmUgY3ViZVVWX202IDQuMAoJZmxvYXQgcm91Z2huZXNzVG9NaXAoIGZsb2F0IHJvdWdobmVzcyApIHsKCQlmbG9hdCBtaXAgPSAwLjA7CgkJaWYgKCByb3VnaG5lc3MgPj0gY3ViZVVWX3IxICkgewoJCQltaXAgPSAoIGN1YmVVVl9yMCAtIHJvdWdobmVzcyApICogKCBjdWJlVVZfbTEgLSBjdWJlVVZfbTAgKSAvICggY3ViZVVWX3IwIC0gY3ViZVVWX3IxICkgKyBjdWJlVVZfbTA7CgkJfSBlbHNlIGlmICggcm91Z2huZXNzID49IGN1YmVVVl9yNCApIHsKCQkJbWlwID0gKCBjdWJlVVZfcjEgLSByb3VnaG5lc3MgKSAqICggY3ViZVVWX200IC0gY3ViZVVWX20xICkgLyAoIGN1YmVVVl9yMSAtIGN1YmVVVl9yNCApICsgY3ViZVVWX20xOwoJCX0gZWxzZSBpZiAoIHJvdWdobmVzcyA+PSBjdWJlVVZfcjUgKSB7CgkJCW1pcCA9ICggY3ViZVVWX3I0IC0gcm91Z2huZXNzICkgKiAoIGN1YmVVVl9tNSAtIGN1YmVVVl9tNCApIC8gKCBjdWJlVVZfcjQgLSBjdWJlVVZfcjUgKSArIGN1YmVVVl9tNDsKCQl9IGVsc2UgaWYgKCByb3VnaG5lc3MgPj0gY3ViZVVWX3I2ICkgewoJCQltaXAgPSAoIGN1YmVVVl9yNSAtIHJvdWdobmVzcyApICogKCBjdWJlVVZfbTYgLSBjdWJlVVZfbTUgKSAvICggY3ViZVVWX3I1IC0gY3ViZVVWX3I2ICkgKyBjdWJlVVZfbTU7CgkJfSBlbHNlIHsKCQkJbWlwID0gLSAyLjAgKiBsb2cyKCAxLjE2ICogcm91Z2huZXNzICk7CQl9CgkJcmV0dXJuIG1pcDsKCX0KCXZlYzQgdGV4dHVyZUN1YmVVViggc2FtcGxlcjJEIGVudk1hcCwgdmVjMyBzYW1wbGVEaXIsIGZsb2F0IHJvdWdobmVzcyApIHsKCQlmbG9hdCBtaXAgPSBjbGFtcCggcm91Z2huZXNzVG9NaXAoIHJvdWdobmVzcyApLCBjdWJlVVZfbTAsIENVQkVVVl9NQVhfTUlQICk7CgkJZmxvYXQgbWlwRiA9IGZyYWN0KCBtaXAgKTsKCQlmbG9hdCBtaXBJbnQgPSBmbG9vciggbWlwICk7CgkJdmVjMyBjb2xvcjAgPSBiaWxpbmVhckN1YmVVViggZW52TWFwLCBzYW1wbGVEaXIsIG1pcEludCApOwoJCWlmICggbWlwRiA9PSAwLjAgKSB7CgkJCXJldHVybiB2ZWM0KCBjb2xvcjAsIDEuMCApOwoJCX0gZWxzZSB7CgkJCXZlYzMgY29sb3IxID0gYmlsaW5lYXJDdWJlVVYoIGVudk1hcCwgc2FtcGxlRGlyLCBtaXBJbnQgKyAxLjAgKTsKCQkJcmV0dXJuIHZlYzQoIG1peCggY29sb3IwLCBjb2xvcjEsIG1pcEYgKSwgMS4wICk7CgkJfQoJfQojZW5kaWZgLHBnPWB2ZWMzIHRyYW5zZm9ybWVkTm9ybWFsID0gb2JqZWN0Tm9ybWFsOwojaWZkZWYgVVNFX1RBTkdFTlQKCXZlYzMgdHJhbnNmb3JtZWRUYW5nZW50ID0gb2JqZWN0VGFuZ2VudDsKI2VuZGlmCiNpZmRlZiBVU0VfQkFUQ0hJTkcKCW1hdDMgYm0gPSBtYXQzKCBiYXRjaGluZ01hdHJpeCApOwoJdHJhbnNmb3JtZWROb3JtYWwgLz0gdmVjMyggZG90KCBibVsgMCBdLCBibVsgMCBdICksIGRvdCggYm1bIDEgXSwgYm1bIDEgXSApLCBkb3QoIGJtWyAyIF0sIGJtWyAyIF0gKSApOwoJdHJhbnNmb3JtZWROb3JtYWwgPSBibSAqIHRyYW5zZm9ybWVkTm9ybWFsOwoJI2lmZGVmIFVTRV9UQU5HRU5UCgkJdHJhbnNmb3JtZWRUYW5nZW50ID0gYm0gKiB0cmFuc2Zvcm1lZFRhbmdlbnQ7CgkjZW5kaWYKI2VuZGlmCiNpZmRlZiBVU0VfSU5TVEFOQ0lORwoJbWF0MyBpbSA9IG1hdDMoIGluc3RhbmNlTWF0cml4ICk7Cgl0cmFuc2Zvcm1lZE5vcm1hbCAvPSB2ZWMzKCBkb3QoIGltWyAwIF0sIGltWyAwIF0gKSwgZG90KCBpbVsgMSBdLCBpbVsgMSBdICksIGRvdCggaW1bIDIgXSwgaW1bIDIgXSApICk7Cgl0cmFuc2Zvcm1lZE5vcm1hbCA9IGltICogdHJhbnNmb3JtZWROb3JtYWw7CgkjaWZkZWYgVVNFX1RBTkdFTlQKCQl0cmFuc2Zvcm1lZFRhbmdlbnQgPSBpbSAqIHRyYW5zZm9ybWVkVGFuZ2VudDsKCSNlbmRpZgojZW5kaWYKdHJhbnNmb3JtZWROb3JtYWwgPSBub3JtYWxNYXRyaXggKiB0cmFuc2Zvcm1lZE5vcm1hbDsKI2lmZGVmIEZMSVBfU0lERUQKCXRyYW5zZm9ybWVkTm9ybWFsID0gLSB0cmFuc2Zvcm1lZE5vcm1hbDsKI2VuZGlmCiNpZmRlZiBVU0VfVEFOR0VOVAoJdHJhbnNmb3JtZWRUYW5nZW50ID0gKCBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZFRhbmdlbnQsIDAuMCApICkueHl6OwoJI2lmZGVmIEZMSVBfU0lERUQKCQl0cmFuc2Zvcm1lZFRhbmdlbnQgPSAtIHRyYW5zZm9ybWVkVGFuZ2VudDsKCSNlbmRpZgojZW5kaWZgLG1nPWAjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUAoJdW5pZm9ybSBzYW1wbGVyMkQgZGlzcGxhY2VtZW50TWFwOwoJdW5pZm9ybSBmbG9hdCBkaXNwbGFjZW1lbnRTY2FsZTsKCXVuaWZvcm0gZmxvYXQgZGlzcGxhY2VtZW50QmlhczsKI2VuZGlmYCxnZz1gI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVAKCXRyYW5zZm9ybWVkICs9IG5vcm1hbGl6ZSggb2JqZWN0Tm9ybWFsICkgKiAoIHRleHR1cmUyRCggZGlzcGxhY2VtZW50TWFwLCB2RGlzcGxhY2VtZW50TWFwVXYgKS54ICogZGlzcGxhY2VtZW50U2NhbGUgKyBkaXNwbGFjZW1lbnRCaWFzICk7CiNlbmRpZmAsX2c9YCNpZmRlZiBVU0VfRU1JU1NJVkVNQVAKCXZlYzQgZW1pc3NpdmVDb2xvciA9IHRleHR1cmUyRCggZW1pc3NpdmVNYXAsIHZFbWlzc2l2ZU1hcFV2ICk7Cgl0b3RhbEVtaXNzaXZlUmFkaWFuY2UgKj0gZW1pc3NpdmVDb2xvci5yZ2I7CiNlbmRpZmAseGc9YCNpZmRlZiBVU0VfRU1JU1NJVkVNQVAKCXVuaWZvcm0gc2FtcGxlcjJEIGVtaXNzaXZlTWFwOwojZW5kaWZgLHZnPSJnbF9GcmFnQ29sb3IgPSBsaW5lYXJUb091dHB1dFRleGVsKCBnbF9GcmFnQ29sb3IgKTsiLHlnPWAKY29uc3QgbWF0MyBMSU5FQVJfU1JHQl9UT19MSU5FQVJfRElTUExBWV9QMyA9IG1hdDMoCgl2ZWMzKCAwLjgyMjQ2MjEsIDAuMTc3NTM4LCAwLjAgKSwKCXZlYzMoIDAuMDMzMTk0MSwgMC45NjY4MDU4LCAwLjAgKSwKCXZlYzMoIDAuMDE3MDgyNywgMC4wNzIzOTc0LCAwLjkxMDUxOTkgKQopOwpjb25zdCBtYXQzIExJTkVBUl9ESVNQTEFZX1AzX1RPX0xJTkVBUl9TUkdCID0gbWF0MygKCXZlYzMoIDEuMjI0OTQwMSwgLSAwLjIyNDk0MDQsIDAuMCApLAoJdmVjMyggLSAwLjA0MjA1NjksIDEuMDQyMDU3MSwgMC4wICksCgl2ZWMzKCAtIDAuMDE5NjM3NiwgLSAwLjA3ODYzNjEsIDEuMDk4MjczNSApCik7CnZlYzQgTGluZWFyU1JHQlRvTGluZWFyRGlzcGxheVAzKCBpbiB2ZWM0IHZhbHVlICkgewoJcmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAqIExJTkVBUl9TUkdCX1RPX0xJTkVBUl9ESVNQTEFZX1AzLCB2YWx1ZS5hICk7Cn0KdmVjNCBMaW5lYXJEaXNwbGF5UDNUb0xpbmVhclNSR0IoIGluIHZlYzQgdmFsdWUgKSB7CglyZXR1cm4gdmVjNCggdmFsdWUucmdiICogTElORUFSX0RJU1BMQVlfUDNfVE9fTElORUFSX1NSR0IsIHZhbHVlLmEgKTsKfQp2ZWM0IExpbmVhclRyYW5zZmVyT0VURiggaW4gdmVjNCB2YWx1ZSApIHsKCXJldHVybiB2YWx1ZTsKfQp2ZWM0IHNSR0JUcmFuc2Zlck9FVEYoIGluIHZlYzQgdmFsdWUgKSB7CglyZXR1cm4gdmVjNCggbWl4KCBwb3coIHZhbHVlLnJnYiwgdmVjMyggMC40MTY2NiApICkgKiAxLjA1NSAtIHZlYzMoIDAuMDU1ICksIHZhbHVlLnJnYiAqIDEyLjkyLCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCB2YWx1ZS5yZ2IsIHZlYzMoIDAuMDAzMTMwOCApICkgKSApLCB2YWx1ZS5hICk7Cn0KdmVjNCBMaW5lYXJUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSApIHsKCXJldHVybiB2YWx1ZTsKfQp2ZWM0IExpbmVhclRvc1JHQiggaW4gdmVjNCB2YWx1ZSApIHsKCXJldHVybiBzUkdCVHJhbnNmZXJPRVRGKCB2YWx1ZSApOwp9YCxNZz1gI2lmZGVmIFVTRV9FTlZNQVAKCSNpZmRlZiBFTlZfV09STERQT1MKCQl2ZWMzIGNhbWVyYVRvRnJhZzsKCQlpZiAoIGlzT3J0aG9ncmFwaGljICkgewoJCQljYW1lcmFUb0ZyYWcgPSBub3JtYWxpemUoIHZlYzMoIC0gdmlld01hdHJpeFsgMCBdWyAyIF0sIC0gdmlld01hdHJpeFsgMSBdWyAyIF0sIC0gdmlld01hdHJpeFsgMiBdWyAyIF0gKSApOwoJCX0gZWxzZSB7CgkJCWNhbWVyYVRvRnJhZyA9IG5vcm1hbGl6ZSggdldvcmxkUG9zaXRpb24gLSBjYW1lcmFQb3NpdGlvbiApOwoJCX0KCQl2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7CgkJI2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT04KCQkJdmVjMyByZWZsZWN0VmVjID0gcmVmbGVjdCggY2FtZXJhVG9GcmFnLCB3b3JsZE5vcm1hbCApOwoJCSNlbHNlCgkJCXZlYzMgcmVmbGVjdFZlYyA9IHJlZnJhY3QoIGNhbWVyYVRvRnJhZywgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApOwoJCSNlbmRpZgoJI2Vsc2UKCQl2ZWMzIHJlZmxlY3RWZWMgPSB2UmVmbGVjdDsKCSNlbmRpZgoJI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkUKCQl2ZWM0IGVudkNvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApICk7CgkjZWxzZQoJCXZlYzQgZW52Q29sb3IgPSB2ZWM0KCAwLjAgKTsKCSNlbmRpZgoJI2lmZGVmIEVOVk1BUF9CTEVORElOR19NVUxUSVBMWQoJCW91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIG91dGdvaW5nTGlnaHQgKiBlbnZDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTsKCSNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19NSVggKQoJCW91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApOwoJI2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX0FERCApCgkJb3V0Z29pbmdMaWdodCArPSBlbnZDb2xvci54eXogKiBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5OwoJI2VuZGlmCiNlbmRpZmAsU2c9YCNpZmRlZiBVU0VfRU5WTUFQCgl1bmlmb3JtIGZsb2F0IGVudk1hcEludGVuc2l0eTsKCXVuaWZvcm0gZmxvYXQgZmxpcEVudk1hcDsKCSNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFCgkJdW5pZm9ybSBzYW1wbGVyQ3ViZSBlbnZNYXA7CgkjZWxzZQoJCXVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDsKCSNlbmRpZgoJCiNlbmRpZmAsYmc9YCNpZmRlZiBVU0VfRU5WTUFQCgl1bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTsKCSNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIHx8IGRlZmluZWQoIExBTUJFUlQgKQoJCSNkZWZpbmUgRU5WX1dPUkxEUE9TCgkjZW5kaWYKCSNpZmRlZiBFTlZfV09STERQT1MKCQl2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247CgkJdW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87CgkjZWxzZQoJCXZhcnlpbmcgdmVjMyB2UmVmbGVjdDsKCSNlbmRpZgojZW5kaWZgLEVnPWAjaWZkZWYgVVNFX0VOVk1BUAoJI2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HICkgfHwgZGVmaW5lZCggTEFNQkVSVCApCgkJI2RlZmluZSBFTlZfV09STERQT1MKCSNlbmRpZgoJI2lmZGVmIEVOVl9XT1JMRFBPUwoJCQoJCXZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjsKCSNlbHNlCgkJdmFyeWluZyB2ZWMzIHZSZWZsZWN0OwoJCXVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvOwoJI2VuZGlmCiNlbmRpZmAsQWc9YCNpZmRlZiBVU0VfRU5WTUFQCgkjaWZkZWYgRU5WX1dPUkxEUE9TCgkJdldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejsKCSNlbHNlCgkJdmVjMyBjYW1lcmFUb1ZlcnRleDsKCQlpZiAoIGlzT3J0aG9ncmFwaGljICkgewoJCQljYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggdmVjMyggLSB2aWV3TWF0cml4WyAwIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAxIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAyIF1bIDIgXSApICk7CgkJfSBlbHNlIHsKCQkJY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHdvcmxkUG9zaXRpb24ueHl6IC0gY2FtZXJhUG9zaXRpb24gKTsKCQl9CgkJdmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHRyYW5zZm9ybWVkTm9ybWFsLCB2aWV3TWF0cml4ICk7CgkJI2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT04KCQkJdlJlZmxlY3QgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTsKCQkjZWxzZQoJCQl2UmVmbGVjdCA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7CgkJI2VuZGlmCgkjZW5kaWYKI2VuZGlmYCxUZz1gI2lmZGVmIFVTRV9GT0cKCXZGb2dEZXB0aCA9IC0gbXZQb3NpdGlvbi56OwojZW5kaWZgLHdnPWAjaWZkZWYgVVNFX0ZPRwoJdmFyeWluZyBmbG9hdCB2Rm9nRGVwdGg7CiNlbmRpZmAsUmc9YCNpZmRlZiBVU0VfRk9HCgkjaWZkZWYgRk9HX0VYUDIKCQlmbG9hdCBmb2dGYWN0b3IgPSAxLjAgLSBleHAoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiB2Rm9nRGVwdGggKiB2Rm9nRGVwdGggKTsKCSNlbHNlCgkJZmxvYXQgZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCB2Rm9nRGVwdGggKTsKCSNlbmRpZgoJZ2xfRnJhZ0NvbG9yLnJnYiA9IG1peCggZ2xfRnJhZ0NvbG9yLnJnYiwgZm9nQ29sb3IsIGZvZ0ZhY3RvciApOwojZW5kaWZgLENnPWAjaWZkZWYgVVNFX0ZPRwoJdW5pZm9ybSB2ZWMzIGZvZ0NvbG9yOwoJdmFyeWluZyBmbG9hdCB2Rm9nRGVwdGg7CgkjaWZkZWYgRk9HX0VYUDIKCQl1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7CgkjZWxzZQoJCXVuaWZvcm0gZmxvYXQgZm9nTmVhcjsKCQl1bmlmb3JtIGZsb2F0IGZvZ0ZhcjsKCSNlbmRpZgojZW5kaWZgLFBnPWAjaWZkZWYgVVNFX0dSQURJRU5UTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBncmFkaWVudE1hcDsKI2VuZGlmCnZlYzMgZ2V0R3JhZGllbnRJcnJhZGlhbmNlKCB2ZWMzIG5vcm1hbCwgdmVjMyBsaWdodERpcmVjdGlvbiApIHsKCWZsb2F0IGRvdE5MID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyZWN0aW9uICk7Cgl2ZWMyIGNvb3JkID0gdmVjMiggZG90TkwgKiAwLjUgKyAwLjUsIDAuMCApOwoJI2lmZGVmIFVTRV9HUkFESUVOVE1BUAoJCXJldHVybiB2ZWMzKCB0ZXh0dXJlMkQoIGdyYWRpZW50TWFwLCBjb29yZCApLnIgKTsKCSNlbHNlCgkJdmVjMiBmdyA9IGZ3aWR0aCggY29vcmQgKSAqIDAuNTsKCQlyZXR1cm4gbWl4KCB2ZWMzKCAwLjcgKSwgdmVjMyggMS4wICksIHNtb290aHN0ZXAoIDAuNyAtIGZ3LngsIDAuNyArIGZ3LngsIGNvb3JkLnggKSApOwoJI2VuZGlmCn1gLExnPWAjaWZkZWYgVVNFX0xJR0hUTUFQCgl2ZWM0IGxpZ2h0TWFwVGV4ZWwgPSB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2TGlnaHRNYXBVdiApOwoJdmVjMyBsaWdodE1hcElycmFkaWFuY2UgPSBsaWdodE1hcFRleGVsLnJnYiAqIGxpZ2h0TWFwSW50ZW5zaXR5OwoJcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGxpZ2h0TWFwSXJyYWRpYW5jZTsKI2VuZGlmYCxJZz1gI2lmZGVmIFVTRV9MSUdIVE1BUAoJdW5pZm9ybSBzYW1wbGVyMkQgbGlnaHRNYXA7Cgl1bmlmb3JtIGZsb2F0IGxpZ2h0TWFwSW50ZW5zaXR5OwojZW5kaWZgLFVnPWBMYW1iZXJ0TWF0ZXJpYWwgbWF0ZXJpYWw7Cm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2I7Cm1hdGVyaWFsLnNwZWN1bGFyU3RyZW5ndGggPSBzcGVjdWxhclN0cmVuZ3RoO2AsRGc9YHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uOwpzdHJ1Y3QgTGFtYmVydE1hdGVyaWFsIHsKCXZlYzMgZGlmZnVzZUNvbG9yOwoJZmxvYXQgc3BlY3VsYXJTdHJlbmd0aDsKfTsKdm9pZCBSRV9EaXJlY3RfTGFtYmVydCggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Tm9ybWFsLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Vmlld0RpciwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgY29uc3QgaW4gTGFtYmVydE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHsKCWZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnlOb3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICk7Cgl2ZWMzIGlycmFkaWFuY2UgPSBkb3ROTCAqIGRpcmVjdExpZ2h0LmNvbG9yOwoJcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTsKfQp2b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9MYW1iZXJ0KCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeU5vcm1hbCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVZpZXdEaXIsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGNvbnN0IGluIExhbWJlcnRNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7CglyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7Cn0KI2RlZmluZSBSRV9EaXJlY3QJCQkJUkVfRGlyZWN0X0xhbWJlcnQKI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2UJCVJFX0luZGlyZWN0RGlmZnVzZV9MYW1iZXJ0YCxOZz1gdW5pZm9ybSBib29sIHJlY2VpdmVTaGFkb3c7CnVuaWZvcm0gdmVjMyBhbWJpZW50TGlnaHRDb2xvcjsKI2lmIGRlZmluZWQoIFVTRV9MSUdIVF9QUk9CRVMgKQoJdW5pZm9ybSB2ZWMzIGxpZ2h0UHJvYmVbIDkgXTsKI2VuZGlmCnZlYzMgc2hHZXRJcnJhZGlhbmNlQXQoIGluIHZlYzMgbm9ybWFsLCBpbiB2ZWMzIHNoQ29lZmZpY2llbnRzWyA5IF0gKSB7CglmbG9hdCB4ID0gbm9ybWFsLngsIHkgPSBub3JtYWwueSwgeiA9IG5vcm1hbC56OwoJdmVjMyByZXN1bHQgPSBzaENvZWZmaWNpZW50c1sgMCBdICogMC44ODYyMjc7CglyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDEgXSAqIDIuMCAqIDAuNTExNjY0ICogeTsKCXJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgMiBdICogMi4wICogMC41MTE2NjQgKiB6OwoJcmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyAzIF0gKiAyLjAgKiAwLjUxMTY2NCAqIHg7CglyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDQgXSAqIDIuMCAqIDAuNDI5MDQzICogeCAqIHk7CglyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDUgXSAqIDIuMCAqIDAuNDI5MDQzICogeSAqIHo7CglyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDYgXSAqICggMC43NDMxMjUgKiB6ICogeiAtIDAuMjQ3NzA4ICk7CglyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDcgXSAqIDIuMCAqIDAuNDI5MDQzICogeCAqIHo7CglyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDggXSAqIDAuNDI5MDQzICogKCB4ICogeCAtIHkgKiB5ICk7CglyZXR1cm4gcmVzdWx0Owp9CnZlYzMgZ2V0TGlnaHRQcm9iZUlycmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgbGlnaHRQcm9iZVsgOSBdLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCApIHsKCXZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTsKCXZlYzMgaXJyYWRpYW5jZSA9IHNoR2V0SXJyYWRpYW5jZUF0KCB3b3JsZE5vcm1hbCwgbGlnaHRQcm9iZSApOwoJcmV0dXJuIGlycmFkaWFuY2U7Cn0KdmVjMyBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIGFtYmllbnRMaWdodENvbG9yICkgewoJdmVjMyBpcnJhZGlhbmNlID0gYW1iaWVudExpZ2h0Q29sb3I7CglyZXR1cm4gaXJyYWRpYW5jZTsKfQpmbG9hdCBnZXREaXN0YW5jZUF0dGVudWF0aW9uKCBjb25zdCBpbiBmbG9hdCBsaWdodERpc3RhbmNlLCBjb25zdCBpbiBmbG9hdCBjdXRvZmZEaXN0YW5jZSwgY29uc3QgaW4gZmxvYXQgZGVjYXlFeHBvbmVudCApIHsKCSNpZiBkZWZpbmVkICggTEVHQUNZX0xJR0hUUyApCgkJaWYgKCBjdXRvZmZEaXN0YW5jZSA+IDAuMCAmJiBkZWNheUV4cG9uZW50ID4gMC4wICkgewoJCQlyZXR1cm4gcG93KCBzYXR1cmF0ZSggLSBsaWdodERpc3RhbmNlIC8gY3V0b2ZmRGlzdGFuY2UgKyAxLjAgKSwgZGVjYXlFeHBvbmVudCApOwoJCX0KCQlyZXR1cm4gMS4wOwoJI2Vsc2UKCQlmbG9hdCBkaXN0YW5jZUZhbGxvZmYgPSAxLjAgLyBtYXgoIHBvdyggbGlnaHREaXN0YW5jZSwgZGVjYXlFeHBvbmVudCApLCAwLjAxICk7CgkJaWYgKCBjdXRvZmZEaXN0YW5jZSA+IDAuMCApIHsKCQkJZGlzdGFuY2VGYWxsb2ZmICo9IHBvdzIoIHNhdHVyYXRlKCAxLjAgLSBwb3c0KCBsaWdodERpc3RhbmNlIC8gY3V0b2ZmRGlzdGFuY2UgKSApICk7CgkJfQoJCXJldHVybiBkaXN0YW5jZUZhbGxvZmY7CgkjZW5kaWYKfQpmbG9hdCBnZXRTcG90QXR0ZW51YXRpb24oIGNvbnN0IGluIGZsb2F0IGNvbmVDb3NpbmUsIGNvbnN0IGluIGZsb2F0IHBlbnVtYnJhQ29zaW5lLCBjb25zdCBpbiBmbG9hdCBhbmdsZUNvc2luZSApIHsKCXJldHVybiBzbW9vdGhzdGVwKCBjb25lQ29zaW5lLCBwZW51bWJyYUNvc2luZSwgYW5nbGVDb3NpbmUgKTsKfQojaWYgTlVNX0RJUl9MSUdIVFMgPiAwCglzdHJ1Y3QgRGlyZWN0aW9uYWxMaWdodCB7CgkJdmVjMyBkaXJlY3Rpb247CgkJdmVjMyBjb2xvcjsKCX07Cgl1bmlmb3JtIERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodHNbIE5VTV9ESVJfTElHSFRTIF07Cgl2b2lkIGdldERpcmVjdGlvbmFsTGlnaHRJbmZvKCBjb25zdCBpbiBEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQsIG91dCBJbmNpZGVudExpZ2h0IGxpZ2h0ICkgewoJCWxpZ2h0LmNvbG9yID0gZGlyZWN0aW9uYWxMaWdodC5jb2xvcjsKCQlsaWdodC5kaXJlY3Rpb24gPSBkaXJlY3Rpb25hbExpZ2h0LmRpcmVjdGlvbjsKCQlsaWdodC52aXNpYmxlID0gdHJ1ZTsKCX0KI2VuZGlmCiNpZiBOVU1fUE9JTlRfTElHSFRTID4gMAoJc3RydWN0IFBvaW50TGlnaHQgewoJCXZlYzMgcG9zaXRpb247CgkJdmVjMyBjb2xvcjsKCQlmbG9hdCBkaXN0YW5jZTsKCQlmbG9hdCBkZWNheTsKCX07Cgl1bmlmb3JtIFBvaW50TGlnaHQgcG9pbnRMaWdodHNbIE5VTV9QT0lOVF9MSUdIVFMgXTsKCXZvaWQgZ2V0UG9pbnRMaWdodEluZm8oIGNvbnN0IGluIFBvaW50TGlnaHQgcG9pbnRMaWdodCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBvdXQgSW5jaWRlbnRMaWdodCBsaWdodCApIHsKCQl2ZWMzIGxWZWN0b3IgPSBwb2ludExpZ2h0LnBvc2l0aW9uIC0gZ2VvbWV0cnlQb3NpdGlvbjsKCQlsaWdodC5kaXJlY3Rpb24gPSBub3JtYWxpemUoIGxWZWN0b3IgKTsKCQlmbG9hdCBsaWdodERpc3RhbmNlID0gbGVuZ3RoKCBsVmVjdG9yICk7CgkJbGlnaHQuY29sb3IgPSBwb2ludExpZ2h0LmNvbG9yOwoJCWxpZ2h0LmNvbG9yICo9IGdldERpc3RhbmNlQXR0ZW51YXRpb24oIGxpZ2h0RGlzdGFuY2UsIHBvaW50TGlnaHQuZGlzdGFuY2UsIHBvaW50TGlnaHQuZGVjYXkgKTsKCQlsaWdodC52aXNpYmxlID0gKCBsaWdodC5jb2xvciAhPSB2ZWMzKCAwLjAgKSApOwoJfQojZW5kaWYKI2lmIE5VTV9TUE9UX0xJR0hUUyA+IDAKCXN0cnVjdCBTcG90TGlnaHQgewoJCXZlYzMgcG9zaXRpb247CgkJdmVjMyBkaXJlY3Rpb247CgkJdmVjMyBjb2xvcjsKCQlmbG9hdCBkaXN0YW5jZTsKCQlmbG9hdCBkZWNheTsKCQlmbG9hdCBjb25lQ29zOwoJCWZsb2F0IHBlbnVtYnJhQ29zOwoJfTsKCXVuaWZvcm0gU3BvdExpZ2h0IHNwb3RMaWdodHNbIE5VTV9TUE9UX0xJR0hUUyBdOwoJdm9pZCBnZXRTcG90TGlnaHRJbmZvKCBjb25zdCBpbiBTcG90TGlnaHQgc3BvdExpZ2h0LCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIG91dCBJbmNpZGVudExpZ2h0IGxpZ2h0ICkgewoJCXZlYzMgbFZlY3RvciA9IHNwb3RMaWdodC5wb3NpdGlvbiAtIGdlb21ldHJ5UG9zaXRpb247CgkJbGlnaHQuZGlyZWN0aW9uID0gbm9ybWFsaXplKCBsVmVjdG9yICk7CgkJZmxvYXQgYW5nbGVDb3MgPSBkb3QoIGxpZ2h0LmRpcmVjdGlvbiwgc3BvdExpZ2h0LmRpcmVjdGlvbiApOwoJCWZsb2F0IHNwb3RBdHRlbnVhdGlvbiA9IGdldFNwb3RBdHRlbnVhdGlvbiggc3BvdExpZ2h0LmNvbmVDb3MsIHNwb3RMaWdodC5wZW51bWJyYUNvcywgYW5nbGVDb3MgKTsKCQlpZiAoIHNwb3RBdHRlbnVhdGlvbiA+IDAuMCApIHsKCQkJZmxvYXQgbGlnaHREaXN0YW5jZSA9IGxlbmd0aCggbFZlY3RvciApOwoJCQlsaWdodC5jb2xvciA9IHNwb3RMaWdodC5jb2xvciAqIHNwb3RBdHRlbnVhdGlvbjsKCQkJbGlnaHQuY29sb3IgKj0gZ2V0RGlzdGFuY2VBdHRlbnVhdGlvbiggbGlnaHREaXN0YW5jZSwgc3BvdExpZ2h0LmRpc3RhbmNlLCBzcG90TGlnaHQuZGVjYXkgKTsKCQkJbGlnaHQudmlzaWJsZSA9ICggbGlnaHQuY29sb3IgIT0gdmVjMyggMC4wICkgKTsKCQl9IGVsc2UgewoJCQlsaWdodC5jb2xvciA9IHZlYzMoIDAuMCApOwoJCQlsaWdodC52aXNpYmxlID0gZmFsc2U7CgkJfQoJfQojZW5kaWYKI2lmIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMAoJc3RydWN0IFJlY3RBcmVhTGlnaHQgewoJCXZlYzMgY29sb3I7CgkJdmVjMyBwb3NpdGlvbjsKCQl2ZWMzIGhhbGZXaWR0aDsKCQl2ZWMzIGhhbGZIZWlnaHQ7Cgl9OwoJdW5pZm9ybSBzYW1wbGVyMkQgbHRjXzE7CXVuaWZvcm0gc2FtcGxlcjJEIGx0Y18yOwoJdW5pZm9ybSBSZWN0QXJlYUxpZ2h0IHJlY3RBcmVhTGlnaHRzWyBOVU1fUkVDVF9BUkVBX0xJR0hUUyBdOwojZW5kaWYKI2lmIE5VTV9IRU1JX0xJR0hUUyA+IDAKCXN0cnVjdCBIZW1pc3BoZXJlTGlnaHQgewoJCXZlYzMgZGlyZWN0aW9uOwoJCXZlYzMgc2t5Q29sb3I7CgkJdmVjMyBncm91bmRDb2xvcjsKCX07Cgl1bmlmb3JtIEhlbWlzcGhlcmVMaWdodCBoZW1pc3BoZXJlTGlnaHRzWyBOVU1fSEVNSV9MSUdIVFMgXTsKCXZlYzMgZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggY29uc3QgaW4gSGVtaXNwaGVyZUxpZ2h0IGhlbWlMaWdodCwgY29uc3QgaW4gdmVjMyBub3JtYWwgKSB7CgkJZmxvYXQgZG90TkwgPSBkb3QoIG5vcm1hbCwgaGVtaUxpZ2h0LmRpcmVjdGlvbiApOwoJCWZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90TkwgKyAwLjU7CgkJdmVjMyBpcnJhZGlhbmNlID0gbWl4KCBoZW1pTGlnaHQuZ3JvdW5kQ29sb3IsIGhlbWlMaWdodC5za3lDb2xvciwgaGVtaURpZmZ1c2VXZWlnaHQgKTsKCQlyZXR1cm4gaXJyYWRpYW5jZTsKCX0KI2VuZGlmYCxPZz1gI2lmZGVmIFVTRV9FTlZNQVAKCXZlYzMgZ2V0SUJMSXJyYWRpYW5jZSggY29uc3QgaW4gdmVjMyBub3JtYWwgKSB7CgkJI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVfVVYKCQkJdmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApOwoJCQl2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVVViggZW52TWFwLCB3b3JsZE5vcm1hbCwgMS4wICk7CgkJCXJldHVybiBQSSAqIGVudk1hcENvbG9yLnJnYiAqIGVudk1hcEludGVuc2l0eTsKCQkjZWxzZQoJCQlyZXR1cm4gdmVjMyggMC4wICk7CgkJI2VuZGlmCgl9Cgl2ZWMzIGdldElCTFJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7CgkJI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVfVVYKCQkJdmVjMyByZWZsZWN0VmVjID0gcmVmbGVjdCggLSB2aWV3RGlyLCBub3JtYWwgKTsKCQkJcmVmbGVjdFZlYyA9IG5vcm1hbGl6ZSggbWl4KCByZWZsZWN0VmVjLCBub3JtYWwsIHJvdWdobmVzcyAqIHJvdWdobmVzcykgKTsKCQkJcmVmbGVjdFZlYyA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHJlZmxlY3RWZWMsIHZpZXdNYXRyaXggKTsKCQkJdmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlVVYoIGVudk1hcCwgcmVmbGVjdFZlYywgcm91Z2huZXNzICk7CgkJCXJldHVybiBlbnZNYXBDb2xvci5yZ2IgKiBlbnZNYXBJbnRlbnNpdHk7CgkJI2Vsc2UKCQkJcmV0dXJuIHZlYzMoIDAuMCApOwoJCSNlbmRpZgoJfQoJI2lmZGVmIFVTRV9BTklTT1RST1BZCgkJdmVjMyBnZXRJQkxBbmlzb3Ryb3B5UmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gdmVjMyBiaXRhbmdlbnQsIGNvbnN0IGluIGZsb2F0IGFuaXNvdHJvcHkgKSB7CgkJCSNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFX1VWCgkJCQl2ZWMzIGJlbnROb3JtYWwgPSBjcm9zcyggYml0YW5nZW50LCB2aWV3RGlyICk7CgkJCQliZW50Tm9ybWFsID0gbm9ybWFsaXplKCBjcm9zcyggYmVudE5vcm1hbCwgYml0YW5nZW50ICkgKTsKCQkJCWJlbnROb3JtYWwgPSBub3JtYWxpemUoIG1peCggYmVudE5vcm1hbCwgbm9ybWFsLCBwb3cyKCBwb3cyKCAxLjAgLSBhbmlzb3Ryb3B5ICogKCAxLjAgLSByb3VnaG5lc3MgKSApICkgKSApOwoJCQkJcmV0dXJuIGdldElCTFJhZGlhbmNlKCB2aWV3RGlyLCBiZW50Tm9ybWFsLCByb3VnaG5lc3MgKTsKCQkJI2Vsc2UKCQkJCXJldHVybiB2ZWMzKCAwLjAgKTsKCQkJI2VuZGlmCgkJfQoJI2VuZGlmCiNlbmRpZmAsRmc9YFRvb25NYXRlcmlhbCBtYXRlcmlhbDsKbWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYjtgLEJnPWB2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjsKc3RydWN0IFRvb25NYXRlcmlhbCB7Cgl2ZWMzIGRpZmZ1c2VDb2xvcjsKfTsKdm9pZCBSRV9EaXJlY3RfVG9vbiggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Tm9ybWFsLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Vmlld0RpciwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgY29uc3QgaW4gVG9vbk1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHsKCXZlYzMgaXJyYWRpYW5jZSA9IGdldEdyYWRpZW50SXJyYWRpYW5jZSggZ2VvbWV0cnlOb3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICogZGlyZWN0TGlnaHQuY29sb3I7CglyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApOwp9CnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX1Rvb24oIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Tm9ybWFsLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Vmlld0RpciwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgY29uc3QgaW4gVG9vbk1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHsKCXJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTsKfQojZGVmaW5lIFJFX0RpcmVjdAkJCQlSRV9EaXJlY3RfVG9vbgojZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZQkJUkVfSW5kaXJlY3REaWZmdXNlX1Rvb25gLHpnPWBCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWw7Cm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2I7Cm1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBzcGVjdWxhcjsKbWF0ZXJpYWwuc3BlY3VsYXJTaGluaW5lc3MgPSBzaGluaW5lc3M7Cm1hdGVyaWFsLnNwZWN1bGFyU3RyZW5ndGggPSBzcGVjdWxhclN0cmVuZ3RoO2AsVmc9YHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uOwpzdHJ1Y3QgQmxpbm5QaG9uZ01hdGVyaWFsIHsKCXZlYzMgZGlmZnVzZUNvbG9yOwoJdmVjMyBzcGVjdWxhckNvbG9yOwoJZmxvYXQgc3BlY3VsYXJTaGluaW5lc3M7CglmbG9hdCBzcGVjdWxhclN0cmVuZ3RoOwp9Owp2b2lkIFJFX0RpcmVjdF9CbGlublBob25nKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlOb3JtYWwsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlWaWV3RGlyLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBjb25zdCBpbiBCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkgewoJZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeU5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTsKCXZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7CglyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApOwoJcmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gaXJyYWRpYW5jZSAqIEJSREZfQmxpbm5QaG9uZyggZGlyZWN0TGlnaHQuZGlyZWN0aW9uLCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Tm9ybWFsLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhclNoaW5pbmVzcyApICogbWF0ZXJpYWwuc3BlY3VsYXJTdHJlbmd0aDsKfQp2b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9CbGlublBob25nKCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlQb3NpdGlvbiwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeU5vcm1hbCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVZpZXdEaXIsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGNvbnN0IGluIEJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7CglyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7Cn0KI2RlZmluZSBSRV9EaXJlY3QJCQkJUkVfRGlyZWN0X0JsaW5uUGhvbmcKI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2UJCVJFX0luZGlyZWN0RGlmZnVzZV9CbGlublBob25nYCxrZz1gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbDsKbWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYiAqICggMS4wIC0gbWV0YWxuZXNzRmFjdG9yICk7CnZlYzMgZHh5ID0gbWF4KCBhYnMoIGRGZHgoIG5vblBlcnR1cmJlZE5vcm1hbCApICksIGFicyggZEZkeSggbm9uUGVydHVyYmVkTm9ybWFsICkgKSApOwpmbG9hdCBnZW9tZXRyeVJvdWdobmVzcyA9IG1heCggbWF4KCBkeHkueCwgZHh5LnkgKSwgZHh5LnogKTsKbWF0ZXJpYWwucm91Z2huZXNzID0gbWF4KCByb3VnaG5lc3NGYWN0b3IsIDAuMDUyNSApO21hdGVyaWFsLnJvdWdobmVzcyArPSBnZW9tZXRyeVJvdWdobmVzczsKbWF0ZXJpYWwucm91Z2huZXNzID0gbWluKCBtYXRlcmlhbC5yb3VnaG5lc3MsIDEuMCApOwojaWZkZWYgSU9SCgltYXRlcmlhbC5pb3IgPSBpb3I7CgkjaWZkZWYgVVNFX1NQRUNVTEFSCgkJZmxvYXQgc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IgPSBzcGVjdWxhckludGVuc2l0eTsKCQl2ZWMzIHNwZWN1bGFyQ29sb3JGYWN0b3IgPSBzcGVjdWxhckNvbG9yOwoJCSNpZmRlZiBVU0VfU1BFQ1VMQVJfQ09MT1JNQVAKCQkJc3BlY3VsYXJDb2xvckZhY3RvciAqPSB0ZXh0dXJlMkQoIHNwZWN1bGFyQ29sb3JNYXAsIHZTcGVjdWxhckNvbG9yTWFwVXYgKS5yZ2I7CgkJI2VuZGlmCgkJI2lmZGVmIFVTRV9TUEVDVUxBUl9JTlRFTlNJVFlNQVAKCQkJc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IgKj0gdGV4dHVyZTJEKCBzcGVjdWxhckludGVuc2l0eU1hcCwgdlNwZWN1bGFySW50ZW5zaXR5TWFwVXYgKS5hOwoJCSNlbmRpZgoJCW1hdGVyaWFsLnNwZWN1bGFyRjkwID0gbWl4KCBzcGVjdWxhckludGVuc2l0eUZhY3RvciwgMS4wLCBtZXRhbG5lc3NGYWN0b3IgKTsKCSNlbHNlCgkJZmxvYXQgc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IgPSAxLjA7CgkJdmVjMyBzcGVjdWxhckNvbG9yRmFjdG9yID0gdmVjMyggMS4wICk7CgkJbWF0ZXJpYWwuc3BlY3VsYXJGOTAgPSAxLjA7CgkjZW5kaWYKCW1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBtaXgoIG1pbiggcG93MiggKCBtYXRlcmlhbC5pb3IgLSAxLjAgKSAvICggbWF0ZXJpYWwuaW9yICsgMS4wICkgKSAqIHNwZWN1bGFyQ29sb3JGYWN0b3IsIHZlYzMoIDEuMCApICkgKiBzcGVjdWxhckludGVuc2l0eUZhY3RvciwgZGlmZnVzZUNvbG9yLnJnYiwgbWV0YWxuZXNzRmFjdG9yICk7CiNlbHNlCgltYXRlcmlhbC5zcGVjdWxhckNvbG9yID0gbWl4KCB2ZWMzKCAwLjA0ICksIGRpZmZ1c2VDb2xvci5yZ2IsIG1ldGFsbmVzc0ZhY3RvciApOwoJbWF0ZXJpYWwuc3BlY3VsYXJGOTAgPSAxLjA7CiNlbmRpZgojaWZkZWYgVVNFX0NMRUFSQ09BVAoJbWF0ZXJpYWwuY2xlYXJjb2F0ID0gY2xlYXJjb2F0OwoJbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzID0gY2xlYXJjb2F0Um91Z2huZXNzOwoJbWF0ZXJpYWwuY2xlYXJjb2F0RjAgPSB2ZWMzKCAwLjA0ICk7CgltYXRlcmlhbC5jbGVhcmNvYXRGOTAgPSAxLjA7CgkjaWZkZWYgVVNFX0NMRUFSQ09BVE1BUAoJCW1hdGVyaWFsLmNsZWFyY29hdCAqPSB0ZXh0dXJlMkQoIGNsZWFyY29hdE1hcCwgdkNsZWFyY29hdE1hcFV2ICkueDsKCSNlbmRpZgoJI2lmZGVmIFVTRV9DTEVBUkNPQVRfUk9VR0hORVNTTUFQCgkJbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzICo9IHRleHR1cmUyRCggY2xlYXJjb2F0Um91Z2huZXNzTWFwLCB2Q2xlYXJjb2F0Um91Z2huZXNzTWFwVXYgKS55OwoJI2VuZGlmCgltYXRlcmlhbC5jbGVhcmNvYXQgPSBzYXR1cmF0ZSggbWF0ZXJpYWwuY2xlYXJjb2F0ICk7CW1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyA9IG1heCggbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzLCAwLjA1MjUgKTsKCW1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyArPSBnZW9tZXRyeVJvdWdobmVzczsKCW1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyA9IG1pbiggbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzLCAxLjAgKTsKI2VuZGlmCiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0UKCW1hdGVyaWFsLmlyaWRlc2NlbmNlID0gaXJpZGVzY2VuY2U7CgltYXRlcmlhbC5pcmlkZXNjZW5jZUlPUiA9IGlyaWRlc2NlbmNlSU9SOwoJI2lmZGVmIFVTRV9JUklERVNDRU5DRU1BUAoJCW1hdGVyaWFsLmlyaWRlc2NlbmNlICo9IHRleHR1cmUyRCggaXJpZGVzY2VuY2VNYXAsIHZJcmlkZXNjZW5jZU1hcFV2ICkucjsKCSNlbmRpZgoJI2lmZGVmIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVAKCQltYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzcyA9IChpcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW0gLSBpcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW0pICogdGV4dHVyZTJEKCBpcmlkZXNjZW5jZVRoaWNrbmVzc01hcCwgdklyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVXYgKS5nICsgaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtOwoJI2Vsc2UKCQltYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzcyA9IGlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bTsKCSNlbmRpZgojZW5kaWYKI2lmZGVmIFVTRV9TSEVFTgoJbWF0ZXJpYWwuc2hlZW5Db2xvciA9IHNoZWVuQ29sb3I7CgkjaWZkZWYgVVNFX1NIRUVOX0NPTE9STUFQCgkJbWF0ZXJpYWwuc2hlZW5Db2xvciAqPSB0ZXh0dXJlMkQoIHNoZWVuQ29sb3JNYXAsIHZTaGVlbkNvbG9yTWFwVXYgKS5yZ2I7CgkjZW5kaWYKCW1hdGVyaWFsLnNoZWVuUm91Z2huZXNzID0gY2xhbXAoIHNoZWVuUm91Z2huZXNzLCAwLjA3LCAxLjAgKTsKCSNpZmRlZiBVU0VfU0hFRU5fUk9VR0hORVNTTUFQCgkJbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3MgKj0gdGV4dHVyZTJEKCBzaGVlblJvdWdobmVzc01hcCwgdlNoZWVuUm91Z2huZXNzTWFwVXYgKS5hOwoJI2VuZGlmCiNlbmRpZgojaWZkZWYgVVNFX0FOSVNPVFJPUFkKCSNpZmRlZiBVU0VfQU5JU09UUk9QWU1BUAoJCW1hdDIgYW5pc290cm9weU1hdCA9IG1hdDIoIGFuaXNvdHJvcHlWZWN0b3IueCwgYW5pc290cm9weVZlY3Rvci55LCAtIGFuaXNvdHJvcHlWZWN0b3IueSwgYW5pc290cm9weVZlY3Rvci54ICk7CgkJdmVjMyBhbmlzb3Ryb3B5UG9sYXIgPSB0ZXh0dXJlMkQoIGFuaXNvdHJvcHlNYXAsIHZBbmlzb3Ryb3B5TWFwVXYgKS5yZ2I7CgkJdmVjMiBhbmlzb3Ryb3B5ViA9IGFuaXNvdHJvcHlNYXQgKiBub3JtYWxpemUoIDIuMCAqIGFuaXNvdHJvcHlQb2xhci5yZyAtIHZlYzIoIDEuMCApICkgKiBhbmlzb3Ryb3B5UG9sYXIuYjsKCSNlbHNlCgkJdmVjMiBhbmlzb3Ryb3B5ViA9IGFuaXNvdHJvcHlWZWN0b3I7CgkjZW5kaWYKCW1hdGVyaWFsLmFuaXNvdHJvcHkgPSBsZW5ndGgoIGFuaXNvdHJvcHlWICk7CglpZiggbWF0ZXJpYWwuYW5pc290cm9weSA9PSAwLjAgKSB7CgkJYW5pc290cm9weVYgPSB2ZWMyKCAxLjAsIDAuMCApOwoJfSBlbHNlIHsKCQlhbmlzb3Ryb3B5ViAvPSBtYXRlcmlhbC5hbmlzb3Ryb3B5OwoJCW1hdGVyaWFsLmFuaXNvdHJvcHkgPSBzYXR1cmF0ZSggbWF0ZXJpYWwuYW5pc290cm9weSApOwoJfQoJbWF0ZXJpYWwuYWxwaGFUID0gbWl4KCBwb3cyKCBtYXRlcmlhbC5yb3VnaG5lc3MgKSwgMS4wLCBwb3cyKCBtYXRlcmlhbC5hbmlzb3Ryb3B5ICkgKTsKCW1hdGVyaWFsLmFuaXNvdHJvcHlUID0gdGJuWyAwIF0gKiBhbmlzb3Ryb3B5Vi54ICsgdGJuWyAxIF0gKiBhbmlzb3Ryb3B5Vi55OwoJbWF0ZXJpYWwuYW5pc290cm9weUIgPSB0Ym5bIDEgXSAqIGFuaXNvdHJvcHlWLnggLSB0Ym5bIDAgXSAqIGFuaXNvdHJvcHlWLnk7CiNlbmRpZmAsSGc9YHN0cnVjdCBQaHlzaWNhbE1hdGVyaWFsIHsKCXZlYzMgZGlmZnVzZUNvbG9yOwoJZmxvYXQgcm91Z2huZXNzOwoJdmVjMyBzcGVjdWxhckNvbG9yOwoJZmxvYXQgc3BlY3VsYXJGOTA7CgkjaWZkZWYgVVNFX0NMRUFSQ09BVAoJCWZsb2F0IGNsZWFyY29hdDsKCQlmbG9hdCBjbGVhcmNvYXRSb3VnaG5lc3M7CgkJdmVjMyBjbGVhcmNvYXRGMDsKCQlmbG9hdCBjbGVhcmNvYXRGOTA7CgkjZW5kaWYKCSNpZmRlZiBVU0VfSVJJREVTQ0VOQ0UKCQlmbG9hdCBpcmlkZXNjZW5jZTsKCQlmbG9hdCBpcmlkZXNjZW5jZUlPUjsKCQlmbG9hdCBpcmlkZXNjZW5jZVRoaWNrbmVzczsKCQl2ZWMzIGlyaWRlc2NlbmNlRnJlc25lbDsKCQl2ZWMzIGlyaWRlc2NlbmNlRjA7CgkjZW5kaWYKCSNpZmRlZiBVU0VfU0hFRU4KCQl2ZWMzIHNoZWVuQ29sb3I7CgkJZmxvYXQgc2hlZW5Sb3VnaG5lc3M7CgkjZW5kaWYKCSNpZmRlZiBJT1IKCQlmbG9hdCBpb3I7CgkjZW5kaWYKCSNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OCgkJZmxvYXQgdHJhbnNtaXNzaW9uOwoJCWZsb2F0IHRyYW5zbWlzc2lvbkFscGhhOwoJCWZsb2F0IHRoaWNrbmVzczsKCQlmbG9hdCBhdHRlbnVhdGlvbkRpc3RhbmNlOwoJCXZlYzMgYXR0ZW51YXRpb25Db2xvcjsKCSNlbmRpZgoJI2lmZGVmIFVTRV9BTklTT1RST1BZCgkJZmxvYXQgYW5pc290cm9weTsKCQlmbG9hdCBhbHBoYVQ7CgkJdmVjMyBhbmlzb3Ryb3B5VDsKCQl2ZWMzIGFuaXNvdHJvcHlCOwoJI2VuZGlmCn07CnZlYzMgY2xlYXJjb2F0U3BlY3VsYXJEaXJlY3QgPSB2ZWMzKCAwLjAgKTsKdmVjMyBjbGVhcmNvYXRTcGVjdWxhckluZGlyZWN0ID0gdmVjMyggMC4wICk7CnZlYzMgc2hlZW5TcGVjdWxhckRpcmVjdCA9IHZlYzMoIDAuMCApOwp2ZWMzIHNoZWVuU3BlY3VsYXJJbmRpcmVjdCA9IHZlYzMoMC4wICk7CnZlYzMgU2NobGlja190b19GMCggY29uc3QgaW4gdmVjMyBmLCBjb25zdCBpbiBmbG9hdCBmOTAsIGNvbnN0IGluIGZsb2F0IGRvdFZIICkgewogICAgZmxvYXQgeCA9IGNsYW1wKCAxLjAgLSBkb3RWSCwgMC4wLCAxLjAgKTsKICAgIGZsb2F0IHgyID0geCAqIHg7CiAgICBmbG9hdCB4NSA9IGNsYW1wKCB4ICogeDIgKiB4MiwgMC4wLCAwLjk5OTkgKTsKICAgIHJldHVybiAoIGYgLSB2ZWMzKCBmOTAgKSAqIHg1ICkgLyAoIDEuMCAtIHg1ICk7Cn0KZmxvYXQgVl9HR1hfU21pdGhDb3JyZWxhdGVkKCBjb25zdCBpbiBmbG9hdCBhbHBoYSwgY29uc3QgaW4gZmxvYXQgZG90TkwsIGNvbnN0IGluIGZsb2F0IGRvdE5WICkgewoJZmxvYXQgYTIgPSBwb3cyKCBhbHBoYSApOwoJZmxvYXQgZ3YgPSBkb3ROTCAqIHNxcnQoIGEyICsgKCAxLjAgLSBhMiApICogcG93MiggZG90TlYgKSApOwoJZmxvYXQgZ2wgPSBkb3ROViAqIHNxcnQoIGEyICsgKCAxLjAgLSBhMiApICogcG93MiggZG90TkwgKSApOwoJcmV0dXJuIDAuNSAvIG1heCggZ3YgKyBnbCwgRVBTSUxPTiApOwp9CmZsb2F0IERfR0dYKCBjb25zdCBpbiBmbG9hdCBhbHBoYSwgY29uc3QgaW4gZmxvYXQgZG90TkggKSB7CglmbG9hdCBhMiA9IHBvdzIoIGFscGhhICk7CglmbG9hdCBkZW5vbSA9IHBvdzIoIGRvdE5IICkgKiAoIGEyIC0gMS4wICkgKyAxLjA7CglyZXR1cm4gUkVDSVBST0NBTF9QSSAqIGEyIC8gcG93MiggZGVub20gKTsKfQojaWZkZWYgVVNFX0FOSVNPVFJPUFkKCWZsb2F0IFZfR0dYX1NtaXRoQ29ycmVsYXRlZF9Bbmlzb3Ryb3BpYyggY29uc3QgaW4gZmxvYXQgYWxwaGFULCBjb25zdCBpbiBmbG9hdCBhbHBoYUIsIGNvbnN0IGluIGZsb2F0IGRvdFRWLCBjb25zdCBpbiBmbG9hdCBkb3RCViwgY29uc3QgaW4gZmxvYXQgZG90VEwsIGNvbnN0IGluIGZsb2F0IGRvdEJMLCBjb25zdCBpbiBmbG9hdCBkb3ROViwgY29uc3QgaW4gZmxvYXQgZG90TkwgKSB7CgkJZmxvYXQgZ3YgPSBkb3ROTCAqIGxlbmd0aCggdmVjMyggYWxwaGFUICogZG90VFYsIGFscGhhQiAqIGRvdEJWLCBkb3ROViApICk7CgkJZmxvYXQgZ2wgPSBkb3ROViAqIGxlbmd0aCggdmVjMyggYWxwaGFUICogZG90VEwsIGFscGhhQiAqIGRvdEJMLCBkb3ROTCApICk7CgkJZmxvYXQgdiA9IDAuNSAvICggZ3YgKyBnbCApOwoJCXJldHVybiBzYXR1cmF0ZSh2KTsKCX0KCWZsb2F0IERfR0dYX0FuaXNvdHJvcGljKCBjb25zdCBpbiBmbG9hdCBhbHBoYVQsIGNvbnN0IGluIGZsb2F0IGFscGhhQiwgY29uc3QgaW4gZmxvYXQgZG90TkgsIGNvbnN0IGluIGZsb2F0IGRvdFRILCBjb25zdCBpbiBmbG9hdCBkb3RCSCApIHsKCQlmbG9hdCBhMiA9IGFscGhhVCAqIGFscGhhQjsKCQloaWdocCB2ZWMzIHYgPSB2ZWMzKCBhbHBoYUIgKiBkb3RUSCwgYWxwaGFUICogZG90QkgsIGEyICogZG90TkggKTsKCQloaWdocCBmbG9hdCB2MiA9IGRvdCggdiwgdiApOwoJCWZsb2F0IHcyID0gYTIgLyB2MjsKCQlyZXR1cm4gUkVDSVBST0NBTF9QSSAqIGEyICogcG93MiAoIHcyICk7Cgl9CiNlbmRpZgojaWZkZWYgVVNFX0NMRUFSQ09BVAoJdmVjMyBCUkRGX0dHWF9DbGVhcmNvYXQoIGNvbnN0IGluIHZlYzMgbGlnaHREaXIsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwpIHsKCQl2ZWMzIGYwID0gbWF0ZXJpYWwuY2xlYXJjb2F0RjA7CgkJZmxvYXQgZjkwID0gbWF0ZXJpYWwuY2xlYXJjb2F0RjkwOwoJCWZsb2F0IHJvdWdobmVzcyA9IG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzczsKCQlmbG9hdCBhbHBoYSA9IHBvdzIoIHJvdWdobmVzcyApOwoJCXZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7CgkJZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTsKCQlmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7CgkJZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApOwoJCWZsb2F0IGRvdFZIID0gc2F0dXJhdGUoIGRvdCggdmlld0RpciwgaGFsZkRpciApICk7CgkJdmVjMyBGID0gRl9TY2hsaWNrKCBmMCwgZjkwLCBkb3RWSCApOwoJCWZsb2F0IFYgPSBWX0dHWF9TbWl0aENvcnJlbGF0ZWQoIGFscGhhLCBkb3ROTCwgZG90TlYgKTsKCQlmbG9hdCBEID0gRF9HR1goIGFscGhhLCBkb3ROSCApOwoJCXJldHVybiBGICogKCBWICogRCApOwoJfQojZW5kaWYKdmVjMyBCUkRGX0dHWCggY29uc3QgaW4gdmVjMyBsaWdodERpciwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCApIHsKCXZlYzMgZjAgPSBtYXRlcmlhbC5zcGVjdWxhckNvbG9yOwoJZmxvYXQgZjkwID0gbWF0ZXJpYWwuc3BlY3VsYXJGOTA7CglmbG9hdCByb3VnaG5lc3MgPSBtYXRlcmlhbC5yb3VnaG5lc3M7CglmbG9hdCBhbHBoYSA9IHBvdzIoIHJvdWdobmVzcyApOwoJdmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBsaWdodERpciArIHZpZXdEaXIgKTsKCWZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBsaWdodERpciApICk7CglmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7CglmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgaGFsZkRpciApICk7CglmbG9hdCBkb3RWSCA9IHNhdHVyYXRlKCBkb3QoIHZpZXdEaXIsIGhhbGZEaXIgKSApOwoJdmVjMyBGID0gRl9TY2hsaWNrKCBmMCwgZjkwLCBkb3RWSCApOwoJI2lmZGVmIFVTRV9JUklERVNDRU5DRQoJCUYgPSBtaXgoIEYsIG1hdGVyaWFsLmlyaWRlc2NlbmNlRnJlc25lbCwgbWF0ZXJpYWwuaXJpZGVzY2VuY2UgKTsKCSNlbmRpZgoJI2lmZGVmIFVTRV9BTklTT1RST1BZCgkJZmxvYXQgZG90VEwgPSBkb3QoIG1hdGVyaWFsLmFuaXNvdHJvcHlULCBsaWdodERpciApOwoJCWZsb2F0IGRvdFRWID0gZG90KCBtYXRlcmlhbC5hbmlzb3Ryb3B5VCwgdmlld0RpciApOwoJCWZsb2F0IGRvdFRIID0gZG90KCBtYXRlcmlhbC5hbmlzb3Ryb3B5VCwgaGFsZkRpciApOwoJCWZsb2F0IGRvdEJMID0gZG90KCBtYXRlcmlhbC5hbmlzb3Ryb3B5QiwgbGlnaHREaXIgKTsKCQlmbG9hdCBkb3RCViA9IGRvdCggbWF0ZXJpYWwuYW5pc290cm9weUIsIHZpZXdEaXIgKTsKCQlmbG9hdCBkb3RCSCA9IGRvdCggbWF0ZXJpYWwuYW5pc290cm9weUIsIGhhbGZEaXIgKTsKCQlmbG9hdCBWID0gVl9HR1hfU21pdGhDb3JyZWxhdGVkX0FuaXNvdHJvcGljKCBtYXRlcmlhbC5hbHBoYVQsIGFscGhhLCBkb3RUViwgZG90QlYsIGRvdFRMLCBkb3RCTCwgZG90TlYsIGRvdE5MICk7CgkJZmxvYXQgRCA9IERfR0dYX0FuaXNvdHJvcGljKCBtYXRlcmlhbC5hbHBoYVQsIGFscGhhLCBkb3ROSCwgZG90VEgsIGRvdEJIICk7CgkjZWxzZQoJCWZsb2F0IFYgPSBWX0dHWF9TbWl0aENvcnJlbGF0ZWQoIGFscGhhLCBkb3ROTCwgZG90TlYgKTsKCQlmbG9hdCBEID0gRF9HR1goIGFscGhhLCBkb3ROSCApOwoJI2VuZGlmCglyZXR1cm4gRiAqICggViAqIEQgKTsKfQp2ZWMyIExUQ19VdiggY29uc3QgaW4gdmVjMyBOLCBjb25zdCBpbiB2ZWMzIFYsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHsKCWNvbnN0IGZsb2F0IExVVF9TSVpFID0gNjQuMDsKCWNvbnN0IGZsb2F0IExVVF9TQ0FMRSA9ICggTFVUX1NJWkUgLSAxLjAgKSAvIExVVF9TSVpFOwoJY29uc3QgZmxvYXQgTFVUX0JJQVMgPSAwLjUgLyBMVVRfU0laRTsKCWZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggTiwgViApICk7Cgl2ZWMyIHV2ID0gdmVjMiggcm91Z2huZXNzLCBzcXJ0KCAxLjAgLSBkb3ROViApICk7Cgl1diA9IHV2ICogTFVUX1NDQUxFICsgTFVUX0JJQVM7CglyZXR1cm4gdXY7Cn0KZmxvYXQgTFRDX0NsaXBwZWRTcGhlcmVGb3JtRmFjdG9yKCBjb25zdCBpbiB2ZWMzIGYgKSB7CglmbG9hdCBsID0gbGVuZ3RoKCBmICk7CglyZXR1cm4gbWF4KCAoIGwgKiBsICsgZi56ICkgLyAoIGwgKyAxLjAgKSwgMC4wICk7Cn0KdmVjMyBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvbnN0IGluIHZlYzMgdjEsIGNvbnN0IGluIHZlYzMgdjIgKSB7CglmbG9hdCB4ID0gZG90KCB2MSwgdjIgKTsKCWZsb2F0IHkgPSBhYnMoIHggKTsKCWZsb2F0IGEgPSAwLjg1NDM5ODUgKyAoIDAuNDk2NTE1NSArIDAuMDE0NTIwNiAqIHkgKSAqIHk7CglmbG9hdCBiID0gMy40MTc1OTQwICsgKCA0LjE2MTY3MjQgKyB5ICkgKiB5OwoJZmxvYXQgdiA9IGEgLyBiOwoJZmxvYXQgdGhldGFfc2ludGhldGEgPSAoIHggPiAwLjAgKSA/IHYgOiAwLjUgKiBpbnZlcnNlc3FydCggbWF4KCAxLjAgLSB4ICogeCwgMWUtNyApICkgLSB2OwoJcmV0dXJuIGNyb3NzKCB2MSwgdjIgKSAqIHRoZXRhX3NpbnRoZXRhOwp9CnZlYzMgTFRDX0V2YWx1YXRlKCBjb25zdCBpbiB2ZWMzIE4sIGNvbnN0IGluIHZlYzMgViwgY29uc3QgaW4gdmVjMyBQLCBjb25zdCBpbiBtYXQzIG1JbnYsIGNvbnN0IGluIHZlYzMgcmVjdENvb3Jkc1sgNCBdICkgewoJdmVjMyB2MSA9IHJlY3RDb29yZHNbIDEgXSAtIHJlY3RDb29yZHNbIDAgXTsKCXZlYzMgdjIgPSByZWN0Q29vcmRzWyAzIF0gLSByZWN0Q29vcmRzWyAwIF07Cgl2ZWMzIGxpZ2h0Tm9ybWFsID0gY3Jvc3MoIHYxLCB2MiApOwoJaWYoIGRvdCggbGlnaHROb3JtYWwsIFAgLSByZWN0Q29vcmRzWyAwIF0gKSA8IDAuMCApIHJldHVybiB2ZWMzKCAwLjAgKTsKCXZlYzMgVDEsIFQyOwoJVDEgPSBub3JtYWxpemUoIFYgLSBOICogZG90KCBWLCBOICkgKTsKCVQyID0gLSBjcm9zcyggTiwgVDEgKTsKCW1hdDMgbWF0ID0gbUludiAqIHRyYW5zcG9zZU1hdDMoIG1hdDMoIFQxLCBUMiwgTiApICk7Cgl2ZWMzIGNvb3Jkc1sgNCBdOwoJY29vcmRzWyAwIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDAgXSAtIFAgKTsKCWNvb3Jkc1sgMSBdID0gbWF0ICogKCByZWN0Q29vcmRzWyAxIF0gLSBQICk7Cgljb29yZHNbIDIgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMiBdIC0gUCApOwoJY29vcmRzWyAzIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDMgXSAtIFAgKTsKCWNvb3Jkc1sgMCBdID0gbm9ybWFsaXplKCBjb29yZHNbIDAgXSApOwoJY29vcmRzWyAxIF0gPSBub3JtYWxpemUoIGNvb3Jkc1sgMSBdICk7Cgljb29yZHNbIDIgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAyIF0gKTsKCWNvb3Jkc1sgMyBdID0gbm9ybWFsaXplKCBjb29yZHNbIDMgXSApOwoJdmVjMyB2ZWN0b3JGb3JtRmFjdG9yID0gdmVjMyggMC4wICk7Cgl2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAwIF0sIGNvb3Jkc1sgMSBdICk7Cgl2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAxIF0sIGNvb3Jkc1sgMiBdICk7Cgl2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAyIF0sIGNvb3Jkc1sgMyBdICk7Cgl2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAzIF0sIGNvb3Jkc1sgMCBdICk7CglmbG9hdCByZXN1bHQgPSBMVENfQ2xpcHBlZFNwaGVyZUZvcm1GYWN0b3IoIHZlY3RvckZvcm1GYWN0b3IgKTsKCXJldHVybiB2ZWMzKCByZXN1bHQgKTsKfQojaWYgZGVmaW5lZCggVVNFX1NIRUVOICkKZmxvYXQgRF9DaGFybGllKCBmbG9hdCByb3VnaG5lc3MsIGZsb2F0IGRvdE5IICkgewoJZmxvYXQgYWxwaGEgPSBwb3cyKCByb3VnaG5lc3MgKTsKCWZsb2F0IGludkFscGhhID0gMS4wIC8gYWxwaGE7CglmbG9hdCBjb3MyaCA9IGRvdE5IICogZG90Tkg7CglmbG9hdCBzaW4yaCA9IG1heCggMS4wIC0gY29zMmgsIDAuMDA3ODEyNSApOwoJcmV0dXJuICggMi4wICsgaW52QWxwaGEgKSAqIHBvdyggc2luMmgsIGludkFscGhhICogMC41ICkgLyAoIDIuMCAqIFBJICk7Cn0KZmxvYXQgVl9OZXViZWx0KCBmbG9hdCBkb3ROViwgZmxvYXQgZG90TkwgKSB7CglyZXR1cm4gc2F0dXJhdGUoIDEuMCAvICggNC4wICogKCBkb3ROTCArIGRvdE5WIC0gZG90TkwgKiBkb3ROViApICkgKTsKfQp2ZWMzIEJSREZfU2hlZW4oIGNvbnN0IGluIHZlYzMgbGlnaHREaXIsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBub3JtYWwsIHZlYzMgc2hlZW5Db2xvciwgY29uc3QgaW4gZmxvYXQgc2hlZW5Sb3VnaG5lc3MgKSB7Cgl2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGxpZ2h0RGlyICsgdmlld0RpciApOwoJZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTsKCWZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCB2aWV3RGlyICkgKTsKCWZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBoYWxmRGlyICkgKTsKCWZsb2F0IEQgPSBEX0NoYXJsaWUoIHNoZWVuUm91Z2huZXNzLCBkb3ROSCApOwoJZmxvYXQgViA9IFZfTmV1YmVsdCggZG90TlYsIGRvdE5MICk7CglyZXR1cm4gc2hlZW5Db2xvciAqICggRCAqIFYgKTsKfQojZW5kaWYKZmxvYXQgSUJMU2hlZW5CUkRGKCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7CglmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7CglmbG9hdCByMiA9IHJvdWdobmVzcyAqIHJvdWdobmVzczsKCWZsb2F0IGEgPSByb3VnaG5lc3MgPCAwLjI1ID8gLTMzOS4yICogcjIgKyAxNjEuNCAqIHJvdWdobmVzcyAtIDI1LjkgOiAtOC40OCAqIHIyICsgMTQuMyAqIHJvdWdobmVzcyAtIDkuOTU7CglmbG9hdCBiID0gcm91Z2huZXNzIDwgMC4yNSA/IDQ0LjAgKiByMiAtIDIzLjcgKiByb3VnaG5lc3MgKyAzLjI2IDogMS45NyAqIHIyIC0gMy4yNyAqIHJvdWdobmVzcyArIDAuNzI7CglmbG9hdCBERyA9IGV4cCggYSAqIGRvdE5WICsgYiApICsgKCByb3VnaG5lc3MgPCAwLjI1ID8gMC4wIDogMC4xICogKCByb3VnaG5lc3MgLSAwLjI1ICkgKTsKCXJldHVybiBzYXR1cmF0ZSggREcgKiBSRUNJUFJPQ0FMX1BJICk7Cn0KdmVjMiBERkdBcHByb3goIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHsKCWZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCB2aWV3RGlyICkgKTsKCWNvbnN0IHZlYzQgYzAgPSB2ZWM0KCAtIDEsIC0gMC4wMjc1LCAtIDAuNTcyLCAwLjAyMiApOwoJY29uc3QgdmVjNCBjMSA9IHZlYzQoIDEsIDAuMDQyNSwgMS4wNCwgLSAwLjA0ICk7Cgl2ZWM0IHIgPSByb3VnaG5lc3MgKiBjMCArIGMxOwoJZmxvYXQgYTAwNCA9IG1pbiggci54ICogci54LCBleHAyKCAtIDkuMjggKiBkb3ROViApICkgKiByLnggKyByLnk7Cgl2ZWMyIGZhYiA9IHZlYzIoIC0gMS4wNCwgMS4wNCApICogYTAwNCArIHIuenc7CglyZXR1cm4gZmFiOwp9CnZlYzMgRW52aXJvbm1lbnRCUkRGKCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNwZWN1bGFyRjkwLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7Cgl2ZWMyIGZhYiA9IERGR0FwcHJveCggbm9ybWFsLCB2aWV3RGlyLCByb3VnaG5lc3MgKTsKCXJldHVybiBzcGVjdWxhckNvbG9yICogZmFiLnggKyBzcGVjdWxhckY5MCAqIGZhYi55Owp9CiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0UKdm9pZCBjb21wdXRlTXVsdGlzY2F0dGVyaW5nSXJpZGVzY2VuY2UoIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgc3BlY3VsYXJGOTAsIGNvbnN0IGluIGZsb2F0IGlyaWRlc2NlbmNlLCBjb25zdCBpbiB2ZWMzIGlyaWRlc2NlbmNlRjAsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgaW5vdXQgdmVjMyBzaW5nbGVTY2F0dGVyLCBpbm91dCB2ZWMzIG11bHRpU2NhdHRlciApIHsKI2Vsc2UKdm9pZCBjb21wdXRlTXVsdGlzY2F0dGVyaW5nKCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNwZWN1bGFyRjkwLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGlub3V0IHZlYzMgc2luZ2xlU2NhdHRlciwgaW5vdXQgdmVjMyBtdWx0aVNjYXR0ZXIgKSB7CiNlbmRpZgoJdmVjMiBmYWIgPSBERkdBcHByb3goIG5vcm1hbCwgdmlld0Rpciwgcm91Z2huZXNzICk7CgkjaWZkZWYgVVNFX0lSSURFU0NFTkNFCgkJdmVjMyBGciA9IG1peCggc3BlY3VsYXJDb2xvciwgaXJpZGVzY2VuY2VGMCwgaXJpZGVzY2VuY2UgKTsKCSNlbHNlCgkJdmVjMyBGciA9IHNwZWN1bGFyQ29sb3I7CgkjZW5kaWYKCXZlYzMgRnNzRXNzID0gRnIgKiBmYWIueCArIHNwZWN1bGFyRjkwICogZmFiLnk7CglmbG9hdCBFc3MgPSBmYWIueCArIGZhYi55OwoJZmxvYXQgRW1zID0gMS4wIC0gRXNzOwoJdmVjMyBGYXZnID0gRnIgKyAoIDEuMCAtIEZyICkgKiAwLjA0NzYxOTsJdmVjMyBGbXMgPSBGc3NFc3MgKiBGYXZnIC8gKCAxLjAgLSBFbXMgKiBGYXZnICk7CglzaW5nbGVTY2F0dGVyICs9IEZzc0VzczsKCW11bHRpU2NhdHRlciArPSBGbXMgKiBFbXM7Cn0KI2lmIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMAoJdm9pZCBSRV9EaXJlY3RfUmVjdEFyZWFfUGh5c2ljYWwoIGNvbnN0IGluIFJlY3RBcmVhTGlnaHQgcmVjdEFyZWFMaWdodCwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Tm9ybWFsLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Vmlld0RpciwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7CgkJdmVjMyBub3JtYWwgPSBnZW9tZXRyeU5vcm1hbDsKCQl2ZWMzIHZpZXdEaXIgPSBnZW9tZXRyeVZpZXdEaXI7CgkJdmVjMyBwb3NpdGlvbiA9IGdlb21ldHJ5UG9zaXRpb247CgkJdmVjMyBsaWdodFBvcyA9IHJlY3RBcmVhTGlnaHQucG9zaXRpb247CgkJdmVjMyBoYWxmV2lkdGggPSByZWN0QXJlYUxpZ2h0LmhhbGZXaWR0aDsKCQl2ZWMzIGhhbGZIZWlnaHQgPSByZWN0QXJlYUxpZ2h0LmhhbGZIZWlnaHQ7CgkJdmVjMyBsaWdodENvbG9yID0gcmVjdEFyZWFMaWdodC5jb2xvcjsKCQlmbG9hdCByb3VnaG5lc3MgPSBtYXRlcmlhbC5yb3VnaG5lc3M7CgkJdmVjMyByZWN0Q29vcmRzWyA0IF07CgkJcmVjdENvb3Jkc1sgMCBdID0gbGlnaHRQb3MgKyBoYWxmV2lkdGggLSBoYWxmSGVpZ2h0OwkJcmVjdENvb3Jkc1sgMSBdID0gbGlnaHRQb3MgLSBoYWxmV2lkdGggLSBoYWxmSGVpZ2h0OwoJCXJlY3RDb29yZHNbIDIgXSA9IGxpZ2h0UG9zIC0gaGFsZldpZHRoICsgaGFsZkhlaWdodDsKCQlyZWN0Q29vcmRzWyAzIF0gPSBsaWdodFBvcyArIGhhbGZXaWR0aCArIGhhbGZIZWlnaHQ7CgkJdmVjMiB1diA9IExUQ19Vdiggbm9ybWFsLCB2aWV3RGlyLCByb3VnaG5lc3MgKTsKCQl2ZWM0IHQxID0gdGV4dHVyZTJEKCBsdGNfMSwgdXYgKTsKCQl2ZWM0IHQyID0gdGV4dHVyZTJEKCBsdGNfMiwgdXYgKTsKCQltYXQzIG1JbnYgPSBtYXQzKAoJCQl2ZWMzKCB0MS54LCAwLCB0MS55ICksCgkJCXZlYzMoICAgIDAsIDEsICAgIDAgKSwKCQkJdmVjMyggdDEueiwgMCwgdDEudyApCgkJKTsKCQl2ZWMzIGZyZXNuZWwgPSAoIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgKiB0Mi54ICsgKCB2ZWMzKCAxLjAgKSAtIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgKSAqIHQyLnkgKTsKCQlyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBsaWdodENvbG9yICogZnJlc25lbCAqIExUQ19FdmFsdWF0ZSggbm9ybWFsLCB2aWV3RGlyLCBwb3NpdGlvbiwgbUludiwgcmVjdENvb3JkcyApOwoJCXJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gbGlnaHRDb2xvciAqIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciAqIExUQ19FdmFsdWF0ZSggbm9ybWFsLCB2aWV3RGlyLCBwb3NpdGlvbiwgbWF0MyggMS4wICksIHJlY3RDb29yZHMgKTsKCX0KI2VuZGlmCnZvaWQgUkVfRGlyZWN0X1BoeXNpY2FsKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlOb3JtYWwsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlWaWV3RGlyLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHsKCWZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnlOb3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICk7Cgl2ZWMzIGlycmFkaWFuY2UgPSBkb3ROTCAqIGRpcmVjdExpZ2h0LmNvbG9yOwoJI2lmZGVmIFVTRV9DTEVBUkNPQVQKCQlmbG9hdCBkb3ROTGNjID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICk7CgkJdmVjMyBjY0lycmFkaWFuY2UgPSBkb3ROTGNjICogZGlyZWN0TGlnaHQuY29sb3I7CgkJY2xlYXJjb2F0U3BlY3VsYXJEaXJlY3QgKz0gY2NJcnJhZGlhbmNlICogQlJERl9HR1hfQ2xlYXJjb2F0KCBkaXJlY3RMaWdodC5kaXJlY3Rpb24sIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIG1hdGVyaWFsICk7CgkjZW5kaWYKCSNpZmRlZiBVU0VfU0hFRU4KCQlzaGVlblNwZWN1bGFyRGlyZWN0ICs9IGlycmFkaWFuY2UgKiBCUkRGX1NoZWVuKCBkaXJlY3RMaWdodC5kaXJlY3Rpb24sIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlOb3JtYWwsIG1hdGVyaWFsLnNoZWVuQ29sb3IsIG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzICk7CgkjZW5kaWYKCXJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9IGlycmFkaWFuY2UgKiBCUkRGX0dHWCggZGlyZWN0TGlnaHQuZGlyZWN0aW9uLCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Tm9ybWFsLCBtYXRlcmlhbCApOwoJcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTsKfQp2b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9QaHlzaWNhbCggY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5UG9zaXRpb24sIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlOb3JtYWwsIGNvbnN0IGluIHZlYzMgZ2VvbWV0cnlWaWV3RGlyLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHsKCXJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTsKfQp2b2lkIFJFX0luZGlyZWN0U3BlY3VsYXJfUGh5c2ljYWwoIGNvbnN0IGluIHZlYzMgcmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBjbGVhcmNvYXRSYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeVBvc2l0aW9uLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Tm9ybWFsLCBjb25zdCBpbiB2ZWMzIGdlb21ldHJ5Vmlld0RpciwgY29uc3QgaW4gdmVjMyBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQpIHsKCSNpZmRlZiBVU0VfQ0xFQVJDT0FUCgkJY2xlYXJjb2F0U3BlY3VsYXJJbmRpcmVjdCArPSBjbGVhcmNvYXRSYWRpYW5jZSAqIEVudmlyb25tZW50QlJERiggZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGdlb21ldHJ5Vmlld0RpciwgbWF0ZXJpYWwuY2xlYXJjb2F0RjAsIG1hdGVyaWFsLmNsZWFyY29hdEY5MCwgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzICk7CgkjZW5kaWYKCSNpZmRlZiBVU0VfU0hFRU4KCQlzaGVlblNwZWN1bGFySW5kaXJlY3QgKz0gaXJyYWRpYW5jZSAqIG1hdGVyaWFsLnNoZWVuQ29sb3IgKiBJQkxTaGVlbkJSREYoIGdlb21ldHJ5Tm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIsIG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzICk7CgkjZW5kaWYKCXZlYzMgc2luZ2xlU2NhdHRlcmluZyA9IHZlYzMoIDAuMCApOwoJdmVjMyBtdWx0aVNjYXR0ZXJpbmcgPSB2ZWMzKCAwLjAgKTsKCXZlYzMgY29zaW5lV2VpZ2h0ZWRJcnJhZGlhbmNlID0gaXJyYWRpYW5jZSAqIFJFQ0lQUk9DQUxfUEk7CgkjaWZkZWYgVVNFX0lSSURFU0NFTkNFCgkJY29tcHV0ZU11bHRpc2NhdHRlcmluZ0lyaWRlc2NlbmNlKCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckY5MCwgbWF0ZXJpYWwuaXJpZGVzY2VuY2UsIG1hdGVyaWFsLmlyaWRlc2NlbmNlRnJlc25lbCwgbWF0ZXJpYWwucm91Z2huZXNzLCBzaW5nbGVTY2F0dGVyaW5nLCBtdWx0aVNjYXR0ZXJpbmcgKTsKCSNlbHNlCgkJY29tcHV0ZU11bHRpc2NhdHRlcmluZyggZ2VvbWV0cnlOb3JtYWwsIGdlb21ldHJ5Vmlld0RpciwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJGOTAsIG1hdGVyaWFsLnJvdWdobmVzcywgc2luZ2xlU2NhdHRlcmluZywgbXVsdGlTY2F0dGVyaW5nICk7CgkjZW5kaWYKCXZlYzMgdG90YWxTY2F0dGVyaW5nID0gc2luZ2xlU2NhdHRlcmluZyArIG11bHRpU2NhdHRlcmluZzsKCXZlYzMgZGlmZnVzZSA9IG1hdGVyaWFsLmRpZmZ1c2VDb2xvciAqICggMS4wIC0gbWF4KCBtYXgoIHRvdGFsU2NhdHRlcmluZy5yLCB0b3RhbFNjYXR0ZXJpbmcuZyApLCB0b3RhbFNjYXR0ZXJpbmcuYiApICk7CglyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICs9IHJhZGlhbmNlICogc2luZ2xlU2NhdHRlcmluZzsKCXJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKz0gbXVsdGlTY2F0dGVyaW5nICogY29zaW5lV2VpZ2h0ZWRJcnJhZGlhbmNlOwoJcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGRpZmZ1c2UgKiBjb3NpbmVXZWlnaHRlZElycmFkaWFuY2U7Cn0KI2RlZmluZSBSRV9EaXJlY3QJCQkJUkVfRGlyZWN0X1BoeXNpY2FsCiNkZWZpbmUgUkVfRGlyZWN0X1JlY3RBcmVhCQlSRV9EaXJlY3RfUmVjdEFyZWFfUGh5c2ljYWwKI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2UJCVJFX0luZGlyZWN0RGlmZnVzZV9QaHlzaWNhbAojZGVmaW5lIFJFX0luZGlyZWN0U3BlY3VsYXIJCVJFX0luZGlyZWN0U3BlY3VsYXJfUGh5c2ljYWwKZmxvYXQgY29tcHV0ZVNwZWN1bGFyT2NjbHVzaW9uKCBjb25zdCBpbiBmbG9hdCBkb3ROViwgY29uc3QgaW4gZmxvYXQgYW1iaWVudE9jY2x1c2lvbiwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkgewoJcmV0dXJuIHNhdHVyYXRlKCBwb3coIGRvdE5WICsgYW1iaWVudE9jY2x1c2lvbiwgZXhwMiggLSAxNi4wICogcm91Z2huZXNzIC0gMS4wICkgKSAtIDEuMCArIGFtYmllbnRPY2NsdXNpb24gKTsKfWAsR2c9YAp2ZWMzIGdlb21ldHJ5UG9zaXRpb24gPSAtIHZWaWV3UG9zaXRpb247CnZlYzMgZ2VvbWV0cnlOb3JtYWwgPSBub3JtYWw7CnZlYzMgZ2VvbWV0cnlWaWV3RGlyID0gKCBpc09ydGhvZ3JhcGhpYyApID8gdmVjMyggMCwgMCwgMSApIDogbm9ybWFsaXplKCB2Vmlld1Bvc2l0aW9uICk7CnZlYzMgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwgPSB2ZWMzKCAwLjAgKTsKI2lmZGVmIFVTRV9DTEVBUkNPQVQKCWdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsID0gY2xlYXJjb2F0Tm9ybWFsOwojZW5kaWYKI2lmZGVmIFVTRV9JUklERVNDRU5DRQoJZmxvYXQgZG90TlZpID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIgKSApOwoJaWYgKCBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzcyA9PSAwLjAgKSB7CgkJbWF0ZXJpYWwuaXJpZGVzY2VuY2UgPSAwLjA7Cgl9IGVsc2UgewoJCW1hdGVyaWFsLmlyaWRlc2NlbmNlID0gc2F0dXJhdGUoIG1hdGVyaWFsLmlyaWRlc2NlbmNlICk7Cgl9CglpZiAoIG1hdGVyaWFsLmlyaWRlc2NlbmNlID4gMC4wICkgewoJCW1hdGVyaWFsLmlyaWRlc2NlbmNlRnJlc25lbCA9IGV2YWxJcmlkZXNjZW5jZSggMS4wLCBtYXRlcmlhbC5pcmlkZXNjZW5jZUlPUiwgZG90TlZpLCBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzcywgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciApOwoJCW1hdGVyaWFsLmlyaWRlc2NlbmNlRjAgPSBTY2hsaWNrX3RvX0YwKCBtYXRlcmlhbC5pcmlkZXNjZW5jZUZyZXNuZWwsIDEuMCwgZG90TlZpICk7Cgl9CiNlbmRpZgpJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0OwojaWYgKCBOVU1fUE9JTlRfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApCglQb2ludExpZ2h0IHBvaW50TGlnaHQ7CgkjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMAoJUG9pbnRMaWdodFNoYWRvdyBwb2ludExpZ2h0U2hhZG93OwoJI2VuZGlmCgkjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0Cglmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkgewoJCXBvaW50TGlnaHQgPSBwb2ludExpZ2h0c1sgaSBdOwoJCWdldFBvaW50TGlnaHRJbmZvKCBwb2ludExpZ2h0LCBnZW9tZXRyeVBvc2l0aW9uLCBkaXJlY3RMaWdodCApOwoJCSNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgKCBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgKQoJCXBvaW50TGlnaHRTaGFkb3cgPSBwb2ludExpZ2h0U2hhZG93c1sgaSBdOwoJCWRpcmVjdExpZ2h0LmNvbG9yICo9ICggZGlyZWN0TGlnaHQudmlzaWJsZSAmJiByZWNlaXZlU2hhZG93ICkgPyBnZXRQb2ludFNoYWRvdyggcG9pbnRTaGFkb3dNYXBbIGkgXSwgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dNYXBTaXplLCBwb2ludExpZ2h0U2hhZG93LnNoYWRvd0JpYXMsIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93UmFkaXVzLCB2UG9pbnRTaGFkb3dDb29yZFsgaSBdLCBwb2ludExpZ2h0U2hhZG93LnNoYWRvd0NhbWVyYU5lYXIsIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93Q2FtZXJhRmFyICkgOiAxLjA7CgkJI2VuZGlmCgkJUkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnlQb3NpdGlvbiwgZ2VvbWV0cnlOb3JtYWwsIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApOwoJfQoJI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmQKI2VuZGlmCiNpZiAoIE5VTV9TUE9UX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKQoJU3BvdExpZ2h0IHNwb3RMaWdodDsKCXZlYzQgc3BvdENvbG9yOwoJdmVjMyBzcG90TGlnaHRDb29yZDsKCWJvb2wgaW5TcG90TGlnaHRNYXA7CgkjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwCglTcG90TGlnaHRTaGFkb3cgc3BvdExpZ2h0U2hhZG93OwoJI2VuZGlmCgkjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0Cglmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7CgkJc3BvdExpZ2h0ID0gc3BvdExpZ2h0c1sgaSBdOwoJCWdldFNwb3RMaWdodEluZm8oIHNwb3RMaWdodCwgZ2VvbWV0cnlQb3NpdGlvbiwgZGlyZWN0TGlnaHQgKTsKCQkjaWYgKCBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX1NQT1RfTElHSFRfU0hBRE9XU19XSVRIX01BUFMgKQoJCSNkZWZpbmUgU1BPVF9MSUdIVF9NQVBfSU5ERVggVU5ST0xMRURfTE9PUF9JTkRFWAoJCSNlbGlmICggVU5ST0xMRURfTE9PUF9JTkRFWCA8IE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgKQoJCSNkZWZpbmUgU1BPVF9MSUdIVF9NQVBfSU5ERVggTlVNX1NQT1RfTElHSFRfTUFQUwoJCSNlbHNlCgkJI2RlZmluZSBTUE9UX0xJR0hUX01BUF9JTkRFWCAoIFVOUk9MTEVEX0xPT1BfSU5ERVggLSBOVU1fU1BPVF9MSUdIVF9TSEFET1dTICsgTlVNX1NQT1RfTElHSFRfU0hBRE9XU19XSVRIX01BUFMgKQoJCSNlbmRpZgoJCSNpZiAoIFNQT1RfTElHSFRfTUFQX0lOREVYIDwgTlVNX1NQT1RfTElHSFRfTUFQUyApCgkJCXNwb3RMaWdodENvb3JkID0gdlNwb3RMaWdodENvb3JkWyBpIF0ueHl6IC8gdlNwb3RMaWdodENvb3JkWyBpIF0udzsKCQkJaW5TcG90TGlnaHRNYXAgPSBhbGwoIGxlc3NUaGFuKCBhYnMoIHNwb3RMaWdodENvb3JkICogMi4gLSAxLiApLCB2ZWMzKCAxLjAgKSApICk7CgkJCXNwb3RDb2xvciA9IHRleHR1cmUyRCggc3BvdExpZ2h0TWFwWyBTUE9UX0xJR0hUX01BUF9JTkRFWCBdLCBzcG90TGlnaHRDb29yZC54eSApOwoJCQlkaXJlY3RMaWdodC5jb2xvciA9IGluU3BvdExpZ2h0TWFwID8gZGlyZWN0TGlnaHQuY29sb3IgKiBzcG90Q29sb3IucmdiIDogZGlyZWN0TGlnaHQuY29sb3I7CgkJI2VuZGlmCgkJI3VuZGVmIFNQT1RfTElHSFRfTUFQX0lOREVYCgkJI2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiAoIFVOUk9MTEVEX0xPT1BfSU5ERVggPCBOVU1fU1BPVF9MSUdIVF9TSEFET1dTICkKCQlzcG90TGlnaHRTaGFkb3cgPSBzcG90TGlnaHRTaGFkb3dzWyBpIF07CgkJZGlyZWN0TGlnaHQuY29sb3IgKj0gKCBkaXJlY3RMaWdodC52aXNpYmxlICYmIHJlY2VpdmVTaGFkb3cgKSA/IGdldFNoYWRvdyggc3BvdFNoYWRvd01hcFsgaSBdLCBzcG90TGlnaHRTaGFkb3cuc2hhZG93TWFwU2l6ZSwgc3BvdExpZ2h0U2hhZG93LnNoYWRvd0JpYXMsIHNwb3RMaWdodFNoYWRvdy5zaGFkb3dSYWRpdXMsIHZTcG90TGlnaHRDb29yZFsgaSBdICkgOiAxLjA7CgkJI2VuZGlmCgkJUkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnlQb3NpdGlvbiwgZ2VvbWV0cnlOb3JtYWwsIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApOwoJfQoJI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmQKI2VuZGlmCiNpZiAoIE5VTV9ESVJfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApCglEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQ7CgkjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDAKCURpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZGlyZWN0aW9uYWxMaWdodFNoYWRvdzsKCSNlbmRpZgoJI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydAoJZm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7CgkJZGlyZWN0aW9uYWxMaWdodCA9IGRpcmVjdGlvbmFsTGlnaHRzWyBpIF07CgkJZ2V0RGlyZWN0aW9uYWxMaWdodEluZm8oIGRpcmVjdGlvbmFsTGlnaHQsIGRpcmVjdExpZ2h0ICk7CgkJI2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiAoIFVOUk9MTEVEX0xPT1BfSU5ERVggPCBOVU1fRElSX0xJR0hUX1NIQURPV1MgKQoJCWRpcmVjdGlvbmFsTGlnaHRTaGFkb3cgPSBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgaSBdOwoJCWRpcmVjdExpZ2h0LmNvbG9yICo9ICggZGlyZWN0TGlnaHQudmlzaWJsZSAmJiByZWNlaXZlU2hhZG93ICkgPyBnZXRTaGFkb3coIGRpcmVjdGlvbmFsU2hhZG93TWFwWyBpIF0sIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3cuc2hhZG93TWFwU2l6ZSwgZGlyZWN0aW9uYWxMaWdodFNoYWRvdy5zaGFkb3dCaWFzLCBkaXJlY3Rpb25hbExpZ2h0U2hhZG93LnNoYWRvd1JhZGl1cywgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSApIDogMS4wOwoJCSNlbmRpZgoJCVJFX0RpcmVjdCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5UG9zaXRpb24sIGdlb21ldHJ5Tm9ybWFsLCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTsKCX0KCSNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kCiNlbmRpZgojaWYgKCBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3RfUmVjdEFyZWEgKQoJUmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0OwoJI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydAoJZm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1JFQ1RfQVJFQV9MSUdIVFM7IGkgKysgKSB7CgkJcmVjdEFyZWFMaWdodCA9IHJlY3RBcmVhTGlnaHRzWyBpIF07CgkJUkVfRGlyZWN0X1JlY3RBcmVhKCByZWN0QXJlYUxpZ2h0LCBnZW9tZXRyeVBvc2l0aW9uLCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7Cgl9CgkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAojZW5kaWYKI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApCgl2ZWMzIGlibElycmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTsKCXZlYzMgaXJyYWRpYW5jZSA9IGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGFtYmllbnRMaWdodENvbG9yICk7CgkjaWYgZGVmaW5lZCggVVNFX0xJR0hUX1BST0JFUyApCgkJaXJyYWRpYW5jZSArPSBnZXRMaWdodFByb2JlSXJyYWRpYW5jZSggbGlnaHRQcm9iZSwgZ2VvbWV0cnlOb3JtYWwgKTsKCSNlbmRpZgoJI2lmICggTlVNX0hFTUlfTElHSFRTID4gMCApCgkJI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydAoJCWZvciAoIGludCBpID0gMDsgaSA8IE5VTV9IRU1JX0xJR0hUUzsgaSArKyApIHsKCQkJaXJyYWRpYW5jZSArPSBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBoZW1pc3BoZXJlTGlnaHRzWyBpIF0sIGdlb21ldHJ5Tm9ybWFsICk7CgkJfQoJCSNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kCgkjZW5kaWYKI2VuZGlmCiNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdFNwZWN1bGFyICkKCXZlYzMgcmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTsKCXZlYzMgY2xlYXJjb2F0UmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTsKI2VuZGlmYCxXZz1gI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApCgkjaWZkZWYgVVNFX0xJR0hUTUFQCgkJdmVjNCBsaWdodE1hcFRleGVsID0gdGV4dHVyZTJEKCBsaWdodE1hcCwgdkxpZ2h0TWFwVXYgKTsKCQl2ZWMzIGxpZ2h0TWFwSXJyYWRpYW5jZSA9IGxpZ2h0TWFwVGV4ZWwucmdiICogbGlnaHRNYXBJbnRlbnNpdHk7CgkJaXJyYWRpYW5jZSArPSBsaWdodE1hcElycmFkaWFuY2U7CgkjZW5kaWYKCSNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggU1RBTkRBUkQgKSAmJiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWICkKCQlpYmxJcnJhZGlhbmNlICs9IGdldElCTElycmFkaWFuY2UoIGdlb21ldHJ5Tm9ybWFsICk7CgkjZW5kaWYKI2VuZGlmCiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggUkVfSW5kaXJlY3RTcGVjdWxhciApCgkjaWZkZWYgVVNFX0FOSVNPVFJPUFkKCQlyYWRpYW5jZSArPSBnZXRJQkxBbmlzb3Ryb3B5UmFkaWFuY2UoIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlOb3JtYWwsIG1hdGVyaWFsLnJvdWdobmVzcywgbWF0ZXJpYWwuYW5pc290cm9weUIsIG1hdGVyaWFsLmFuaXNvdHJvcHkgKTsKCSNlbHNlCgkJcmFkaWFuY2UgKz0gZ2V0SUJMUmFkaWFuY2UoIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlOb3JtYWwsIG1hdGVyaWFsLnJvdWdobmVzcyApOwoJI2VuZGlmCgkjaWZkZWYgVVNFX0NMRUFSQ09BVAoJCWNsZWFyY29hdFJhZGlhbmNlICs9IGdldElCTFJhZGlhbmNlKCBnZW9tZXRyeVZpZXdEaXIsIGdlb21ldHJ5Q2xlYXJjb2F0Tm9ybWFsLCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgKTsKCSNlbmRpZgojZW5kaWZgLFhnPWAjaWYgZGVmaW5lZCggUkVfSW5kaXJlY3REaWZmdXNlICkKCVJFX0luZGlyZWN0RGlmZnVzZSggaXJyYWRpYW5jZSwgZ2VvbWV0cnlQb3NpdGlvbiwgZ2VvbWV0cnlOb3JtYWwsIGdlb21ldHJ5Vmlld0RpciwgZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApOwojZW5kaWYKI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0U3BlY3VsYXIgKQoJUkVfSW5kaXJlY3RTcGVjdWxhciggcmFkaWFuY2UsIGlibElycmFkaWFuY2UsIGNsZWFyY29hdFJhZGlhbmNlLCBnZW9tZXRyeVBvc2l0aW9uLCBnZW9tZXRyeU5vcm1hbCwgZ2VvbWV0cnlWaWV3RGlyLCBnZW9tZXRyeUNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7CiNlbmRpZmAscWc9YCNpZiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUYgKSAmJiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUZfRVhUICkKCWdsX0ZyYWdEZXB0aEVYVCA9IHZJc1BlcnNwZWN0aXZlID09IDAuMCA/IGdsX0ZyYWdDb29yZC56IDogbG9nMiggdkZyYWdEZXB0aCApICogbG9nRGVwdGhCdWZGQyAqIDAuNTsKI2VuZGlmYCxZZz1gI2lmIGRlZmluZWQoIFVTRV9MT0dERVBUSEJVRiApICYmIGRlZmluZWQoIFVTRV9MT0dERVBUSEJVRl9FWFQgKQoJdW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDOwoJdmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoOwoJdmFyeWluZyBmbG9hdCB2SXNQZXJzcGVjdGl2ZTsKI2VuZGlmYCxaZz1gI2lmZGVmIFVTRV9MT0dERVBUSEJVRgoJI2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFQKCQl2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7CgkJdmFyeWluZyBmbG9hdCB2SXNQZXJzcGVjdGl2ZTsKCSNlbHNlCgkJdW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDOwoJI2VuZGlmCiNlbmRpZmAsSmc9YCNpZmRlZiBVU0VfTE9HREVQVEhCVUYKCSNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUCgkJdkZyYWdEZXB0aCA9IDEuMCArIGdsX1Bvc2l0aW9uLnc7CgkJdklzUGVyc3BlY3RpdmUgPSBmbG9hdCggaXNQZXJzcGVjdGl2ZU1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApICk7CgkjZWxzZQoJCWlmICggaXNQZXJzcGVjdGl2ZU1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApICkgewoJCQlnbF9Qb3NpdGlvbi56ID0gbG9nMiggbWF4KCBFUFNJTE9OLCBnbF9Qb3NpdGlvbi53ICsgMS4wICkgKSAqIGxvZ0RlcHRoQnVmRkMgLSAxLjA7CgkJCWdsX1Bvc2l0aW9uLnogKj0gZ2xfUG9zaXRpb24udzsKCQl9CgkjZW5kaWYKI2VuZGlmYCwkZz1gI2lmZGVmIFVTRV9NQVAKCXZlYzQgc2FtcGxlZERpZmZ1c2VDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2TWFwVXYgKTsKCSNpZmRlZiBERUNPREVfVklERU9fVEVYVFVSRQoJCXNhbXBsZWREaWZmdXNlQ29sb3IgPSB2ZWM0KCBtaXgoIHBvdyggc2FtcGxlZERpZmZ1c2VDb2xvci5yZ2IgKiAwLjk0Nzg2NzI5ODYgKyB2ZWMzKCAwLjA1MjEzMjcwMTQgKSwgdmVjMyggMi40ICkgKSwgc2FtcGxlZERpZmZ1c2VDb2xvci5yZ2IgKiAwLjA3NzM5OTM4MDgsIHZlYzMoIGxlc3NUaGFuRXF1YWwoIHNhbXBsZWREaWZmdXNlQ29sb3IucmdiLCB2ZWMzKCAwLjA0MDQ1ICkgKSApICksIHNhbXBsZWREaWZmdXNlQ29sb3IudyApOwoJCgkjZW5kaWYKCWRpZmZ1c2VDb2xvciAqPSBzYW1wbGVkRGlmZnVzZUNvbG9yOwojZW5kaWZgLEtnPWAjaWZkZWYgVVNFX01BUAoJdW5pZm9ybSBzYW1wbGVyMkQgbWFwOwojZW5kaWZgLFFnPWAjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApCgkjaWYgZGVmaW5lZCggVVNFX1BPSU5UU19VViApCgkJdmVjMiB1diA9IHZVdjsKCSNlbHNlCgkJdmVjMiB1diA9ICggdXZUcmFuc2Zvcm0gKiB2ZWMzKCBnbF9Qb2ludENvb3JkLngsIDEuMCAtIGdsX1BvaW50Q29vcmQueSwgMSApICkueHk7CgkjZW5kaWYKI2VuZGlmCiNpZmRlZiBVU0VfTUFQCglkaWZmdXNlQ29sb3IgKj0gdGV4dHVyZTJEKCBtYXAsIHV2ICk7CiNlbmRpZgojaWZkZWYgVVNFX0FMUEhBTUFQCglkaWZmdXNlQ29sb3IuYSAqPSB0ZXh0dXJlMkQoIGFscGhhTWFwLCB1diApLmc7CiNlbmRpZmAsamc9YCNpZiBkZWZpbmVkKCBVU0VfUE9JTlRTX1VWICkKCXZhcnlpbmcgdmVjMiB2VXY7CiNlbHNlCgkjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApCgkJdW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtOwoJI2VuZGlmCiNlbmRpZgojaWZkZWYgVVNFX01BUAoJdW5pZm9ybSBzYW1wbGVyMkQgbWFwOwojZW5kaWYKI2lmZGVmIFVTRV9BTFBIQU1BUAoJdW5pZm9ybSBzYW1wbGVyMkQgYWxwaGFNYXA7CiNlbmRpZmAsdF89YGZsb2F0IG1ldGFsbmVzc0ZhY3RvciA9IG1ldGFsbmVzczsKI2lmZGVmIFVTRV9NRVRBTE5FU1NNQVAKCXZlYzQgdGV4ZWxNZXRhbG5lc3MgPSB0ZXh0dXJlMkQoIG1ldGFsbmVzc01hcCwgdk1ldGFsbmVzc01hcFV2ICk7CgltZXRhbG5lc3NGYWN0b3IgKj0gdGV4ZWxNZXRhbG5lc3MuYjsKI2VuZGlmYCxlXz1gI2lmZGVmIFVTRV9NRVRBTE5FU1NNQVAKCXVuaWZvcm0gc2FtcGxlcjJEIG1ldGFsbmVzc01hcDsKI2VuZGlmYCxuXz1gI2lmIGRlZmluZWQoIFVTRV9NT1JQSENPTE9SUyApICYmIGRlZmluZWQoIE1PUlBIVEFSR0VUU19URVhUVVJFICkKCXZDb2xvciAqPSBtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2U7Cglmb3IgKCBpbnQgaSA9IDA7IGkgPCBNT1JQSFRBUkdFVFNfQ09VTlQ7IGkgKysgKSB7CgkJI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApCgkJCWlmICggbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gIT0gMC4wICkgdkNvbG9yICs9IGdldE1vcnBoKCBnbF9WZXJ0ZXhJRCwgaSwgMiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF07CgkJI2VsaWYgZGVmaW5lZCggVVNFX0NPTE9SICkKCQkJaWYgKCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSAhPSAwLjAgKSB2Q29sb3IgKz0gZ2V0TW9ycGgoIGdsX1ZlcnRleElELCBpLCAyICkucmdiICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF07CgkJI2VuZGlmCgl9CiNlbmRpZmAsaV89YCNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTCglvYmplY3ROb3JtYWwgKj0gbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlOwoJI2lmZGVmIE1PUlBIVEFSR0VUU19URVhUVVJFCgkJZm9yICggaW50IGkgPSAwOyBpIDwgTU9SUEhUQVJHRVRTX0NPVU5UOyBpICsrICkgewoJCQlpZiAoIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdICE9IDAuMCApIG9iamVjdE5vcm1hbCArPSBnZXRNb3JwaCggZ2xfVmVydGV4SUQsIGksIDEgKS54eXogKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTsKCQl9CgkjZWxzZQoJCW9iamVjdE5vcm1hbCArPSBtb3JwaE5vcm1hbDAgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTsKCQlvYmplY3ROb3JtYWwgKz0gbW9ycGhOb3JtYWwxICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07CgkJb2JqZWN0Tm9ybWFsICs9IG1vcnBoTm9ybWFsMiAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdOwoJCW9iamVjdE5vcm1hbCArPSBtb3JwaE5vcm1hbDMgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTsKCSNlbmRpZgojZW5kaWZgLHNfPWAjaWZkZWYgVVNFX01PUlBIVEFSR0VUUwoJdW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2U7CgkjaWZkZWYgTU9SUEhUQVJHRVRTX1RFWFRVUkUKCQl1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgTU9SUEhUQVJHRVRTX0NPVU5UIF07CgkJdW5pZm9ybSBzYW1wbGVyMkRBcnJheSBtb3JwaFRhcmdldHNUZXh0dXJlOwoJCXVuaWZvcm0gaXZlYzIgbW9ycGhUYXJnZXRzVGV4dHVyZVNpemU7CgkJdmVjNCBnZXRNb3JwaCggY29uc3QgaW4gaW50IHZlcnRleEluZGV4LCBjb25zdCBpbiBpbnQgbW9ycGhUYXJnZXRJbmRleCwgY29uc3QgaW4gaW50IG9mZnNldCApIHsKCQkJaW50IHRleGVsSW5kZXggPSB2ZXJ0ZXhJbmRleCAqIE1PUlBIVEFSR0VUU19URVhUVVJFX1NUUklERSArIG9mZnNldDsKCQkJaW50IHkgPSB0ZXhlbEluZGV4IC8gbW9ycGhUYXJnZXRzVGV4dHVyZVNpemUueDsKCQkJaW50IHggPSB0ZXhlbEluZGV4IC0geSAqIG1vcnBoVGFyZ2V0c1RleHR1cmVTaXplLng7CgkJCWl2ZWMzIG1vcnBoVVYgPSBpdmVjMyggeCwgeSwgbW9ycGhUYXJnZXRJbmRleCApOwoJCQlyZXR1cm4gdGV4ZWxGZXRjaCggbW9ycGhUYXJnZXRzVGV4dHVyZSwgbW9ycGhVViwgMCApOwoJCX0KCSNlbHNlCgkJI2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTCgkJCXVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA4IF07CgkJI2Vsc2UKCQkJdW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDQgXTsKCQkjZW5kaWYKCSNlbmRpZgojZW5kaWZgLHJfPWAjaWZkZWYgVVNFX01PUlBIVEFSR0VUUwoJdHJhbnNmb3JtZWQgKj0gbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlOwoJI2lmZGVmIE1PUlBIVEFSR0VUU19URVhUVVJFCgkJZm9yICggaW50IGkgPSAwOyBpIDwgTU9SUEhUQVJHRVRTX0NPVU5UOyBpICsrICkgewoJCQlpZiAoIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdICE9IDAuMCApIHRyYW5zZm9ybWVkICs9IGdldE1vcnBoKCBnbF9WZXJ0ZXhJRCwgaSwgMCApLnh5eiAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdOwoJCX0KCSNlbHNlCgkJdHJhbnNmb3JtZWQgKz0gbW9ycGhUYXJnZXQwICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07CgkJdHJhbnNmb3JtZWQgKz0gbW9ycGhUYXJnZXQxICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07CgkJdHJhbnNmb3JtZWQgKz0gbW9ycGhUYXJnZXQyICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAyIF07CgkJdHJhbnNmb3JtZWQgKz0gbW9ycGhUYXJnZXQzICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07CgkJI2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTCgkJCXRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0NCAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdOwoJCQl0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDUgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDUgXTsKCQkJdHJhbnNmb3JtZWQgKz0gbW9ycGhUYXJnZXQ2ICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA2IF07CgkJCXRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0NyAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNyBdOwoJCSNlbmRpZgoJI2VuZGlmCiNlbmRpZmAsYV89YGZsb2F0IGZhY2VEaXJlY3Rpb24gPSBnbF9Gcm9udEZhY2luZyA/IDEuMCA6IC0gMS4wOwojaWZkZWYgRkxBVF9TSEFERUQKCXZlYzMgZmR4ID0gZEZkeCggdlZpZXdQb3NpdGlvbiApOwoJdmVjMyBmZHkgPSBkRmR5KCB2Vmlld1Bvc2l0aW9uICk7Cgl2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIGZkeCwgZmR5ICkgKTsKI2Vsc2UKCXZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICk7CgkjaWZkZWYgRE9VQkxFX1NJREVECgkJbm9ybWFsICo9IGZhY2VEaXJlY3Rpb247CgkjZW5kaWYKI2VuZGlmCiNpZiBkZWZpbmVkKCBVU0VfTk9STUFMTUFQX1RBTkdFTlRTUEFDRSApIHx8IGRlZmluZWQoIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX0FOSVNPVFJPUFkgKQoJI2lmZGVmIFVTRV9UQU5HRU5UCgkJbWF0MyB0Ym4gPSBtYXQzKCBub3JtYWxpemUoIHZUYW5nZW50ICksIG5vcm1hbGl6ZSggdkJpdGFuZ2VudCApLCBub3JtYWwgKTsKCSNlbHNlCgkJbWF0MyB0Ym4gPSBnZXRUYW5nZW50RnJhbWUoIC0gdlZpZXdQb3NpdGlvbiwgbm9ybWFsLAoJCSNpZiBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkKCQkJdk5vcm1hbE1hcFV2CgkJI2VsaWYgZGVmaW5lZCggVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAgKQoJCQl2Q2xlYXJjb2F0Tm9ybWFsTWFwVXYKCQkjZWxzZQoJCQl2VXYKCQkjZW5kaWYKCQkpOwoJI2VuZGlmCgkjaWYgZGVmaW5lZCggRE9VQkxFX1NJREVEICkgJiYgISBkZWZpbmVkKCBGTEFUX1NIQURFRCApCgkJdGJuWzBdICo9IGZhY2VEaXJlY3Rpb247CgkJdGJuWzFdICo9IGZhY2VEaXJlY3Rpb247CgkjZW5kaWYKI2VuZGlmCiNpZmRlZiBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUAoJI2lmZGVmIFVTRV9UQU5HRU5UCgkJbWF0MyB0Ym4yID0gbWF0Myggbm9ybWFsaXplKCB2VGFuZ2VudCApLCBub3JtYWxpemUoIHZCaXRhbmdlbnQgKSwgbm9ybWFsICk7CgkjZWxzZQoJCW1hdDMgdGJuMiA9IGdldFRhbmdlbnRGcmFtZSggLSB2Vmlld1Bvc2l0aW9uLCBub3JtYWwsIHZDbGVhcmNvYXROb3JtYWxNYXBVdiApOwoJI2VuZGlmCgkjaWYgZGVmaW5lZCggRE9VQkxFX1NJREVEICkgJiYgISBkZWZpbmVkKCBGTEFUX1NIQURFRCApCgkJdGJuMlswXSAqPSBmYWNlRGlyZWN0aW9uOwoJCXRibjJbMV0gKj0gZmFjZURpcmVjdGlvbjsKCSNlbmRpZgojZW5kaWYKdmVjMyBub25QZXJ0dXJiZWROb3JtYWwgPSBub3JtYWw7YCxvXz1gI2lmZGVmIFVTRV9OT1JNQUxNQVBfT0JKRUNUU1BBQ0UKCW5vcm1hbCA9IHRleHR1cmUyRCggbm9ybWFsTWFwLCB2Tm9ybWFsTWFwVXYgKS54eXogKiAyLjAgLSAxLjA7CgkjaWZkZWYgRkxJUF9TSURFRAoJCW5vcm1hbCA9IC0gbm9ybWFsOwoJI2VuZGlmCgkjaWZkZWYgRE9VQkxFX1NJREVECgkJbm9ybWFsID0gbm9ybWFsICogZmFjZURpcmVjdGlvbjsKCSNlbmRpZgoJbm9ybWFsID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiBub3JtYWwgKTsKI2VsaWYgZGVmaW5lZCggVVNFX05PUk1BTE1BUF9UQU5HRU5UU1BBQ0UgKQoJdmVjMyBtYXBOID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZOb3JtYWxNYXBVdiApLnh5eiAqIDIuMCAtIDEuMDsKCW1hcE4ueHkgKj0gbm9ybWFsU2NhbGU7Cglub3JtYWwgPSBub3JtYWxpemUoIHRibiAqIG1hcE4gKTsKI2VsaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKQoJbm9ybWFsID0gcGVydHVyYk5vcm1hbEFyYiggLSB2Vmlld1Bvc2l0aW9uLCBub3JtYWwsIGRIZHh5X2Z3ZCgpLCBmYWNlRGlyZWN0aW9uICk7CiNlbmRpZmAsbF89YCNpZm5kZWYgRkxBVF9TSEFERUQKCXZhcnlpbmcgdmVjMyB2Tm9ybWFsOwoJI2lmZGVmIFVTRV9UQU5HRU5UCgkJdmFyeWluZyB2ZWMzIHZUYW5nZW50OwoJCXZhcnlpbmcgdmVjMyB2Qml0YW5nZW50OwoJI2VuZGlmCiNlbmRpZmAsY189YCNpZm5kZWYgRkxBVF9TSEFERUQKCXZhcnlpbmcgdmVjMyB2Tm9ybWFsOwoJI2lmZGVmIFVTRV9UQU5HRU5UCgkJdmFyeWluZyB2ZWMzIHZUYW5nZW50OwoJCXZhcnlpbmcgdmVjMyB2Qml0YW5nZW50OwoJI2VuZGlmCiNlbmRpZmAsaF89YCNpZm5kZWYgRkxBVF9TSEFERUQKCXZOb3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7CgkjaWZkZWYgVVNFX1RBTkdFTlQKCQl2VGFuZ2VudCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWRUYW5nZW50ICk7CgkJdkJpdGFuZ2VudCA9IG5vcm1hbGl6ZSggY3Jvc3MoIHZOb3JtYWwsIHZUYW5nZW50ICkgKiB0YW5nZW50LncgKTsKCSNlbmRpZgojZW5kaWZgLHVfPWAjaWZkZWYgVVNFX05PUk1BTE1BUAoJdW5pZm9ybSBzYW1wbGVyMkQgbm9ybWFsTWFwOwoJdW5pZm9ybSB2ZWMyIG5vcm1hbFNjYWxlOwojZW5kaWYKI2lmZGVmIFVTRV9OT1JNQUxNQVBfT0JKRUNUU1BBQ0UKCXVuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7CiNlbmRpZgojaWYgISBkZWZpbmVkICggVVNFX1RBTkdFTlQgKSAmJiAoIGRlZmluZWQgKCBVU0VfTk9STUFMTUFQX1RBTkdFTlRTUEFDRSApIHx8IGRlZmluZWQgKCBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9BTklTT1RST1BZICkgKQoJbWF0MyBnZXRUYW5nZW50RnJhbWUoIHZlYzMgZXllX3BvcywgdmVjMyBzdXJmX25vcm0sIHZlYzIgdXYgKSB7CgkJdmVjMyBxMCA9IGRGZHgoIGV5ZV9wb3MueHl6ICk7CgkJdmVjMyBxMSA9IGRGZHkoIGV5ZV9wb3MueHl6ICk7CgkJdmVjMiBzdDAgPSBkRmR4KCB1di5zdCApOwoJCXZlYzIgc3QxID0gZEZkeSggdXYuc3QgKTsKCQl2ZWMzIE4gPSBzdXJmX25vcm07CgkJdmVjMyBxMXBlcnAgPSBjcm9zcyggcTEsIE4gKTsKCQl2ZWMzIHEwcGVycCA9IGNyb3NzKCBOLCBxMCApOwoJCXZlYzMgVCA9IHExcGVycCAqIHN0MC54ICsgcTBwZXJwICogc3QxLng7CgkJdmVjMyBCID0gcTFwZXJwICogc3QwLnkgKyBxMHBlcnAgKiBzdDEueTsKCQlmbG9hdCBkZXQgPSBtYXgoIGRvdCggVCwgVCApLCBkb3QoIEIsIEIgKSApOwoJCWZsb2F0IHNjYWxlID0gKCBkZXQgPT0gMC4wICkgPyAwLjAgOiBpbnZlcnNlc3FydCggZGV0ICk7CgkJcmV0dXJuIG1hdDMoIFQgKiBzY2FsZSwgQiAqIHNjYWxlLCBOICk7Cgl9CiNlbmRpZmAsZF89YCNpZmRlZiBVU0VfQ0xFQVJDT0FUCgl2ZWMzIGNsZWFyY29hdE5vcm1hbCA9IG5vblBlcnR1cmJlZE5vcm1hbDsKI2VuZGlmYCxmXz1gI2lmZGVmIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQCgl2ZWMzIGNsZWFyY29hdE1hcE4gPSB0ZXh0dXJlMkQoIGNsZWFyY29hdE5vcm1hbE1hcCwgdkNsZWFyY29hdE5vcm1hbE1hcFV2ICkueHl6ICogMi4wIC0gMS4wOwoJY2xlYXJjb2F0TWFwTi54eSAqPSBjbGVhcmNvYXROb3JtYWxTY2FsZTsKCWNsZWFyY29hdE5vcm1hbCA9IG5vcm1hbGl6ZSggdGJuMiAqIGNsZWFyY29hdE1hcE4gKTsKI2VuZGlmYCxwXz1gI2lmZGVmIFVTRV9DTEVBUkNPQVRNQVAKCXVuaWZvcm0gc2FtcGxlcjJEIGNsZWFyY29hdE1hcDsKI2VuZGlmCiNpZmRlZiBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUAoJdW5pZm9ybSBzYW1wbGVyMkQgY2xlYXJjb2F0Tm9ybWFsTWFwOwoJdW5pZm9ybSB2ZWMyIGNsZWFyY29hdE5vcm1hbFNjYWxlOwojZW5kaWYKI2lmZGVmIFVTRV9DTEVBUkNPQVRfUk9VR0hORVNTTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBjbGVhcmNvYXRSb3VnaG5lc3NNYXA7CiNlbmRpZmAsbV89YCNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VNQVAKCXVuaWZvcm0gc2FtcGxlcjJEIGlyaWRlc2NlbmNlTWFwOwojZW5kaWYKI2lmZGVmIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVAKCXVuaWZvcm0gc2FtcGxlcjJEIGlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwOwojZW5kaWZgLGdfPWAjaWZkZWYgT1BBUVVFCmRpZmZ1c2VDb2xvci5hID0gMS4wOwojZW5kaWYKI2lmZGVmIFVTRV9UUkFOU01JU1NJT04KZGlmZnVzZUNvbG9yLmEgKj0gbWF0ZXJpYWwudHJhbnNtaXNzaW9uQWxwaGE7CiNlbmRpZgpnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO2AsX189YHZlYzMgcGFja05vcm1hbFRvUkdCKCBjb25zdCBpbiB2ZWMzIG5vcm1hbCApIHsKCXJldHVybiBub3JtYWxpemUoIG5vcm1hbCApICogMC41ICsgMC41Owp9CnZlYzMgdW5wYWNrUkdCVG9Ob3JtYWwoIGNvbnN0IGluIHZlYzMgcmdiICkgewoJcmV0dXJuIDIuMCAqIHJnYi54eXogLSAxLjA7Cn0KY29uc3QgZmxvYXQgUGFja1Vwc2NhbGUgPSAyNTYuIC8gMjU1Ljtjb25zdCBmbG9hdCBVbnBhY2tEb3duc2NhbGUgPSAyNTUuIC8gMjU2LjsKY29uc3QgdmVjMyBQYWNrRmFjdG9ycyA9IHZlYzMoIDI1Ni4gKiAyNTYuICogMjU2LiwgMjU2LiAqIDI1Ni4sIDI1Ni4gKTsKY29uc3QgdmVjNCBVbnBhY2tGYWN0b3JzID0gVW5wYWNrRG93bnNjYWxlIC8gdmVjNCggUGFja0ZhY3RvcnMsIDEuICk7CmNvbnN0IGZsb2F0IFNoaWZ0UmlnaHQ4ID0gMS4gLyAyNTYuOwp2ZWM0IHBhY2tEZXB0aFRvUkdCQSggY29uc3QgaW4gZmxvYXQgdiApIHsKCXZlYzQgciA9IHZlYzQoIGZyYWN0KCB2ICogUGFja0ZhY3RvcnMgKSwgdiApOwoJci55encgLT0gci54eXogKiBTaGlmdFJpZ2h0ODsJcmV0dXJuIHIgKiBQYWNrVXBzY2FsZTsKfQpmbG9hdCB1bnBhY2tSR0JBVG9EZXB0aCggY29uc3QgaW4gdmVjNCB2ICkgewoJcmV0dXJuIGRvdCggdiwgVW5wYWNrRmFjdG9ycyApOwp9CnZlYzIgcGFja0RlcHRoVG9SRyggaW4gaGlnaHAgZmxvYXQgdiApIHsKCXJldHVybiBwYWNrRGVwdGhUb1JHQkEoIHYgKS55eDsKfQpmbG9hdCB1bnBhY2tSR1RvRGVwdGgoIGNvbnN0IGluIGhpZ2hwIHZlYzIgdiApIHsKCXJldHVybiB1bnBhY2tSR0JBVG9EZXB0aCggdmVjNCggdi54eSwgMC4wLCAwLjAgKSApOwp9CnZlYzQgcGFjazJIYWxmVG9SR0JBKCB2ZWMyIHYgKSB7Cgl2ZWM0IHIgPSB2ZWM0KCB2LngsIGZyYWN0KCB2LnggKiAyNTUuMCApLCB2LnksIGZyYWN0KCB2LnkgKiAyNTUuMCApICk7CglyZXR1cm4gdmVjNCggci54IC0gci55IC8gMjU1LjAsIHIueSwgci56IC0gci53IC8gMjU1LjAsIHIudyApOwp9CnZlYzIgdW5wYWNrUkdCQVRvMkhhbGYoIHZlYzQgdiApIHsKCXJldHVybiB2ZWMyKCB2LnggKyAoIHYueSAvIDI1NS4wICksIHYueiArICggdi53IC8gMjU1LjAgKSApOwp9CmZsb2F0IHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCggY29uc3QgaW4gZmxvYXQgdmlld1osIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHsKCXJldHVybiAoIHZpZXdaICsgbmVhciApIC8gKCBuZWFyIC0gZmFyICk7Cn0KZmxvYXQgb3J0aG9ncmFwaGljRGVwdGhUb1ZpZXdaKCBjb25zdCBpbiBmbG9hdCBkZXB0aCwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkgewoJcmV0dXJuIGRlcHRoICogKCBuZWFyIC0gZmFyICkgLSBuZWFyOwp9CmZsb2F0IHZpZXdaVG9QZXJzcGVjdGl2ZURlcHRoKCBjb25zdCBpbiBmbG9hdCB2aWV3WiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkgewoJcmV0dXJuICggKCBuZWFyICsgdmlld1ogKSAqIGZhciApIC8gKCAoIGZhciAtIG5lYXIgKSAqIHZpZXdaICk7Cn0KZmxvYXQgcGVyc3BlY3RpdmVEZXB0aFRvVmlld1ooIGNvbnN0IGluIGZsb2F0IGRlcHRoLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7CglyZXR1cm4gKCBuZWFyICogZmFyICkgLyAoICggZmFyIC0gbmVhciApICogZGVwdGggLSBmYXIgKTsKfWAseF89YCNpZmRlZiBQUkVNVUxUSVBMSUVEX0FMUEhBCglnbF9GcmFnQ29sb3IucmdiICo9IGdsX0ZyYWdDb2xvci5hOwojZW5kaWZgLHZfPWB2ZWM0IG12UG9zaXRpb24gPSB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7CiNpZmRlZiBVU0VfQkFUQ0hJTkcKCW12UG9zaXRpb24gPSBiYXRjaGluZ01hdHJpeCAqIG12UG9zaXRpb247CiNlbmRpZgojaWZkZWYgVVNFX0lOU1RBTkNJTkcKCW12UG9zaXRpb24gPSBpbnN0YW5jZU1hdHJpeCAqIG12UG9zaXRpb247CiNlbmRpZgptdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogbXZQb3NpdGlvbjsKZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtgLHlfPWAjaWZkZWYgRElUSEVSSU5HCglnbF9GcmFnQ29sb3IucmdiID0gZGl0aGVyaW5nKCBnbF9GcmFnQ29sb3IucmdiICk7CiNlbmRpZmAsTV89YCNpZmRlZiBESVRIRVJJTkcKCXZlYzMgZGl0aGVyaW5nKCB2ZWMzIGNvbG9yICkgewoJCWZsb2F0IGdyaWRfcG9zaXRpb24gPSByYW5kKCBnbF9GcmFnQ29vcmQueHkgKTsKCQl2ZWMzIGRpdGhlcl9zaGlmdF9SR0IgPSB2ZWMzKCAwLjI1IC8gMjU1LjAsIC0wLjI1IC8gMjU1LjAsIDAuMjUgLyAyNTUuMCApOwoJCWRpdGhlcl9zaGlmdF9SR0IgPSBtaXgoIDIuMCAqIGRpdGhlcl9zaGlmdF9SR0IsIC0yLjAgKiBkaXRoZXJfc2hpZnRfUkdCLCBncmlkX3Bvc2l0aW9uICk7CgkJcmV0dXJuIGNvbG9yICsgZGl0aGVyX3NoaWZ0X1JHQjsKCX0KI2VuZGlmYCxTXz1gZmxvYXQgcm91Z2huZXNzRmFjdG9yID0gcm91Z2huZXNzOwojaWZkZWYgVVNFX1JPVUdITkVTU01BUAoJdmVjNCB0ZXhlbFJvdWdobmVzcyA9IHRleHR1cmUyRCggcm91Z2huZXNzTWFwLCB2Um91Z2huZXNzTWFwVXYgKTsKCXJvdWdobmVzc0ZhY3RvciAqPSB0ZXhlbFJvdWdobmVzcy5nOwojZW5kaWZgLGJfPWAjaWZkZWYgVVNFX1JPVUdITkVTU01BUAoJdW5pZm9ybSBzYW1wbGVyMkQgcm91Z2huZXNzTWFwOwojZW5kaWZgLEVfPWAjaWYgTlVNX1NQT1RfTElHSFRfQ09PUkRTID4gMAoJdmFyeWluZyB2ZWM0IHZTcG90TGlnaHRDb29yZFsgTlVNX1NQT1RfTElHSFRfQ09PUkRTIF07CiNlbmRpZgojaWYgTlVNX1NQT1RfTElHSFRfTUFQUyA+IDAKCXVuaWZvcm0gc2FtcGxlcjJEIHNwb3RMaWdodE1hcFsgTlVNX1NQT1RfTElHSFRfTUFQUyBdOwojZW5kaWYKI2lmZGVmIFVTRV9TSEFET1dNQVAKCSNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwCgkJdW5pZm9ybSBzYW1wbGVyMkQgZGlyZWN0aW9uYWxTaGFkb3dNYXBbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdOwoJCXZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07CgkJc3RydWN0IERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgewoJCQlmbG9hdCBzaGFkb3dCaWFzOwoJCQlmbG9hdCBzaGFkb3dOb3JtYWxCaWFzOwoJCQlmbG9hdCBzaGFkb3dSYWRpdXM7CgkJCXZlYzIgc2hhZG93TWFwU2l6ZTsKCQl9OwoJCXVuaWZvcm0gRGlyZWN0aW9uYWxMaWdodFNoYWRvdyBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07CgkjZW5kaWYKCSNpZiBOVU1fU1BPVF9MSUdIVF9TSEFET1dTID4gMAoJCXVuaWZvcm0gc2FtcGxlcjJEIHNwb3RTaGFkb3dNYXBbIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgXTsKCQlzdHJ1Y3QgU3BvdExpZ2h0U2hhZG93IHsKCQkJZmxvYXQgc2hhZG93QmlhczsKCQkJZmxvYXQgc2hhZG93Tm9ybWFsQmlhczsKCQkJZmxvYXQgc2hhZG93UmFkaXVzOwoJCQl2ZWMyIHNoYWRvd01hcFNpemU7CgkJfTsKCQl1bmlmb3JtIFNwb3RMaWdodFNoYWRvdyBzcG90TGlnaHRTaGFkb3dzWyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIF07CgkjZW5kaWYKCSNpZiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDAKCQl1bmlmb3JtIHNhbXBsZXIyRCBwb2ludFNoYWRvd01hcFsgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgXTsKCQl2YXJ5aW5nIHZlYzQgdlBvaW50U2hhZG93Q29vcmRbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07CgkJc3RydWN0IFBvaW50TGlnaHRTaGFkb3cgewoJCQlmbG9hdCBzaGFkb3dCaWFzOwoJCQlmbG9hdCBzaGFkb3dOb3JtYWxCaWFzOwoJCQlmbG9hdCBzaGFkb3dSYWRpdXM7CgkJCXZlYzIgc2hhZG93TWFwU2l6ZTsKCQkJZmxvYXQgc2hhZG93Q2FtZXJhTmVhcjsKCQkJZmxvYXQgc2hhZG93Q2FtZXJhRmFyOwoJCX07CgkJdW5pZm9ybSBQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHRTaGFkb3dzWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdOwoJI2VuZGlmCglmbG9hdCB0ZXh0dXJlMkRDb21wYXJlKCBzYW1wbGVyMkQgZGVwdGhzLCB2ZWMyIHV2LCBmbG9hdCBjb21wYXJlICkgewoJCXJldHVybiBzdGVwKCBjb21wYXJlLCB1bnBhY2tSR0JBVG9EZXB0aCggdGV4dHVyZTJEKCBkZXB0aHMsIHV2ICkgKSApOwoJfQoJdmVjMiB0ZXh0dXJlMkREaXN0cmlidXRpb24oIHNhbXBsZXIyRCBzaGFkb3csIHZlYzIgdXYgKSB7CgkJcmV0dXJuIHVucGFja1JHQkFUbzJIYWxmKCB0ZXh0dXJlMkQoIHNoYWRvdywgdXYgKSApOwoJfQoJZmxvYXQgVlNNU2hhZG93IChzYW1wbGVyMkQgc2hhZG93LCB2ZWMyIHV2LCBmbG9hdCBjb21wYXJlICl7CgkJZmxvYXQgb2NjbHVzaW9uID0gMS4wOwoJCXZlYzIgZGlzdHJpYnV0aW9uID0gdGV4dHVyZTJERGlzdHJpYnV0aW9uKCBzaGFkb3csIHV2ICk7CgkJZmxvYXQgaGFyZF9zaGFkb3cgPSBzdGVwKCBjb21wYXJlICwgZGlzdHJpYnV0aW9uLnggKTsKCQlpZiAoaGFyZF9zaGFkb3cgIT0gMS4wICkgewoJCQlmbG9hdCBkaXN0YW5jZSA9IGNvbXBhcmUgLSBkaXN0cmlidXRpb24ueCA7CgkJCWZsb2F0IHZhcmlhbmNlID0gbWF4KCAwLjAwMDAwLCBkaXN0cmlidXRpb24ueSAqIGRpc3RyaWJ1dGlvbi55ICk7CgkJCWZsb2F0IHNvZnRuZXNzX3Byb2JhYmlsaXR5ID0gdmFyaWFuY2UgLyAodmFyaWFuY2UgKyBkaXN0YW5jZSAqIGRpc3RhbmNlICk7CQkJc29mdG5lc3NfcHJvYmFiaWxpdHkgPSBjbGFtcCggKCBzb2Z0bmVzc19wcm9iYWJpbGl0eSAtIDAuMyApIC8gKCAwLjk1IC0gMC4zICksIDAuMCwgMS4wICk7CQkJb2NjbHVzaW9uID0gY2xhbXAoIG1heCggaGFyZF9zaGFkb3csIHNvZnRuZXNzX3Byb2JhYmlsaXR5ICksIDAuMCwgMS4wICk7CgkJfQoJCXJldHVybiBvY2NsdXNpb247Cgl9CglmbG9hdCBnZXRTaGFkb3coIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgc2hhZG93TWFwU2l6ZSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkICkgewoJCWZsb2F0IHNoYWRvdyA9IDEuMDsKCQlzaGFkb3dDb29yZC54eXogLz0gc2hhZG93Q29vcmQudzsKCQlzaGFkb3dDb29yZC56ICs9IHNoYWRvd0JpYXM7CgkJYm9vbCBpbkZydXN0dW0gPSBzaGFkb3dDb29yZC54ID49IDAuMCAmJiBzaGFkb3dDb29yZC54IDw9IDEuMCAmJiBzaGFkb3dDb29yZC55ID49IDAuMCAmJiBzaGFkb3dDb29yZC55IDw9IDEuMDsKCQlib29sIGZydXN0dW1UZXN0ID0gaW5GcnVzdHVtICYmIHNoYWRvd0Nvb3JkLnogPD0gMS4wOwoJCWlmICggZnJ1c3R1bVRlc3QgKSB7CgkJI2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApCgkJCXZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyBzaGFkb3dNYXBTaXplOwoJCQlmbG9hdCBkeDAgPSAtIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzOwoJCQlmbG9hdCBkeTAgPSAtIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzOwoJCQlmbG9hdCBkeDEgPSArIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzOwoJCQlmbG9hdCBkeTEgPSArIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzOwoJCQlmbG9hdCBkeDIgPSBkeDAgLyAyLjA7CgkJCWZsb2F0IGR5MiA9IGR5MCAvIDIuMDsKCQkJZmxvYXQgZHgzID0gZHgxIC8gMi4wOwoJCQlmbG9hdCBkeTMgPSBkeTEgLyAyLjA7CgkJCXNoYWRvdyA9ICgKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDIsIGR5MiApLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkyICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgzLCBkeTIgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MiwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MywgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDIsIGR5MyApLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkzICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgzLCBkeTMgKSwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSwgc2hhZG93Q29vcmQueiApCgkJCSkgKiAoIDEuMCAvIDE3LjAgKTsKCQkjZWxpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApCgkJCXZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyBzaGFkb3dNYXBTaXplOwoJCQlmbG9hdCBkeCA9IHRleGVsU2l6ZS54OwoJCQlmbG9hdCBkeSA9IHRleGVsU2l6ZS55OwoJCQl2ZWMyIHV2ID0gc2hhZG93Q29vcmQueHk7CgkJCXZlYzIgZiA9IGZyYWN0KCB1diAqIHNoYWRvd01hcFNpemUgKyAwLjUgKTsKCQkJdXYgLT0gZiAqIHRleGVsU2l6ZTsKCQkJc2hhZG93ID0gKAoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diwgc2hhZG93Q29vcmQueiApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCBkeCwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArCgkJCQl0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMC4wLCBkeSApLCBzaGFkb3dDb29yZC56ICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHRleGVsU2l6ZSwgc2hhZG93Q29vcmQueiApICsKCQkJCW1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIC1keCwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSwKCQkJCQkgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDIuMCAqIGR4LCAwLjAgKSwgc2hhZG93Q29vcmQueiApLAoJCQkJCSBmLnggKSArCgkJCQltaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAtZHgsIGR5ICksIHNoYWRvd0Nvb3JkLnogKSwKCQkJCQkgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDIuMCAqIGR4LCBkeSApLCBzaGFkb3dDb29yZC56ICksCgkJCQkJIGYueCApICsKCQkJCW1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDAuMCwgLWR5ICksIHNoYWRvd0Nvb3JkLnogKSwKCQkJCQkgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDAuMCwgMi4wICogZHkgKSwgc2hhZG93Q29vcmQueiApLAoJCQkJCSBmLnkgKSArCgkJCQltaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCBkeCwgLWR5ICksIHNoYWRvd0Nvb3JkLnogKSwKCQkJCQkgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIGR4LCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksCgkJCQkJIGYueSApICsKCQkJCW1peCggbWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCAtZHkgKSwgc2hhZG93Q29vcmQueiApLAoJCQkJCQkgIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAyLjAgKiBkeCwgLWR5ICksIHNoYWRvd0Nvb3JkLnogKSwKCQkJCQkJICBmLnggKSwKCQkJCQkgbWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksCgkJCQkJCSAgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDIuMCAqIGR4LCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksCgkJCQkJCSAgZi54ICksCgkJCQkJIGYueSApCgkJCSkgKiAoIDEuMCAvIDkuMCApOwoJCSNlbGlmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1ZTTSApCgkJCXNoYWRvdyA9IFZTTVNoYWRvdyggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApOwoJCSNlbHNlCgkJCXNoYWRvdyA9IHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKTsKCQkjZW5kaWYKCQl9CgkJcmV0dXJuIHNoYWRvdzsKCX0KCXZlYzIgY3ViZVRvVVYoIHZlYzMgdiwgZmxvYXQgdGV4ZWxTaXplWSApIHsKCQl2ZWMzIGFic1YgPSBhYnMoIHYgKTsKCQlmbG9hdCBzY2FsZVRvQ3ViZSA9IDEuMCAvIG1heCggYWJzVi54LCBtYXgoIGFic1YueSwgYWJzVi56ICkgKTsKCQlhYnNWICo9IHNjYWxlVG9DdWJlOwoJCXYgKj0gc2NhbGVUb0N1YmUgKiAoIDEuMCAtIDIuMCAqIHRleGVsU2l6ZVkgKTsKCQl2ZWMyIHBsYW5hciA9IHYueHk7CgkJZmxvYXQgYWxtb3N0QVRleGVsID0gMS41ICogdGV4ZWxTaXplWTsKCQlmbG9hdCBhbG1vc3RPbmUgPSAxLjAgLSBhbG1vc3RBVGV4ZWw7CgkJaWYgKCBhYnNWLnogPj0gYWxtb3N0T25lICkgewoJCQlpZiAoIHYueiA+IDAuMCApCgkJCQlwbGFuYXIueCA9IDQuMCAtIHYueDsKCQl9IGVsc2UgaWYgKCBhYnNWLnggPj0gYWxtb3N0T25lICkgewoJCQlmbG9hdCBzaWduWCA9IHNpZ24oIHYueCApOwoJCQlwbGFuYXIueCA9IHYueiAqIHNpZ25YICsgMi4wICogc2lnblg7CgkJfSBlbHNlIGlmICggYWJzVi55ID49IGFsbW9zdE9uZSApIHsKCQkJZmxvYXQgc2lnblkgPSBzaWduKCB2LnkgKTsKCQkJcGxhbmFyLnggPSB2LnggKyAyLjAgKiBzaWduWSArIDIuMDsKCQkJcGxhbmFyLnkgPSB2LnogKiBzaWduWSAtIDIuMDsKCQl9CgkJcmV0dXJuIHZlYzIoIDAuMTI1LCAwLjI1ICkgKiBwbGFuYXIgKyB2ZWMyKCAwLjM3NSwgMC43NSApOwoJfQoJZmxvYXQgZ2V0UG9pbnRTaGFkb3coIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgc2hhZG93TWFwU2l6ZSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkLCBmbG9hdCBzaGFkb3dDYW1lcmFOZWFyLCBmbG9hdCBzaGFkb3dDYW1lcmFGYXIgKSB7CgkJdmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvICggc2hhZG93TWFwU2l6ZSAqIHZlYzIoIDQuMCwgMi4wICkgKTsKCQl2ZWMzIGxpZ2h0VG9Qb3NpdGlvbiA9IHNoYWRvd0Nvb3JkLnh5ejsKCQlmbG9hdCBkcCA9ICggbGVuZ3RoKCBsaWdodFRvUG9zaXRpb24gKSAtIHNoYWRvd0NhbWVyYU5lYXIgKSAvICggc2hhZG93Q2FtZXJhRmFyIC0gc2hhZG93Q2FtZXJhTmVhciApOwkJZHAgKz0gc2hhZG93QmlhczsKCQl2ZWMzIGJkM0QgPSBub3JtYWxpemUoIGxpZ2h0VG9Qb3NpdGlvbiApOwoJCSNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKSB8fCBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApIHx8IGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1ZTTSApCgkJCXZlYzIgb2Zmc2V0ID0gdmVjMiggLSAxLCAxICkgKiBzaGFkb3dSYWRpdXMgKiB0ZXhlbFNpemUueTsKCQkJcmV0dXJuICgKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHl5LCB0ZXhlbFNpemUueSApLCBkcCApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXl5LCB0ZXhlbFNpemUueSApLCBkcCApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHl4LCB0ZXhlbFNpemUueSApLCBkcCApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXl4LCB0ZXhlbFNpemUueSApLCBkcCApICsKCQkJCXRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QsIHRleGVsU2l6ZS55ICksIGRwICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eHksIHRleGVsU2l6ZS55ICksIGRwICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eHksIHRleGVsU2l6ZS55ICksIGRwICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eHgsIHRleGVsU2l6ZS55ICksIGRwICkgKwoJCQkJdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eHgsIHRleGVsU2l6ZS55ICksIGRwICkKCQkJKSAqICggMS4wIC8gOS4wICk7CgkJI2Vsc2UKCQkJcmV0dXJuIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QsIHRleGVsU2l6ZS55ICksIGRwICk7CgkJI2VuZGlmCgl9CiNlbmRpZmAsQV89YCNpZiBOVU1fU1BPVF9MSUdIVF9DT09SRFMgPiAwCgl1bmlmb3JtIG1hdDQgc3BvdExpZ2h0TWF0cml4WyBOVU1fU1BPVF9MSUdIVF9DT09SRFMgXTsKCXZhcnlpbmcgdmVjNCB2U3BvdExpZ2h0Q29vcmRbIE5VTV9TUE9UX0xJR0hUX0NPT1JEUyBdOwojZW5kaWYKI2lmZGVmIFVTRV9TSEFET1dNQVAKCSNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwCgkJdW5pZm9ybSBtYXQ0IGRpcmVjdGlvbmFsU2hhZG93TWF0cml4WyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTsKCQl2YXJ5aW5nIHZlYzQgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdOwoJCXN0cnVjdCBEaXJlY3Rpb25hbExpZ2h0U2hhZG93IHsKCQkJZmxvYXQgc2hhZG93QmlhczsKCQkJZmxvYXQgc2hhZG93Tm9ybWFsQmlhczsKCQkJZmxvYXQgc2hhZG93UmFkaXVzOwoJCQl2ZWMyIHNoYWRvd01hcFNpemU7CgkJfTsKCQl1bmlmb3JtIERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdOwoJI2VuZGlmCgkjaWYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDAKCQlzdHJ1Y3QgU3BvdExpZ2h0U2hhZG93IHsKCQkJZmxvYXQgc2hhZG93QmlhczsKCQkJZmxvYXQgc2hhZG93Tm9ybWFsQmlhczsKCQkJZmxvYXQgc2hhZG93UmFkaXVzOwoJCQl2ZWMyIHNoYWRvd01hcFNpemU7CgkJfTsKCQl1bmlmb3JtIFNwb3RMaWdodFNoYWRvdyBzcG90TGlnaHRTaGFkb3dzWyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIF07CgkjZW5kaWYKCSNpZiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDAKCQl1bmlmb3JtIG1hdDQgcG9pbnRTaGFkb3dNYXRyaXhbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07CgkJdmFyeWluZyB2ZWM0IHZQb2ludFNoYWRvd0Nvb3JkWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdOwoJCXN0cnVjdCBQb2ludExpZ2h0U2hhZG93IHsKCQkJZmxvYXQgc2hhZG93QmlhczsKCQkJZmxvYXQgc2hhZG93Tm9ybWFsQmlhczsKCQkJZmxvYXQgc2hhZG93UmFkaXVzOwoJCQl2ZWMyIHNoYWRvd01hcFNpemU7CgkJCWZsb2F0IHNoYWRvd0NhbWVyYU5lYXI7CgkJCWZsb2F0IHNoYWRvd0NhbWVyYUZhcjsKCQl9OwoJCXVuaWZvcm0gUG9pbnRMaWdodFNoYWRvdyBwb2ludExpZ2h0U2hhZG93c1sgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgXTsKCSNlbmRpZgojZW5kaWZgLFRfPWAjaWYgKCBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgKCBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwIHx8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMCApICkgfHwgKCBOVU1fU1BPVF9MSUdIVF9DT09SRFMgPiAwICkKCXZlYzMgc2hhZG93V29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCB0cmFuc2Zvcm1lZE5vcm1hbCwgdmlld01hdHJpeCApOwoJdmVjNCBzaGFkb3dXb3JsZFBvc2l0aW9uOwojZW5kaWYKI2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKQoJI2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDAKCQkjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0CgkJZm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVF9TSEFET1dTOyBpICsrICkgewoJCQlzaGFkb3dXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbiArIHZlYzQoIHNoYWRvd1dvcmxkTm9ybWFsICogZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIGkgXS5zaGFkb3dOb3JtYWxCaWFzLCAwICk7CgkJCXZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gPSBkaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgaSBdICogc2hhZG93V29ybGRQb3NpdGlvbjsKCQl9CgkJI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmQKCSNlbmRpZgoJI2lmIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMAoJCSNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnQKCQlmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUzsgaSArKyApIHsKCQkJc2hhZG93V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24gKyB2ZWM0KCBzaGFkb3dXb3JsZE5vcm1hbCAqIHBvaW50TGlnaHRTaGFkb3dzWyBpIF0uc2hhZG93Tm9ybWFsQmlhcywgMCApOwoJCQl2UG9pbnRTaGFkb3dDb29yZFsgaSBdID0gcG9pbnRTaGFkb3dNYXRyaXhbIGkgXSAqIHNoYWRvd1dvcmxkUG9zaXRpb247CgkJfQoJCSNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kCgkjZW5kaWYKI2VuZGlmCiNpZiBOVU1fU1BPVF9MSUdIVF9DT09SRFMgPiAwCgkjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0Cglmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVF9DT09SRFM7IGkgKysgKSB7CgkJc2hhZG93V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb247CgkJI2lmICggZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmIFVOUk9MTEVEX0xPT1BfSU5ERVggPCBOVU1fU1BPVF9MSUdIVF9TSEFET1dTICkKCQkJc2hhZG93V29ybGRQb3NpdGlvbi54eXogKz0gc2hhZG93V29ybGROb3JtYWwgKiBzcG90TGlnaHRTaGFkb3dzWyBpIF0uc2hhZG93Tm9ybWFsQmlhczsKCQkjZW5kaWYKCQl2U3BvdExpZ2h0Q29vcmRbIGkgXSA9IHNwb3RMaWdodE1hdHJpeFsgaSBdICogc2hhZG93V29ybGRQb3NpdGlvbjsKCX0KCSNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kCiNlbmRpZmAsd189YGZsb2F0IGdldFNoYWRvd01hc2soKSB7CglmbG9hdCBzaGFkb3cgPSAxLjA7CgkjaWZkZWYgVVNFX1NIQURPV01BUAoJI2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDAKCURpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZGlyZWN0aW9uYWxMaWdodDsKCSNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnQKCWZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRfU0hBRE9XUzsgaSArKyApIHsKCQlkaXJlY3Rpb25hbExpZ2h0ID0gZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIGkgXTsKCQlzaGFkb3cgKj0gcmVjZWl2ZVNoYWRvdyA/IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7Cgl9CgkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAoJI2VuZGlmCgkjaWYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDAKCVNwb3RMaWdodFNoYWRvdyBzcG90TGlnaHQ7CgkjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0Cglmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVF9TSEFET1dTOyBpICsrICkgewoJCXNwb3RMaWdodCA9IHNwb3RMaWdodFNoYWRvd3NbIGkgXTsKCQlzaGFkb3cgKj0gcmVjZWl2ZVNoYWRvdyA/IGdldFNoYWRvdyggc3BvdFNoYWRvd01hcFsgaSBdLCBzcG90TGlnaHQuc2hhZG93TWFwU2l6ZSwgc3BvdExpZ2h0LnNoYWRvd0JpYXMsIHNwb3RMaWdodC5zaGFkb3dSYWRpdXMsIHZTcG90TGlnaHRDb29yZFsgaSBdICkgOiAxLjA7Cgl9CgkjcHJhZ21hIHVucm9sbF9sb29wX2VuZAoJI2VuZGlmCgkjaWYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwCglQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHQ7CgkjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0Cglmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUzsgaSArKyApIHsKCQlwb2ludExpZ2h0ID0gcG9pbnRMaWdodFNoYWRvd3NbIGkgXTsKCQlzaGFkb3cgKj0gcmVjZWl2ZVNoYWRvdyA/IGdldFBvaW50U2hhZG93KCBwb2ludFNoYWRvd01hcFsgaSBdLCBwb2ludExpZ2h0LnNoYWRvd01hcFNpemUsIHBvaW50TGlnaHQuc2hhZG93QmlhcywgcG9pbnRMaWdodC5zaGFkb3dSYWRpdXMsIHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93Q2FtZXJhTmVhciwgcG9pbnRMaWdodC5zaGFkb3dDYW1lcmFGYXIgKSA6IDEuMDsKCX0KCSNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kCgkjZW5kaWYKCSNlbmRpZgoJcmV0dXJuIHNoYWRvdzsKfWAsUl89YCNpZmRlZiBVU0VfU0tJTk5JTkcKCW1hdDQgYm9uZU1hdFggPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueCApOwoJbWF0NCBib25lTWF0WSA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC55ICk7CgltYXQ0IGJvbmVNYXRaID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnogKTsKCW1hdDQgYm9uZU1hdFcgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgudyApOwojZW5kaWZgLENfPWAjaWZkZWYgVVNFX1NLSU5OSU5HCgl1bmlmb3JtIG1hdDQgYmluZE1hdHJpeDsKCXVuaWZvcm0gbWF0NCBiaW5kTWF0cml4SW52ZXJzZTsKCXVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGJvbmVUZXh0dXJlOwoJbWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkgewoJCWludCBzaXplID0gdGV4dHVyZVNpemUoIGJvbmVUZXh0dXJlLCAwICkueDsKCQlpbnQgaiA9IGludCggaSApICogNDsKCQlpbnQgeCA9IGogJSBzaXplOwoJCWludCB5ID0gaiAvIHNpemU7CgkJdmVjNCB2MSA9IHRleGVsRmV0Y2goIGJvbmVUZXh0dXJlLCBpdmVjMiggeCwgeSApLCAwICk7CgkJdmVjNCB2MiA9IHRleGVsRmV0Y2goIGJvbmVUZXh0dXJlLCBpdmVjMiggeCArIDEsIHkgKSwgMCApOwoJCXZlYzQgdjMgPSB0ZXhlbEZldGNoKCBib25lVGV4dHVyZSwgaXZlYzIoIHggKyAyLCB5ICksIDAgKTsKCQl2ZWM0IHY0ID0gdGV4ZWxGZXRjaCggYm9uZVRleHR1cmUsIGl2ZWMyKCB4ICsgMywgeSApLCAwICk7CgkJcmV0dXJuIG1hdDQoIHYxLCB2MiwgdjMsIHY0ICk7Cgl9CiNlbmRpZmAsUF89YCNpZmRlZiBVU0VfU0tJTk5JTkcKCXZlYzQgc2tpblZlcnRleCA9IGJpbmRNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7Cgl2ZWM0IHNraW5uZWQgPSB2ZWM0KCAwLjAgKTsKCXNraW5uZWQgKz0gYm9uZU1hdFggKiBza2luVmVydGV4ICogc2tpbldlaWdodC54OwoJc2tpbm5lZCArPSBib25lTWF0WSAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnk7Cglza2lubmVkICs9IGJvbmVNYXRaICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQuejsKCXNraW5uZWQgKz0gYm9uZU1hdFcgKiBza2luVmVydGV4ICogc2tpbldlaWdodC53OwoJdHJhbnNmb3JtZWQgPSAoIGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbm5lZCApLnh5ejsKI2VuZGlmYCxMXz1gI2lmZGVmIFVTRV9TS0lOTklORwoJbWF0NCBza2luTWF0cml4ID0gbWF0NCggMC4wICk7Cglza2luTWF0cml4ICs9IHNraW5XZWlnaHQueCAqIGJvbmVNYXRYOwoJc2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnkgKiBib25lTWF0WTsKCXNraW5NYXRyaXggKz0gc2tpbldlaWdodC56ICogYm9uZU1hdFo7Cglza2luTWF0cml4ICs9IHNraW5XZWlnaHQudyAqIGJvbmVNYXRXOwoJc2tpbk1hdHJpeCA9IGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbk1hdHJpeCAqIGJpbmRNYXRyaXg7CglvYmplY3ROb3JtYWwgPSB2ZWM0KCBza2luTWF0cml4ICogdmVjNCggb2JqZWN0Tm9ybWFsLCAwLjAgKSApLnh5ejsKCSNpZmRlZiBVU0VfVEFOR0VOVAoJCW9iamVjdFRhbmdlbnQgPSB2ZWM0KCBza2luTWF0cml4ICogdmVjNCggb2JqZWN0VGFuZ2VudCwgMC4wICkgKS54eXo7CgkjZW5kaWYKI2VuZGlmYCxJXz1gZmxvYXQgc3BlY3VsYXJTdHJlbmd0aDsKI2lmZGVmIFVTRV9TUEVDVUxBUk1BUAoJdmVjNCB0ZXhlbFNwZWN1bGFyID0gdGV4dHVyZTJEKCBzcGVjdWxhck1hcCwgdlNwZWN1bGFyTWFwVXYgKTsKCXNwZWN1bGFyU3RyZW5ndGggPSB0ZXhlbFNwZWN1bGFyLnI7CiNlbHNlCglzcGVjdWxhclN0cmVuZ3RoID0gMS4wOwojZW5kaWZgLFVfPWAjaWZkZWYgVVNFX1NQRUNVTEFSTUFQCgl1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhck1hcDsKI2VuZGlmYCxEXz1gI2lmIGRlZmluZWQoIFRPTkVfTUFQUElORyApCglnbF9GcmFnQ29sb3IucmdiID0gdG9uZU1hcHBpbmcoIGdsX0ZyYWdDb2xvci5yZ2IgKTsKI2VuZGlmYCxOXz1gI2lmbmRlZiBzYXR1cmF0ZQojZGVmaW5lIHNhdHVyYXRlKCBhICkgY2xhbXAoIGEsIDAuMCwgMS4wICkKI2VuZGlmCnVuaWZvcm0gZmxvYXQgdG9uZU1hcHBpbmdFeHBvc3VyZTsKdmVjMyBMaW5lYXJUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHsKCXJldHVybiBzYXR1cmF0ZSggdG9uZU1hcHBpbmdFeHBvc3VyZSAqIGNvbG9yICk7Cn0KdmVjMyBSZWluaGFyZFRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkgewoJY29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTsKCXJldHVybiBzYXR1cmF0ZSggY29sb3IgLyAoIHZlYzMoIDEuMCApICsgY29sb3IgKSApOwp9CnZlYzMgT3B0aW1pemVkQ2luZW9uVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7Cgljb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlOwoJY29sb3IgPSBtYXgoIHZlYzMoIDAuMCApLCBjb2xvciAtIDAuMDA0ICk7CglyZXR1cm4gcG93KCAoIGNvbG9yICogKCA2LjIgKiBjb2xvciArIDAuNSApICkgLyAoIGNvbG9yICogKCA2LjIgKiBjb2xvciArIDEuNyApICsgMC4wNiApLCB2ZWMzKCAyLjIgKSApOwp9CnZlYzMgUlJUQW5kT0RURml0KCB2ZWMzIHYgKSB7Cgl2ZWMzIGEgPSB2ICogKCB2ICsgMC4wMjQ1Nzg2ICkgLSAwLjAwMDA5MDUzNzsKCXZlYzMgYiA9IHYgKiAoIDAuOTgzNzI5ICogdiArIDAuNDMyOTUxMCApICsgMC4yMzgwODE7CglyZXR1cm4gYSAvIGI7Cn0KdmVjMyBBQ0VTRmlsbWljVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7Cgljb25zdCBtYXQzIEFDRVNJbnB1dE1hdCA9IG1hdDMoCgkJdmVjMyggMC41OTcxOSwgMC4wNzYwMCwgMC4wMjg0MCApLAkJdmVjMyggMC4zNTQ1OCwgMC45MDgzNCwgMC4xMzM4MyApLAoJCXZlYzMoIDAuMDQ4MjMsIDAuMDE1NjYsIDAuODM3NzcgKQoJKTsKCWNvbnN0IG1hdDMgQUNFU091dHB1dE1hdCA9IG1hdDMoCgkJdmVjMyggIDEuNjA0NzUsIC0wLjEwMjA4LCAtMC4wMDMyNyApLAkJdmVjMyggLTAuNTMxMDgsICAxLjEwODEzLCAtMC4wNzI3NiApLAoJCXZlYzMoIC0wLjA3MzY3LCAtMC4wMDYwNSwgIDEuMDc2MDIgKQoJKTsKCWNvbG9yICo9IHRvbmVNYXBwaW5nRXhwb3N1cmUgLyAwLjY7Cgljb2xvciA9IEFDRVNJbnB1dE1hdCAqIGNvbG9yOwoJY29sb3IgPSBSUlRBbmRPRFRGaXQoIGNvbG9yICk7Cgljb2xvciA9IEFDRVNPdXRwdXRNYXQgKiBjb2xvcjsKCXJldHVybiBzYXR1cmF0ZSggY29sb3IgKTsKfQpjb25zdCBtYXQzIExJTkVBUl9SRUMyMDIwX1RPX0xJTkVBUl9TUkdCID0gbWF0MygKCXZlYzMoIDEuNjYwNSwgLSAwLjEyNDYsIC0gMC4wMTgyICksCgl2ZWMzKCAtIDAuNTg3NiwgMS4xMzI5LCAtIDAuMTAwNiApLAoJdmVjMyggLSAwLjA3MjgsIC0gMC4wMDgzLCAxLjExODcgKQopOwpjb25zdCBtYXQzIExJTkVBUl9TUkdCX1RPX0xJTkVBUl9SRUMyMDIwID0gbWF0MygKCXZlYzMoIDAuNjI3NCwgMC4wNjkxLCAwLjAxNjQgKSwKCXZlYzMoIDAuMzI5MywgMC45MTk1LCAwLjA4ODAgKSwKCXZlYzMoIDAuMDQzMywgMC4wMTEzLCAwLjg5NTYgKQopOwp2ZWMzIGFneERlZmF1bHRDb250cmFzdEFwcHJveCggdmVjMyB4ICkgewoJdmVjMyB4MiA9IHggKiB4OwoJdmVjMyB4NCA9IHgyICogeDI7CglyZXR1cm4gKyAxNS41ICogeDQgKiB4MgoJCS0gNDAuMTQgKiB4NCAqIHgKCQkrIDMxLjk2ICogeDQKCQktIDYuODY4ICogeDIgKiB4CgkJKyAwLjQyOTggKiB4MgoJCSsgMC4xMTkxICogeAoJCS0gMC4wMDIzMjsKfQp2ZWMzIEFnWFRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkgewoJY29uc3QgbWF0MyBBZ1hJbnNldE1hdHJpeCA9IG1hdDMoCgkJdmVjMyggMC44NTY2MjcxNTMzMTU5ODMsIDAuMTM3MzE4OTcyOTI5ODQ3LCAwLjExMTg5ODIxMjk5OTk1ICksCgkJdmVjMyggMC4wOTUxMjEyNDA1MzgxNTg4LCAwLjc2MTI0MTk5MDYwMjU5MSwgMC4wNzY3OTk0MTg2MDMxOTAzICksCgkJdmVjMyggMC4wNDgyNTE2MDYxNDU4NTgzLCAwLjEwMTQzOTAzNjQ2NzU2MiwgMC44MTEzMDIzNjgzOTY4NTkgKQoJKTsKCWNvbnN0IG1hdDMgQWdYT3V0c2V0TWF0cml4ID0gbWF0MygKCQl2ZWMzKCAxLjEyNzEwMDU4MTgxNDQzNjgsIC0gMC4xNDEzMjk3NjM0OTg0MzgzLCAtIDAuMTQxMzI5NzYzNDk4NDM4MjYgKSwKCQl2ZWMzKCAtIDAuMTEwNjA2NjQzMDk2NjAzMjMsIDEuMTU3ODIzNzAyMjE2MjcyLCAtIDAuMTEwNjA2NjQzMDk2NjAyOTQgKSwKCQl2ZWMzKCAtIDAuMDE2NDkzOTM4NzE3ODM0NTczLCAtIDAuMDE2NDkzOTM4NzE3ODM0MjU3LCAxLjI1MTkzNjQwNjU5NTA0MDUgKQoJKTsKCWNvbnN0IGZsb2F0IEFneE1pbkV2ID0gLSAxMi40NzM5MzsJY29uc3QgZmxvYXQgQWd4TWF4RXYgPSA0LjAyNjA2OTsKCWNvbG9yICo9IHRvbmVNYXBwaW5nRXhwb3N1cmU7Cgljb2xvciA9IExJTkVBUl9TUkdCX1RPX0xJTkVBUl9SRUMyMDIwICogY29sb3I7Cgljb2xvciA9IEFnWEluc2V0TWF0cml4ICogY29sb3I7Cgljb2xvciA9IG1heCggY29sb3IsIDFlLTEwICk7CWNvbG9yID0gbG9nMiggY29sb3IgKTsKCWNvbG9yID0gKCBjb2xvciAtIEFneE1pbkV2ICkgLyAoIEFneE1heEV2IC0gQWd4TWluRXYgKTsKCWNvbG9yID0gY2xhbXAoIGNvbG9yLCAwLjAsIDEuMCApOwoJY29sb3IgPSBhZ3hEZWZhdWx0Q29udHJhc3RBcHByb3goIGNvbG9yICk7Cgljb2xvciA9IEFnWE91dHNldE1hdHJpeCAqIGNvbG9yOwoJY29sb3IgPSBwb3coIG1heCggdmVjMyggMC4wICksIGNvbG9yICksIHZlYzMoIDIuMiApICk7Cgljb2xvciA9IExJTkVBUl9SRUMyMDIwX1RPX0xJTkVBUl9TUkdCICogY29sb3I7Cgljb2xvciA9IGNsYW1wKCBjb2xvciwgMC4wLCAxLjAgKTsKCXJldHVybiBjb2xvcjsKfQp2ZWMzIEN1c3RvbVRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkgeyByZXR1cm4gY29sb3I7IH1gLE9fPWAjaWZkZWYgVVNFX1RSQU5TTUlTU0lPTgoJbWF0ZXJpYWwudHJhbnNtaXNzaW9uID0gdHJhbnNtaXNzaW9uOwoJbWF0ZXJpYWwudHJhbnNtaXNzaW9uQWxwaGEgPSAxLjA7CgltYXRlcmlhbC50aGlja25lc3MgPSB0aGlja25lc3M7CgltYXRlcmlhbC5hdHRlbnVhdGlvbkRpc3RhbmNlID0gYXR0ZW51YXRpb25EaXN0YW5jZTsKCW1hdGVyaWFsLmF0dGVudWF0aW9uQ29sb3IgPSBhdHRlbnVhdGlvbkNvbG9yOwoJI2lmZGVmIFVTRV9UUkFOU01JU1NJT05NQVAKCQltYXRlcmlhbC50cmFuc21pc3Npb24gKj0gdGV4dHVyZTJEKCB0cmFuc21pc3Npb25NYXAsIHZUcmFuc21pc3Npb25NYXBVdiApLnI7CgkjZW5kaWYKCSNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQCgkJbWF0ZXJpYWwudGhpY2tuZXNzICo9IHRleHR1cmUyRCggdGhpY2tuZXNzTWFwLCB2VGhpY2tuZXNzTWFwVXYgKS5nOwoJI2VuZGlmCgl2ZWMzIHBvcyA9IHZXb3JsZFBvc2l0aW9uOwoJdmVjMyB2ID0gbm9ybWFsaXplKCBjYW1lcmFQb3NpdGlvbiAtIHBvcyApOwoJdmVjMyBuID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7Cgl2ZWM0IHRyYW5zbWl0dGVkID0gZ2V0SUJMVm9sdW1lUmVmcmFjdGlvbigKCQluLCB2LCBtYXRlcmlhbC5yb3VnaG5lc3MsIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJGOTAsCgkJcG9zLCBtb2RlbE1hdHJpeCwgdmlld01hdHJpeCwgcHJvamVjdGlvbk1hdHJpeCwgbWF0ZXJpYWwuaW9yLCBtYXRlcmlhbC50aGlja25lc3MsCgkJbWF0ZXJpYWwuYXR0ZW51YXRpb25Db2xvciwgbWF0ZXJpYWwuYXR0ZW51YXRpb25EaXN0YW5jZSApOwoJbWF0ZXJpYWwudHJhbnNtaXNzaW9uQWxwaGEgPSBtaXgoIG1hdGVyaWFsLnRyYW5zbWlzc2lvbkFscGhhLCB0cmFuc21pdHRlZC5hLCBtYXRlcmlhbC50cmFuc21pc3Npb24gKTsKCXRvdGFsRGlmZnVzZSA9IG1peCggdG90YWxEaWZmdXNlLCB0cmFuc21pdHRlZC5yZ2IsIG1hdGVyaWFsLnRyYW5zbWlzc2lvbiApOwojZW5kaWZgLEZfPWAjaWZkZWYgVVNFX1RSQU5TTUlTU0lPTgoJdW5pZm9ybSBmbG9hdCB0cmFuc21pc3Npb247Cgl1bmlmb3JtIGZsb2F0IHRoaWNrbmVzczsKCXVuaWZvcm0gZmxvYXQgYXR0ZW51YXRpb25EaXN0YW5jZTsKCXVuaWZvcm0gdmVjMyBhdHRlbnVhdGlvbkNvbG9yOwoJI2lmZGVmIFVTRV9UUkFOU01JU1NJT05NQVAKCQl1bmlmb3JtIHNhbXBsZXIyRCB0cmFuc21pc3Npb25NYXA7CgkjZW5kaWYKCSNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQCgkJdW5pZm9ybSBzYW1wbGVyMkQgdGhpY2tuZXNzTWFwOwoJI2VuZGlmCgl1bmlmb3JtIHZlYzIgdHJhbnNtaXNzaW9uU2FtcGxlclNpemU7Cgl1bmlmb3JtIHNhbXBsZXIyRCB0cmFuc21pc3Npb25TYW1wbGVyTWFwOwoJdW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4OwoJdW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7Cgl2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247CglmbG9hdCB3MCggZmxvYXQgYSApIHsKCQlyZXR1cm4gKCAxLjAgLyA2LjAgKSAqICggYSAqICggYSAqICggLSBhICsgMy4wICkgLSAzLjAgKSArIDEuMCApOwoJfQoJZmxvYXQgdzEoIGZsb2F0IGEgKSB7CgkJcmV0dXJuICggMS4wIC8gNi4wICkgKiAoIGEgKiAgYSAqICggMy4wICogYSAtIDYuMCApICsgNC4wICk7Cgl9CglmbG9hdCB3MiggZmxvYXQgYSApewoJCXJldHVybiAoIDEuMCAvIDYuMCApICogKCBhICogKCBhICogKCAtIDMuMCAqIGEgKyAzLjAgKSArIDMuMCApICsgMS4wICk7Cgl9CglmbG9hdCB3MyggZmxvYXQgYSApIHsKCQlyZXR1cm4gKCAxLjAgLyA2LjAgKSAqICggYSAqIGEgKiBhICk7Cgl9CglmbG9hdCBnMCggZmxvYXQgYSApIHsKCQlyZXR1cm4gdzAoIGEgKSArIHcxKCBhICk7Cgl9CglmbG9hdCBnMSggZmxvYXQgYSApIHsKCQlyZXR1cm4gdzIoIGEgKSArIHczKCBhICk7Cgl9CglmbG9hdCBoMCggZmxvYXQgYSApIHsKCQlyZXR1cm4gLSAxLjAgKyB3MSggYSApIC8gKCB3MCggYSApICsgdzEoIGEgKSApOwoJfQoJZmxvYXQgaDEoIGZsb2F0IGEgKSB7CgkJcmV0dXJuIDEuMCArIHczKCBhICkgLyAoIHcyKCBhICkgKyB3MyggYSApICk7Cgl9Cgl2ZWM0IGJpY3ViaWMoIHNhbXBsZXIyRCB0ZXgsIHZlYzIgdXYsIHZlYzQgdGV4ZWxTaXplLCBmbG9hdCBsb2QgKSB7CgkJdXYgPSB1diAqIHRleGVsU2l6ZS56dyArIDAuNTsKCQl2ZWMyIGl1diA9IGZsb29yKCB1diApOwoJCXZlYzIgZnV2ID0gZnJhY3QoIHV2ICk7CgkJZmxvYXQgZzB4ID0gZzAoIGZ1di54ICk7CgkJZmxvYXQgZzF4ID0gZzEoIGZ1di54ICk7CgkJZmxvYXQgaDB4ID0gaDAoIGZ1di54ICk7CgkJZmxvYXQgaDF4ID0gaDEoIGZ1di54ICk7CgkJZmxvYXQgaDB5ID0gaDAoIGZ1di55ICk7CgkJZmxvYXQgaDF5ID0gaDEoIGZ1di55ICk7CgkJdmVjMiBwMCA9ICggdmVjMiggaXV2LnggKyBoMHgsIGl1di55ICsgaDB5ICkgLSAwLjUgKSAqIHRleGVsU2l6ZS54eTsKCQl2ZWMyIHAxID0gKCB2ZWMyKCBpdXYueCArIGgxeCwgaXV2LnkgKyBoMHkgKSAtIDAuNSApICogdGV4ZWxTaXplLnh5OwoJCXZlYzIgcDIgPSAoIHZlYzIoIGl1di54ICsgaDB4LCBpdXYueSArIGgxeSApIC0gMC41ICkgKiB0ZXhlbFNpemUueHk7CgkJdmVjMiBwMyA9ICggdmVjMiggaXV2LnggKyBoMXgsIGl1di55ICsgaDF5ICkgLSAwLjUgKSAqIHRleGVsU2l6ZS54eTsKCQlyZXR1cm4gZzAoIGZ1di55ICkgKiAoIGcweCAqIHRleHR1cmVMb2QoIHRleCwgcDAsIGxvZCApICsgZzF4ICogdGV4dHVyZUxvZCggdGV4LCBwMSwgbG9kICkgKSArCgkJCWcxKCBmdXYueSApICogKCBnMHggKiB0ZXh0dXJlTG9kKCB0ZXgsIHAyLCBsb2QgKSArIGcxeCAqIHRleHR1cmVMb2QoIHRleCwgcDMsIGxvZCApICk7Cgl9Cgl2ZWM0IHRleHR1cmVCaWN1YmljKCBzYW1wbGVyMkQgc2FtcGxlciwgdmVjMiB1diwgZmxvYXQgbG9kICkgewoJCXZlYzIgZkxvZFNpemUgPSB2ZWMyKCB0ZXh0dXJlU2l6ZSggc2FtcGxlciwgaW50KCBsb2QgKSApICk7CgkJdmVjMiBjTG9kU2l6ZSA9IHZlYzIoIHRleHR1cmVTaXplKCBzYW1wbGVyLCBpbnQoIGxvZCArIDEuMCApICkgKTsKCQl2ZWMyIGZMb2RTaXplSW52ID0gMS4wIC8gZkxvZFNpemU7CgkJdmVjMiBjTG9kU2l6ZUludiA9IDEuMCAvIGNMb2RTaXplOwoJCXZlYzQgZlNhbXBsZSA9IGJpY3ViaWMoIHNhbXBsZXIsIHV2LCB2ZWM0KCBmTG9kU2l6ZUludiwgZkxvZFNpemUgKSwgZmxvb3IoIGxvZCApICk7CgkJdmVjNCBjU2FtcGxlID0gYmljdWJpYyggc2FtcGxlciwgdXYsIHZlYzQoIGNMb2RTaXplSW52LCBjTG9kU2l6ZSApLCBjZWlsKCBsb2QgKSApOwoJCXJldHVybiBtaXgoIGZTYW1wbGUsIGNTYW1wbGUsIGZyYWN0KCBsb2QgKSApOwoJfQoJdmVjMyBnZXRWb2x1bWVUcmFuc21pc3Npb25SYXkoIGNvbnN0IGluIHZlYzMgbiwgY29uc3QgaW4gdmVjMyB2LCBjb25zdCBpbiBmbG9hdCB0aGlja25lc3MsIGNvbnN0IGluIGZsb2F0IGlvciwgY29uc3QgaW4gbWF0NCBtb2RlbE1hdHJpeCApIHsKCQl2ZWMzIHJlZnJhY3Rpb25WZWN0b3IgPSByZWZyYWN0KCAtIHYsIG5vcm1hbGl6ZSggbiApLCAxLjAgLyBpb3IgKTsKCQl2ZWMzIG1vZGVsU2NhbGU7CgkJbW9kZWxTY2FsZS54ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMCBdLnh5eiApICk7CgkJbW9kZWxTY2FsZS55ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMSBdLnh5eiApICk7CgkJbW9kZWxTY2FsZS56ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMiBdLnh5eiApICk7CgkJcmV0dXJuIG5vcm1hbGl6ZSggcmVmcmFjdGlvblZlY3RvciApICogdGhpY2tuZXNzICogbW9kZWxTY2FsZTsKCX0KCWZsb2F0IGFwcGx5SW9yVG9Sb3VnaG5lc3MoIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gZmxvYXQgaW9yICkgewoJCXJldHVybiByb3VnaG5lc3MgKiBjbGFtcCggaW9yICogMi4wIC0gMi4wLCAwLjAsIDEuMCApOwoJfQoJdmVjNCBnZXRUcmFuc21pc3Npb25TYW1wbGUoIGNvbnN0IGluIHZlYzIgZnJhZ0Nvb3JkLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIGZsb2F0IGlvciApIHsKCQlmbG9hdCBsb2QgPSBsb2cyKCB0cmFuc21pc3Npb25TYW1wbGVyU2l6ZS54ICkgKiBhcHBseUlvclRvUm91Z2huZXNzKCByb3VnaG5lc3MsIGlvciApOwoJCXJldHVybiB0ZXh0dXJlQmljdWJpYyggdHJhbnNtaXNzaW9uU2FtcGxlck1hcCwgZnJhZ0Nvb3JkLnh5LCBsb2QgKTsKCX0KCXZlYzMgdm9sdW1lQXR0ZW51YXRpb24oIGNvbnN0IGluIGZsb2F0IHRyYW5zbWlzc2lvbkRpc3RhbmNlLCBjb25zdCBpbiB2ZWMzIGF0dGVudWF0aW9uQ29sb3IsIGNvbnN0IGluIGZsb2F0IGF0dGVudWF0aW9uRGlzdGFuY2UgKSB7CgkJaWYgKCBpc2luZiggYXR0ZW51YXRpb25EaXN0YW5jZSApICkgewoJCQlyZXR1cm4gdmVjMyggMS4wICk7CgkJfSBlbHNlIHsKCQkJdmVjMyBhdHRlbnVhdGlvbkNvZWZmaWNpZW50ID0gLWxvZyggYXR0ZW51YXRpb25Db2xvciApIC8gYXR0ZW51YXRpb25EaXN0YW5jZTsKCQkJdmVjMyB0cmFuc21pdHRhbmNlID0gZXhwKCAtIGF0dGVudWF0aW9uQ29lZmZpY2llbnQgKiB0cmFuc21pc3Npb25EaXN0YW5jZSApOwkJCXJldHVybiB0cmFuc21pdHRhbmNlOwoJCX0KCX0KCXZlYzQgZ2V0SUJMVm9sdW1lUmVmcmFjdGlvbiggY29uc3QgaW4gdmVjMyBuLCBjb25zdCBpbiB2ZWMzIHYsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gdmVjMyBkaWZmdXNlQ29sb3IsCgkJY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzcGVjdWxhckY5MCwgY29uc3QgaW4gdmVjMyBwb3NpdGlvbiwgY29uc3QgaW4gbWF0NCBtb2RlbE1hdHJpeCwKCQljb25zdCBpbiBtYXQ0IHZpZXdNYXRyaXgsIGNvbnN0IGluIG1hdDQgcHJvak1hdHJpeCwgY29uc3QgaW4gZmxvYXQgaW9yLCBjb25zdCBpbiBmbG9hdCB0aGlja25lc3MsCgkJY29uc3QgaW4gdmVjMyBhdHRlbnVhdGlvbkNvbG9yLCBjb25zdCBpbiBmbG9hdCBhdHRlbnVhdGlvbkRpc3RhbmNlICkgewoJCXZlYzMgdHJhbnNtaXNzaW9uUmF5ID0gZ2V0Vm9sdW1lVHJhbnNtaXNzaW9uUmF5KCBuLCB2LCB0aGlja25lc3MsIGlvciwgbW9kZWxNYXRyaXggKTsKCQl2ZWMzIHJlZnJhY3RlZFJheUV4aXQgPSBwb3NpdGlvbiArIHRyYW5zbWlzc2lvblJheTsKCQl2ZWM0IG5kY1BvcyA9IHByb2pNYXRyaXggKiB2aWV3TWF0cml4ICogdmVjNCggcmVmcmFjdGVkUmF5RXhpdCwgMS4wICk7CgkJdmVjMiByZWZyYWN0aW9uQ29vcmRzID0gbmRjUG9zLnh5IC8gbmRjUG9zLnc7CgkJcmVmcmFjdGlvbkNvb3JkcyArPSAxLjA7CgkJcmVmcmFjdGlvbkNvb3JkcyAvPSAyLjA7CgkJdmVjNCB0cmFuc21pdHRlZExpZ2h0ID0gZ2V0VHJhbnNtaXNzaW9uU2FtcGxlKCByZWZyYWN0aW9uQ29vcmRzLCByb3VnaG5lc3MsIGlvciApOwoJCXZlYzMgdHJhbnNtaXR0YW5jZSA9IGRpZmZ1c2VDb2xvciAqIHZvbHVtZUF0dGVudWF0aW9uKCBsZW5ndGgoIHRyYW5zbWlzc2lvblJheSApLCBhdHRlbnVhdGlvbkNvbG9yLCBhdHRlbnVhdGlvbkRpc3RhbmNlICk7CgkJdmVjMyBhdHRlbnVhdGVkQ29sb3IgPSB0cmFuc21pdHRhbmNlICogdHJhbnNtaXR0ZWRMaWdodC5yZ2I7CgkJdmVjMyBGID0gRW52aXJvbm1lbnRCUkRGKCBuLCB2LCBzcGVjdWxhckNvbG9yLCBzcGVjdWxhckY5MCwgcm91Z2huZXNzICk7CgkJZmxvYXQgdHJhbnNtaXR0YW5jZUZhY3RvciA9ICggdHJhbnNtaXR0YW5jZS5yICsgdHJhbnNtaXR0YW5jZS5nICsgdHJhbnNtaXR0YW5jZS5iICkgLyAzLjA7CgkJcmV0dXJuIHZlYzQoICggMS4wIC0gRiApICogYXR0ZW51YXRlZENvbG9yLCAxLjAgLSAoIDEuMCAtIHRyYW5zbWl0dGVkTGlnaHQuYSApICogdHJhbnNtaXR0YW5jZUZhY3RvciApOwoJfQojZW5kaWZgLEJfPWAjaWYgZGVmaW5lZCggVVNFX1VWICkgfHwgZGVmaW5lZCggVVNFX0FOSVNPVFJPUFkgKQoJdmFyeWluZyB2ZWMyIHZVdjsKI2VuZGlmCiNpZmRlZiBVU0VfTUFQCgl2YXJ5aW5nIHZlYzIgdk1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9BTFBIQU1BUAoJdmFyeWluZyB2ZWMyIHZBbHBoYU1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9MSUdIVE1BUAoJdmFyeWluZyB2ZWMyIHZMaWdodE1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9BT01BUAoJdmFyeWluZyB2ZWMyIHZBb01hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9CVU1QTUFQCgl2YXJ5aW5nIHZlYzIgdkJ1bXBNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfTk9STUFMTUFQCgl2YXJ5aW5nIHZlYzIgdk5vcm1hbE1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9FTUlTU0lWRU1BUAoJdmFyeWluZyB2ZWMyIHZFbWlzc2l2ZU1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9NRVRBTE5FU1NNQVAKCXZhcnlpbmcgdmVjMiB2TWV0YWxuZXNzTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX1JPVUdITkVTU01BUAoJdmFyeWluZyB2ZWMyIHZSb3VnaG5lc3NNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQU5JU09UUk9QWU1BUAoJdmFyeWluZyB2ZWMyIHZBbmlzb3Ryb3B5TWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX0NMRUFSQ09BVE1BUAoJdmFyeWluZyB2ZWMyIHZDbGVhcmNvYXRNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUAoJdmFyeWluZyB2ZWMyIHZDbGVhcmNvYXROb3JtYWxNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUAoJdmFyeWluZyB2ZWMyIHZDbGVhcmNvYXRSb3VnaG5lc3NNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VNQVAKCXZhcnlpbmcgdmVjMiB2SXJpZGVzY2VuY2VNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQCgl2YXJ5aW5nIHZlYzIgdklyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX1NIRUVOX0NPTE9STUFQCgl2YXJ5aW5nIHZlYzIgdlNoZWVuQ29sb3JNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfU0hFRU5fUk9VR0hORVNTTUFQCgl2YXJ5aW5nIHZlYzIgdlNoZWVuUm91Z2huZXNzTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX1NQRUNVTEFSTUFQCgl2YXJ5aW5nIHZlYzIgdlNwZWN1bGFyTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX1NQRUNVTEFSX0NPTE9STUFQCgl2YXJ5aW5nIHZlYzIgdlNwZWN1bGFyQ29sb3JNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfU1BFQ1VMQVJfSU5URU5TSVRZTUFQCgl2YXJ5aW5nIHZlYzIgdlNwZWN1bGFySW50ZW5zaXR5TWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX1RSQU5TTUlTU0lPTk1BUAoJdW5pZm9ybSBtYXQzIHRyYW5zbWlzc2lvbk1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2VHJhbnNtaXNzaW9uTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX1RISUNLTkVTU01BUAoJdW5pZm9ybSBtYXQzIHRoaWNrbmVzc01hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2VGhpY2tuZXNzTWFwVXY7CiNlbmRpZmAsel89YCNpZiBkZWZpbmVkKCBVU0VfVVYgKSB8fCBkZWZpbmVkKCBVU0VfQU5JU09UUk9QWSApCgl2YXJ5aW5nIHZlYzIgdlV2OwojZW5kaWYKI2lmZGVmIFVTRV9NQVAKCXVuaWZvcm0gbWF0MyBtYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdk1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9BTFBIQU1BUAoJdW5pZm9ybSBtYXQzIGFscGhhTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZBbHBoYU1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9MSUdIVE1BUAoJdW5pZm9ybSBtYXQzIGxpZ2h0TWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZMaWdodE1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9BT01BUAoJdW5pZm9ybSBtYXQzIGFvTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZBb01hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9CVU1QTUFQCgl1bmlmb3JtIG1hdDMgYnVtcE1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2QnVtcE1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9OT1JNQUxNQVAKCXVuaWZvcm0gbWF0MyBub3JtYWxNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdk5vcm1hbE1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVAKCXVuaWZvcm0gbWF0MyBkaXNwbGFjZW1lbnRNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdkRpc3BsYWNlbWVudE1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9FTUlTU0lWRU1BUAoJdW5pZm9ybSBtYXQzIGVtaXNzaXZlTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZFbWlzc2l2ZU1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9NRVRBTE5FU1NNQVAKCXVuaWZvcm0gbWF0MyBtZXRhbG5lc3NNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdk1ldGFsbmVzc01hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVAKCXVuaWZvcm0gbWF0MyByb3VnaG5lc3NNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdlJvdWdobmVzc01hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9BTklTT1RST1BZTUFQCgl1bmlmb3JtIG1hdDMgYW5pc290cm9weU1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2QW5pc290cm9weU1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9DTEVBUkNPQVRNQVAKCXVuaWZvcm0gbWF0MyBjbGVhcmNvYXRNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdkNsZWFyY29hdE1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQCgl1bmlmb3JtIG1hdDMgY2xlYXJjb2F0Tm9ybWFsTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZDbGVhcmNvYXROb3JtYWxNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUAoJdW5pZm9ybSBtYXQzIGNsZWFyY29hdFJvdWdobmVzc01hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2Q2xlYXJjb2F0Um91Z2huZXNzTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX1NIRUVOX0NPTE9STUFQCgl1bmlmb3JtIG1hdDMgc2hlZW5Db2xvck1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2U2hlZW5Db2xvck1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9TSEVFTl9ST1VHSE5FU1NNQVAKCXVuaWZvcm0gbWF0MyBzaGVlblJvdWdobmVzc01hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2U2hlZW5Sb3VnaG5lc3NNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VNQVAKCXVuaWZvcm0gbWF0MyBpcmlkZXNjZW5jZU1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2SXJpZGVzY2VuY2VNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQCgl1bmlmb3JtIG1hdDMgaXJpZGVzY2VuY2VUaGlja25lc3NNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdklyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX1NQRUNVTEFSTUFQCgl1bmlmb3JtIG1hdDMgc3BlY3VsYXJNYXBUcmFuc2Zvcm07Cgl2YXJ5aW5nIHZlYzIgdlNwZWN1bGFyTWFwVXY7CiNlbmRpZgojaWZkZWYgVVNFX1NQRUNVTEFSX0NPTE9STUFQCgl1bmlmb3JtIG1hdDMgc3BlY3VsYXJDb2xvck1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2U3BlY3VsYXJDb2xvck1hcFV2OwojZW5kaWYKI2lmZGVmIFVTRV9TUEVDVUxBUl9JTlRFTlNJVFlNQVAKCXVuaWZvcm0gbWF0MyBzcGVjdWxhckludGVuc2l0eU1hcFRyYW5zZm9ybTsKCXZhcnlpbmcgdmVjMiB2U3BlY3VsYXJJbnRlbnNpdHlNYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OTUFQCgl1bmlmb3JtIG1hdDMgdHJhbnNtaXNzaW9uTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZUcmFuc21pc3Npb25NYXBVdjsKI2VuZGlmCiNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQCgl1bmlmb3JtIG1hdDMgdGhpY2tuZXNzTWFwVHJhbnNmb3JtOwoJdmFyeWluZyB2ZWMyIHZUaGlja25lc3NNYXBVdjsKI2VuZGlmYCxWXz1gI2lmIGRlZmluZWQoIFVTRV9VViApIHx8IGRlZmluZWQoIFVTRV9BTklTT1RST1BZICkKCXZVdiA9IHZlYzMoIHV2LCAxICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX01BUAoJdk1hcFV2ID0gKCBtYXBUcmFuc2Zvcm0gKiB2ZWMzKCBNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9BTFBIQU1BUAoJdkFscGhhTWFwVXYgPSAoIGFscGhhTWFwVHJhbnNmb3JtICogdmVjMyggQUxQSEFNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9MSUdIVE1BUAoJdkxpZ2h0TWFwVXYgPSAoIGxpZ2h0TWFwVHJhbnNmb3JtICogdmVjMyggTElHSFRNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9BT01BUAoJdkFvTWFwVXYgPSAoIGFvTWFwVHJhbnNmb3JtICogdmVjMyggQU9NQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9CVU1QTUFQCgl2QnVtcE1hcFV2ID0gKCBidW1wTWFwVHJhbnNmb3JtICogdmVjMyggQlVNUE1BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX05PUk1BTE1BUAoJdk5vcm1hbE1hcFV2ID0gKCBub3JtYWxNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBOT1JNQUxNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVAKCXZEaXNwbGFjZW1lbnRNYXBVdiA9ICggZGlzcGxhY2VtZW50TWFwVHJhbnNmb3JtICogdmVjMyggRElTUExBQ0VNRU5UTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfRU1JU1NJVkVNQVAKCXZFbWlzc2l2ZU1hcFV2ID0gKCBlbWlzc2l2ZU1hcFRyYW5zZm9ybSAqIHZlYzMoIEVNSVNTSVZFTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmCiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQCgl2TWV0YWxuZXNzTWFwVXYgPSAoIG1ldGFsbmVzc01hcFRyYW5zZm9ybSAqIHZlYzMoIE1FVEFMTkVTU01BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX1JPVUdITkVTU01BUAoJdlJvdWdobmVzc01hcFV2ID0gKCByb3VnaG5lc3NNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBST1VHSE5FU1NNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9BTklTT1RST1BZTUFQCgl2QW5pc290cm9weU1hcFV2ID0gKCBhbmlzb3Ryb3B5TWFwVHJhbnNmb3JtICogdmVjMyggQU5JU09UUk9QWU1BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX0NMRUFSQ09BVE1BUAoJdkNsZWFyY29hdE1hcFV2ID0gKCBjbGVhcmNvYXRNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBDTEVBUkNPQVRNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQCgl2Q2xlYXJjb2F0Tm9ybWFsTWFwVXYgPSAoIGNsZWFyY29hdE5vcm1hbE1hcFRyYW5zZm9ybSAqIHZlYzMoIENMRUFSQ09BVF9OT1JNQUxNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9DTEVBUkNPQVRfUk9VR0hORVNTTUFQCgl2Q2xlYXJjb2F0Um91Z2huZXNzTWFwVXYgPSAoIGNsZWFyY29hdFJvdWdobmVzc01hcFRyYW5zZm9ybSAqIHZlYzMoIENMRUFSQ09BVF9ST1VHSE5FU1NNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9JUklERVNDRU5DRU1BUAoJdklyaWRlc2NlbmNlTWFwVXYgPSAoIGlyaWRlc2NlbmNlTWFwVHJhbnNmb3JtICogdmVjMyggSVJJREVTQ0VOQ0VNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVAKCXZJcmlkZXNjZW5jZVRoaWNrbmVzc01hcFV2ID0gKCBpcmlkZXNjZW5jZVRoaWNrbmVzc01hcFRyYW5zZm9ybSAqIHZlYzMoIElSSURFU0NFTkNFX1RISUNLTkVTU01BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX1NIRUVOX0NPTE9STUFQCgl2U2hlZW5Db2xvck1hcFV2ID0gKCBzaGVlbkNvbG9yTWFwVHJhbnNmb3JtICogdmVjMyggU0hFRU5fQ09MT1JNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9TSEVFTl9ST1VHSE5FU1NNQVAKCXZTaGVlblJvdWdobmVzc01hcFV2ID0gKCBzaGVlblJvdWdobmVzc01hcFRyYW5zZm9ybSAqIHZlYzMoIFNIRUVOX1JPVUdITkVTU01BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX1NQRUNVTEFSTUFQCgl2U3BlY3VsYXJNYXBVdiA9ICggc3BlY3VsYXJNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBTUEVDVUxBUk1BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX1NQRUNVTEFSX0NPTE9STUFQCgl2U3BlY3VsYXJDb2xvck1hcFV2ID0gKCBzcGVjdWxhckNvbG9yTWFwVHJhbnNmb3JtICogdmVjMyggU1BFQ1VMQVJfQ09MT1JNQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9TUEVDVUxBUl9JTlRFTlNJVFlNQVAKCXZTcGVjdWxhckludGVuc2l0eU1hcFV2ID0gKCBzcGVjdWxhckludGVuc2l0eU1hcFRyYW5zZm9ybSAqIHZlYzMoIFNQRUNVTEFSX0lOVEVOU0lUWU1BUF9VViwgMSApICkueHk7CiNlbmRpZgojaWZkZWYgVVNFX1RSQU5TTUlTU0lPTk1BUAoJdlRyYW5zbWlzc2lvbk1hcFV2ID0gKCB0cmFuc21pc3Npb25NYXBUcmFuc2Zvcm0gKiB2ZWMzKCBUUkFOU01JU1NJT05NQVBfVVYsIDEgKSApLnh5OwojZW5kaWYKI2lmZGVmIFVTRV9USElDS05FU1NNQVAKCXZUaGlja25lc3NNYXBVdiA9ICggdGhpY2tuZXNzTWFwVHJhbnNmb3JtICogdmVjMyggVEhJQ0tORVNTTUFQX1VWLCAxICkgKS54eTsKI2VuZGlmYCxrXz1gI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkKCBESVNUQU5DRSApIHx8IGRlZmluZWQgKCBVU0VfU0hBRE9XTUFQICkgfHwgZGVmaW5lZCAoIFVTRV9UUkFOU01JU1NJT04gKSB8fCBOVU1fU1BPVF9MSUdIVF9DT09SRFMgPiAwCgl2ZWM0IHdvcmxkUG9zaXRpb24gPSB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7CgkjaWZkZWYgVVNFX0JBVENISU5HCgkJd29ybGRQb3NpdGlvbiA9IGJhdGNoaW5nTWF0cml4ICogd29ybGRQb3NpdGlvbjsKCSNlbmRpZgoJI2lmZGVmIFVTRV9JTlNUQU5DSU5HCgkJd29ybGRQb3NpdGlvbiA9IGluc3RhbmNlTWF0cml4ICogd29ybGRQb3NpdGlvbjsKCSNlbmRpZgoJd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogd29ybGRQb3NpdGlvbjsKI2VuZGlmYCxIXz1gdmFyeWluZyB2ZWMyIHZVdjsKdW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtOwp2b2lkIG1haW4oKSB7Cgl2VXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggdXYsIDEgKSApLnh5OwoJZ2xfUG9zaXRpb24gPSB2ZWM0KCBwb3NpdGlvbi54eSwgMS4wLCAxLjAgKTsKfWAsR189YHVuaWZvcm0gc2FtcGxlcjJEIHQyRDsKdW5pZm9ybSBmbG9hdCBiYWNrZ3JvdW5kSW50ZW5zaXR5Owp2YXJ5aW5nIHZlYzIgdlV2Owp2b2lkIG1haW4oKSB7Cgl2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKCB0MkQsIHZVdiApOwoJI2lmZGVmIERFQ09ERV9WSURFT19URVhUVVJFCgkJdGV4Q29sb3IgPSB2ZWM0KCBtaXgoIHBvdyggdGV4Q29sb3IucmdiICogMC45NDc4NjcyOTg2ICsgdmVjMyggMC4wNTIxMzI3MDE0ICksIHZlYzMoIDIuNCApICksIHRleENvbG9yLnJnYiAqIDAuMDc3Mzk5MzgwOCwgdmVjMyggbGVzc1RoYW5FcXVhbCggdGV4Q29sb3IucmdiLCB2ZWMzKCAwLjA0MDQ1ICkgKSApICksIHRleENvbG9yLncgKTsKCSNlbmRpZgoJdGV4Q29sb3IucmdiICo9IGJhY2tncm91bmRJbnRlbnNpdHk7CglnbF9GcmFnQ29sb3IgPSB0ZXhDb2xvcjsKCSNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50Pgp9YCxXXz1gdmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjsKI2luY2x1ZGUgPGNvbW1vbj4Kdm9pZCBtYWluKCkgewoJdldvcmxkRGlyZWN0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTsKCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+CglnbF9Qb3NpdGlvbi56ID0gZ2xfUG9zaXRpb24udzsKfWAsWF89YCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFCgl1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDsKI2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApCgl1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7CiNlbmRpZgp1bmlmb3JtIGZsb2F0IGZsaXBFbnZNYXA7CnVuaWZvcm0gZmxvYXQgYmFja2dyb3VuZEJsdXJyaW5lc3M7CnVuaWZvcm0gZmxvYXQgYmFja2dyb3VuZEludGVuc2l0eTsKdmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjsKI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD4Kdm9pZCBtYWluKCkgewoJI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkUKCQl2ZWM0IHRleENvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgdmVjMyggZmxpcEVudk1hcCAqIHZXb3JsZERpcmVjdGlvbi54LCB2V29ybGREaXJlY3Rpb24ueXogKSApOwoJI2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApCgkJdmVjNCB0ZXhDb2xvciA9IHRleHR1cmVDdWJlVVYoIGVudk1hcCwgdldvcmxkRGlyZWN0aW9uLCBiYWNrZ3JvdW5kQmx1cnJpbmVzcyApOwoJI2Vsc2UKCQl2ZWM0IHRleENvbG9yID0gdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7CgkjZW5kaWYKCXRleENvbG9yLnJnYiAqPSBiYWNrZ3JvdW5kSW50ZW5zaXR5OwoJZ2xfRnJhZ0NvbG9yID0gdGV4Q29sb3I7CgkjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD4KfWAscV89YHZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247CiNpbmNsdWRlIDxjb21tb24+CnZvaWQgbWFpbigpIHsKCXZXb3JsZERpcmVjdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7CgkjaW5jbHVkZSA8YmVnaW5fdmVydGV4PgoJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PgoJZ2xfUG9zaXRpb24ueiA9IGdsX1Bvc2l0aW9uLnc7Cn1gLFlfPWB1bmlmb3JtIHNhbXBsZXJDdWJlIHRDdWJlOwp1bmlmb3JtIGZsb2F0IHRGbGlwOwp1bmlmb3JtIGZsb2F0IG9wYWNpdHk7CnZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247CnZvaWQgbWFpbigpIHsKCXZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlQ3ViZSggdEN1YmUsIHZlYzMoIHRGbGlwICogdldvcmxkRGlyZWN0aW9uLngsIHZXb3JsZERpcmVjdGlvbi55eiApICk7CglnbF9GcmFnQ29sb3IgPSB0ZXhDb2xvcjsKCWdsX0ZyYWdDb2xvci5hICo9IG9wYWNpdHk7CgkjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD4KfWAsWl89YCNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxiYXRjaGluZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4Pgp2YXJ5aW5nIHZlYzIgdkhpZ2hQcmVjaXNpb25aVzsKdm9pZCBtYWluKCkgewoJI2luY2x1ZGUgPHV2X3ZlcnRleD4KCSNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PgoJI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVAKCQkjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PgoJCSNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+CgkJI2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PgoJI2VuZGlmCgkjaW5jbHVkZSA8YmVnaW5fdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD4KCSNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD4KCSNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD4KCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD4KCXZIaWdoUHJlY2lzaW9uWlcgPSBnbF9Qb3NpdGlvbi56dzsKfWAsSl89YCNpZiBERVBUSF9QQUNLSU5HID09IDMyMDAKCXVuaWZvcm0gZmxvYXQgb3BhY2l0eTsKI2VuZGlmCiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxwYWNraW5nPgojaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+CnZhcnlpbmcgdmVjMiB2SGlnaFByZWNpc2lvblpXOwp2b2lkIG1haW4oKSB7Cgl2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIDEuMCApOwoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD4KCSNpZiBERVBUSF9QQUNLSU5HID09IDMyMDAKCQlkaWZmdXNlQ29sb3IuYSA9IG9wYWNpdHk7CgkjZW5kaWYKCSNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD4KCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD4KCWZsb2F0IGZyYWdDb29yZFogPSAwLjUgKiB2SGlnaFByZWNpc2lvblpXWzBdIC8gdkhpZ2hQcmVjaXNpb25aV1sxXSArIDAuNTsKCSNpZiBERVBUSF9QQUNLSU5HID09IDMyMDAKCQlnbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzKCAxLjAgLSBmcmFnQ29vcmRaICksIG9wYWNpdHkgKTsKCSNlbGlmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMQoJCWdsX0ZyYWdDb2xvciA9IHBhY2tEZXB0aFRvUkdCQSggZnJhZ0Nvb3JkWiApOwoJI2VuZGlmCn1gLCRfPWAjZGVmaW5lIERJU1RBTkNFCnZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPGJhdGNoaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4Pgp2b2lkIG1haW4oKSB7CgkjaW5jbHVkZSA8dXZfdmVydGV4PgoJI2luY2x1ZGUgPGJhdGNoaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+CgkjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUAoJCSNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+CgkJI2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD4KCQkjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+CgkjZW5kaWYKCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PgoJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PgoJI2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD4KCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PgoJdldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejsKfWAsS189YCNkZWZpbmUgRElTVEFOQ0UKdW5pZm9ybSB2ZWMzIHJlZmVyZW5jZVBvc2l0aW9uOwp1bmlmb3JtIGZsb2F0IG5lYXJEaXN0YW5jZTsKdW5pZm9ybSBmbG9hdCBmYXJEaXN0YW5jZTsKdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uOwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8cGFja2luZz4KI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+CnZvaWQgbWFpbiAoKSB7Cgl2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIDEuMCApOwoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD4KCSNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD4KCWZsb2F0IGRpc3QgPSBsZW5ndGgoIHZXb3JsZFBvc2l0aW9uIC0gcmVmZXJlbmNlUG9zaXRpb24gKTsKCWRpc3QgPSAoIGRpc3QgLSBuZWFyRGlzdGFuY2UgKSAvICggZmFyRGlzdGFuY2UgLSBuZWFyRGlzdGFuY2UgKTsKCWRpc3QgPSBzYXR1cmF0ZSggZGlzdCApOwoJZ2xfRnJhZ0NvbG9yID0gcGFja0RlcHRoVG9SR0JBKCBkaXN0ICk7Cn1gLFFfPWB2YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uOwojaW5jbHVkZSA8Y29tbW9uPgp2b2lkIG1haW4oKSB7Cgl2V29ybGREaXJlY3Rpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApOwoJI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD4KCSNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD4KfWAsal89YHVuaWZvcm0gc2FtcGxlcjJEIHRFcXVpcmVjdDsKdmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjsKI2luY2x1ZGUgPGNvbW1vbj4Kdm9pZCBtYWluKCkgewoJdmVjMyBkaXJlY3Rpb24gPSBub3JtYWxpemUoIHZXb3JsZERpcmVjdGlvbiApOwoJdmVjMiBzYW1wbGVVViA9IGVxdWlyZWN0VXYoIGRpcmVjdGlvbiApOwoJZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCB0RXF1aXJlY3QsIHNhbXBsZVVWICk7CgkjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD4KfWAsdDA9YHVuaWZvcm0gZmxvYXQgc2NhbGU7CmF0dHJpYnV0ZSBmbG9hdCBsaW5lRGlzdGFuY2U7CnZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4Pgp2b2lkIG1haW4oKSB7Cgl2TGluZURpc3RhbmNlID0gc2NhbGUgKiBsaW5lRGlzdGFuY2U7CgkjaW5jbHVkZSA8dXZfdmVydGV4PgoJI2luY2x1ZGUgPGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PgoJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PgoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD4KCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PgoJI2luY2x1ZGUgPGZvZ192ZXJ0ZXg+Cn1gLGUwPWB1bmlmb3JtIHZlYzMgZGlmZnVzZTsKdW5pZm9ybSBmbG9hdCBvcGFjaXR5Owp1bmlmb3JtIGZsb2F0IGRhc2hTaXplOwp1bmlmb3JtIGZsb2F0IHRvdGFsU2l6ZTsKdmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlOwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50Pgp2b2lkIG1haW4oKSB7Cgl2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTsKCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+CglpZiAoIG1vZCggdkxpbmVEaXN0YW5jZSwgdG90YWxTaXplICkgPiBkYXNoU2l6ZSApIHsKCQlkaXNjYXJkOwoJfQoJdmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PgoJb3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7CgkjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+Cn1gLG4wPWAjaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4Pgp2b2lkIG1haW4oKSB7CgkjaW5jbHVkZSA8dXZfdmVydGV4PgoJI2luY2x1ZGUgPGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+CgkjaWYgZGVmaW5lZCAoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkICggVVNFX1NLSU5OSU5HICkKCQkjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PgoJCSNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+CgkJI2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD4KCQkjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+CgkJI2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PgoJI2VuZGlmCgkjaW5jbHVkZSA8YmVnaW5fdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD4KCSNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PgoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+CgkjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PgoJI2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8Zm9nX3ZlcnRleD4KfWAsaTA9YHVuaWZvcm0gdmVjMyBkaWZmdXNlOwp1bmlmb3JtIGZsb2F0IG9wYWNpdHk7CiNpZm5kZWYgRkxBVF9TSEFERUQKCXZhcnlpbmcgdmVjMyB2Tm9ybWFsOwojZW5kaWYKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD4Kdm9pZCBtYWluKCkgewoJdmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PgoJUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTsKCSNpZmRlZiBVU0VfTElHSFRNQVAKCQl2ZWM0IGxpZ2h0TWFwVGV4ZWwgPSB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2TGlnaHRNYXBVdiApOwoJCXJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBsaWdodE1hcFRleGVsLnJnYiAqIGxpZ2h0TWFwSW50ZW5zaXR5ICogUkVDSVBST0NBTF9QSTsKCSNlbHNlCgkJcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IHZlYzMoIDEuMCApOwoJI2VuZGlmCgkjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+CglyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKj0gZGlmZnVzZUNvbG9yLnJnYjsKCXZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZTsKCSNpbmNsdWRlIDxlbnZtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Pgp9YCxzMD1gI2RlZmluZSBMQU1CRVJUCnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uOwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bm9ybWFsX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4Pgp2b2lkIG1haW4oKSB7CgkjaW5jbHVkZSA8dXZfdmVydGV4PgoJI2luY2x1ZGUgPGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PgoJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PgoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD4KCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PgoJdlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7CgkjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PgoJI2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD4KCSNpbmNsdWRlIDxmb2dfdmVydGV4Pgp9YCxyMD1gI2RlZmluZSBMQU1CRVJUCnVuaWZvcm0gdmVjMyBkaWZmdXNlOwp1bmlmb3JtIHZlYzMgZW1pc3NpdmU7CnVuaWZvcm0gZmxvYXQgb3BhY2l0eTsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPHBhY2tpbmc+CiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxic2Rmcz4KI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPgojaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsaWdodHNfbGFtYmVydF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+CnZvaWQgbWFpbigpIHsKCXZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApOwoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD4KCVJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7Cgl2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlOwoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj4KCSNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz4KCSNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxsaWdodHNfbGFtYmVydF9mcmFnbWVudD4KCSNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfYmVnaW4+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2VuZD4KCSNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD4KCXZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7CgkjaW5jbHVkZSA8ZW52bWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD4KCSNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGZvZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD4KfWAsYTA9YCNkZWZpbmUgTUFUQ0FQCnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uOwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bm9ybWFsX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4Pgp2b2lkIG1haW4oKSB7CgkjaW5jbHVkZSA8dXZfdmVydGV4PgoJI2luY2x1ZGUgPGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PgoJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PgoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD4KCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PgoJI2luY2x1ZGUgPGZvZ192ZXJ0ZXg+Cgl2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejsKfWAsbzA9YCNkZWZpbmUgTUFUQ0FQCnVuaWZvcm0gdmVjMyBkaWZmdXNlOwp1bmlmb3JtIGZsb2F0IG9wYWNpdHk7CnVuaWZvcm0gc2FtcGxlcjJEIG1hdGNhcDsKdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD4Kdm9pZCBtYWluKCkgewoJdmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj4KCSNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz4KCXZlYzMgdmlld0RpciA9IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApOwoJdmVjMyB4ID0gbm9ybWFsaXplKCB2ZWMzKCB2aWV3RGlyLnosIDAuMCwgLSB2aWV3RGlyLnggKSApOwoJdmVjMyB5ID0gY3Jvc3MoIHZpZXdEaXIsIHggKTsKCXZlYzIgdXYgPSB2ZWMyKCBkb3QoIHgsIG5vcm1hbCApLCBkb3QoIHksIG5vcm1hbCApICkgKiAwLjQ5NSArIDAuNTsKCSNpZmRlZiBVU0VfTUFUQ0FQCgkJdmVjNCBtYXRjYXBDb2xvciA9IHRleHR1cmUyRCggbWF0Y2FwLCB1diApOwoJI2Vsc2UKCQl2ZWM0IG1hdGNhcENvbG9yID0gdmVjNCggdmVjMyggbWl4KCAwLjIsIDAuOCwgdXYueSApICksIDEuMCApOwoJI2VuZGlmCgl2ZWMzIG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiICogbWF0Y2FwQ29sb3IucmdiOwoJI2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD4KCSNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGZvZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD4KfWAsbDA9YCNkZWZpbmUgTk9STUFMCiNpZiBkZWZpbmVkKCBGTEFUX1NIQURFRCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUF9UQU5HRU5UU1BBQ0UgKQoJdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247CiNlbmRpZgojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD4Kdm9pZCBtYWluKCkgewoJI2luY2x1ZGUgPHV2X3ZlcnRleD4KCSNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PgoJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PgoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD4KCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PgojaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFICkKCXZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6OwojZW5kaWYKfWAsYzA9YCNkZWZpbmUgTk9STUFMCnVuaWZvcm0gZmxvYXQgb3BhY2l0eTsKI2lmIGRlZmluZWQoIEZMQVRfU0hBREVEICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQX1RBTkdFTlRTUEFDRSApCgl2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjsKI2VuZGlmCiNpbmNsdWRlIDxwYWNraW5nPgojaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG5vcm1hbF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+CnZvaWQgbWFpbigpIHsKCXZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggMC4wLCAwLjAsIDAuMCwgb3BhY2l0eSApOwoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD4KCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD4KCSNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfYmVnaW4+CgkjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X21hcHM+CglnbF9GcmFnQ29sb3IgPSB2ZWM0KCBwYWNrTm9ybWFsVG9SR0IoIG5vcm1hbCApLCBkaWZmdXNlQ29sb3IuYSApOwoJI2lmZGVmIE9QQVFVRQoJCWdsX0ZyYWdDb2xvci5hID0gMS4wOwoJI2VuZGlmCn1gLGgwPWAjZGVmaW5lIFBIT05HCnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uOwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bm9ybWFsX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4Pgp2b2lkIG1haW4oKSB7CgkjaW5jbHVkZSA8dXZfdmVydGV4PgoJI2luY2x1ZGUgPGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PgoJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PgoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD4KCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PgoJdlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7CgkjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PgoJI2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD4KCSNpbmNsdWRlIDxmb2dfdmVydGV4Pgp9YCx1MD1gI2RlZmluZSBQSE9ORwp1bmlmb3JtIHZlYzMgZGlmZnVzZTsKdW5pZm9ybSB2ZWMzIGVtaXNzaXZlOwp1bmlmb3JtIHZlYzMgc3BlY3VsYXI7CnVuaWZvcm0gZmxvYXQgc2hpbmluZXNzOwp1bmlmb3JtIGZsb2F0IG9wYWNpdHk7CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxwYWNraW5nPgojaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YnNkZnM+CiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj4KI2luY2x1ZGUgPG5vcm1hbF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD4Kdm9pZCBtYWluKCkgewoJdmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PgoJUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTsKCXZlYzMgdG90YWxFbWlzc2l2ZVJhZGlhbmNlID0gZW1pc3NpdmU7CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYWhhc2hfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPgoJI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPgoJI2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGxpZ2h0c19waG9uZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfYmVnaW4+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2VuZD4KCSNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD4KCXZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7CgkjaW5jbHVkZSA8ZW52bWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD4KCSNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGZvZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD4KfWAsZDA9YCNkZWZpbmUgU1RBTkRBUkQKdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247CiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OCgl2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247CiNlbmRpZgojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bm9ybWFsX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4Pgp2b2lkIG1haW4oKSB7CgkjaW5jbHVkZSA8dXZfdmVydGV4PgoJI2luY2x1ZGUgPGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PgoJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PgoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD4KCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PgoJdlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7CgkjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PgoJI2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8Zm9nX3ZlcnRleD4KI2lmZGVmIFVTRV9UUkFOU01JU1NJT04KCXZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7CiNlbmRpZgp9YCxmMD1gI2RlZmluZSBTVEFOREFSRAojaWZkZWYgUEhZU0lDQUwKCSNkZWZpbmUgSU9SCgkjZGVmaW5lIFVTRV9TUEVDVUxBUgojZW5kaWYKdW5pZm9ybSB2ZWMzIGRpZmZ1c2U7CnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTsKdW5pZm9ybSBmbG9hdCByb3VnaG5lc3M7CnVuaWZvcm0gZmxvYXQgbWV0YWxuZXNzOwp1bmlmb3JtIGZsb2F0IG9wYWNpdHk7CiNpZmRlZiBJT1IKCXVuaWZvcm0gZmxvYXQgaW9yOwojZW5kaWYKI2lmZGVmIFVTRV9TUEVDVUxBUgoJdW5pZm9ybSBmbG9hdCBzcGVjdWxhckludGVuc2l0eTsKCXVuaWZvcm0gdmVjMyBzcGVjdWxhckNvbG9yOwoJI2lmZGVmIFVTRV9TUEVDVUxBUl9DT0xPUk1BUAoJCXVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyQ29sb3JNYXA7CgkjZW5kaWYKCSNpZmRlZiBVU0VfU1BFQ1VMQVJfSU5URU5TSVRZTUFQCgkJdW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJJbnRlbnNpdHlNYXA7CgkjZW5kaWYKI2VuZGlmCiNpZmRlZiBVU0VfQ0xFQVJDT0FUCgl1bmlmb3JtIGZsb2F0IGNsZWFyY29hdDsKCXVuaWZvcm0gZmxvYXQgY2xlYXJjb2F0Um91Z2huZXNzOwojZW5kaWYKI2lmZGVmIFVTRV9JUklERVNDRU5DRQoJdW5pZm9ybSBmbG9hdCBpcmlkZXNjZW5jZTsKCXVuaWZvcm0gZmxvYXQgaXJpZGVzY2VuY2VJT1I7Cgl1bmlmb3JtIGZsb2F0IGlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bTsKCXVuaWZvcm0gZmxvYXQgaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtOwojZW5kaWYKI2lmZGVmIFVTRV9TSEVFTgoJdW5pZm9ybSB2ZWMzIHNoZWVuQ29sb3I7Cgl1bmlmb3JtIGZsb2F0IHNoZWVuUm91Z2huZXNzOwoJI2lmZGVmIFVTRV9TSEVFTl9DT0xPUk1BUAoJCXVuaWZvcm0gc2FtcGxlcjJEIHNoZWVuQ29sb3JNYXA7CgkjZW5kaWYKCSNpZmRlZiBVU0VfU0hFRU5fUk9VR0hORVNTTUFQCgkJdW5pZm9ybSBzYW1wbGVyMkQgc2hlZW5Sb3VnaG5lc3NNYXA7CgkjZW5kaWYKI2VuZGlmCiNpZmRlZiBVU0VfQU5JU09UUk9QWQoJdW5pZm9ybSB2ZWMyIGFuaXNvdHJvcHlWZWN0b3I7CgkjaWZkZWYgVVNFX0FOSVNPVFJPUFlNQVAKCQl1bmlmb3JtIHNhbXBsZXIyRCBhbmlzb3Ryb3B5TWFwOwoJI2VuZGlmCiNlbmRpZgp2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjsKI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPHBhY2tpbmc+CiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGlyaWRlc2NlbmNlX2ZyYWdtZW50PgojaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PgojaW5jbHVkZSA8ZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8ZW52bWFwX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPgojaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHRyYW5zbWlzc2lvbl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNsZWFyY29hdF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8aXJpZGVzY2VuY2VfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+CnZvaWQgbWFpbigpIHsKCXZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApOwoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD4KCVJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7Cgl2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlOwoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PgoJI2luY2x1ZGUgPG1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHJvdWdobmVzc21hcF9mcmFnbWVudD4KCSNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPgoJI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPgoJI2luY2x1ZGUgPGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfYmVnaW4+CgkjaW5jbHVkZSA8Y2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9tYXBzPgoJI2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudD4KCSNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfYmVnaW4+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+CgkjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2VuZD4KCSNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD4KCXZlYzMgdG90YWxEaWZmdXNlID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZTsKCXZlYzMgdG90YWxTcGVjdWxhciA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhcjsKCSNpbmNsdWRlIDx0cmFuc21pc3Npb25fZnJhZ21lbnQ+Cgl2ZWMzIG91dGdvaW5nTGlnaHQgPSB0b3RhbERpZmZ1c2UgKyB0b3RhbFNwZWN1bGFyICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlOwoJI2lmZGVmIFVTRV9TSEVFTgoJCWZsb2F0IHNoZWVuRW5lcmd5Q29tcCA9IDEuMCAtIDAuMTU3ICogbWF4MyggbWF0ZXJpYWwuc2hlZW5Db2xvciApOwoJCW91dGdvaW5nTGlnaHQgPSBvdXRnb2luZ0xpZ2h0ICogc2hlZW5FbmVyZ3lDb21wICsgc2hlZW5TcGVjdWxhckRpcmVjdCArIHNoZWVuU3BlY3VsYXJJbmRpcmVjdDsKCSNlbmRpZgoJI2lmZGVmIFVTRV9DTEVBUkNPQVQKCQlmbG9hdCBkb3ROVmNjID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnlDbGVhcmNvYXROb3JtYWwsIGdlb21ldHJ5Vmlld0RpciApICk7CgkJdmVjMyBGY2MgPSBGX1NjaGxpY2soIG1hdGVyaWFsLmNsZWFyY29hdEYwLCBtYXRlcmlhbC5jbGVhcmNvYXRGOTAsIGRvdE5WY2MgKTsKCQlvdXRnb2luZ0xpZ2h0ID0gb3V0Z29pbmdMaWdodCAqICggMS4wIC0gbWF0ZXJpYWwuY2xlYXJjb2F0ICogRmNjICkgKyAoIGNsZWFyY29hdFNwZWN1bGFyRGlyZWN0ICsgY2xlYXJjb2F0U3BlY3VsYXJJbmRpcmVjdCApICogbWF0ZXJpYWwuY2xlYXJjb2F0OwoJI2VuZGlmCgkjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PgoJI2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Pgp9YCxwMD1gI2RlZmluZSBUT09OCnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uOwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8YmF0Y2hpbmdfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bm9ybWFsX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4Pgp2b2lkIG1haW4oKSB7CgkjaW5jbHVkZSA8dXZfdmVydGV4PgoJI2luY2x1ZGUgPGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD4KCSNpbmNsdWRlIDxiYXRjaGluZ192ZXJ0ZXg+CgkjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+CgkjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD4KCSNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PgoJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PgoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD4KCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PgoJdlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7CgkjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PgoJI2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+CgkjaW5jbHVkZSA8Zm9nX3ZlcnRleD4KfWAsbTA9YCNkZWZpbmUgVE9PTgp1bmlmb3JtIHZlYzMgZGlmZnVzZTsKdW5pZm9ybSB2ZWMzIGVtaXNzaXZlOwp1bmlmb3JtIGZsb2F0IG9wYWNpdHk7CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxwYWNraW5nPgojaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxic2Rmcz4KI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPgojaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxsaWdodHNfdG9vbl9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD4Kdm9pZCBtYWluKCkgewoJdmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PgoJUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTsKCXZlYzMgdG90YWxFbWlzc2l2ZVJhZGlhbmNlID0gZW1pc3NpdmU7CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYWhhc2hfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPgoJI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPgoJI2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGxpZ2h0c190b29uX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9iZWdpbj4KCSNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfbWFwcz4KCSNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfZW5kPgoJI2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PgoJdmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTsKCSNpbmNsdWRlIDxvcGFxdWVfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD4KCSNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD4KCSNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+Cn1gLGcwPWB1bmlmb3JtIGZsb2F0IHNpemU7CnVuaWZvcm0gZmxvYXQgc2NhbGU7CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+CiNpZmRlZiBVU0VfUE9JTlRTX1VWCgl2YXJ5aW5nIHZlYzIgdlV2OwoJdW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtOwojZW5kaWYKdm9pZCBtYWluKCkgewoJI2lmZGVmIFVTRV9QT0lOVFNfVVYKCQl2VXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggdXYsIDEgKSApLnh5OwoJI2VuZGlmCgkjaW5jbHVkZSA8Y29sb3JfdmVydGV4PgoJI2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PgoJI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+CgkjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+CglnbF9Qb2ludFNpemUgPSBzaXplOwoJI2lmZGVmIFVTRV9TSVpFQVRURU5VQVRJT04KCQlib29sIGlzUGVyc3BlY3RpdmUgPSBpc1BlcnNwZWN0aXZlTWF0cml4KCBwcm9qZWN0aW9uTWF0cml4ICk7CgkJaWYgKCBpc1BlcnNwZWN0aXZlICkgZ2xfUG9pbnRTaXplICo9ICggc2NhbGUgLyAtIG12UG9zaXRpb24ueiApOwoJI2VuZGlmCgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PgoJI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+CgkjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PgoJI2luY2x1ZGUgPGZvZ192ZXJ0ZXg+Cn1gLF8wPWB1bmlmb3JtIHZlYzMgZGlmZnVzZTsKdW5pZm9ybSBmbG9hdCBvcGFjaXR5OwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50Pgp2b2lkIG1haW4oKSB7Cgl2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTsKCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+Cgl2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTsKCSNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD4KCSNpbmNsdWRlIDxtYXBfcGFydGljbGVfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD4KCW91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiOwoJI2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD4KCSNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGZvZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50Pgp9YCx4MD1gI2luY2x1ZGUgPGNvbW1vbj4KI2luY2x1ZGUgPGJhdGNoaW5nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+CiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4Pgp2b2lkIG1haW4oKSB7CgkjaW5jbHVkZSA8YmF0Y2hpbmdfdmVydGV4PgoJI2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PgoJI2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PgoJI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD4KCSNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+CgkjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PgoJI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PgoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD4KCSNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+CgkjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD4KCSNpbmNsdWRlIDxmb2dfdmVydGV4Pgp9YCx2MD1gdW5pZm9ybSB2ZWMzIGNvbG9yOwp1bmlmb3JtIGZsb2F0IG9wYWNpdHk7CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDxwYWNraW5nPgojaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxic2Rmcz4KI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPgojaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8c2hhZG93bWFza19wYXJzX2ZyYWdtZW50Pgp2b2lkIG1haW4oKSB7CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+CglnbF9GcmFnQ29sb3IgPSB2ZWM0KCBjb2xvciwgb3BhY2l0eSAqICggMS4wIC0gZ2V0U2hhZG93TWFzaygpICkgKTsKCSNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD4KCSNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGZvZ19mcmFnbWVudD4KfWAseTA9YHVuaWZvcm0gZmxvYXQgcm90YXRpb247CnVuaWZvcm0gdmVjMiBjZW50ZXI7CiNpbmNsdWRlIDxjb21tb24+CiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PgojaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4Pgp2b2lkIG1haW4oKSB7CgkjaW5jbHVkZSA8dXZfdmVydGV4PgoJdmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7Cgl2ZWMyIHNjYWxlOwoJc2NhbGUueCA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDAgXS54LCBtb2RlbE1hdHJpeFsgMCBdLnksIG1vZGVsTWF0cml4WyAwIF0ueiApICk7CglzY2FsZS55ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMSBdLngsIG1vZGVsTWF0cml4WyAxIF0ueSwgbW9kZWxNYXRyaXhbIDEgXS56ICkgKTsKCSNpZm5kZWYgVVNFX1NJWkVBVFRFTlVBVElPTgoJCWJvb2wgaXNQZXJzcGVjdGl2ZSA9IGlzUGVyc3BlY3RpdmVNYXRyaXgoIHByb2plY3Rpb25NYXRyaXggKTsKCQlpZiAoIGlzUGVyc3BlY3RpdmUgKSBzY2FsZSAqPSAtIG12UG9zaXRpb24uejsKCSNlbmRpZgoJdmVjMiBhbGlnbmVkUG9zaXRpb24gPSAoIHBvc2l0aW9uLnh5IC0gKCBjZW50ZXIgLSB2ZWMyKCAwLjUgKSApICkgKiBzY2FsZTsKCXZlYzIgcm90YXRlZFBvc2l0aW9uOwoJcm90YXRlZFBvc2l0aW9uLnggPSBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55OwoJcm90YXRlZFBvc2l0aW9uLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55OwoJbXZQb3NpdGlvbi54eSArPSByb3RhdGVkUG9zaXRpb247CglnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uOwoJI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD4KCSNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PgoJI2luY2x1ZGUgPGZvZ192ZXJ0ZXg+Cn1gLE0wPWB1bmlmb3JtIHZlYzMgZGlmZnVzZTsKdW5pZm9ybSBmbG9hdCBvcGFjaXR5OwojaW5jbHVkZSA8Y29tbW9uPgojaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PgojaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD4KI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+CiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD4Kdm9pZCBtYWluKCkgewoJdmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7CgkjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PgoJdmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7CgkjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PgoJI2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD4KCSNpbmNsdWRlIDxhbHBoYWhhc2hfZnJhZ21lbnQ+CglvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjsKCSNpbmNsdWRlIDxvcGFxdWVfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+CgkjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD4KCSNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+Cn1gLHp0PXthbHBoYWhhc2hfZnJhZ21lbnQ6R20sYWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ6V20sYWxwaGFtYXBfZnJhZ21lbnQ6WG0sYWxwaGFtYXBfcGFyc19mcmFnbWVudDpxbSxhbHBoYXRlc3RfZnJhZ21lbnQ6WW0sYWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ6Wm0sYW9tYXBfZnJhZ21lbnQ6Sm0sYW9tYXBfcGFyc19mcmFnbWVudDokbSxiYXRjaGluZ19wYXJzX3ZlcnRleDpLbSxiYXRjaGluZ192ZXJ0ZXg6UW0sYmVnaW5fdmVydGV4OmptLGJlZ2lubm9ybWFsX3ZlcnRleDp0Zyxic2RmczplZyxpcmlkZXNjZW5jZV9mcmFnbWVudDpuZyxidW1wbWFwX3BhcnNfZnJhZ21lbnQ6aWcsY2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50OnNnLGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50OnJnLGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleDphZyxjbGlwcGluZ19wbGFuZXNfdmVydGV4Om9nLGNvbG9yX2ZyYWdtZW50OmxnLGNvbG9yX3BhcnNfZnJhZ21lbnQ6Y2csY29sb3JfcGFyc192ZXJ0ZXg6aGcsY29sb3JfdmVydGV4OnVnLGNvbW1vbjpkZyxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ6ZmcsZGVmYXVsdG5vcm1hbF92ZXJ0ZXg6cGcsZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4Om1nLGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg6Z2csZW1pc3NpdmVtYXBfZnJhZ21lbnQ6X2csZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudDp4Zyxjb2xvcnNwYWNlX2ZyYWdtZW50OnZnLGNvbG9yc3BhY2VfcGFyc19mcmFnbWVudDp5ZyxlbnZtYXBfZnJhZ21lbnQ6TWcsZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50OlNnLGVudm1hcF9wYXJzX2ZyYWdtZW50OmJnLGVudm1hcF9wYXJzX3ZlcnRleDpFZyxlbnZtYXBfcGh5c2ljYWxfcGFyc19mcmFnbWVudDpPZyxlbnZtYXBfdmVydGV4OkFnLGZvZ192ZXJ0ZXg6VGcsZm9nX3BhcnNfdmVydGV4OndnLGZvZ19mcmFnbWVudDpSZyxmb2dfcGFyc19mcmFnbWVudDpDZyxncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50OlBnLGxpZ2h0bWFwX2ZyYWdtZW50OkxnLGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ6SWcsbGlnaHRzX2xhbWJlcnRfZnJhZ21lbnQ6VWcsbGlnaHRzX2xhbWJlcnRfcGFyc19mcmFnbWVudDpEZyxsaWdodHNfcGFyc19iZWdpbjpOZyxsaWdodHNfdG9vbl9mcmFnbWVudDpGZyxsaWdodHNfdG9vbl9wYXJzX2ZyYWdtZW50OkJnLGxpZ2h0c19waG9uZ19mcmFnbWVudDp6ZyxsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudDpWZyxsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQ6a2csbGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ6SGcsbGlnaHRzX2ZyYWdtZW50X2JlZ2luOkdnLGxpZ2h0c19mcmFnbWVudF9tYXBzOldnLGxpZ2h0c19mcmFnbWVudF9lbmQ6WGcsbG9nZGVwdGhidWZfZnJhZ21lbnQ6cWcsbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudDpZZyxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleDpaZyxsb2dkZXB0aGJ1Zl92ZXJ0ZXg6SmcsbWFwX2ZyYWdtZW50OiRnLG1hcF9wYXJzX2ZyYWdtZW50OktnLG1hcF9wYXJ0aWNsZV9mcmFnbWVudDpRZyxtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudDpqZyxtZXRhbG5lc3NtYXBfZnJhZ21lbnQ6dF8sbWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQ6ZV8sbW9ycGhjb2xvcl92ZXJ0ZXg6bl8sbW9ycGhub3JtYWxfdmVydGV4OmlfLG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4OnNfLG1vcnBodGFyZ2V0X3ZlcnRleDpyXyxub3JtYWxfZnJhZ21lbnRfYmVnaW46YV8sbm9ybWFsX2ZyYWdtZW50X21hcHM6b18sbm9ybWFsX3BhcnNfZnJhZ21lbnQ6bF8sbm9ybWFsX3BhcnNfdmVydGV4OmNfLG5vcm1hbF92ZXJ0ZXg6aF8sbm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ6dV8sY2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9iZWdpbjpkXyxjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X21hcHM6Zl8sY2xlYXJjb2F0X3BhcnNfZnJhZ21lbnQ6cF8saXJpZGVzY2VuY2VfcGFyc19mcmFnbWVudDptXyxvcGFxdWVfZnJhZ21lbnQ6Z18scGFja2luZzpfXyxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50OnhfLHByb2plY3RfdmVydGV4OnZfLGRpdGhlcmluZ19mcmFnbWVudDp5XyxkaXRoZXJpbmdfcGFyc19mcmFnbWVudDpNXyxyb3VnaG5lc3NtYXBfZnJhZ21lbnQ6U18scm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQ6Yl8sc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ6RV8sc2hhZG93bWFwX3BhcnNfdmVydGV4OkFfLHNoYWRvd21hcF92ZXJ0ZXg6VF8sc2hhZG93bWFza19wYXJzX2ZyYWdtZW50OndfLHNraW5iYXNlX3ZlcnRleDpSXyxza2lubmluZ19wYXJzX3ZlcnRleDpDXyxza2lubmluZ192ZXJ0ZXg6UF8sc2tpbm5vcm1hbF92ZXJ0ZXg6TF8sc3BlY3VsYXJtYXBfZnJhZ21lbnQ6SV8sc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudDpVXyx0b25lbWFwcGluZ19mcmFnbWVudDpEXyx0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50Ok5fLHRyYW5zbWlzc2lvbl9mcmFnbWVudDpPXyx0cmFuc21pc3Npb25fcGFyc19mcmFnbWVudDpGXyx1dl9wYXJzX2ZyYWdtZW50OkJfLHV2X3BhcnNfdmVydGV4OnpfLHV2X3ZlcnRleDpWXyx3b3JsZHBvc192ZXJ0ZXg6a18sYmFja2dyb3VuZF92ZXJ0OkhfLGJhY2tncm91bmRfZnJhZzpHXyxiYWNrZ3JvdW5kQ3ViZV92ZXJ0OldfLGJhY2tncm91bmRDdWJlX2ZyYWc6WF8sY3ViZV92ZXJ0OnFfLGN1YmVfZnJhZzpZXyxkZXB0aF92ZXJ0OlpfLGRlcHRoX2ZyYWc6Sl8sZGlzdGFuY2VSR0JBX3ZlcnQ6JF8sZGlzdGFuY2VSR0JBX2ZyYWc6S18sZXF1aXJlY3RfdmVydDpRXyxlcXVpcmVjdF9mcmFnOmpfLGxpbmVkYXNoZWRfdmVydDp0MCxsaW5lZGFzaGVkX2ZyYWc6ZTAsbWVzaGJhc2ljX3ZlcnQ6bjAsbWVzaGJhc2ljX2ZyYWc6aTAsbWVzaGxhbWJlcnRfdmVydDpzMCxtZXNobGFtYmVydF9mcmFnOnIwLG1lc2htYXRjYXBfdmVydDphMCxtZXNobWF0Y2FwX2ZyYWc6bzAsbWVzaG5vcm1hbF92ZXJ0OmwwLG1lc2hub3JtYWxfZnJhZzpjMCxtZXNocGhvbmdfdmVydDpoMCxtZXNocGhvbmdfZnJhZzp1MCxtZXNocGh5c2ljYWxfdmVydDpkMCxtZXNocGh5c2ljYWxfZnJhZzpmMCxtZXNodG9vbl92ZXJ0OnAwLG1lc2h0b29uX2ZyYWc6bTAscG9pbnRzX3ZlcnQ6ZzAscG9pbnRzX2ZyYWc6XzAsc2hhZG93X3ZlcnQ6eDAsc2hhZG93X2ZyYWc6djAsc3ByaXRlX3ZlcnQ6eTAsc3ByaXRlX2ZyYWc6TTB9LGx0PXtjb21tb246e2RpZmZ1c2U6e3ZhbHVlOm5ldyB1dCgxNjc3NzIxNSl9LG9wYWNpdHk6e3ZhbHVlOjF9LG1hcDp7dmFsdWU6bnVsbH0sbWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcga3R9LGFscGhhTWFwOnt2YWx1ZTpudWxsfSxhbHBoYU1hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGt0fSxhbHBoYVRlc3Q6e3ZhbHVlOjB9fSxzcGVjdWxhcm1hcDp7c3BlY3VsYXJNYXA6e3ZhbHVlOm51bGx9LHNwZWN1bGFyTWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcga3R9fSxlbnZtYXA6e2Vudk1hcDp7dmFsdWU6bnVsbH0sZmxpcEVudk1hcDp7dmFsdWU6LTF9LHJlZmxlY3Rpdml0eTp7dmFsdWU6MX0saW9yOnt2YWx1ZToxLjV9LHJlZnJhY3Rpb25SYXRpbzp7dmFsdWU6Ljk4fX0sYW9tYXA6e2FvTWFwOnt2YWx1ZTpudWxsfSxhb01hcEludGVuc2l0eTp7dmFsdWU6MX0sYW9NYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBrdH19LGxpZ2h0bWFwOntsaWdodE1hcDp7dmFsdWU6bnVsbH0sbGlnaHRNYXBJbnRlbnNpdHk6e3ZhbHVlOjF9LGxpZ2h0TWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcga3R9fSxidW1wbWFwOntidW1wTWFwOnt2YWx1ZTpudWxsfSxidW1wTWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcga3R9LGJ1bXBTY2FsZTp7dmFsdWU6MX19LG5vcm1hbG1hcDp7bm9ybWFsTWFwOnt2YWx1ZTpudWxsfSxub3JtYWxNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBrdH0sbm9ybWFsU2NhbGU6e3ZhbHVlOm5ldyBaKDEsMSl9fSxkaXNwbGFjZW1lbnRtYXA6e2Rpc3BsYWNlbWVudE1hcDp7dmFsdWU6bnVsbH0sZGlzcGxhY2VtZW50TWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcga3R9LGRpc3BsYWNlbWVudFNjYWxlOnt2YWx1ZToxfSxkaXNwbGFjZW1lbnRCaWFzOnt2YWx1ZTowfX0sZW1pc3NpdmVtYXA6e2VtaXNzaXZlTWFwOnt2YWx1ZTpudWxsfSxlbWlzc2l2ZU1hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGt0fX0sbWV0YWxuZXNzbWFwOnttZXRhbG5lc3NNYXA6e3ZhbHVlOm51bGx9LG1ldGFsbmVzc01hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGt0fX0scm91Z2huZXNzbWFwOntyb3VnaG5lc3NNYXA6e3ZhbHVlOm51bGx9LHJvdWdobmVzc01hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGt0fX0sZ3JhZGllbnRtYXA6e2dyYWRpZW50TWFwOnt2YWx1ZTpudWxsfX0sZm9nOntmb2dEZW5zaXR5Ont2YWx1ZToyNWUtNX0sZm9nTmVhcjp7dmFsdWU6MX0sZm9nRmFyOnt2YWx1ZToyZTN9LGZvZ0NvbG9yOnt2YWx1ZTpuZXcgdXQoMTY3NzcyMTUpfX0sbGlnaHRzOnthbWJpZW50TGlnaHRDb2xvcjp7dmFsdWU6W119LGxpZ2h0UHJvYmU6e3ZhbHVlOltdfSxkaXJlY3Rpb25hbExpZ2h0czp7dmFsdWU6W10scHJvcGVydGllczp7ZGlyZWN0aW9uOnt9LGNvbG9yOnt9fX0sZGlyZWN0aW9uYWxMaWdodFNoYWRvd3M6e3ZhbHVlOltdLHByb3BlcnRpZXM6e3NoYWRvd0JpYXM6e30sc2hhZG93Tm9ybWFsQmlhczp7fSxzaGFkb3dSYWRpdXM6e30sc2hhZG93TWFwU2l6ZTp7fX19LGRpcmVjdGlvbmFsU2hhZG93TWFwOnt2YWx1ZTpbXX0sZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg6e3ZhbHVlOltdfSxzcG90TGlnaHRzOnt2YWx1ZTpbXSxwcm9wZXJ0aWVzOntjb2xvcjp7fSxwb3NpdGlvbjp7fSxkaXJlY3Rpb246e30sZGlzdGFuY2U6e30sY29uZUNvczp7fSxwZW51bWJyYUNvczp7fSxkZWNheTp7fX19LHNwb3RMaWdodFNoYWRvd3M6e3ZhbHVlOltdLHByb3BlcnRpZXM6e3NoYWRvd0JpYXM6e30sc2hhZG93Tm9ybWFsQmlhczp7fSxzaGFkb3dSYWRpdXM6e30sc2hhZG93TWFwU2l6ZTp7fX19LHNwb3RMaWdodE1hcDp7dmFsdWU6W119LHNwb3RTaGFkb3dNYXA6e3ZhbHVlOltdfSxzcG90TGlnaHRNYXRyaXg6e3ZhbHVlOltdfSxwb2ludExpZ2h0czp7dmFsdWU6W10scHJvcGVydGllczp7Y29sb3I6e30scG9zaXRpb246e30sZGVjYXk6e30sZGlzdGFuY2U6e319fSxwb2ludExpZ2h0U2hhZG93czp7dmFsdWU6W10scHJvcGVydGllczp7c2hhZG93Qmlhczp7fSxzaGFkb3dOb3JtYWxCaWFzOnt9LHNoYWRvd1JhZGl1czp7fSxzaGFkb3dNYXBTaXplOnt9LHNoYWRvd0NhbWVyYU5lYXI6e30sc2hhZG93Q2FtZXJhRmFyOnt9fX0scG9pbnRTaGFkb3dNYXA6e3ZhbHVlOltdfSxwb2ludFNoYWRvd01hdHJpeDp7dmFsdWU6W119LGhlbWlzcGhlcmVMaWdodHM6e3ZhbHVlOltdLHByb3BlcnRpZXM6e2RpcmVjdGlvbjp7fSxza3lDb2xvcjp7fSxncm91bmRDb2xvcjp7fX19LHJlY3RBcmVhTGlnaHRzOnt2YWx1ZTpbXSxwcm9wZXJ0aWVzOntjb2xvcjp7fSxwb3NpdGlvbjp7fSx3aWR0aDp7fSxoZWlnaHQ6e319fSxsdGNfMTp7dmFsdWU6bnVsbH0sbHRjXzI6e3ZhbHVlOm51bGx9fSxwb2ludHM6e2RpZmZ1c2U6e3ZhbHVlOm5ldyB1dCgxNjc3NzIxNSl9LG9wYWNpdHk6e3ZhbHVlOjF9LHNpemU6e3ZhbHVlOjF9LHNjYWxlOnt2YWx1ZToxfSxtYXA6e3ZhbHVlOm51bGx9LGFscGhhTWFwOnt2YWx1ZTpudWxsfSxhbHBoYU1hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGt0fSxhbHBoYVRlc3Q6e3ZhbHVlOjB9LHV2VHJhbnNmb3JtOnt2YWx1ZTpuZXcga3R9fSxzcHJpdGU6e2RpZmZ1c2U6e3ZhbHVlOm5ldyB1dCgxNjc3NzIxNSl9LG9wYWNpdHk6e3ZhbHVlOjF9LGNlbnRlcjp7dmFsdWU6bmV3IFooLjUsLjUpfSxyb3RhdGlvbjp7dmFsdWU6MH0sbWFwOnt2YWx1ZTpudWxsfSxtYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBrdH0sYWxwaGFNYXA6e3ZhbHVlOm51bGx9LGFscGhhTWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcga3R9LGFscGhhVGVzdDp7dmFsdWU6MH19fSxvbj17YmFzaWM6e3VuaWZvcm1zOkJlKFtsdC5jb21tb24sbHQuc3BlY3VsYXJtYXAsbHQuZW52bWFwLGx0LmFvbWFwLGx0LmxpZ2h0bWFwLGx0LmZvZ10pLHZlcnRleFNoYWRlcjp6dC5tZXNoYmFzaWNfdmVydCxmcmFnbWVudFNoYWRlcjp6dC5tZXNoYmFzaWNfZnJhZ30sbGFtYmVydDp7dW5pZm9ybXM6QmUoW2x0LmNvbW1vbixsdC5zcGVjdWxhcm1hcCxsdC5lbnZtYXAsbHQuYW9tYXAsbHQubGlnaHRtYXAsbHQuZW1pc3NpdmVtYXAsbHQuYnVtcG1hcCxsdC5ub3JtYWxtYXAsbHQuZGlzcGxhY2VtZW50bWFwLGx0LmZvZyxsdC5saWdodHMse2VtaXNzaXZlOnt2YWx1ZTpuZXcgdXQoMCl9fV0pLHZlcnRleFNoYWRlcjp6dC5tZXNobGFtYmVydF92ZXJ0LGZyYWdtZW50U2hhZGVyOnp0Lm1lc2hsYW1iZXJ0X2ZyYWd9LHBob25nOnt1bmlmb3JtczpCZShbbHQuY29tbW9uLGx0LnNwZWN1bGFybWFwLGx0LmVudm1hcCxsdC5hb21hcCxsdC5saWdodG1hcCxsdC5lbWlzc2l2ZW1hcCxsdC5idW1wbWFwLGx0Lm5vcm1hbG1hcCxsdC5kaXNwbGFjZW1lbnRtYXAsbHQuZm9nLGx0LmxpZ2h0cyx7ZW1pc3NpdmU6e3ZhbHVlOm5ldyB1dCgwKX0sc3BlY3VsYXI6e3ZhbHVlOm5ldyB1dCgxMTE4NDgxKX0sc2hpbmluZXNzOnt2YWx1ZTozMH19XSksdmVydGV4U2hhZGVyOnp0Lm1lc2hwaG9uZ192ZXJ0LGZyYWdtZW50U2hhZGVyOnp0Lm1lc2hwaG9uZ19mcmFnfSxzdGFuZGFyZDp7dW5pZm9ybXM6QmUoW2x0LmNvbW1vbixsdC5lbnZtYXAsbHQuYW9tYXAsbHQubGlnaHRtYXAsbHQuZW1pc3NpdmVtYXAsbHQuYnVtcG1hcCxsdC5ub3JtYWxtYXAsbHQuZGlzcGxhY2VtZW50bWFwLGx0LnJvdWdobmVzc21hcCxsdC5tZXRhbG5lc3NtYXAsbHQuZm9nLGx0LmxpZ2h0cyx7ZW1pc3NpdmU6e3ZhbHVlOm5ldyB1dCgwKX0scm91Z2huZXNzOnt2YWx1ZToxfSxtZXRhbG5lc3M6e3ZhbHVlOjB9LGVudk1hcEludGVuc2l0eTp7dmFsdWU6MX19XSksdmVydGV4U2hhZGVyOnp0Lm1lc2hwaHlzaWNhbF92ZXJ0LGZyYWdtZW50U2hhZGVyOnp0Lm1lc2hwaHlzaWNhbF9mcmFnfSx0b29uOnt1bmlmb3JtczpCZShbbHQuY29tbW9uLGx0LmFvbWFwLGx0LmxpZ2h0bWFwLGx0LmVtaXNzaXZlbWFwLGx0LmJ1bXBtYXAsbHQubm9ybWFsbWFwLGx0LmRpc3BsYWNlbWVudG1hcCxsdC5ncmFkaWVudG1hcCxsdC5mb2csbHQubGlnaHRzLHtlbWlzc2l2ZTp7dmFsdWU6bmV3IHV0KDApfX1dKSx2ZXJ0ZXhTaGFkZXI6enQubWVzaHRvb25fdmVydCxmcmFnbWVudFNoYWRlcjp6dC5tZXNodG9vbl9mcmFnfSxtYXRjYXA6e3VuaWZvcm1zOkJlKFtsdC5jb21tb24sbHQuYnVtcG1hcCxsdC5ub3JtYWxtYXAsbHQuZGlzcGxhY2VtZW50bWFwLGx0LmZvZyx7bWF0Y2FwOnt2YWx1ZTpudWxsfX1dKSx2ZXJ0ZXhTaGFkZXI6enQubWVzaG1hdGNhcF92ZXJ0LGZyYWdtZW50U2hhZGVyOnp0Lm1lc2htYXRjYXBfZnJhZ30scG9pbnRzOnt1bmlmb3JtczpCZShbbHQucG9pbnRzLGx0LmZvZ10pLHZlcnRleFNoYWRlcjp6dC5wb2ludHNfdmVydCxmcmFnbWVudFNoYWRlcjp6dC5wb2ludHNfZnJhZ30sZGFzaGVkOnt1bmlmb3JtczpCZShbbHQuY29tbW9uLGx0LmZvZyx7c2NhbGU6e3ZhbHVlOjF9LGRhc2hTaXplOnt2YWx1ZToxfSx0b3RhbFNpemU6e3ZhbHVlOjJ9fV0pLHZlcnRleFNoYWRlcjp6dC5saW5lZGFzaGVkX3ZlcnQsZnJhZ21lbnRTaGFkZXI6enQubGluZWRhc2hlZF9mcmFnfSxkZXB0aDp7dW5pZm9ybXM6QmUoW2x0LmNvbW1vbixsdC5kaXNwbGFjZW1lbnRtYXBdKSx2ZXJ0ZXhTaGFkZXI6enQuZGVwdGhfdmVydCxmcmFnbWVudFNoYWRlcjp6dC5kZXB0aF9mcmFnfSxub3JtYWw6e3VuaWZvcm1zOkJlKFtsdC5jb21tb24sbHQuYnVtcG1hcCxsdC5ub3JtYWxtYXAsbHQuZGlzcGxhY2VtZW50bWFwLHtvcGFjaXR5Ont2YWx1ZToxfX1dKSx2ZXJ0ZXhTaGFkZXI6enQubWVzaG5vcm1hbF92ZXJ0LGZyYWdtZW50U2hhZGVyOnp0Lm1lc2hub3JtYWxfZnJhZ30sc3ByaXRlOnt1bmlmb3JtczpCZShbbHQuc3ByaXRlLGx0LmZvZ10pLHZlcnRleFNoYWRlcjp6dC5zcHJpdGVfdmVydCxmcmFnbWVudFNoYWRlcjp6dC5zcHJpdGVfZnJhZ30sYmFja2dyb3VuZDp7dW5pZm9ybXM6e3V2VHJhbnNmb3JtOnt2YWx1ZTpuZXcga3R9LHQyRDp7dmFsdWU6bnVsbH0sYmFja2dyb3VuZEludGVuc2l0eTp7dmFsdWU6MX19LHZlcnRleFNoYWRlcjp6dC5iYWNrZ3JvdW5kX3ZlcnQsZnJhZ21lbnRTaGFkZXI6enQuYmFja2dyb3VuZF9mcmFnfSxiYWNrZ3JvdW5kQ3ViZTp7dW5pZm9ybXM6e2Vudk1hcDp7dmFsdWU6bnVsbH0sZmxpcEVudk1hcDp7dmFsdWU6LTF9LGJhY2tncm91bmRCbHVycmluZXNzOnt2YWx1ZTowfSxiYWNrZ3JvdW5kSW50ZW5zaXR5Ont2YWx1ZToxfX0sdmVydGV4U2hhZGVyOnp0LmJhY2tncm91bmRDdWJlX3ZlcnQsZnJhZ21lbnRTaGFkZXI6enQuYmFja2dyb3VuZEN1YmVfZnJhZ30sY3ViZTp7dW5pZm9ybXM6e3RDdWJlOnt2YWx1ZTpudWxsfSx0RmxpcDp7dmFsdWU6LTF9LG9wYWNpdHk6e3ZhbHVlOjF9fSx2ZXJ0ZXhTaGFkZXI6enQuY3ViZV92ZXJ0LGZyYWdtZW50U2hhZGVyOnp0LmN1YmVfZnJhZ30sZXF1aXJlY3Q6e3VuaWZvcm1zOnt0RXF1aXJlY3Q6e3ZhbHVlOm51bGx9fSx2ZXJ0ZXhTaGFkZXI6enQuZXF1aXJlY3RfdmVydCxmcmFnbWVudFNoYWRlcjp6dC5lcXVpcmVjdF9mcmFnfSxkaXN0YW5jZVJHQkE6e3VuaWZvcm1zOkJlKFtsdC5jb21tb24sbHQuZGlzcGxhY2VtZW50bWFwLHtyZWZlcmVuY2VQb3NpdGlvbjp7dmFsdWU6bmV3IFJ9LG5lYXJEaXN0YW5jZTp7dmFsdWU6MX0sZmFyRGlzdGFuY2U6e3ZhbHVlOjFlM319XSksdmVydGV4U2hhZGVyOnp0LmRpc3RhbmNlUkdCQV92ZXJ0LGZyYWdtZW50U2hhZGVyOnp0LmRpc3RhbmNlUkdCQV9mcmFnfSxzaGFkb3c6e3VuaWZvcm1zOkJlKFtsdC5saWdodHMsbHQuZm9nLHtjb2xvcjp7dmFsdWU6bmV3IHV0KDApfSxvcGFjaXR5Ont2YWx1ZToxfX1dKSx2ZXJ0ZXhTaGFkZXI6enQuc2hhZG93X3ZlcnQsZnJhZ21lbnRTaGFkZXI6enQuc2hhZG93X2ZyYWd9fTtvbi5waHlzaWNhbD17dW5pZm9ybXM6QmUoW29uLnN0YW5kYXJkLnVuaWZvcm1zLHtjbGVhcmNvYXQ6e3ZhbHVlOjB9LGNsZWFyY29hdE1hcDp7dmFsdWU6bnVsbH0sY2xlYXJjb2F0TWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcga3R9LGNsZWFyY29hdE5vcm1hbE1hcDp7dmFsdWU6bnVsbH0sY2xlYXJjb2F0Tm9ybWFsTWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcga3R9LGNsZWFyY29hdE5vcm1hbFNjYWxlOnt2YWx1ZTpuZXcgWigxLDEpfSxjbGVhcmNvYXRSb3VnaG5lc3M6e3ZhbHVlOjB9LGNsZWFyY29hdFJvdWdobmVzc01hcDp7dmFsdWU6bnVsbH0sY2xlYXJjb2F0Um91Z2huZXNzTWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcga3R9LGlyaWRlc2NlbmNlOnt2YWx1ZTowfSxpcmlkZXNjZW5jZU1hcDp7dmFsdWU6bnVsbH0saXJpZGVzY2VuY2VNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBrdH0saXJpZGVzY2VuY2VJT1I6e3ZhbHVlOjEuM30saXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtOnt2YWx1ZToxMDB9LGlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bTp7dmFsdWU6NDAwfSxpcmlkZXNjZW5jZVRoaWNrbmVzc01hcDp7dmFsdWU6bnVsbH0saXJpZGVzY2VuY2VUaGlja25lc3NNYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBrdH0sc2hlZW46e3ZhbHVlOjB9LHNoZWVuQ29sb3I6e3ZhbHVlOm5ldyB1dCgwKX0sc2hlZW5Db2xvck1hcDp7dmFsdWU6bnVsbH0sc2hlZW5Db2xvck1hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGt0fSxzaGVlblJvdWdobmVzczp7dmFsdWU6MX0sc2hlZW5Sb3VnaG5lc3NNYXA6e3ZhbHVlOm51bGx9LHNoZWVuUm91Z2huZXNzTWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcga3R9LHRyYW5zbWlzc2lvbjp7dmFsdWU6MH0sdHJhbnNtaXNzaW9uTWFwOnt2YWx1ZTpudWxsfSx0cmFuc21pc3Npb25NYXBUcmFuc2Zvcm06e3ZhbHVlOm5ldyBrdH0sdHJhbnNtaXNzaW9uU2FtcGxlclNpemU6e3ZhbHVlOm5ldyBafSx0cmFuc21pc3Npb25TYW1wbGVyTWFwOnt2YWx1ZTpudWxsfSx0aGlja25lc3M6e3ZhbHVlOjB9LHRoaWNrbmVzc01hcDp7dmFsdWU6bnVsbH0sdGhpY2tuZXNzTWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcga3R9LGF0dGVudWF0aW9uRGlzdGFuY2U6e3ZhbHVlOjB9LGF0dGVudWF0aW9uQ29sb3I6e3ZhbHVlOm5ldyB1dCgwKX0sc3BlY3VsYXJDb2xvcjp7dmFsdWU6bmV3IHV0KDEsMSwxKX0sc3BlY3VsYXJDb2xvck1hcDp7dmFsdWU6bnVsbH0sc3BlY3VsYXJDb2xvck1hcFRyYW5zZm9ybTp7dmFsdWU6bmV3IGt0fSxzcGVjdWxhckludGVuc2l0eTp7dmFsdWU6MX0sc3BlY3VsYXJJbnRlbnNpdHlNYXA6e3ZhbHVlOm51bGx9LHNwZWN1bGFySW50ZW5zaXR5TWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcga3R9LGFuaXNvdHJvcHlWZWN0b3I6e3ZhbHVlOm5ldyBafSxhbmlzb3Ryb3B5TWFwOnt2YWx1ZTpudWxsfSxhbmlzb3Ryb3B5TWFwVHJhbnNmb3JtOnt2YWx1ZTpuZXcga3R9fV0pLHZlcnRleFNoYWRlcjp6dC5tZXNocGh5c2ljYWxfdmVydCxmcmFnbWVudFNoYWRlcjp6dC5tZXNocGh5c2ljYWxfZnJhZ307dmFyIHJhPXtyOjAsYjowLGc6MH07ZnVuY3Rpb24gUzAocyx0LGUsbixpLHIsYSl7bGV0IG89bmV3IHV0KDApLGw9cj09PSEwPzA6MSxjLGgsdT1udWxsLGQ9MCxmPW51bGw7ZnVuY3Rpb24gbShnLHApe2xldCB2PSExLHg9cC5pc1NjZW5lPT09ITA/cC5iYWNrZ3JvdW5kOm51bGw7eCYmeC5pc1RleHR1cmUmJih4PShwLmJhY2tncm91bmRCbHVycmluZXNzPjA/ZTp0KS5nZXQoeCkpLHg9PT1udWxsP18obyxsKTp4JiZ4LmlzQ29sb3ImJihfKHgsMSksdj0hMCk7bGV0IE09cy54ci5nZXRFbnZpcm9ubWVudEJsZW5kTW9kZSgpO009PT0iYWRkaXRpdmUiP24uYnVmZmVycy5jb2xvci5zZXRDbGVhcigwLDAsMCwxLGEpOk09PT0iYWxwaGEtYmxlbmQiJiZuLmJ1ZmZlcnMuY29sb3Iuc2V0Q2xlYXIoMCwwLDAsMCxhKSwocy5hdXRvQ2xlYXJ8fHYpJiZzLmNsZWFyKHMuYXV0b0NsZWFyQ29sb3Iscy5hdXRvQ2xlYXJEZXB0aCxzLmF1dG9DbGVhclN0ZW5jaWwpLHgmJih4LmlzQ3ViZVRleHR1cmV8fHgubWFwcGluZz09PVRzKT8oaD09PXZvaWQgMCYmKGg9bmV3IGRlKG5ldyBQaSgxLDEsMSksbmV3IEplKHtuYW1lOiJCYWNrZ3JvdW5kQ3ViZU1hdGVyaWFsIix1bmlmb3Jtczp4cyhvbi5iYWNrZ3JvdW5kQ3ViZS51bmlmb3JtcyksdmVydGV4U2hhZGVyOm9uLmJhY2tncm91bmRDdWJlLnZlcnRleFNoYWRlcixmcmFnbWVudFNoYWRlcjpvbi5iYWNrZ3JvdW5kQ3ViZS5mcmFnbWVudFNoYWRlcixzaWRlOlZlLGRlcHRoVGVzdDohMSxkZXB0aFdyaXRlOiExLGZvZzohMX0pKSxoLmdlb21ldHJ5LmRlbGV0ZUF0dHJpYnV0ZSgibm9ybWFsIiksaC5nZW9tZXRyeS5kZWxldGVBdHRyaWJ1dGUoInV2IiksaC5vbkJlZm9yZVJlbmRlcj1mdW5jdGlvbihDLEEsVCl7dGhpcy5tYXRyaXhXb3JsZC5jb3B5UG9zaXRpb24oVC5tYXRyaXhXb3JsZCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLm1hdGVyaWFsLCJlbnZNYXAiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5lbnZNYXAudmFsdWV9fSksaS51cGRhdGUoaCkpLGgubWF0ZXJpYWwudW5pZm9ybXMuZW52TWFwLnZhbHVlPXgsaC5tYXRlcmlhbC51bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlPXguaXNDdWJlVGV4dHVyZSYmeC5pc1JlbmRlclRhcmdldFRleHR1cmU9PT0hMT8tMToxLGgubWF0ZXJpYWwudW5pZm9ybXMuYmFja2dyb3VuZEJsdXJyaW5lc3MudmFsdWU9cC5iYWNrZ3JvdW5kQmx1cnJpbmVzcyxoLm1hdGVyaWFsLnVuaWZvcm1zLmJhY2tncm91bmRJbnRlbnNpdHkudmFsdWU9cC5iYWNrZ3JvdW5kSW50ZW5zaXR5LGgubWF0ZXJpYWwudG9uZU1hcHBlZD1qdC5nZXRUcmFuc2Zlcih4LmNvbG9yU3BhY2UpIT09c2UsKHUhPT14fHxkIT09eC52ZXJzaW9ufHxmIT09cy50b25lTWFwcGluZykmJihoLm1hdGVyaWFsLm5lZWRzVXBkYXRlPSEwLHU9eCxkPXgudmVyc2lvbixmPXMudG9uZU1hcHBpbmcpLGgubGF5ZXJzLmVuYWJsZUFsbCgpLGcudW5zaGlmdChoLGguZ2VvbWV0cnksaC5tYXRlcmlhbCwwLDAsbnVsbCkpOngmJnguaXNUZXh0dXJlJiYoYz09PXZvaWQgMCYmKGM9bmV3IGRlKG5ldyB5cygyLDIpLG5ldyBKZSh7bmFtZToiQmFja2dyb3VuZE1hdGVyaWFsIix1bmlmb3Jtczp4cyhvbi5iYWNrZ3JvdW5kLnVuaWZvcm1zKSx2ZXJ0ZXhTaGFkZXI6b24uYmFja2dyb3VuZC52ZXJ0ZXhTaGFkZXIsZnJhZ21lbnRTaGFkZXI6b24uYmFja2dyb3VuZC5mcmFnbWVudFNoYWRlcixzaWRlOkJuLGRlcHRoVGVzdDohMSxkZXB0aFdyaXRlOiExLGZvZzohMX0pKSxjLmdlb21ldHJ5LmRlbGV0ZUF0dHJpYnV0ZSgibm9ybWFsIiksT2JqZWN0LmRlZmluZVByb3BlcnR5KGMubWF0ZXJpYWwsIm1hcCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLnQyRC52YWx1ZX19KSxpLnVwZGF0ZShjKSksYy5tYXRlcmlhbC51bmlmb3Jtcy50MkQudmFsdWU9eCxjLm1hdGVyaWFsLnVuaWZvcm1zLmJhY2tncm91bmRJbnRlbnNpdHkudmFsdWU9cC5iYWNrZ3JvdW5kSW50ZW5zaXR5LGMubWF0ZXJpYWwudG9uZU1hcHBlZD1qdC5nZXRUcmFuc2Zlcih4LmNvbG9yU3BhY2UpIT09c2UseC5tYXRyaXhBdXRvVXBkYXRlPT09ITAmJngudXBkYXRlTWF0cml4KCksYy5tYXRlcmlhbC51bmlmb3Jtcy51dlRyYW5zZm9ybS52YWx1ZS5jb3B5KHgubWF0cml4KSwodSE9PXh8fGQhPT14LnZlcnNpb258fGYhPT1zLnRvbmVNYXBwaW5nKSYmKGMubWF0ZXJpYWwubmVlZHNVcGRhdGU9ITAsdT14LGQ9eC52ZXJzaW9uLGY9cy50b25lTWFwcGluZyksYy5sYXllcnMuZW5hYmxlQWxsKCksZy51bnNoaWZ0KGMsYy5nZW9tZXRyeSxjLm1hdGVyaWFsLDAsMCxudWxsKSl9ZnVuY3Rpb24gXyhnLHApe2cuZ2V0UkdCKHJhLEtmKHMpKSxuLmJ1ZmZlcnMuY29sb3Iuc2V0Q2xlYXIocmEucixyYS5nLHJhLmIscCxhKX1yZXR1cm57Z2V0Q2xlYXJDb2xvcjpmdW5jdGlvbigpe3JldHVybiBvfSxzZXRDbGVhckNvbG9yOmZ1bmN0aW9uKGcscD0xKXtvLnNldChnKSxsPXAsXyhvLGwpfSxnZXRDbGVhckFscGhhOmZ1bmN0aW9uKCl7cmV0dXJuIGx9LHNldENsZWFyQWxwaGE6ZnVuY3Rpb24oZyl7bD1nLF8obyxsKX0scmVuZGVyOm19fWZ1bmN0aW9uIGIwKHMsdCxlLG4pe2xldCBpPXMuZ2V0UGFyYW1ldGVyKHMuTUFYX1ZFUlRFWF9BVFRSSUJTKSxyPW4uaXNXZWJHTDI/bnVsbDp0LmdldCgiT0VTX3ZlcnRleF9hcnJheV9vYmplY3QiKSxhPW4uaXNXZWJHTDJ8fHIhPT1udWxsLG89e30sbD1nKG51bGwpLGM9bCxoPSExO2Z1bmN0aW9uIHUoSSx6LEYsJCxxKXtsZXQgVz0hMTtpZihhKXtsZXQgZXQ9XygkLEYseik7YyE9PWV0JiYoYz1ldCxmKGMub2JqZWN0KSksVz1wKEksJCxGLHEpLFcmJnYoSSwkLEYscSl9ZWxzZXtsZXQgZXQ9ei53aXJlZnJhbWU9PT0hMDsoYy5nZW9tZXRyeSE9PSQuaWR8fGMucHJvZ3JhbSE9PUYuaWR8fGMud2lyZWZyYW1lIT09ZXQpJiYoYy5nZW9tZXRyeT0kLmlkLGMucHJvZ3JhbT1GLmlkLGMud2lyZWZyYW1lPWV0LFc9ITApfXEhPT1udWxsJiZlLnVwZGF0ZShxLHMuRUxFTUVOVF9BUlJBWV9CVUZGRVIpLChXfHxoKSYmKGg9ITEsVShJLHosRiwkKSxxIT09bnVsbCYmcy5iaW5kQnVmZmVyKHMuRUxFTUVOVF9BUlJBWV9CVUZGRVIsZS5nZXQocSkuYnVmZmVyKSl9ZnVuY3Rpb24gZCgpe3JldHVybiBuLmlzV2ViR0wyP3MuY3JlYXRlVmVydGV4QXJyYXkoKTpyLmNyZWF0ZVZlcnRleEFycmF5T0VTKCl9ZnVuY3Rpb24gZihJKXtyZXR1cm4gbi5pc1dlYkdMMj9zLmJpbmRWZXJ0ZXhBcnJheShJKTpyLmJpbmRWZXJ0ZXhBcnJheU9FUyhJKX1mdW5jdGlvbiBtKEkpe3JldHVybiBuLmlzV2ViR0wyP3MuZGVsZXRlVmVydGV4QXJyYXkoSSk6ci5kZWxldGVWZXJ0ZXhBcnJheU9FUyhJKX1mdW5jdGlvbiBfKEkseixGKXtsZXQgJD1GLndpcmVmcmFtZT09PSEwLHE9b1tJLmlkXTtxPT09dm9pZCAwJiYocT17fSxvW0kuaWRdPXEpO2xldCBXPXFbei5pZF07Vz09PXZvaWQgMCYmKFc9e30scVt6LmlkXT1XKTtsZXQgZXQ9V1skXTtyZXR1cm4gZXQ9PT12b2lkIDAmJihldD1nKGQoKSksV1skXT1ldCksZXR9ZnVuY3Rpb24gZyhJKXtsZXQgej1bXSxGPVtdLCQ9W107Zm9yKGxldCBxPTA7cTxpO3ErKyl6W3FdPTAsRltxXT0wLCRbcV09MDtyZXR1cm57Z2VvbWV0cnk6bnVsbCxwcm9ncmFtOm51bGwsd2lyZWZyYW1lOiExLG5ld0F0dHJpYnV0ZXM6eixlbmFibGVkQXR0cmlidXRlczpGLGF0dHJpYnV0ZURpdmlzb3JzOiQsb2JqZWN0OkksYXR0cmlidXRlczp7fSxpbmRleDpudWxsfX1mdW5jdGlvbiBwKEkseixGLCQpe2xldCBxPWMuYXR0cmlidXRlcyxXPXouYXR0cmlidXRlcyxldD0wLFE9Ri5nZXRBdHRyaWJ1dGVzKCk7Zm9yKGxldCBmdCBpbiBRKWlmKFFbZnRdLmxvY2F0aW9uPj0wKXtsZXQgSD1xW2Z0XSxpdD1XW2Z0XTtpZihpdD09PXZvaWQgMCYmKGZ0PT09Imluc3RhbmNlTWF0cml4IiYmSS5pbnN0YW5jZU1hdHJpeCYmKGl0PUkuaW5zdGFuY2VNYXRyaXgpLGZ0PT09Imluc3RhbmNlQ29sb3IiJiZJLmluc3RhbmNlQ29sb3ImJihpdD1JLmluc3RhbmNlQ29sb3IpKSxIPT09dm9pZCAwfHxILmF0dHJpYnV0ZSE9PWl0fHxpdCYmSC5kYXRhIT09aXQuZGF0YSlyZXR1cm4hMDtldCsrfXJldHVybiBjLmF0dHJpYnV0ZXNOdW0hPT1ldHx8Yy5pbmRleCE9PSR9ZnVuY3Rpb24gdihJLHosRiwkKXtsZXQgcT17fSxXPXouYXR0cmlidXRlcyxldD0wLFE9Ri5nZXRBdHRyaWJ1dGVzKCk7Zm9yKGxldCBmdCBpbiBRKWlmKFFbZnRdLmxvY2F0aW9uPj0wKXtsZXQgSD1XW2Z0XTtIPT09dm9pZCAwJiYoZnQ9PT0iaW5zdGFuY2VNYXRyaXgiJiZJLmluc3RhbmNlTWF0cml4JiYoSD1JLmluc3RhbmNlTWF0cml4KSxmdD09PSJpbnN0YW5jZUNvbG9yIiYmSS5pbnN0YW5jZUNvbG9yJiYoSD1JLmluc3RhbmNlQ29sb3IpKTtsZXQgaXQ9e307aXQuYXR0cmlidXRlPUgsSCYmSC5kYXRhJiYoaXQuZGF0YT1ILmRhdGEpLHFbZnRdPWl0LGV0Kyt9Yy5hdHRyaWJ1dGVzPXEsYy5hdHRyaWJ1dGVzTnVtPWV0LGMuaW5kZXg9JH1mdW5jdGlvbiB4KCl7bGV0IEk9Yy5uZXdBdHRyaWJ1dGVzO2ZvcihsZXQgej0wLEY9SS5sZW5ndGg7ejxGO3orKylJW3pdPTB9ZnVuY3Rpb24gTShJKXtDKEksMCl9ZnVuY3Rpb24gQyhJLHope2xldCBGPWMubmV3QXR0cmlidXRlcywkPWMuZW5hYmxlZEF0dHJpYnV0ZXMscT1jLmF0dHJpYnV0ZURpdmlzb3JzO0ZbSV09MSwkW0ldPT09MCYmKHMuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoSSksJFtJXT0xKSxxW0ldIT09eiYmKChuLmlzV2ViR0wyP3M6dC5nZXQoIkFOR0xFX2luc3RhbmNlZF9hcnJheXMiKSlbbi5pc1dlYkdMMj8idmVydGV4QXR0cmliRGl2aXNvciI6InZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSJdKEkseikscVtJXT16KX1mdW5jdGlvbiBBKCl7bGV0IEk9Yy5uZXdBdHRyaWJ1dGVzLHo9Yy5lbmFibGVkQXR0cmlidXRlcztmb3IobGV0IEY9MCwkPXoubGVuZ3RoO0Y8JDtGKyspeltGXSE9PUlbRl0mJihzLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShGKSx6W0ZdPTApfWZ1bmN0aW9uIFQoSSx6LEYsJCxxLFcsZXQpe2V0PT09ITA/cy52ZXJ0ZXhBdHRyaWJJUG9pbnRlcihJLHosRixxLFcpOnMudmVydGV4QXR0cmliUG9pbnRlcihJLHosRiwkLHEsVyl9ZnVuY3Rpb24gVShJLHosRiwkKXtpZihuLmlzV2ViR0wyPT09ITEmJihJLmlzSW5zdGFuY2VkTWVzaHx8JC5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5KSYmdC5nZXQoIkFOR0xFX2luc3RhbmNlZF9hcnJheXMiKT09PW51bGwpcmV0dXJuO3goKTtsZXQgcT0kLmF0dHJpYnV0ZXMsVz1GLmdldEF0dHJpYnV0ZXMoKSxldD16LmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXM7Zm9yKGxldCBRIGluIFcpe2xldCBmdD1XW1FdO2lmKGZ0LmxvY2F0aW9uPj0wKXtsZXQgUHQ9cVtRXTtpZihQdD09PXZvaWQgMCYmKFE9PT0iaW5zdGFuY2VNYXRyaXgiJiZJLmluc3RhbmNlTWF0cml4JiYoUHQ9SS5pbnN0YW5jZU1hdHJpeCksUT09PSJpbnN0YW5jZUNvbG9yIiYmSS5pbnN0YW5jZUNvbG9yJiYoUHQ9SS5pbnN0YW5jZUNvbG9yKSksUHQhPT12b2lkIDApe2xldCBIPVB0Lm5vcm1hbGl6ZWQsaXQ9UHQuaXRlbVNpemUscHQ9ZS5nZXQoUHQpO2lmKHB0PT09dm9pZCAwKWNvbnRpbnVlO2xldCB2dD1wdC5idWZmZXIsRXQ9cHQudHlwZSx5dD1wdC5ieXRlc1BlckVsZW1lbnQsT3Q9bi5pc1dlYkdMMj09PSEwJiYoRXQ9PT1zLklOVHx8RXQ9PT1zLlVOU0lHTkVEX0lOVHx8UHQuZ3B1VHlwZT09PXFoKTtpZihQdC5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKXtsZXQgQXQ9UHQuZGF0YSxMPUF0LnN0cmlkZSxvdD1QdC5vZmZzZXQ7aWYoQXQuaXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlcil7Zm9yKGxldCBYPTA7WDxmdC5sb2NhdGlvblNpemU7WCsrKUMoZnQubG9jYXRpb24rWCxBdC5tZXNoUGVyQXR0cmlidXRlKTtJLmlzSW5zdGFuY2VkTWVzaCE9PSEwJiYkLl9tYXhJbnN0YW5jZUNvdW50PT09dm9pZCAwJiYoJC5fbWF4SW5zdGFuY2VDb3VudD1BdC5tZXNoUGVyQXR0cmlidXRlKkF0LmNvdW50KX1lbHNlIGZvcihsZXQgWD0wO1g8ZnQubG9jYXRpb25TaXplO1grKylNKGZ0LmxvY2F0aW9uK1gpO3MuYmluZEJ1ZmZlcihzLkFSUkFZX0JVRkZFUix2dCk7Zm9yKGxldCBYPTA7WDxmdC5sb2NhdGlvblNpemU7WCsrKVQoZnQubG9jYXRpb24rWCxpdC9mdC5sb2NhdGlvblNpemUsRXQsSCxMKnl0LChvdCtpdC9mdC5sb2NhdGlvblNpemUqWCkqeXQsT3QpfWVsc2V7aWYoUHQuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUpe2ZvcihsZXQgQXQ9MDtBdDxmdC5sb2NhdGlvblNpemU7QXQrKylDKGZ0LmxvY2F0aW9uK0F0LFB0Lm1lc2hQZXJBdHRyaWJ1dGUpO0kuaXNJbnN0YW5jZWRNZXNoIT09ITAmJiQuX21heEluc3RhbmNlQ291bnQ9PT12b2lkIDAmJigkLl9tYXhJbnN0YW5jZUNvdW50PVB0Lm1lc2hQZXJBdHRyaWJ1dGUqUHQuY291bnQpfWVsc2UgZm9yKGxldCBBdD0wO0F0PGZ0LmxvY2F0aW9uU2l6ZTtBdCsrKU0oZnQubG9jYXRpb24rQXQpO3MuYmluZEJ1ZmZlcihzLkFSUkFZX0JVRkZFUix2dCk7Zm9yKGxldCBBdD0wO0F0PGZ0LmxvY2F0aW9uU2l6ZTtBdCsrKVQoZnQubG9jYXRpb24rQXQsaXQvZnQubG9jYXRpb25TaXplLEV0LEgsaXQqeXQsaXQvZnQubG9jYXRpb25TaXplKkF0Knl0LE90KX19ZWxzZSBpZihldCE9PXZvaWQgMCl7bGV0IEg9ZXRbUV07aWYoSCE9PXZvaWQgMClzd2l0Y2goSC5sZW5ndGgpe2Nhc2UgMjpzLnZlcnRleEF0dHJpYjJmdihmdC5sb2NhdGlvbixIKTticmVhaztjYXNlIDM6cy52ZXJ0ZXhBdHRyaWIzZnYoZnQubG9jYXRpb24sSCk7YnJlYWs7Y2FzZSA0OnMudmVydGV4QXR0cmliNGZ2KGZ0LmxvY2F0aW9uLEgpO2JyZWFrO2RlZmF1bHQ6cy52ZXJ0ZXhBdHRyaWIxZnYoZnQubG9jYXRpb24sSCl9fX19QSgpfWZ1bmN0aW9uIGsoKXtHKCk7Zm9yKGxldCBJIGluIG8pe2xldCB6PW9bSV07Zm9yKGxldCBGIGluIHope2xldCAkPXpbRl07Zm9yKGxldCBxIGluICQpbSgkW3FdLm9iamVjdCksZGVsZXRlICRbcV07ZGVsZXRlIHpbRl19ZGVsZXRlIG9bSV19fWZ1bmN0aW9uIHkoSSl7aWYob1tJLmlkXT09PXZvaWQgMClyZXR1cm47bGV0IHo9b1tJLmlkXTtmb3IobGV0IEYgaW4geil7bGV0ICQ9eltGXTtmb3IobGV0IHEgaW4gJCltKCRbcV0ub2JqZWN0KSxkZWxldGUgJFtxXTtkZWxldGUgeltGXX1kZWxldGUgb1tJLmlkXX1mdW5jdGlvbiB3KEkpe2ZvcihsZXQgeiBpbiBvKXtsZXQgRj1vW3pdO2lmKEZbSS5pZF09PT12b2lkIDApY29udGludWU7bGV0ICQ9RltJLmlkXTtmb3IobGV0IHEgaW4gJCltKCRbcV0ub2JqZWN0KSxkZWxldGUgJFtxXTtkZWxldGUgRltJLmlkXX19ZnVuY3Rpb24gRygpe0ooKSxoPSEwLGMhPT1sJiYoYz1sLGYoYy5vYmplY3QpKX1mdW5jdGlvbiBKKCl7bC5nZW9tZXRyeT1udWxsLGwucHJvZ3JhbT1udWxsLGwud2lyZWZyYW1lPSExfXJldHVybntzZXR1cDp1LHJlc2V0OkcscmVzZXREZWZhdWx0U3RhdGU6SixkaXNwb3NlOmsscmVsZWFzZVN0YXRlc09mR2VvbWV0cnk6eSxyZWxlYXNlU3RhdGVzT2ZQcm9ncmFtOncsaW5pdEF0dHJpYnV0ZXM6eCxlbmFibGVBdHRyaWJ1dGU6TSxkaXNhYmxlVW51c2VkQXR0cmlidXRlczpBfX1mdW5jdGlvbiBFMChzLHQsZSxuKXtsZXQgaT1uLmlzV2ViR0wyLHI7ZnVuY3Rpb24gYShoKXtyPWh9ZnVuY3Rpb24gbyhoLHUpe3MuZHJhd0FycmF5cyhyLGgsdSksZS51cGRhdGUodSxyLDEpfWZ1bmN0aW9uIGwoaCx1LGQpe2lmKGQ9PT0wKXJldHVybjtsZXQgZixtO2lmKGkpZj1zLG09ImRyYXdBcnJheXNJbnN0YW5jZWQiO2Vsc2UgaWYoZj10LmdldCgiQU5HTEVfaW5zdGFuY2VkX2FycmF5cyIpLG09ImRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSIsZj09PW51bGwpe2NvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXI6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLiIpO3JldHVybn1mW21dKHIsaCx1LGQpLGUudXBkYXRlKHUscixkKX1mdW5jdGlvbiBjKGgsdSxkKXtpZihkPT09MClyZXR1cm47bGV0IGY9dC5nZXQoIldFQkdMX211bHRpX2RyYXciKTtpZihmPT09bnVsbClmb3IobGV0IG09MDttPGQ7bSsrKXRoaXMucmVuZGVyKGhbbV0sdVttXSk7ZWxzZXtmLm11bHRpRHJhd0FycmF5c1dFQkdMKHIsaCwwLHUsMCxkKTtsZXQgbT0wO2ZvcihsZXQgXz0wO188ZDtfKyspbSs9dVtfXTtlLnVwZGF0ZShtLHIsMSl9fXRoaXMuc2V0TW9kZT1hLHRoaXMucmVuZGVyPW8sdGhpcy5yZW5kZXJJbnN0YW5jZXM9bCx0aGlzLnJlbmRlck11bHRpRHJhdz1jfWZ1bmN0aW9uIEEwKHMsdCxlKXtsZXQgbjtmdW5jdGlvbiBpKCl7aWYobiE9PXZvaWQgMClyZXR1cm4gbjtpZih0LmhhcygiRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljIik9PT0hMCl7bGV0IFQ9dC5nZXQoIkVYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyIpO249cy5nZXRQYXJhbWV0ZXIoVC5NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQpfWVsc2Ugbj0wO3JldHVybiBufWZ1bmN0aW9uIHIoVCl7aWYoVD09PSJoaWdocCIpe2lmKHMuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KHMuVkVSVEVYX1NIQURFUixzLkhJR0hfRkxPQVQpLnByZWNpc2lvbj4wJiZzLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChzLkZSQUdNRU5UX1NIQURFUixzLkhJR0hfRkxPQVQpLnByZWNpc2lvbj4wKXJldHVybiJoaWdocCI7VD0ibWVkaXVtcCJ9cmV0dXJuIFQ9PT0ibWVkaXVtcCImJnMuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KHMuVkVSVEVYX1NIQURFUixzLk1FRElVTV9GTE9BVCkucHJlY2lzaW9uPjAmJnMuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KHMuRlJBR01FTlRfU0hBREVSLHMuTUVESVVNX0ZMT0FUKS5wcmVjaXNpb24+MD8ibWVkaXVtcCI6Imxvd3AifWxldCBhPXR5cGVvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0PCJ1IiYmcy5jb25zdHJ1Y3Rvci5uYW1lPT09IldlYkdMMlJlbmRlcmluZ0NvbnRleHQiLG89ZS5wcmVjaXNpb24hPT12b2lkIDA/ZS5wcmVjaXNpb246ImhpZ2hwIixsPXIobyk7bCE9PW8mJihjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUmVuZGVyZXI6IixvLCJub3Qgc3VwcG9ydGVkLCB1c2luZyIsbCwiaW5zdGVhZC4iKSxvPWwpO2xldCBjPWF8fHQuaGFzKCJXRUJHTF9kcmF3X2J1ZmZlcnMiKSxoPWUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcj09PSEwLHU9cy5nZXRQYXJhbWV0ZXIocy5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyksZD1zLmdldFBhcmFtZXRlcihzLk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyksZj1zLmdldFBhcmFtZXRlcihzLk1BWF9URVhUVVJFX1NJWkUpLG09cy5nZXRQYXJhbWV0ZXIocy5NQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFKSxfPXMuZ2V0UGFyYW1ldGVyKHMuTUFYX1ZFUlRFWF9BVFRSSUJTKSxnPXMuZ2V0UGFyYW1ldGVyKHMuTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMpLHA9cy5nZXRQYXJhbWV0ZXIocy5NQVhfVkFSWUlOR19WRUNUT1JTKSx2PXMuZ2V0UGFyYW1ldGVyKHMuTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUykseD1kPjAsTT1hfHx0LmhhcygiT0VTX3RleHR1cmVfZmxvYXQiKSxDPXgmJk0sQT1hP3MuZ2V0UGFyYW1ldGVyKHMuTUFYX1NBTVBMRVMpOjA7cmV0dXJue2lzV2ViR0wyOmEsZHJhd0J1ZmZlcnM6YyxnZXRNYXhBbmlzb3Ryb3B5OmksZ2V0TWF4UHJlY2lzaW9uOnIscHJlY2lzaW9uOm8sbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcjpoLG1heFRleHR1cmVzOnUsbWF4VmVydGV4VGV4dHVyZXM6ZCxtYXhUZXh0dXJlU2l6ZTpmLG1heEN1YmVtYXBTaXplOm0sbWF4QXR0cmlidXRlczpfLG1heFZlcnRleFVuaWZvcm1zOmcsbWF4VmFyeWluZ3M6cCxtYXhGcmFnbWVudFVuaWZvcm1zOnYsdmVydGV4VGV4dHVyZXM6eCxmbG9hdEZyYWdtZW50VGV4dHVyZXM6TSxmbG9hdFZlcnRleFRleHR1cmVzOkMsbWF4U2FtcGxlczpBfX1mdW5jdGlvbiBUMChzKXtsZXQgdD10aGlzLGU9bnVsbCxuPTAsaT0hMSxyPSExLGE9bmV3IGRuLG89bmV3IGt0LGw9e3ZhbHVlOm51bGwsbmVlZHNVcGRhdGU6ITF9O3RoaXMudW5pZm9ybT1sLHRoaXMubnVtUGxhbmVzPTAsdGhpcy5udW1JbnRlcnNlY3Rpb249MCx0aGlzLmluaXQ9ZnVuY3Rpb24odSxkKXtsZXQgZj11Lmxlbmd0aCE9PTB8fGR8fG4hPT0wfHxpO3JldHVybiBpPWQsbj11Lmxlbmd0aCxmfSx0aGlzLmJlZ2luU2hhZG93cz1mdW5jdGlvbigpe3I9ITAsaChudWxsKX0sdGhpcy5lbmRTaGFkb3dzPWZ1bmN0aW9uKCl7cj0hMX0sdGhpcy5zZXRHbG9iYWxTdGF0ZT1mdW5jdGlvbih1LGQpe2U9aCh1LGQsMCl9LHRoaXMuc2V0U3RhdGU9ZnVuY3Rpb24odSxkLGYpe2xldCBtPXUuY2xpcHBpbmdQbGFuZXMsXz11LmNsaXBJbnRlcnNlY3Rpb24sZz11LmNsaXBTaGFkb3dzLHA9cy5nZXQodSk7aWYoIWl8fG09PT1udWxsfHxtLmxlbmd0aD09PTB8fHImJiFnKXI/aChudWxsKTpjKCk7ZWxzZXtsZXQgdj1yPzA6bix4PXYqNCxNPXAuY2xpcHBpbmdTdGF0ZXx8bnVsbDtsLnZhbHVlPU0sTT1oKG0sZCx4LGYpO2ZvcihsZXQgQz0wO0MhPT14OysrQylNW0NdPWVbQ107cC5jbGlwcGluZ1N0YXRlPU0sdGhpcy5udW1JbnRlcnNlY3Rpb249Xz90aGlzLm51bVBsYW5lczowLHRoaXMubnVtUGxhbmVzKz12fX07ZnVuY3Rpb24gYygpe2wudmFsdWUhPT1lJiYobC52YWx1ZT1lLGwubmVlZHNVcGRhdGU9bj4wKSx0Lm51bVBsYW5lcz1uLHQubnVtSW50ZXJzZWN0aW9uPTB9ZnVuY3Rpb24gaCh1LGQsZixtKXtsZXQgXz11IT09bnVsbD91Lmxlbmd0aDowLGc9bnVsbDtpZihfIT09MCl7aWYoZz1sLnZhbHVlLG0hPT0hMHx8Zz09PW51bGwpe2xldCBwPWYrXyo0LHY9ZC5tYXRyaXhXb3JsZEludmVyc2U7by5nZXROb3JtYWxNYXRyaXgodiksKGc9PT1udWxsfHxnLmxlbmd0aDxwKSYmKGc9bmV3IEZsb2F0MzJBcnJheShwKSk7Zm9yKGxldCB4PTAsTT1mO3ghPT1fOysreCxNKz00KWEuY29weSh1W3hdKS5hcHBseU1hdHJpeDQodixvKSxhLm5vcm1hbC50b0FycmF5KGcsTSksZ1tNKzNdPWEuY29uc3RhbnR9bC52YWx1ZT1nLGwubmVlZHNVcGRhdGU9ITB9cmV0dXJuIHQubnVtUGxhbmVzPV8sdC5udW1JbnRlcnNlY3Rpb249MCxnfX1mdW5jdGlvbiB3MChzKXtsZXQgdD1uZXcgV2Vha01hcDtmdW5jdGlvbiBlKGEsbyl7cmV0dXJuIG89PT1Zcz9hLm1hcHBpbmc9em46bz09PVpzJiYoYS5tYXBwaW5nPWVpKSxhfWZ1bmN0aW9uIG4oYSl7aWYoYSYmYS5pc1RleHR1cmUpe2xldCBvPWEubWFwcGluZztpZihvPT09WXN8fG89PT1acylpZih0LmhhcyhhKSl7bGV0IGw9dC5nZXQoYSkudGV4dHVyZTtyZXR1cm4gZShsLGEubWFwcGluZyl9ZWxzZXtsZXQgbD1hLmltYWdlO2lmKGwmJmwuaGVpZ2h0PjApe2xldCBjPW5ldyBXYShsLmhlaWdodCk7cmV0dXJuIGMuZnJvbUVxdWlyZWN0YW5ndWxhclRleHR1cmUocyxhKSx0LnNldChhLGMpLGEuYWRkRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsaSksZShjLnRleHR1cmUsYS5tYXBwaW5nKX1lbHNlIHJldHVybiBudWxsfX1yZXR1cm4gYX1mdW5jdGlvbiBpKGEpe2xldCBvPWEudGFyZ2V0O28ucmVtb3ZlRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsaSk7bGV0IGw9dC5nZXQobyk7bCE9PXZvaWQgMCYmKHQuZGVsZXRlKG8pLGwuZGlzcG9zZSgpKX1mdW5jdGlvbiByKCl7dD1uZXcgV2Vha01hcH1yZXR1cm57Z2V0Om4sZGlzcG9zZTpyfX12YXIgTXM9Y2xhc3MgZXh0ZW5kcyB2c3tjb25zdHJ1Y3Rvcih0PS0xLGU9MSxuPTEsaT0tMSxyPS4xLGE9MmUzKXtzdXBlcigpLHRoaXMuaXNPcnRob2dyYXBoaWNDYW1lcmE9ITAsdGhpcy50eXBlPSJPcnRob2dyYXBoaWNDYW1lcmEiLHRoaXMuem9vbT0xLHRoaXMudmlldz1udWxsLHRoaXMubGVmdD10LHRoaXMucmlnaHQ9ZSx0aGlzLnRvcD1uLHRoaXMuYm90dG9tPWksdGhpcy5uZWFyPXIsdGhpcy5mYXI9YSx0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKX1jb3B5KHQsZSl7cmV0dXJuIHN1cGVyLmNvcHkodCxlKSx0aGlzLmxlZnQ9dC5sZWZ0LHRoaXMucmlnaHQ9dC5yaWdodCx0aGlzLnRvcD10LnRvcCx0aGlzLmJvdHRvbT10LmJvdHRvbSx0aGlzLm5lYXI9dC5uZWFyLHRoaXMuZmFyPXQuZmFyLHRoaXMuem9vbT10Lnpvb20sdGhpcy52aWV3PXQudmlldz09PW51bGw/bnVsbDpPYmplY3QuYXNzaWduKHt9LHQudmlldyksdGhpc31zZXRWaWV3T2Zmc2V0KHQsZSxuLGkscixhKXt0aGlzLnZpZXc9PT1udWxsJiYodGhpcy52aWV3PXtlbmFibGVkOiEwLGZ1bGxXaWR0aDoxLGZ1bGxIZWlnaHQ6MSxvZmZzZXRYOjAsb2Zmc2V0WTowLHdpZHRoOjEsaGVpZ2h0OjF9KSx0aGlzLnZpZXcuZW5hYmxlZD0hMCx0aGlzLnZpZXcuZnVsbFdpZHRoPXQsdGhpcy52aWV3LmZ1bGxIZWlnaHQ9ZSx0aGlzLnZpZXcub2Zmc2V0WD1uLHRoaXMudmlldy5vZmZzZXRZPWksdGhpcy52aWV3LndpZHRoPXIsdGhpcy52aWV3LmhlaWdodD1hLHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpfWNsZWFyVmlld09mZnNldCgpe3RoaXMudmlldyE9PW51bGwmJih0aGlzLnZpZXcuZW5hYmxlZD0hMSksdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9dXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpe2xldCB0PSh0aGlzLnJpZ2h0LXRoaXMubGVmdCkvKDIqdGhpcy56b29tKSxlPSh0aGlzLnRvcC10aGlzLmJvdHRvbSkvKDIqdGhpcy56b29tKSxuPSh0aGlzLnJpZ2h0K3RoaXMubGVmdCkvMixpPSh0aGlzLnRvcCt0aGlzLmJvdHRvbSkvMixyPW4tdCxhPW4rdCxvPWkrZSxsPWktZTtpZih0aGlzLnZpZXchPT1udWxsJiZ0aGlzLnZpZXcuZW5hYmxlZCl7bGV0IGM9KHRoaXMucmlnaHQtdGhpcy5sZWZ0KS90aGlzLnZpZXcuZnVsbFdpZHRoL3RoaXMuem9vbSxoPSh0aGlzLnRvcC10aGlzLmJvdHRvbSkvdGhpcy52aWV3LmZ1bGxIZWlnaHQvdGhpcy56b29tO3IrPWMqdGhpcy52aWV3Lm9mZnNldFgsYT1yK2MqdGhpcy52aWV3LndpZHRoLG8tPWgqdGhpcy52aWV3Lm9mZnNldFksbD1vLWgqdGhpcy52aWV3LmhlaWdodH10aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZU9ydGhvZ3JhcGhpYyhyLGEsbyxsLHRoaXMubmVhcix0aGlzLmZhcix0aGlzLmNvb3JkaW5hdGVTeXN0ZW0pLHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weSh0aGlzLnByb2plY3Rpb25NYXRyaXgpLmludmVydCgpfXRvSlNPTih0KXtsZXQgZT1zdXBlci50b0pTT04odCk7cmV0dXJuIGUub2JqZWN0Lnpvb209dGhpcy56b29tLGUub2JqZWN0LmxlZnQ9dGhpcy5sZWZ0LGUub2JqZWN0LnJpZ2h0PXRoaXMucmlnaHQsZS5vYmplY3QudG9wPXRoaXMudG9wLGUub2JqZWN0LmJvdHRvbT10aGlzLmJvdHRvbSxlLm9iamVjdC5uZWFyPXRoaXMubmVhcixlLm9iamVjdC5mYXI9dGhpcy5mYXIsdGhpcy52aWV3IT09bnVsbCYmKGUub2JqZWN0LnZpZXc9T2JqZWN0LmFzc2lnbih7fSx0aGlzLnZpZXcpKSxlfX0sY3M9NCxVdT1bLjEyNSwuMjE1LC4zNSwuNDQ2LC41MjYsLjU4Ml0sU2k9MjAsUmw9bmV3IE1zLER1PW5ldyB1dCxDbD1udWxsLFBsPTAsTGw9MCx5aT0oMStNYXRoLnNxcnQoNSkpLzIsZXM9MS95aSxOdT1bbmV3IFIoMSwxLDEpLG5ldyBSKC0xLDEsMSksbmV3IFIoMSwxLC0xKSxuZXcgUigtMSwxLC0xKSxuZXcgUigwLHlpLGVzKSxuZXcgUigwLHlpLC1lcyksbmV3IFIoZXMsMCx5aSksbmV3IFIoLWVzLDAseWkpLG5ldyBSKHlpLGVzLDApLG5ldyBSKC15aSxlcywwKV0sdXI9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5fcmVuZGVyZXI9dCx0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldD1udWxsLHRoaXMuX2xvZE1heD0wLHRoaXMuX2N1YmVTaXplPTAsdGhpcy5fbG9kUGxhbmVzPVtdLHRoaXMuX3NpemVMb2RzPVtdLHRoaXMuX3NpZ21hcz1bXSx0aGlzLl9ibHVyTWF0ZXJpYWw9bnVsbCx0aGlzLl9jdWJlbWFwTWF0ZXJpYWw9bnVsbCx0aGlzLl9lcXVpcmVjdE1hdGVyaWFsPW51bGwsdGhpcy5fY29tcGlsZU1hdGVyaWFsKHRoaXMuX2JsdXJNYXRlcmlhbCl9ZnJvbVNjZW5lKHQsZT0wLG49LjEsaT0xMDApe0NsPXRoaXMuX3JlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpLFBsPXRoaXMuX3JlbmRlcmVyLmdldEFjdGl2ZUN1YmVGYWNlKCksTGw9dGhpcy5fcmVuZGVyZXIuZ2V0QWN0aXZlTWlwbWFwTGV2ZWwoKSx0aGlzLl9zZXRTaXplKDI1Nik7bGV0IHI9dGhpcy5fYWxsb2NhdGVUYXJnZXRzKCk7cmV0dXJuIHIuZGVwdGhCdWZmZXI9ITAsdGhpcy5fc2NlbmVUb0N1YmVVVih0LG4saSxyKSxlPjAmJnRoaXMuX2JsdXIociwwLDAsZSksdGhpcy5fYXBwbHlQTVJFTShyKSx0aGlzLl9jbGVhbnVwKHIpLHJ9ZnJvbUVxdWlyZWN0YW5ndWxhcih0LGU9bnVsbCl7cmV0dXJuIHRoaXMuX2Zyb21UZXh0dXJlKHQsZSl9ZnJvbUN1YmVtYXAodCxlPW51bGwpe3JldHVybiB0aGlzLl9mcm9tVGV4dHVyZSh0LGUpfWNvbXBpbGVDdWJlbWFwU2hhZGVyKCl7dGhpcy5fY3ViZW1hcE1hdGVyaWFsPT09bnVsbCYmKHRoaXMuX2N1YmVtYXBNYXRlcmlhbD1CdSgpLHRoaXMuX2NvbXBpbGVNYXRlcmlhbCh0aGlzLl9jdWJlbWFwTWF0ZXJpYWwpKX1jb21waWxlRXF1aXJlY3Rhbmd1bGFyU2hhZGVyKCl7dGhpcy5fZXF1aXJlY3RNYXRlcmlhbD09PW51bGwmJih0aGlzLl9lcXVpcmVjdE1hdGVyaWFsPUZ1KCksdGhpcy5fY29tcGlsZU1hdGVyaWFsKHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwpKX1kaXNwb3NlKCl7dGhpcy5fZGlzcG9zZSgpLHRoaXMuX2N1YmVtYXBNYXRlcmlhbCE9PW51bGwmJnRoaXMuX2N1YmVtYXBNYXRlcmlhbC5kaXNwb3NlKCksdGhpcy5fZXF1aXJlY3RNYXRlcmlhbCE9PW51bGwmJnRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwuZGlzcG9zZSgpfV9zZXRTaXplKHQpe3RoaXMuX2xvZE1heD1NYXRoLmZsb29yKE1hdGgubG9nMih0KSksdGhpcy5fY3ViZVNpemU9TWF0aC5wb3coMix0aGlzLl9sb2RNYXgpfV9kaXNwb3NlKCl7dGhpcy5fYmx1ck1hdGVyaWFsIT09bnVsbCYmdGhpcy5fYmx1ck1hdGVyaWFsLmRpc3Bvc2UoKSx0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldCE9PW51bGwmJnRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0LmRpc3Bvc2UoKTtmb3IobGV0IHQ9MDt0PHRoaXMuX2xvZFBsYW5lcy5sZW5ndGg7dCsrKXRoaXMuX2xvZFBsYW5lc1t0XS5kaXNwb3NlKCl9X2NsZWFudXAodCl7dGhpcy5fcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KENsLFBsLExsKSx0LnNjaXNzb3JUZXN0PSExLGFhKHQsMCwwLHQud2lkdGgsdC5oZWlnaHQpfV9mcm9tVGV4dHVyZSh0LGUpe3QubWFwcGluZz09PXpufHx0Lm1hcHBpbmc9PT1laT90aGlzLl9zZXRTaXplKHQuaW1hZ2UubGVuZ3RoPT09MD8xNjp0LmltYWdlWzBdLndpZHRofHx0LmltYWdlWzBdLmltYWdlLndpZHRoKTp0aGlzLl9zZXRTaXplKHQuaW1hZ2Uud2lkdGgvNCksQ2w9dGhpcy5fcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCksUGw9dGhpcy5fcmVuZGVyZXIuZ2V0QWN0aXZlQ3ViZUZhY2UoKSxMbD10aGlzLl9yZW5kZXJlci5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpO2xldCBuPWV8fHRoaXMuX2FsbG9jYXRlVGFyZ2V0cygpO3JldHVybiB0aGlzLl90ZXh0dXJlVG9DdWJlVVYodCxuKSx0aGlzLl9hcHBseVBNUkVNKG4pLHRoaXMuX2NsZWFudXAobiksbn1fYWxsb2NhdGVUYXJnZXRzKCl7bGV0IHQ9MypNYXRoLm1heCh0aGlzLl9jdWJlU2l6ZSwxMTIpLGU9NCp0aGlzLl9jdWJlU2l6ZSxuPXttYWdGaWx0ZXI6b2UsbWluRmlsdGVyOm9lLGdlbmVyYXRlTWlwbWFwczohMSx0eXBlOnBzLGZvcm1hdDpIZSxjb2xvclNwYWNlOl9uLGRlcHRoQnVmZmVyOiExfSxpPU91KHQsZSxuKTtpZih0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldD09PW51bGx8fHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0LndpZHRoIT09dHx8dGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQuaGVpZ2h0IT09ZSl7dGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQhPT1udWxsJiZ0aGlzLl9kaXNwb3NlKCksdGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQ9T3UodCxlLG4pO2xldHtfbG9kTWF4OnJ9PXRoaXM7KHtzaXplTG9kczp0aGlzLl9zaXplTG9kcyxsb2RQbGFuZXM6dGhpcy5fbG9kUGxhbmVzLHNpZ21hczp0aGlzLl9zaWdtYXN9PVIwKHIpKSx0aGlzLl9ibHVyTWF0ZXJpYWw9QzAocix0LGUpfXJldHVybiBpfV9jb21waWxlTWF0ZXJpYWwodCl7bGV0IGU9bmV3IGRlKHRoaXMuX2xvZFBsYW5lc1swXSx0KTt0aGlzLl9yZW5kZXJlci5jb21waWxlKGUsUmwpfV9zY2VuZVRvQ3ViZVVWKHQsZSxuLGkpe2xldCBvPW5ldyB2ZSg5MCwxLGUsbiksbD1bMSwtMSwxLDEsMSwxXSxjPVsxLDEsMSwtMSwtMSwtMV0saD10aGlzLl9yZW5kZXJlcix1PWguYXV0b0NsZWFyLGQ9aC50b25lTWFwcGluZztoLmdldENsZWFyQ29sb3IoRHUpLGgudG9uZU1hcHBpbmc9RG4saC5hdXRvQ2xlYXI9ITE7bGV0IGY9bmV3IHhuKHtuYW1lOiJQTVJFTS5CYWNrZ3JvdW5kIixzaWRlOlZlLGRlcHRoV3JpdGU6ITEsZGVwdGhUZXN0OiExfSksbT1uZXcgZGUobmV3IFBpLGYpLF89ITEsZz10LmJhY2tncm91bmQ7Zz9nLmlzQ29sb3ImJihmLmNvbG9yLmNvcHkoZyksdC5iYWNrZ3JvdW5kPW51bGwsXz0hMCk6KGYuY29sb3IuY29weShEdSksXz0hMCk7Zm9yKGxldCBwPTA7cDw2O3ArKyl7bGV0IHY9cCUzO3Y9PT0wPyhvLnVwLnNldCgwLGxbcF0sMCksby5sb29rQXQoY1twXSwwLDApKTp2PT09MT8oby51cC5zZXQoMCwwLGxbcF0pLG8ubG9va0F0KDAsY1twXSwwKSk6KG8udXAuc2V0KDAsbFtwXSwwKSxvLmxvb2tBdCgwLDAsY1twXSkpO2xldCB4PXRoaXMuX2N1YmVTaXplO2FhKGksdip4LHA+Mj94OjAseCx4KSxoLnNldFJlbmRlclRhcmdldChpKSxfJiZoLnJlbmRlcihtLG8pLGgucmVuZGVyKHQsbyl9bS5nZW9tZXRyeS5kaXNwb3NlKCksbS5tYXRlcmlhbC5kaXNwb3NlKCksaC50b25lTWFwcGluZz1kLGguYXV0b0NsZWFyPXUsdC5iYWNrZ3JvdW5kPWd9X3RleHR1cmVUb0N1YmVVVih0LGUpe2xldCBuPXRoaXMuX3JlbmRlcmVyLGk9dC5tYXBwaW5nPT09em58fHQubWFwcGluZz09PWVpO2k/KHRoaXMuX2N1YmVtYXBNYXRlcmlhbD09PW51bGwmJih0aGlzLl9jdWJlbWFwTWF0ZXJpYWw9QnUoKSksdGhpcy5fY3ViZW1hcE1hdGVyaWFsLnVuaWZvcm1zLmZsaXBFbnZNYXAudmFsdWU9dC5pc1JlbmRlclRhcmdldFRleHR1cmU9PT0hMT8tMToxKTp0aGlzLl9lcXVpcmVjdE1hdGVyaWFsPT09bnVsbCYmKHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWw9RnUoKSk7bGV0IHI9aT90aGlzLl9jdWJlbWFwTWF0ZXJpYWw6dGhpcy5fZXF1aXJlY3RNYXRlcmlhbCxhPW5ldyBkZSh0aGlzLl9sb2RQbGFuZXNbMF0sciksbz1yLnVuaWZvcm1zO28uZW52TWFwLnZhbHVlPXQ7bGV0IGw9dGhpcy5fY3ViZVNpemU7YWEoZSwwLDAsMypsLDIqbCksbi5zZXRSZW5kZXJUYXJnZXQoZSksbi5yZW5kZXIoYSxSbCl9X2FwcGx5UE1SRU0odCl7bGV0IGU9dGhpcy5fcmVuZGVyZXIsbj1lLmF1dG9DbGVhcjtlLmF1dG9DbGVhcj0hMTtmb3IobGV0IGk9MTtpPHRoaXMuX2xvZFBsYW5lcy5sZW5ndGg7aSsrKXtsZXQgcj1NYXRoLnNxcnQodGhpcy5fc2lnbWFzW2ldKnRoaXMuX3NpZ21hc1tpXS10aGlzLl9zaWdtYXNbaS0xXSp0aGlzLl9zaWdtYXNbaS0xXSksYT1OdVsoaS0xKSVOdS5sZW5ndGhdO3RoaXMuX2JsdXIodCxpLTEsaSxyLGEpfWUuYXV0b0NsZWFyPW59X2JsdXIodCxlLG4saSxyKXtsZXQgYT10aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldDt0aGlzLl9oYWxmQmx1cih0LGEsZSxuLGksImxhdGl0dWRpbmFsIixyKSx0aGlzLl9oYWxmQmx1cihhLHQsbixuLGksImxvbmdpdHVkaW5hbCIscil9X2hhbGZCbHVyKHQsZSxuLGkscixhLG8pe2xldCBsPXRoaXMuX3JlbmRlcmVyLGM9dGhpcy5fYmx1ck1hdGVyaWFsO2EhPT0ibGF0aXR1ZGluYWwiJiZhIT09ImxvbmdpdHVkaW5hbCImJmNvbnNvbGUuZXJyb3IoImJsdXIgZGlyZWN0aW9uIG11c3QgYmUgZWl0aGVyIGxhdGl0dWRpbmFsIG9yIGxvbmdpdHVkaW5hbCEiKTtsZXQgaD0zLHU9bmV3IGRlKHRoaXMuX2xvZFBsYW5lc1tpXSxjKSxkPWMudW5pZm9ybXMsZj10aGlzLl9zaXplTG9kc1tuXS0xLG09aXNGaW5pdGUocik/TWF0aC5QSS8oMipmKToyKk1hdGguUEkvKDIqU2ktMSksXz1yL20sZz1pc0Zpbml0ZShyKT8xK01hdGguZmxvb3IoaCpfKTpTaTtnPlNpJiZjb25zb2xlLndhcm4oYHNpZ21hUmFkaWFucywgJHtyfSwgaXMgdG9vIGxhcmdlIGFuZCB3aWxsIGNsaXAsIGFzIGl0IHJlcXVlc3RlZCAke2d9IHNhbXBsZXMgd2hlbiB0aGUgbWF4aW11bSBpcyBzZXQgdG8gJHtTaX1gKTtsZXQgcD1bXSx2PTA7Zm9yKGxldCBUPTA7VDxTaTsrK1Qpe2xldCBVPVQvXyxrPU1hdGguZXhwKC1VKlUvMik7cC5wdXNoKGspLFQ9PT0wP3YrPWs6VDxnJiYodis9MiprKX1mb3IobGV0IFQ9MDtUPHAubGVuZ3RoO1QrKylwW1RdPXBbVF0vdjtkLmVudk1hcC52YWx1ZT10LnRleHR1cmUsZC5zYW1wbGVzLnZhbHVlPWcsZC53ZWlnaHRzLnZhbHVlPXAsZC5sYXRpdHVkaW5hbC52YWx1ZT1hPT09ImxhdGl0dWRpbmFsIixvJiYoZC5wb2xlQXhpcy52YWx1ZT1vKTtsZXR7X2xvZE1heDp4fT10aGlzO2QuZFRoZXRhLnZhbHVlPW0sZC5taXBJbnQudmFsdWU9eC1uO2xldCBNPXRoaXMuX3NpemVMb2RzW2ldLEM9MypNKihpPngtY3M/aS14K2NzOjApLEE9NCoodGhpcy5fY3ViZVNpemUtTSk7YWEoZSxDLEEsMypNLDIqTSksbC5zZXRSZW5kZXJUYXJnZXQoZSksbC5yZW5kZXIodSxSbCl9fTtmdW5jdGlvbiBSMChzKXtsZXQgdD1bXSxlPVtdLG49W10saT1zLHI9cy1jcysxK1V1Lmxlbmd0aDtmb3IobGV0IGE9MDthPHI7YSsrKXtsZXQgbz1NYXRoLnBvdygyLGkpO2UucHVzaChvKTtsZXQgbD0xL287YT5zLWNzP2w9VXVbYS1zK2NzLTFdOmE9PT0wJiYobD0wKSxuLnB1c2gobCk7bGV0IGM9MS8oby0yKSxoPS1jLHU9MStjLGQ9W2gsaCx1LGgsdSx1LGgsaCx1LHUsaCx1XSxmPTYsbT02LF89MyxnPTIscD0xLHY9bmV3IEZsb2F0MzJBcnJheShfKm0qZikseD1uZXcgRmxvYXQzMkFycmF5KGcqbSpmKSxNPW5ldyBGbG9hdDMyQXJyYXkocCptKmYpO2ZvcihsZXQgQT0wO0E8ZjtBKyspe2xldCBUPUElMyoyLzMtMSxVPUE+Mj8wOi0xLGs9W1QsVSwwLFQrMi8zLFUsMCxUKzIvMyxVKzEsMCxULFUsMCxUKzIvMyxVKzEsMCxULFUrMSwwXTt2LnNldChrLF8qbSpBKSx4LnNldChkLGcqbSpBKTtsZXQgeT1bQSxBLEEsQSxBLEFdO00uc2V0KHkscCptKkEpfWxldCBDPW5ldyBIdDtDLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBadCh2LF8pKSxDLnNldEF0dHJpYnV0ZSgidXYiLG5ldyBadCh4LGcpKSxDLnNldEF0dHJpYnV0ZSgiZmFjZUluZGV4IixuZXcgWnQoTSxwKSksdC5wdXNoKEMpLGk+Y3MmJmktLX1yZXR1cm57bG9kUGxhbmVzOnQsc2l6ZUxvZHM6ZSxzaWdtYXM6bn19ZnVuY3Rpb24gT3Uocyx0LGUpe2xldCBuPW5ldyBaZShzLHQsZSk7cmV0dXJuIG4udGV4dHVyZS5tYXBwaW5nPVRzLG4udGV4dHVyZS5uYW1lPSJQTVJFTS5jdWJlVXYiLG4uc2Npc3NvclRlc3Q9ITAsbn1mdW5jdGlvbiBhYShzLHQsZSxuLGkpe3Mudmlld3BvcnQuc2V0KHQsZSxuLGkpLHMuc2Npc3Nvci5zZXQodCxlLG4saSl9ZnVuY3Rpb24gQzAocyx0LGUpe2xldCBuPW5ldyBGbG9hdDMyQXJyYXkoU2kpLGk9bmV3IFIoMCwxLDApO3JldHVybiBuZXcgSmUoe25hbWU6IlNwaGVyaWNhbEdhdXNzaWFuQmx1ciIsZGVmaW5lczp7bjpTaSxDVUJFVVZfVEVYRUxfV0lEVEg6MS90LENVQkVVVl9URVhFTF9IRUlHSFQ6MS9lLENVQkVVVl9NQVhfTUlQOmAke3N9LjBgfSx1bmlmb3Jtczp7ZW52TWFwOnt2YWx1ZTpudWxsfSxzYW1wbGVzOnt2YWx1ZToxfSx3ZWlnaHRzOnt2YWx1ZTpufSxsYXRpdHVkaW5hbDp7dmFsdWU6ITF9LGRUaGV0YTp7dmFsdWU6MH0sbWlwSW50Ont2YWx1ZTowfSxwb2xlQXhpczp7dmFsdWU6aX19LHZlcnRleFNoYWRlcjppdSgpLGZyYWdtZW50U2hhZGVyOmAKCgkJCXByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwoJCQlwcmVjaXNpb24gbWVkaXVtcCBpbnQ7CgoJCQl2YXJ5aW5nIHZlYzMgdk91dHB1dERpcmVjdGlvbjsKCgkJCXVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDsKCQkJdW5pZm9ybSBpbnQgc2FtcGxlczsKCQkJdW5pZm9ybSBmbG9hdCB3ZWlnaHRzWyBuIF07CgkJCXVuaWZvcm0gYm9vbCBsYXRpdHVkaW5hbDsKCQkJdW5pZm9ybSBmbG9hdCBkVGhldGE7CgkJCXVuaWZvcm0gZmxvYXQgbWlwSW50OwoJCQl1bmlmb3JtIHZlYzMgcG9sZUF4aXM7CgoJCQkjZGVmaW5lIEVOVk1BUF9UWVBFX0NVQkVfVVYKCQkJI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD4KCgkJCXZlYzMgZ2V0U2FtcGxlKCBmbG9hdCB0aGV0YSwgdmVjMyBheGlzICkgewoKCQkJCWZsb2F0IGNvc1RoZXRhID0gY29zKCB0aGV0YSApOwoJCQkJLy8gUm9kcmlndWVzJyBheGlzLWFuZ2xlIHJvdGF0aW9uCgkJCQl2ZWMzIHNhbXBsZURpcmVjdGlvbiA9IHZPdXRwdXREaXJlY3Rpb24gKiBjb3NUaGV0YQoJCQkJCSsgY3Jvc3MoIGF4aXMsIHZPdXRwdXREaXJlY3Rpb24gKSAqIHNpbiggdGhldGEgKQoJCQkJCSsgYXhpcyAqIGRvdCggYXhpcywgdk91dHB1dERpcmVjdGlvbiApICogKCAxLjAgLSBjb3NUaGV0YSApOwoKCQkJCXJldHVybiBiaWxpbmVhckN1YmVVViggZW52TWFwLCBzYW1wbGVEaXJlY3Rpb24sIG1pcEludCApOwoKCQkJfQoKCQkJdm9pZCBtYWluKCkgewoKCQkJCXZlYzMgYXhpcyA9IGxhdGl0dWRpbmFsID8gcG9sZUF4aXMgOiBjcm9zcyggcG9sZUF4aXMsIHZPdXRwdXREaXJlY3Rpb24gKTsKCgkJCQlpZiAoIGFsbCggZXF1YWwoIGF4aXMsIHZlYzMoIDAuMCApICkgKSApIHsKCgkJCQkJYXhpcyA9IHZlYzMoIHZPdXRwdXREaXJlY3Rpb24ueiwgMC4wLCAtIHZPdXRwdXREaXJlY3Rpb24ueCApOwoKCQkJCX0KCgkJCQlheGlzID0gbm9ybWFsaXplKCBheGlzICk7CgoJCQkJZ2xfRnJhZ0NvbG9yID0gdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7CgkJCQlnbF9GcmFnQ29sb3IucmdiICs9IHdlaWdodHNbIDAgXSAqIGdldFNhbXBsZSggMC4wLCBheGlzICk7CgoJCQkJZm9yICggaW50IGkgPSAxOyBpIDwgbjsgaSsrICkgewoKCQkJCQlpZiAoIGkgPj0gc2FtcGxlcyApIHsKCgkJCQkJCWJyZWFrOwoKCQkJCQl9CgoJCQkJCWZsb2F0IHRoZXRhID0gZFRoZXRhICogZmxvYXQoIGkgKTsKCQkJCQlnbF9GcmFnQ29sb3IucmdiICs9IHdlaWdodHNbIGkgXSAqIGdldFNhbXBsZSggLTEuMCAqIHRoZXRhLCBheGlzICk7CgkJCQkJZ2xfRnJhZ0NvbG9yLnJnYiArPSB3ZWlnaHRzWyBpIF0gKiBnZXRTYW1wbGUoIHRoZXRhLCBheGlzICk7CgoJCQkJfQoKCQkJfQoJCWAsYmxlbmRpbmc6VW4sZGVwdGhUZXN0OiExLGRlcHRoV3JpdGU6ITF9KX1mdW5jdGlvbiBGdSgpe3JldHVybiBuZXcgSmUoe25hbWU6IkVxdWlyZWN0YW5ndWxhclRvQ3ViZVVWIix1bmlmb3Jtczp7ZW52TWFwOnt2YWx1ZTpudWxsfX0sdmVydGV4U2hhZGVyOml1KCksZnJhZ21lbnRTaGFkZXI6YAoKCQkJcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CgkJCXByZWNpc2lvbiBtZWRpdW1wIGludDsKCgkJCXZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uOwoKCQkJdW5pZm9ybSBzYW1wbGVyMkQgZW52TWFwOwoKCQkJI2luY2x1ZGUgPGNvbW1vbj4KCgkJCXZvaWQgbWFpbigpIHsKCgkJCQl2ZWMzIG91dHB1dERpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdk91dHB1dERpcmVjdGlvbiApOwoJCQkJdmVjMiB1diA9IGVxdWlyZWN0VXYoIG91dHB1dERpcmVjdGlvbiApOwoKCQkJCWdsX0ZyYWdDb2xvciA9IHZlYzQoIHRleHR1cmUyRCAoIGVudk1hcCwgdXYgKS5yZ2IsIDEuMCApOwoKCQkJfQoJCWAsYmxlbmRpbmc6VW4sZGVwdGhUZXN0OiExLGRlcHRoV3JpdGU6ITF9KX1mdW5jdGlvbiBCdSgpe3JldHVybiBuZXcgSmUoe25hbWU6IkN1YmVtYXBUb0N1YmVVViIsdW5pZm9ybXM6e2Vudk1hcDp7dmFsdWU6bnVsbH0sZmxpcEVudk1hcDp7dmFsdWU6LTF9fSx2ZXJ0ZXhTaGFkZXI6aXUoKSxmcmFnbWVudFNoYWRlcjpgCgoJCQlwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKCQkJcHJlY2lzaW9uIG1lZGl1bXAgaW50OwoKCQkJdW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwOwoKCQkJdmFyeWluZyB2ZWMzIHZPdXRwdXREaXJlY3Rpb247CgoJCQl1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDsKCgkJCXZvaWQgbWFpbigpIHsKCgkJCQlnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCB2ZWMzKCBmbGlwRW52TWFwICogdk91dHB1dERpcmVjdGlvbi54LCB2T3V0cHV0RGlyZWN0aW9uLnl6ICkgKTsKCgkJCX0KCQlgLGJsZW5kaW5nOlVuLGRlcHRoVGVzdDohMSxkZXB0aFdyaXRlOiExfSl9ZnVuY3Rpb24gaXUoKXtyZXR1cm5gCgoJCXByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwoJCXByZWNpc2lvbiBtZWRpdW1wIGludDsKCgkJYXR0cmlidXRlIGZsb2F0IGZhY2VJbmRleDsKCgkJdmFyeWluZyB2ZWMzIHZPdXRwdXREaXJlY3Rpb247CgoJCS8vIFJIIGNvb3JkaW5hdGUgc3lzdGVtOyBQTVJFTSBmYWNlLWluZGV4aW5nIGNvbnZlbnRpb24KCQl2ZWMzIGdldERpcmVjdGlvbiggdmVjMiB1diwgZmxvYXQgZmFjZSApIHsKCgkJCXV2ID0gMi4wICogdXYgLSAxLjA7CgoJCQl2ZWMzIGRpcmVjdGlvbiA9IHZlYzMoIHV2LCAxLjAgKTsKCgkJCWlmICggZmFjZSA9PSAwLjAgKSB7CgoJCQkJZGlyZWN0aW9uID0gZGlyZWN0aW9uLnp5eDsgLy8gKCAxLCB2LCB1ICkgcG9zIHgKCgkJCX0gZWxzZSBpZiAoIGZhY2UgPT0gMS4wICkgewoKCQkJCWRpcmVjdGlvbiA9IGRpcmVjdGlvbi54enk7CgkJCQlkaXJlY3Rpb24ueHogKj0gLTEuMDsgLy8gKCAtdSwgMSwgLXYgKSBwb3MgeQoKCQkJfSBlbHNlIGlmICggZmFjZSA9PSAyLjAgKSB7CgoJCQkJZGlyZWN0aW9uLnggKj0gLTEuMDsgLy8gKCAtdSwgdiwgMSApIHBvcyB6CgoJCQl9IGVsc2UgaWYgKCBmYWNlID09IDMuMCApIHsKCgkJCQlkaXJlY3Rpb24gPSBkaXJlY3Rpb24uenl4OwoJCQkJZGlyZWN0aW9uLnh6ICo9IC0xLjA7IC8vICggLTEsIHYsIC11ICkgbmVnIHgKCgkJCX0gZWxzZSBpZiAoIGZhY2UgPT0gNC4wICkgewoKCQkJCWRpcmVjdGlvbiA9IGRpcmVjdGlvbi54enk7CgkJCQlkaXJlY3Rpb24ueHkgKj0gLTEuMDsgLy8gKCAtdSwgLTEsIHYgKSBuZWcgeQoKCQkJfSBlbHNlIGlmICggZmFjZSA9PSA1LjAgKSB7CgoJCQkJZGlyZWN0aW9uLnogKj0gLTEuMDsgLy8gKCB1LCB2LCAtMSApIG5lZyB6CgoJCQl9CgoJCQlyZXR1cm4gZGlyZWN0aW9uOwoKCQl9CgoJCXZvaWQgbWFpbigpIHsKCgkJCXZPdXRwdXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oIHV2LCBmYWNlSW5kZXggKTsKCQkJZ2xfUG9zaXRpb24gPSB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7CgoJCX0KCWB9ZnVuY3Rpb24gUDAocyl7bGV0IHQ9bmV3IFdlYWtNYXAsZT1udWxsO2Z1bmN0aW9uIG4obyl7aWYobyYmby5pc1RleHR1cmUpe2xldCBsPW8ubWFwcGluZyxjPWw9PT1Zc3x8bD09PVpzLGg9bD09PXpufHxsPT09ZWk7aWYoY3x8aClpZihvLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSYmby5uZWVkc1BNUkVNVXBkYXRlPT09ITApe28ubmVlZHNQTVJFTVVwZGF0ZT0hMTtsZXQgdT10LmdldChvKTtyZXR1cm4gZT09PW51bGwmJihlPW5ldyB1cihzKSksdT1jP2UuZnJvbUVxdWlyZWN0YW5ndWxhcihvLHUpOmUuZnJvbUN1YmVtYXAobyx1KSx0LnNldChvLHUpLHUudGV4dHVyZX1lbHNle2lmKHQuaGFzKG8pKXJldHVybiB0LmdldChvKS50ZXh0dXJlO3tsZXQgdT1vLmltYWdlO2lmKGMmJnUmJnUuaGVpZ2h0PjB8fGgmJnUmJmkodSkpe2U9PT1udWxsJiYoZT1uZXcgdXIocykpO2xldCBkPWM/ZS5mcm9tRXF1aXJlY3Rhbmd1bGFyKG8pOmUuZnJvbUN1YmVtYXAobyk7cmV0dXJuIHQuc2V0KG8sZCksby5hZGRFdmVudExpc3RlbmVyKCJkaXNwb3NlIixyKSxkLnRleHR1cmV9ZWxzZSByZXR1cm4gbnVsbH19fXJldHVybiBvfWZ1bmN0aW9uIGkobyl7bGV0IGw9MCxjPTY7Zm9yKGxldCBoPTA7aDxjO2grKylvW2hdIT09dm9pZCAwJiZsKys7cmV0dXJuIGw9PT1jfWZ1bmN0aW9uIHIobyl7bGV0IGw9by50YXJnZXQ7bC5yZW1vdmVFdmVudExpc3RlbmVyKCJkaXNwb3NlIixyKTtsZXQgYz10LmdldChsKTtjIT09dm9pZCAwJiYodC5kZWxldGUobCksYy5kaXNwb3NlKCkpfWZ1bmN0aW9uIGEoKXt0PW5ldyBXZWFrTWFwLGUhPT1udWxsJiYoZS5kaXNwb3NlKCksZT1udWxsKX1yZXR1cm57Z2V0Om4sZGlzcG9zZTphfX1mdW5jdGlvbiBMMChzKXtsZXQgdD17fTtmdW5jdGlvbiBlKG4pe2lmKHRbbl0hPT12b2lkIDApcmV0dXJuIHRbbl07bGV0IGk7c3dpdGNoKG4pe2Nhc2UiV0VCR0xfZGVwdGhfdGV4dHVyZSI6aT1zLmdldEV4dGVuc2lvbigiV0VCR0xfZGVwdGhfdGV4dHVyZSIpfHxzLmdldEV4dGVuc2lvbigiTU9aX1dFQkdMX2RlcHRoX3RleHR1cmUiKXx8cy5nZXRFeHRlbnNpb24oIldFQktJVF9XRUJHTF9kZXB0aF90ZXh0dXJlIik7YnJlYWs7Y2FzZSJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMiOmk9cy5nZXRFeHRlbnNpb24oIkVYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyIpfHxzLmdldEV4dGVuc2lvbigiTU9aX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyIpfHxzLmdldEV4dGVuc2lvbigiV0VCS0lUX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyIpO2JyZWFrO2Nhc2UiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMiOmk9cy5nZXRFeHRlbnNpb24oIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjIil8fHMuZ2V0RXh0ZW5zaW9uKCJNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMiKXx8cy5nZXRFeHRlbnNpb24oIldFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YyIpO2JyZWFrO2Nhc2UiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjIjppPXMuZ2V0RXh0ZW5zaW9uKCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMiKXx8cy5nZXRFeHRlbnNpb24oIldFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMiKTticmVhaztkZWZhdWx0Omk9cy5nZXRFeHRlbnNpb24obil9cmV0dXJuIHRbbl09aSxpfXJldHVybntoYXM6ZnVuY3Rpb24obil7cmV0dXJuIGUobikhPT1udWxsfSxpbml0OmZ1bmN0aW9uKG4pe24uaXNXZWJHTDI/KGUoIkVYVF9jb2xvcl9idWZmZXJfZmxvYXQiKSxlKCJXRUJHTF9jbGlwX2N1bGxfZGlzdGFuY2UiKSk6KGUoIldFQkdMX2RlcHRoX3RleHR1cmUiKSxlKCJPRVNfdGV4dHVyZV9mbG9hdCIpLGUoIk9FU190ZXh0dXJlX2hhbGZfZmxvYXQiKSxlKCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhciIpLGUoIk9FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyIpLGUoIk9FU19lbGVtZW50X2luZGV4X3VpbnQiKSxlKCJPRVNfdmVydGV4X2FycmF5X29iamVjdCIpLGUoIkFOR0xFX2luc3RhbmNlZF9hcnJheXMiKSksZSgiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyIiksZSgiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0IiksZSgiV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlIil9LGdldDpmdW5jdGlvbihuKXtsZXQgaT1lKG4pO3JldHVybiBpPT09bnVsbCYmY29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAiK24rIiBleHRlbnNpb24gbm90IHN1cHBvcnRlZC4iKSxpfX19ZnVuY3Rpb24gSTAocyx0LGUsbil7bGV0IGk9e30scj1uZXcgV2Vha01hcDtmdW5jdGlvbiBhKHUpe2xldCBkPXUudGFyZ2V0O2QuaW5kZXghPT1udWxsJiZ0LnJlbW92ZShkLmluZGV4KTtmb3IobGV0IG0gaW4gZC5hdHRyaWJ1dGVzKXQucmVtb3ZlKGQuYXR0cmlidXRlc1ttXSk7Zm9yKGxldCBtIGluIGQubW9ycGhBdHRyaWJ1dGVzKXtsZXQgXz1kLm1vcnBoQXR0cmlidXRlc1ttXTtmb3IobGV0IGc9MCxwPV8ubGVuZ3RoO2c8cDtnKyspdC5yZW1vdmUoX1tnXSl9ZC5yZW1vdmVFdmVudExpc3RlbmVyKCJkaXNwb3NlIixhKSxkZWxldGUgaVtkLmlkXTtsZXQgZj1yLmdldChkKTtmJiYodC5yZW1vdmUoZiksci5kZWxldGUoZCkpLG4ucmVsZWFzZVN0YXRlc09mR2VvbWV0cnkoZCksZC5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5PT09ITAmJmRlbGV0ZSBkLl9tYXhJbnN0YW5jZUNvdW50LGUubWVtb3J5Lmdlb21ldHJpZXMtLX1mdW5jdGlvbiBvKHUsZCl7cmV0dXJuIGlbZC5pZF09PT0hMHx8KGQuYWRkRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsYSksaVtkLmlkXT0hMCxlLm1lbW9yeS5nZW9tZXRyaWVzKyspLGR9ZnVuY3Rpb24gbCh1KXtsZXQgZD11LmF0dHJpYnV0ZXM7Zm9yKGxldCBtIGluIGQpdC51cGRhdGUoZFttXSxzLkFSUkFZX0JVRkZFUik7bGV0IGY9dS5tb3JwaEF0dHJpYnV0ZXM7Zm9yKGxldCBtIGluIGYpe2xldCBfPWZbbV07Zm9yKGxldCBnPTAscD1fLmxlbmd0aDtnPHA7ZysrKXQudXBkYXRlKF9bZ10scy5BUlJBWV9CVUZGRVIpfX1mdW5jdGlvbiBjKHUpe2xldCBkPVtdLGY9dS5pbmRleCxtPXUuYXR0cmlidXRlcy5wb3NpdGlvbixfPTA7aWYoZiE9PW51bGwpe2xldCB2PWYuYXJyYXk7Xz1mLnZlcnNpb247Zm9yKGxldCB4PTAsTT12Lmxlbmd0aDt4PE07eCs9Myl7bGV0IEM9dlt4KzBdLEE9dlt4KzFdLFQ9dlt4KzJdO2QucHVzaChDLEEsQSxULFQsQyl9fWVsc2UgaWYobSE9PXZvaWQgMCl7bGV0IHY9bS5hcnJheTtfPW0udmVyc2lvbjtmb3IobGV0IHg9MCxNPXYubGVuZ3RoLzMtMTt4PE07eCs9Myl7bGV0IEM9eCswLEE9eCsxLFQ9eCsyO2QucHVzaChDLEEsQSxULFQsQyl9fWVsc2UgcmV0dXJuO2xldCBnPW5ldyhaZihkKT9ocjpjcikoZCwxKTtnLnZlcnNpb249XztsZXQgcD1yLmdldCh1KTtwJiZ0LnJlbW92ZShwKSxyLnNldCh1LGcpfWZ1bmN0aW9uIGgodSl7bGV0IGQ9ci5nZXQodSk7aWYoZCl7bGV0IGY9dS5pbmRleDtmIT09bnVsbCYmZC52ZXJzaW9uPGYudmVyc2lvbiYmYyh1KX1lbHNlIGModSk7cmV0dXJuIHIuZ2V0KHUpfXJldHVybntnZXQ6byx1cGRhdGU6bCxnZXRXaXJlZnJhbWVBdHRyaWJ1dGU6aH19ZnVuY3Rpb24gVTAocyx0LGUsbil7bGV0IGk9bi5pc1dlYkdMMixyO2Z1bmN0aW9uIGEoZil7cj1mfWxldCBvLGw7ZnVuY3Rpb24gYyhmKXtvPWYudHlwZSxsPWYuYnl0ZXNQZXJFbGVtZW50fWZ1bmN0aW9uIGgoZixtKXtzLmRyYXdFbGVtZW50cyhyLG0sbyxmKmwpLGUudXBkYXRlKG0sciwxKX1mdW5jdGlvbiB1KGYsbSxfKXtpZihfPT09MClyZXR1cm47bGV0IGcscDtpZihpKWc9cyxwPSJkcmF3RWxlbWVudHNJbnN0YW5jZWQiO2Vsc2UgaWYoZz10LmdldCgiQU5HTEVfaW5zdGFuY2VkX2FycmF5cyIpLHA9ImRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFIixnPT09bnVsbCl7Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXI6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLiIpO3JldHVybn1nW3BdKHIsbSxvLGYqbCxfKSxlLnVwZGF0ZShtLHIsXyl9ZnVuY3Rpb24gZChmLG0sXyl7aWYoXz09PTApcmV0dXJuO2xldCBnPXQuZ2V0KCJXRUJHTF9tdWx0aV9kcmF3Iik7aWYoZz09PW51bGwpZm9yKGxldCBwPTA7cDxfO3ArKyl0aGlzLnJlbmRlcihmW3BdL2wsbVtwXSk7ZWxzZXtnLm11bHRpRHJhd0VsZW1lbnRzV0VCR0wocixtLDAsbyxmLDAsXyk7bGV0IHA9MDtmb3IobGV0IHY9MDt2PF87disrKXArPW1bdl07ZS51cGRhdGUocCxyLDEpfX10aGlzLnNldE1vZGU9YSx0aGlzLnNldEluZGV4PWMsdGhpcy5yZW5kZXI9aCx0aGlzLnJlbmRlckluc3RhbmNlcz11LHRoaXMucmVuZGVyTXVsdGlEcmF3PWR9ZnVuY3Rpb24gRDAocyl7bGV0IHQ9e2dlb21ldHJpZXM6MCx0ZXh0dXJlczowfSxlPXtmcmFtZTowLGNhbGxzOjAsdHJpYW5nbGVzOjAscG9pbnRzOjAsbGluZXM6MH07ZnVuY3Rpb24gbihyLGEsbyl7c3dpdGNoKGUuY2FsbHMrKyxhKXtjYXNlIHMuVFJJQU5HTEVTOmUudHJpYW5nbGVzKz1vKihyLzMpO2JyZWFrO2Nhc2Ugcy5MSU5FUzplLmxpbmVzKz1vKihyLzIpO2JyZWFrO2Nhc2Ugcy5MSU5FX1NUUklQOmUubGluZXMrPW8qKHItMSk7YnJlYWs7Y2FzZSBzLkxJTkVfTE9PUDplLmxpbmVzKz1vKnI7YnJlYWs7Y2FzZSBzLlBPSU5UUzplLnBvaW50cys9bypyO2JyZWFrO2RlZmF1bHQ6Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xJbmZvOiBVbmtub3duIGRyYXcgbW9kZToiLGEpO2JyZWFrfX1mdW5jdGlvbiBpKCl7ZS5jYWxscz0wLGUudHJpYW5nbGVzPTAsZS5wb2ludHM9MCxlLmxpbmVzPTB9cmV0dXJue21lbW9yeTp0LHJlbmRlcjplLHByb2dyYW1zOm51bGwsYXV0b1Jlc2V0OiEwLHJlc2V0OmksdXBkYXRlOm59fWZ1bmN0aW9uIE4wKHMsdCl7cmV0dXJuIHNbMF0tdFswXX1mdW5jdGlvbiBPMChzLHQpe3JldHVybiBNYXRoLmFicyh0WzFdKS1NYXRoLmFicyhzWzFdKX1mdW5jdGlvbiBGMChzLHQsZSl7bGV0IG49e30saT1uZXcgRmxvYXQzMkFycmF5KDgpLHI9bmV3IFdlYWtNYXAsYT1uZXcgdGUsbz1bXTtmb3IobGV0IGM9MDtjPDg7YysrKW9bY109W2MsMF07ZnVuY3Rpb24gbChjLGgsdSl7bGV0IGQ9Yy5tb3JwaFRhcmdldEluZmx1ZW5jZXM7aWYodC5pc1dlYkdMMj09PSEwKXtsZXQgZj1oLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbnx8aC5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsfHxoLm1vcnBoQXR0cmlidXRlcy5jb2xvcixtPWYhPT12b2lkIDA/Zi5sZW5ndGg6MCxfPXIuZ2V0KGgpO2lmKF89PT12b2lkIDB8fF8uY291bnQhPT1tKXtsZXQgST1mdW5jdGlvbigpe0cuZGlzcG9zZSgpLHIuZGVsZXRlKGgpLGgucmVtb3ZlRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsSSl9O18hPT12b2lkIDAmJl8udGV4dHVyZS5kaXNwb3NlKCk7bGV0IHY9aC5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24hPT12b2lkIDAseD1oLm1vcnBoQXR0cmlidXRlcy5ub3JtYWwhPT12b2lkIDAsTT1oLm1vcnBoQXR0cmlidXRlcy5jb2xvciE9PXZvaWQgMCxDPWgubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9ufHxbXSxBPWgubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbHx8W10sVD1oLm1vcnBoQXR0cmlidXRlcy5jb2xvcnx8W10sVT0wO3Y9PT0hMCYmKFU9MSkseD09PSEwJiYoVT0yKSxNPT09ITAmJihVPTMpO2xldCBrPWguYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudCpVLHk9MTtrPnQubWF4VGV4dHVyZVNpemUmJih5PU1hdGguY2VpbChrL3QubWF4VGV4dHVyZVNpemUpLGs9dC5tYXhUZXh0dXJlU2l6ZSk7bGV0IHc9bmV3IEZsb2F0MzJBcnJheShrKnkqNCptKSxHPW5ldyBncyh3LGsseSxtKTtHLnR5cGU9ZW4sRy5uZWVkc1VwZGF0ZT0hMDtsZXQgSj1VKjQ7Zm9yKGxldCB6PTA7ejxtO3orKyl7bGV0IEY9Q1t6XSwkPUFbel0scT1UW3pdLFc9ayp5KjQqejtmb3IobGV0IGV0PTA7ZXQ8Ri5jb3VudDtldCsrKXtsZXQgUT1ldCpKO3Y9PT0hMCYmKGEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShGLGV0KSx3W1crUSswXT1hLngsd1tXK1ErMV09YS55LHdbVytRKzJdPWEueix3W1crUSszXT0wKSx4PT09ITAmJihhLmZyb21CdWZmZXJBdHRyaWJ1dGUoJCxldCksd1tXK1ErNF09YS54LHdbVytRKzVdPWEueSx3W1crUSs2XT1hLnosd1tXK1ErN109MCksTT09PSEwJiYoYS5mcm9tQnVmZmVyQXR0cmlidXRlKHEsZXQpLHdbVytRKzhdPWEueCx3W1crUSs5XT1hLnksd1tXK1ErMTBdPWEueix3W1crUSsxMV09cS5pdGVtU2l6ZT09PTQ/YS53OjEpfX1fPXtjb3VudDptLHRleHR1cmU6RyxzaXplOm5ldyBaKGsseSl9LHIuc2V0KGgsXyksaC5hZGRFdmVudExpc3RlbmVyKCJkaXNwb3NlIixJKX1sZXQgZz0wO2ZvcihsZXQgdj0wO3Y8ZC5sZW5ndGg7disrKWcrPWRbdl07bGV0IHA9aC5tb3JwaFRhcmdldHNSZWxhdGl2ZT8xOjEtZzt1LmdldFVuaWZvcm1zKCkuc2V0VmFsdWUocywibW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlIixwKSx1LmdldFVuaWZvcm1zKCkuc2V0VmFsdWUocywibW9ycGhUYXJnZXRJbmZsdWVuY2VzIixkKSx1LmdldFVuaWZvcm1zKCkuc2V0VmFsdWUocywibW9ycGhUYXJnZXRzVGV4dHVyZSIsXy50ZXh0dXJlLGUpLHUuZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZShzLCJtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZSIsXy5zaXplKX1lbHNle2xldCBmPWQ9PT12b2lkIDA/MDpkLmxlbmd0aCxtPW5baC5pZF07aWYobT09PXZvaWQgMHx8bS5sZW5ndGghPT1mKXttPVtdO2ZvcihsZXQgeD0wO3g8Zjt4KyspbVt4XT1beCwwXTtuW2guaWRdPW19Zm9yKGxldCB4PTA7eDxmO3grKyl7bGV0IE09bVt4XTtNWzBdPXgsTVsxXT1kW3hdfW0uc29ydChPMCk7Zm9yKGxldCB4PTA7eDw4O3grKyl4PGYmJm1beF1bMV0/KG9beF1bMF09bVt4XVswXSxvW3hdWzFdPW1beF1bMV0pOihvW3hdWzBdPU51bWJlci5NQVhfU0FGRV9JTlRFR0VSLG9beF1bMV09MCk7by5zb3J0KE4wKTtsZXQgXz1oLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbixnPWgubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCxwPTA7Zm9yKGxldCB4PTA7eDw4O3grKyl7bGV0IE09b1t4XSxDPU1bMF0sQT1NWzFdO0MhPT1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUiYmQT8oXyYmaC5nZXRBdHRyaWJ1dGUoIm1vcnBoVGFyZ2V0Iit4KSE9PV9bQ10mJmguc2V0QXR0cmlidXRlKCJtb3JwaFRhcmdldCIreCxfW0NdKSxnJiZoLmdldEF0dHJpYnV0ZSgibW9ycGhOb3JtYWwiK3gpIT09Z1tDXSYmaC5zZXRBdHRyaWJ1dGUoIm1vcnBoTm9ybWFsIit4LGdbQ10pLGlbeF09QSxwKz1BKTooXyYmaC5oYXNBdHRyaWJ1dGUoIm1vcnBoVGFyZ2V0Iit4KT09PSEwJiZoLmRlbGV0ZUF0dHJpYnV0ZSgibW9ycGhUYXJnZXQiK3gpLGcmJmguaGFzQXR0cmlidXRlKCJtb3JwaE5vcm1hbCIreCk9PT0hMCYmaC5kZWxldGVBdHRyaWJ1dGUoIm1vcnBoTm9ybWFsIit4KSxpW3hdPTApfWxldCB2PWgubW9ycGhUYXJnZXRzUmVsYXRpdmU/MToxLXA7dS5nZXRVbmlmb3JtcygpLnNldFZhbHVlKHMsIm1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZSIsdiksdS5nZXRVbmlmb3JtcygpLnNldFZhbHVlKHMsIm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyIsaSl9fXJldHVybnt1cGRhdGU6bH19ZnVuY3Rpb24gQjAocyx0LGUsbil7bGV0IGk9bmV3IFdlYWtNYXA7ZnVuY3Rpb24gcihsKXtsZXQgYz1uLnJlbmRlci5mcmFtZSxoPWwuZ2VvbWV0cnksdT10LmdldChsLGgpO2lmKGkuZ2V0KHUpIT09YyYmKHQudXBkYXRlKHUpLGkuc2V0KHUsYykpLGwuaXNJbnN0YW5jZWRNZXNoJiYobC5oYXNFdmVudExpc3RlbmVyKCJkaXNwb3NlIixvKT09PSExJiZsLmFkZEV2ZW50TGlzdGVuZXIoImRpc3Bvc2UiLG8pLGkuZ2V0KGwpIT09YyYmKGUudXBkYXRlKGwuaW5zdGFuY2VNYXRyaXgscy5BUlJBWV9CVUZGRVIpLGwuaW5zdGFuY2VDb2xvciE9PW51bGwmJmUudXBkYXRlKGwuaW5zdGFuY2VDb2xvcixzLkFSUkFZX0JVRkZFUiksaS5zZXQobCxjKSkpLGwuaXNTa2lubmVkTWVzaCl7bGV0IGQ9bC5za2VsZXRvbjtpLmdldChkKSE9PWMmJihkLnVwZGF0ZSgpLGkuc2V0KGQsYykpfXJldHVybiB1fWZ1bmN0aW9uIGEoKXtpPW5ldyBXZWFrTWFwfWZ1bmN0aW9uIG8obCl7bGV0IGM9bC50YXJnZXQ7Yy5yZW1vdmVFdmVudExpc3RlbmVyKCJkaXNwb3NlIixvKSxlLnJlbW92ZShjLmluc3RhbmNlTWF0cml4KSxjLmluc3RhbmNlQ29sb3IhPT1udWxsJiZlLnJlbW92ZShjLmluc3RhbmNlQ29sb3IpfXJldHVybnt1cGRhdGU6cixkaXNwb3NlOmF9fXZhciBkcj1jbGFzcyBleHRlbmRzIF9le2NvbnN0cnVjdG9yKHQsZSxuLGkscixhLG8sbCxjLGgpe2lmKGg9aCE9PXZvaWQgMD9oOmpuLGghPT1qbiYmaCE9PUNpKXRocm93IG5ldyBFcnJvcigiRGVwdGhUZXh0dXJlIGZvcm1hdCBtdXN0IGJlIGVpdGhlciBUSFJFRS5EZXB0aEZvcm1hdCBvciBUSFJFRS5EZXB0aFN0ZW5jaWxGb3JtYXQiKTtuPT09dm9pZCAwJiZoPT09am4mJihuPUNuKSxuPT09dm9pZCAwJiZoPT09Q2kmJihuPVFuKSxzdXBlcihudWxsLGkscixhLG8sbCxoLG4sYyksdGhpcy5pc0RlcHRoVGV4dHVyZT0hMCx0aGlzLmltYWdlPXt3aWR0aDp0LGhlaWdodDplfSx0aGlzLm1hZ0ZpbHRlcj1vIT09dm9pZCAwP286bWUsdGhpcy5taW5GaWx0ZXI9bCE9PXZvaWQgMD9sOm1lLHRoaXMuZmxpcFk9ITEsdGhpcy5nZW5lcmF0ZU1pcG1hcHM9ITEsdGhpcy5jb21wYXJlRnVuY3Rpb249bnVsbH1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMuY29tcGFyZUZ1bmN0aW9uPXQuY29tcGFyZUZ1bmN0aW9uLHRoaXN9dG9KU09OKHQpe2xldCBlPXN1cGVyLnRvSlNPTih0KTtyZXR1cm4gdGhpcy5jb21wYXJlRnVuY3Rpb24hPT1udWxsJiYoZS5jb21wYXJlRnVuY3Rpb249dGhpcy5jb21wYXJlRnVuY3Rpb24pLGV9fSx0cD1uZXcgX2UsZXA9bmV3IGRyKDEsMSk7ZXAuY29tcGFyZUZ1bmN0aW9uPWV1O3ZhciBucD1uZXcgZ3MsaXA9bmV3IG9yLHNwPW5ldyBMaSx6dT1bXSxWdT1bXSxrdT1uZXcgRmxvYXQzMkFycmF5KDE2KSxIdT1uZXcgRmxvYXQzMkFycmF5KDkpLEd1PW5ldyBGbG9hdDMyQXJyYXkoNCk7ZnVuY3Rpb24gd3Mocyx0LGUpe2xldCBuPXNbMF07aWYobjw9MHx8bj4wKXJldHVybiBzO2xldCBpPXQqZSxyPXp1W2ldO2lmKHI9PT12b2lkIDAmJihyPW5ldyBGbG9hdDMyQXJyYXkoaSksenVbaV09ciksdCE9PTApe24udG9BcnJheShyLDApO2ZvcihsZXQgYT0xLG89MDthIT09dDsrK2Epbys9ZSxzW2FdLnRvQXJyYXkocixvKX1yZXR1cm4gcn1mdW5jdGlvbiB5ZShzLHQpe2lmKHMubGVuZ3RoIT09dC5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBlPTAsbj1zLmxlbmd0aDtlPG47ZSsrKWlmKHNbZV0hPT10W2VdKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIE1lKHMsdCl7Zm9yKGxldCBlPTAsbj10Lmxlbmd0aDtlPG47ZSsrKXNbZV09dFtlXX1mdW5jdGlvbiBzbChzLHQpe2xldCBlPVZ1W3RdO2U9PT12b2lkIDAmJihlPW5ldyBJbnQzMkFycmF5KHQpLFZ1W3RdPWUpO2ZvcihsZXQgbj0wO24hPT10OysrbillW25dPXMuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO3JldHVybiBlfWZ1bmN0aW9uIHowKHMsdCl7bGV0IGU9dGhpcy5jYWNoZTtlWzBdIT09dCYmKHMudW5pZm9ybTFmKHRoaXMuYWRkcix0KSxlWzBdPXQpfWZ1bmN0aW9uIFYwKHMsdCl7bGV0IGU9dGhpcy5jYWNoZTtpZih0LnghPT12b2lkIDApKGVbMF0hPT10Lnh8fGVbMV0hPT10LnkpJiYocy51bmlmb3JtMmYodGhpcy5hZGRyLHQueCx0LnkpLGVbMF09dC54LGVbMV09dC55KTtlbHNle2lmKHllKGUsdCkpcmV0dXJuO3MudW5pZm9ybTJmdih0aGlzLmFkZHIsdCksTWUoZSx0KX19ZnVuY3Rpb24gazAocyx0KXtsZXQgZT10aGlzLmNhY2hlO2lmKHQueCE9PXZvaWQgMCkoZVswXSE9PXQueHx8ZVsxXSE9PXQueXx8ZVsyXSE9PXQueikmJihzLnVuaWZvcm0zZih0aGlzLmFkZHIsdC54LHQueSx0LnopLGVbMF09dC54LGVbMV09dC55LGVbMl09dC56KTtlbHNlIGlmKHQuciE9PXZvaWQgMCkoZVswXSE9PXQucnx8ZVsxXSE9PXQuZ3x8ZVsyXSE9PXQuYikmJihzLnVuaWZvcm0zZih0aGlzLmFkZHIsdC5yLHQuZyx0LmIpLGVbMF09dC5yLGVbMV09dC5nLGVbMl09dC5iKTtlbHNle2lmKHllKGUsdCkpcmV0dXJuO3MudW5pZm9ybTNmdih0aGlzLmFkZHIsdCksTWUoZSx0KX19ZnVuY3Rpb24gSDAocyx0KXtsZXQgZT10aGlzLmNhY2hlO2lmKHQueCE9PXZvaWQgMCkoZVswXSE9PXQueHx8ZVsxXSE9PXQueXx8ZVsyXSE9PXQuenx8ZVszXSE9PXQudykmJihzLnVuaWZvcm00Zih0aGlzLmFkZHIsdC54LHQueSx0LnosdC53KSxlWzBdPXQueCxlWzFdPXQueSxlWzJdPXQueixlWzNdPXQudyk7ZWxzZXtpZih5ZShlLHQpKXJldHVybjtzLnVuaWZvcm00ZnYodGhpcy5hZGRyLHQpLE1lKGUsdCl9fWZ1bmN0aW9uIEcwKHMsdCl7bGV0IGU9dGhpcy5jYWNoZSxuPXQuZWxlbWVudHM7aWYobj09PXZvaWQgMCl7aWYoeWUoZSx0KSlyZXR1cm47cy51bmlmb3JtTWF0cml4MmZ2KHRoaXMuYWRkciwhMSx0KSxNZShlLHQpfWVsc2V7aWYoeWUoZSxuKSlyZXR1cm47R3Uuc2V0KG4pLHMudW5pZm9ybU1hdHJpeDJmdih0aGlzLmFkZHIsITEsR3UpLE1lKGUsbil9fWZ1bmN0aW9uIFcwKHMsdCl7bGV0IGU9dGhpcy5jYWNoZSxuPXQuZWxlbWVudHM7aWYobj09PXZvaWQgMCl7aWYoeWUoZSx0KSlyZXR1cm47cy51bmlmb3JtTWF0cml4M2Z2KHRoaXMuYWRkciwhMSx0KSxNZShlLHQpfWVsc2V7aWYoeWUoZSxuKSlyZXR1cm47SHUuc2V0KG4pLHMudW5pZm9ybU1hdHJpeDNmdih0aGlzLmFkZHIsITEsSHUpLE1lKGUsbil9fWZ1bmN0aW9uIFgwKHMsdCl7bGV0IGU9dGhpcy5jYWNoZSxuPXQuZWxlbWVudHM7aWYobj09PXZvaWQgMCl7aWYoeWUoZSx0KSlyZXR1cm47cy51bmlmb3JtTWF0cml4NGZ2KHRoaXMuYWRkciwhMSx0KSxNZShlLHQpfWVsc2V7aWYoeWUoZSxuKSlyZXR1cm47a3Uuc2V0KG4pLHMudW5pZm9ybU1hdHJpeDRmdih0aGlzLmFkZHIsITEsa3UpLE1lKGUsbil9fWZ1bmN0aW9uIHEwKHMsdCl7bGV0IGU9dGhpcy5jYWNoZTtlWzBdIT09dCYmKHMudW5pZm9ybTFpKHRoaXMuYWRkcix0KSxlWzBdPXQpfWZ1bmN0aW9uIFkwKHMsdCl7bGV0IGU9dGhpcy5jYWNoZTtpZih0LnghPT12b2lkIDApKGVbMF0hPT10Lnh8fGVbMV0hPT10LnkpJiYocy51bmlmb3JtMmkodGhpcy5hZGRyLHQueCx0LnkpLGVbMF09dC54LGVbMV09dC55KTtlbHNle2lmKHllKGUsdCkpcmV0dXJuO3MudW5pZm9ybTJpdih0aGlzLmFkZHIsdCksTWUoZSx0KX19ZnVuY3Rpb24gWjAocyx0KXtsZXQgZT10aGlzLmNhY2hlO2lmKHQueCE9PXZvaWQgMCkoZVswXSE9PXQueHx8ZVsxXSE9PXQueXx8ZVsyXSE9PXQueikmJihzLnVuaWZvcm0zaSh0aGlzLmFkZHIsdC54LHQueSx0LnopLGVbMF09dC54LGVbMV09dC55LGVbMl09dC56KTtlbHNle2lmKHllKGUsdCkpcmV0dXJuO3MudW5pZm9ybTNpdih0aGlzLmFkZHIsdCksTWUoZSx0KX19ZnVuY3Rpb24gSjAocyx0KXtsZXQgZT10aGlzLmNhY2hlO2lmKHQueCE9PXZvaWQgMCkoZVswXSE9PXQueHx8ZVsxXSE9PXQueXx8ZVsyXSE9PXQuenx8ZVszXSE9PXQudykmJihzLnVuaWZvcm00aSh0aGlzLmFkZHIsdC54LHQueSx0LnosdC53KSxlWzBdPXQueCxlWzFdPXQueSxlWzJdPXQueixlWzNdPXQudyk7ZWxzZXtpZih5ZShlLHQpKXJldHVybjtzLnVuaWZvcm00aXYodGhpcy5hZGRyLHQpLE1lKGUsdCl9fWZ1bmN0aW9uICQwKHMsdCl7bGV0IGU9dGhpcy5jYWNoZTtlWzBdIT09dCYmKHMudW5pZm9ybTF1aSh0aGlzLmFkZHIsdCksZVswXT10KX1mdW5jdGlvbiBLMChzLHQpe2xldCBlPXRoaXMuY2FjaGU7aWYodC54IT09dm9pZCAwKShlWzBdIT09dC54fHxlWzFdIT09dC55KSYmKHMudW5pZm9ybTJ1aSh0aGlzLmFkZHIsdC54LHQueSksZVswXT10LngsZVsxXT10LnkpO2Vsc2V7aWYoeWUoZSx0KSlyZXR1cm47cy51bmlmb3JtMnVpdih0aGlzLmFkZHIsdCksTWUoZSx0KX19ZnVuY3Rpb24gUTAocyx0KXtsZXQgZT10aGlzLmNhY2hlO2lmKHQueCE9PXZvaWQgMCkoZVswXSE9PXQueHx8ZVsxXSE9PXQueXx8ZVsyXSE9PXQueikmJihzLnVuaWZvcm0zdWkodGhpcy5hZGRyLHQueCx0LnksdC56KSxlWzBdPXQueCxlWzFdPXQueSxlWzJdPXQueik7ZWxzZXtpZih5ZShlLHQpKXJldHVybjtzLnVuaWZvcm0zdWl2KHRoaXMuYWRkcix0KSxNZShlLHQpfX1mdW5jdGlvbiBqMChzLHQpe2xldCBlPXRoaXMuY2FjaGU7aWYodC54IT09dm9pZCAwKShlWzBdIT09dC54fHxlWzFdIT09dC55fHxlWzJdIT09dC56fHxlWzNdIT09dC53KSYmKHMudW5pZm9ybTR1aSh0aGlzLmFkZHIsdC54LHQueSx0LnosdC53KSxlWzBdPXQueCxlWzFdPXQueSxlWzJdPXQueixlWzNdPXQudyk7ZWxzZXtpZih5ZShlLHQpKXJldHVybjtzLnVuaWZvcm00dWl2KHRoaXMuYWRkcix0KSxNZShlLHQpfX1mdW5jdGlvbiB0eChzLHQsZSl7bGV0IG49dGhpcy5jYWNoZSxpPWUuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO25bMF0hPT1pJiYocy51bmlmb3JtMWkodGhpcy5hZGRyLGkpLG5bMF09aSk7bGV0IHI9dGhpcy50eXBlPT09cy5TQU1QTEVSXzJEX1NIQURPVz9lcDp0cDtlLnNldFRleHR1cmUyRCh0fHxyLGkpfWZ1bmN0aW9uIGV4KHMsdCxlKXtsZXQgbj10aGlzLmNhY2hlLGk9ZS5hbGxvY2F0ZVRleHR1cmVVbml0KCk7blswXSE9PWkmJihzLnVuaWZvcm0xaSh0aGlzLmFkZHIsaSksblswXT1pKSxlLnNldFRleHR1cmUzRCh0fHxpcCxpKX1mdW5jdGlvbiBueChzLHQsZSl7bGV0IG49dGhpcy5jYWNoZSxpPWUuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO25bMF0hPT1pJiYocy51bmlmb3JtMWkodGhpcy5hZGRyLGkpLG5bMF09aSksZS5zZXRUZXh0dXJlQ3ViZSh0fHxzcCxpKX1mdW5jdGlvbiBpeChzLHQsZSl7bGV0IG49dGhpcy5jYWNoZSxpPWUuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO25bMF0hPT1pJiYocy51bmlmb3JtMWkodGhpcy5hZGRyLGkpLG5bMF09aSksZS5zZXRUZXh0dXJlMkRBcnJheSh0fHxucCxpKX1mdW5jdGlvbiBzeChzKXtzd2l0Y2gocyl7Y2FzZSA1MTI2OnJldHVybiB6MDtjYXNlIDM1NjY0OnJldHVybiBWMDtjYXNlIDM1NjY1OnJldHVybiBrMDtjYXNlIDM1NjY2OnJldHVybiBIMDtjYXNlIDM1Njc0OnJldHVybiBHMDtjYXNlIDM1Njc1OnJldHVybiBXMDtjYXNlIDM1Njc2OnJldHVybiBYMDtjYXNlIDUxMjQ6Y2FzZSAzNTY3MDpyZXR1cm4gcTA7Y2FzZSAzNTY2NzpjYXNlIDM1NjcxOnJldHVybiBZMDtjYXNlIDM1NjY4OmNhc2UgMzU2NzI6cmV0dXJuIFowO2Nhc2UgMzU2Njk6Y2FzZSAzNTY3MzpyZXR1cm4gSjA7Y2FzZSA1MTI1OnJldHVybiAkMDtjYXNlIDM2Mjk0OnJldHVybiBLMDtjYXNlIDM2Mjk1OnJldHVybiBRMDtjYXNlIDM2Mjk2OnJldHVybiBqMDtjYXNlIDM1Njc4OmNhc2UgMzYxOTg6Y2FzZSAzNjI5ODpjYXNlIDM2MzA2OmNhc2UgMzU2ODI6cmV0dXJuIHR4O2Nhc2UgMzU2Nzk6Y2FzZSAzNjI5OTpjYXNlIDM2MzA3OnJldHVybiBleDtjYXNlIDM1NjgwOmNhc2UgMzYzMDA6Y2FzZSAzNjMwODpjYXNlIDM2MjkzOnJldHVybiBueDtjYXNlIDM2Mjg5OmNhc2UgMzYzMDM6Y2FzZSAzNjMxMTpjYXNlIDM2MjkyOnJldHVybiBpeH19ZnVuY3Rpb24gcngocyx0KXtzLnVuaWZvcm0xZnYodGhpcy5hZGRyLHQpfWZ1bmN0aW9uIGF4KHMsdCl7bGV0IGU9d3ModCx0aGlzLnNpemUsMik7cy51bmlmb3JtMmZ2KHRoaXMuYWRkcixlKX1mdW5jdGlvbiBveChzLHQpe2xldCBlPXdzKHQsdGhpcy5zaXplLDMpO3MudW5pZm9ybTNmdih0aGlzLmFkZHIsZSl9ZnVuY3Rpb24gbHgocyx0KXtsZXQgZT13cyh0LHRoaXMuc2l6ZSw0KTtzLnVuaWZvcm00ZnYodGhpcy5hZGRyLGUpfWZ1bmN0aW9uIGN4KHMsdCl7bGV0IGU9d3ModCx0aGlzLnNpemUsNCk7cy51bmlmb3JtTWF0cml4MmZ2KHRoaXMuYWRkciwhMSxlKX1mdW5jdGlvbiBoeChzLHQpe2xldCBlPXdzKHQsdGhpcy5zaXplLDkpO3MudW5pZm9ybU1hdHJpeDNmdih0aGlzLmFkZHIsITEsZSl9ZnVuY3Rpb24gdXgocyx0KXtsZXQgZT13cyh0LHRoaXMuc2l6ZSwxNik7cy51bmlmb3JtTWF0cml4NGZ2KHRoaXMuYWRkciwhMSxlKX1mdW5jdGlvbiBkeChzLHQpe3MudW5pZm9ybTFpdih0aGlzLmFkZHIsdCl9ZnVuY3Rpb24gZngocyx0KXtzLnVuaWZvcm0yaXYodGhpcy5hZGRyLHQpfWZ1bmN0aW9uIHB4KHMsdCl7cy51bmlmb3JtM2l2KHRoaXMuYWRkcix0KX1mdW5jdGlvbiBteChzLHQpe3MudW5pZm9ybTRpdih0aGlzLmFkZHIsdCl9ZnVuY3Rpb24gZ3gocyx0KXtzLnVuaWZvcm0xdWl2KHRoaXMuYWRkcix0KX1mdW5jdGlvbiBfeChzLHQpe3MudW5pZm9ybTJ1aXYodGhpcy5hZGRyLHQpfWZ1bmN0aW9uIHh4KHMsdCl7cy51bmlmb3JtM3Vpdih0aGlzLmFkZHIsdCl9ZnVuY3Rpb24gdngocyx0KXtzLnVuaWZvcm00dWl2KHRoaXMuYWRkcix0KX1mdW5jdGlvbiB5eChzLHQsZSl7bGV0IG49dGhpcy5jYWNoZSxpPXQubGVuZ3RoLHI9c2woZSxpKTt5ZShuLHIpfHwocy51bmlmb3JtMWl2KHRoaXMuYWRkcixyKSxNZShuLHIpKTtmb3IobGV0IGE9MDthIT09aTsrK2EpZS5zZXRUZXh0dXJlMkQodFthXXx8dHAsclthXSl9ZnVuY3Rpb24gTXgocyx0LGUpe2xldCBuPXRoaXMuY2FjaGUsaT10Lmxlbmd0aCxyPXNsKGUsaSk7eWUobixyKXx8KHMudW5pZm9ybTFpdih0aGlzLmFkZHIsciksTWUobixyKSk7Zm9yKGxldCBhPTA7YSE9PWk7KythKWUuc2V0VGV4dHVyZTNEKHRbYV18fGlwLHJbYV0pfWZ1bmN0aW9uIFN4KHMsdCxlKXtsZXQgbj10aGlzLmNhY2hlLGk9dC5sZW5ndGgscj1zbChlLGkpO3llKG4scil8fChzLnVuaWZvcm0xaXYodGhpcy5hZGRyLHIpLE1lKG4scikpO2ZvcihsZXQgYT0wO2EhPT1pOysrYSllLnNldFRleHR1cmVDdWJlKHRbYV18fHNwLHJbYV0pfWZ1bmN0aW9uIGJ4KHMsdCxlKXtsZXQgbj10aGlzLmNhY2hlLGk9dC5sZW5ndGgscj1zbChlLGkpO3llKG4scil8fChzLnVuaWZvcm0xaXYodGhpcy5hZGRyLHIpLE1lKG4scikpO2ZvcihsZXQgYT0wO2EhPT1pOysrYSllLnNldFRleHR1cmUyREFycmF5KHRbYV18fG5wLHJbYV0pfWZ1bmN0aW9uIEV4KHMpe3N3aXRjaChzKXtjYXNlIDUxMjY6cmV0dXJuIHJ4O2Nhc2UgMzU2NjQ6cmV0dXJuIGF4O2Nhc2UgMzU2NjU6cmV0dXJuIG94O2Nhc2UgMzU2NjY6cmV0dXJuIGx4O2Nhc2UgMzU2NzQ6cmV0dXJuIGN4O2Nhc2UgMzU2NzU6cmV0dXJuIGh4O2Nhc2UgMzU2NzY6cmV0dXJuIHV4O2Nhc2UgNTEyNDpjYXNlIDM1NjcwOnJldHVybiBkeDtjYXNlIDM1NjY3OmNhc2UgMzU2NzE6cmV0dXJuIGZ4O2Nhc2UgMzU2Njg6Y2FzZSAzNTY3MjpyZXR1cm4gcHg7Y2FzZSAzNTY2OTpjYXNlIDM1NjczOnJldHVybiBteDtjYXNlIDUxMjU6cmV0dXJuIGd4O2Nhc2UgMzYyOTQ6cmV0dXJuIF94O2Nhc2UgMzYyOTU6cmV0dXJuIHh4O2Nhc2UgMzYyOTY6cmV0dXJuIHZ4O2Nhc2UgMzU2Nzg6Y2FzZSAzNjE5ODpjYXNlIDM2Mjk4OmNhc2UgMzYzMDY6Y2FzZSAzNTY4MjpyZXR1cm4geXg7Y2FzZSAzNTY3OTpjYXNlIDM2Mjk5OmNhc2UgMzYzMDc6cmV0dXJuIE14O2Nhc2UgMzU2ODA6Y2FzZSAzNjMwMDpjYXNlIDM2MzA4OmNhc2UgMzYyOTM6cmV0dXJuIFN4O2Nhc2UgMzYyODk6Y2FzZSAzNjMwMzpjYXNlIDM2MzExOmNhc2UgMzYyOTI6cmV0dXJuIGJ4fX12YXIgQmM9Y2xhc3N7Y29uc3RydWN0b3IodCxlLG4pe3RoaXMuaWQ9dCx0aGlzLmFkZHI9bix0aGlzLmNhY2hlPVtdLHRoaXMudHlwZT1lLnR5cGUsdGhpcy5zZXRWYWx1ZT1zeChlLnR5cGUpfX0semM9Y2xhc3N7Y29uc3RydWN0b3IodCxlLG4pe3RoaXMuaWQ9dCx0aGlzLmFkZHI9bix0aGlzLmNhY2hlPVtdLHRoaXMudHlwZT1lLnR5cGUsdGhpcy5zaXplPWUuc2l6ZSx0aGlzLnNldFZhbHVlPUV4KGUudHlwZSl9fSxWYz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmlkPXQsdGhpcy5zZXE9W10sdGhpcy5tYXA9e319c2V0VmFsdWUodCxlLG4pe2xldCBpPXRoaXMuc2VxO2ZvcihsZXQgcj0wLGE9aS5sZW5ndGg7ciE9PWE7KytyKXtsZXQgbz1pW3JdO28uc2V0VmFsdWUodCxlW28uaWRdLG4pfX19LElsPS8oXHcrKShcXSk/KFxbfFwuKT8vZztmdW5jdGlvbiBXdShzLHQpe3Muc2VxLnB1c2godCkscy5tYXBbdC5pZF09dH1mdW5jdGlvbiBBeChzLHQsZSl7bGV0IG49cy5uYW1lLGk9bi5sZW5ndGg7Zm9yKElsLmxhc3RJbmRleD0wOzspe2xldCByPUlsLmV4ZWMobiksYT1JbC5sYXN0SW5kZXgsbz1yWzFdLGw9clsyXT09PSJdIixjPXJbM107aWYobCYmKG89b3wwKSxjPT09dm9pZCAwfHxjPT09IlsiJiZhKzI9PT1pKXtXdShlLGM9PT12b2lkIDA/bmV3IEJjKG8scyx0KTpuZXcgemMobyxzLHQpKTticmVha31lbHNle2xldCB1PWUubWFwW29dO3U9PT12b2lkIDAmJih1PW5ldyBWYyhvKSxXdShlLHUpKSxlPXV9fX12YXIgZnM9Y2xhc3N7Y29uc3RydWN0b3IodCxlKXt0aGlzLnNlcT1bXSx0aGlzLm1hcD17fTtsZXQgbj10LmdldFByb2dyYW1QYXJhbWV0ZXIoZSx0LkFDVElWRV9VTklGT1JNUyk7Zm9yKGxldCBpPTA7aTxuOysraSl7bGV0IHI9dC5nZXRBY3RpdmVVbmlmb3JtKGUsaSksYT10LmdldFVuaWZvcm1Mb2NhdGlvbihlLHIubmFtZSk7QXgocixhLHRoaXMpfX1zZXRWYWx1ZSh0LGUsbixpKXtsZXQgcj10aGlzLm1hcFtlXTtyIT09dm9pZCAwJiZyLnNldFZhbHVlKHQsbixpKX1zZXRPcHRpb25hbCh0LGUsbil7bGV0IGk9ZVtuXTtpIT09dm9pZCAwJiZ0aGlzLnNldFZhbHVlKHQsbixpKX1zdGF0aWMgdXBsb2FkKHQsZSxuLGkpe2ZvcihsZXQgcj0wLGE9ZS5sZW5ndGg7ciE9PWE7KytyKXtsZXQgbz1lW3JdLGw9bltvLmlkXTtsLm5lZWRzVXBkYXRlIT09ITEmJm8uc2V0VmFsdWUodCxsLnZhbHVlLGkpfX1zdGF0aWMgc2VxV2l0aFZhbHVlKHQsZSl7bGV0IG49W107Zm9yKGxldCBpPTAscj10Lmxlbmd0aDtpIT09cjsrK2kpe2xldCBhPXRbaV07YS5pZCBpbiBlJiZuLnB1c2goYSl9cmV0dXJuIG59fTtmdW5jdGlvbiBYdShzLHQsZSl7bGV0IG49cy5jcmVhdGVTaGFkZXIodCk7cmV0dXJuIHMuc2hhZGVyU291cmNlKG4sZSkscy5jb21waWxlU2hhZGVyKG4pLG59dmFyIFR4PTM3Mjk3LHd4PTA7ZnVuY3Rpb24gUngocyx0KXtsZXQgZT1zLnNwbGl0KGAKYCksbj1bXSxpPU1hdGgubWF4KHQtNiwwKSxyPU1hdGgubWluKHQrNixlLmxlbmd0aCk7Zm9yKGxldCBhPWk7YTxyO2ErKyl7bGV0IG89YSsxO24ucHVzaChgJHtvPT09dD8iPiI6IiAifSAke299OiAke2VbYV19YCl9cmV0dXJuIG4uam9pbihgCmApfWZ1bmN0aW9uIEN4KHMpe2xldCB0PWp0LmdldFByaW1hcmllcyhqdC53b3JraW5nQ29sb3JTcGFjZSksZT1qdC5nZXRQcmltYXJpZXMocyksbjtzd2l0Y2godD09PWU/bj0iIjp0PT09bnImJmU9PT1lcj9uPSJMaW5lYXJEaXNwbGF5UDNUb0xpbmVhclNSR0IiOnQ9PT1lciYmZT09PW5yJiYobj0iTGluZWFyU1JHQlRvTGluZWFyRGlzcGxheVAzIikscyl7Y2FzZSBfbjpjYXNlIEZyOnJldHVybltuLCJMaW5lYXJUcmFuc2Zlck9FVEYiXTtjYXNlIHhlOmNhc2UgaWw6cmV0dXJuW24sInNSR0JUcmFuc2Zlck9FVEYiXTtkZWZhdWx0OnJldHVybiBjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUHJvZ3JhbTogVW5zdXBwb3J0ZWQgY29sb3Igc3BhY2U6IixzKSxbbiwiTGluZWFyVHJhbnNmZXJPRVRGIl19fWZ1bmN0aW9uIHF1KHMsdCxlKXtsZXQgbj1zLmdldFNoYWRlclBhcmFtZXRlcih0LHMuQ09NUElMRV9TVEFUVVMpLGk9cy5nZXRTaGFkZXJJbmZvTG9nKHQpLnRyaW0oKTtpZihuJiZpPT09IiIpcmV0dXJuIiI7bGV0IHI9L0VSUk9SOiAwOihcZCspLy5leGVjKGkpO2lmKHIpe2xldCBhPXBhcnNlSW50KHJbMV0pO3JldHVybiBlLnRvVXBwZXJDYXNlKCkrYAoKYCtpK2AKCmArUngocy5nZXRTaGFkZXJTb3VyY2UodCksYSl9ZWxzZSByZXR1cm4gaX1mdW5jdGlvbiBQeChzLHQpe2xldCBlPUN4KHQpO3JldHVybmB2ZWM0ICR7c30oIHZlYzQgdmFsdWUgKSB7IHJldHVybiAke2VbMF19KCAke2VbMV19KCB2YWx1ZSApICk7IH1gfWZ1bmN0aW9uIEx4KHMsdCl7bGV0IGU7c3dpdGNoKHQpe2Nhc2UgeWY6ZT0iTGluZWFyIjticmVhaztjYXNlIE1mOmU9IlJlaW5oYXJkIjticmVhaztjYXNlIFNmOmU9Ik9wdGltaXplZENpbmVvbiI7YnJlYWs7Y2FzZSBiZjplPSJBQ0VTRmlsbWljIjticmVhaztjYXNlIEFmOmU9IkFnWCI7YnJlYWs7Y2FzZSBFZjplPSJDdXN0b20iO2JyZWFrO2RlZmF1bHQ6Y29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFByb2dyYW06IFVuc3VwcG9ydGVkIHRvbmVNYXBwaW5nOiIsdCksZT0iTGluZWFyIn1yZXR1cm4idmVjMyAiK3MrIiggdmVjMyBjb2xvciApIHsgcmV0dXJuICIrZSsiVG9uZU1hcHBpbmcoIGNvbG9yICk7IH0ifWZ1bmN0aW9uIEl4KHMpe3JldHVybltzLmV4dGVuc2lvbkRlcml2YXRpdmVzfHxzLmVudk1hcEN1YmVVVkhlaWdodHx8cy5idW1wTWFwfHxzLm5vcm1hbE1hcFRhbmdlbnRTcGFjZXx8cy5jbGVhcmNvYXROb3JtYWxNYXB8fHMuZmxhdFNoYWRpbmd8fHMuYWxwaGFUb0NvdmVyYWdlfHxzLnNoYWRlcklEPT09InBoeXNpY2FsIj8iI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGUiOiIiLChzLmV4dGVuc2lvbkZyYWdEZXB0aHx8cy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyKSYmcy5yZW5kZXJlckV4dGVuc2lvbkZyYWdEZXB0aD8iI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZSI6IiIscy5leHRlbnNpb25EcmF3QnVmZmVycyYmcy5yZW5kZXJlckV4dGVuc2lvbkRyYXdCdWZmZXJzPyIjZXh0ZW5zaW9uIEdMX0VYVF9kcmF3X2J1ZmZlcnMgOiByZXF1aXJlIjoiIiwocy5leHRlbnNpb25TaGFkZXJUZXh0dXJlTE9EfHxzLmVudk1hcHx8cy50cmFuc21pc3Npb24pJiZzLnJlbmRlcmVyRXh0ZW5zaW9uU2hhZGVyVGV4dHVyZUxvZD8iI2V4dGVuc2lvbiBHTF9FWFRfc2hhZGVyX3RleHR1cmVfbG9kIDogZW5hYmxlIjoiIl0uZmlsdGVyKGhzKS5qb2luKGAKYCl9ZnVuY3Rpb24gVXgocyl7cmV0dXJuW3MuZXh0ZW5zaW9uQ2xpcEN1bGxEaXN0YW5jZT8iI2V4dGVuc2lvbiBHTF9BTkdMRV9jbGlwX2N1bGxfZGlzdGFuY2UgOiByZXF1aXJlIjoiIixzLmV4dGVuc2lvbk11bHRpRHJhdz8iI2V4dGVuc2lvbiBHTF9BTkdMRV9tdWx0aV9kcmF3IDogcmVxdWlyZSI6IiJdLmZpbHRlcihocykuam9pbihgCmApfWZ1bmN0aW9uIER4KHMpe2xldCB0PVtdO2ZvcihsZXQgZSBpbiBzKXtsZXQgbj1zW2VdO24hPT0hMSYmdC5wdXNoKCIjZGVmaW5lICIrZSsiICIrbil9cmV0dXJuIHQuam9pbihgCmApfWZ1bmN0aW9uIE54KHMsdCl7bGV0IGU9e30sbj1zLmdldFByb2dyYW1QYXJhbWV0ZXIodCxzLkFDVElWRV9BVFRSSUJVVEVTKTtmb3IobGV0IGk9MDtpPG47aSsrKXtsZXQgcj1zLmdldEFjdGl2ZUF0dHJpYih0LGkpLGE9ci5uYW1lLG89MTtyLnR5cGU9PT1zLkZMT0FUX01BVDImJihvPTIpLHIudHlwZT09PXMuRkxPQVRfTUFUMyYmKG89Myksci50eXBlPT09cy5GTE9BVF9NQVQ0JiYobz00KSxlW2FdPXt0eXBlOnIudHlwZSxsb2NhdGlvbjpzLmdldEF0dHJpYkxvY2F0aW9uKHQsYSksbG9jYXRpb25TaXplOm99fXJldHVybiBlfWZ1bmN0aW9uIGhzKHMpe3JldHVybiBzIT09IiJ9ZnVuY3Rpb24gWXUocyx0KXtsZXQgZT10Lm51bVNwb3RMaWdodFNoYWRvd3MrdC5udW1TcG90TGlnaHRNYXBzLXQubnVtU3BvdExpZ2h0U2hhZG93c1dpdGhNYXBzO3JldHVybiBzLnJlcGxhY2UoL05VTV9ESVJfTElHSFRTL2csdC5udW1EaXJMaWdodHMpLnJlcGxhY2UoL05VTV9TUE9UX0xJR0hUUy9nLHQubnVtU3BvdExpZ2h0cykucmVwbGFjZSgvTlVNX1NQT1RfTElHSFRfTUFQUy9nLHQubnVtU3BvdExpZ2h0TWFwcykucmVwbGFjZSgvTlVNX1NQT1RfTElHSFRfQ09PUkRTL2csZSkucmVwbGFjZSgvTlVNX1JFQ1RfQVJFQV9MSUdIVFMvZyx0Lm51bVJlY3RBcmVhTGlnaHRzKS5yZXBsYWNlKC9OVU1fUE9JTlRfTElHSFRTL2csdC5udW1Qb2ludExpZ2h0cykucmVwbGFjZSgvTlVNX0hFTUlfTElHSFRTL2csdC5udW1IZW1pTGlnaHRzKS5yZXBsYWNlKC9OVU1fRElSX0xJR0hUX1NIQURPV1MvZyx0Lm51bURpckxpZ2h0U2hhZG93cykucmVwbGFjZSgvTlVNX1NQT1RfTElHSFRfU0hBRE9XU19XSVRIX01BUFMvZyx0Lm51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwcykucmVwbGFjZSgvTlVNX1NQT1RfTElHSFRfU0hBRE9XUy9nLHQubnVtU3BvdExpZ2h0U2hhZG93cykucmVwbGFjZSgvTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MvZyx0Lm51bVBvaW50TGlnaHRTaGFkb3dzKX1mdW5jdGlvbiBadShzLHQpe3JldHVybiBzLnJlcGxhY2UoL05VTV9DTElQUElOR19QTEFORVMvZyx0Lm51bUNsaXBwaW5nUGxhbmVzKS5yZXBsYWNlKC9VTklPTl9DTElQUElOR19QTEFORVMvZyx0Lm51bUNsaXBwaW5nUGxhbmVzLXQubnVtQ2xpcEludGVyc2VjdGlvbil9dmFyIE94PS9eWyBcdF0qI2luY2x1ZGUgKzwoW1x3XGQuL10rKT4vZ207ZnVuY3Rpb24ga2Mocyl7cmV0dXJuIHMucmVwbGFjZShPeCxCeCl9dmFyIEZ4PW5ldyBNYXAoW1siZW5jb2RpbmdzX2ZyYWdtZW50IiwiY29sb3JzcGFjZV9mcmFnbWVudCJdLFsiZW5jb2RpbmdzX3BhcnNfZnJhZ21lbnQiLCJjb2xvcnNwYWNlX3BhcnNfZnJhZ21lbnQiXSxbIm91dHB1dF9mcmFnbWVudCIsIm9wYXF1ZV9mcmFnbWVudCJdXSk7ZnVuY3Rpb24gQngocyx0KXtsZXQgZT16dFt0XTtpZihlPT09dm9pZCAwKXtsZXQgbj1GeC5nZXQodCk7aWYobiE9PXZvaWQgMCllPXp0W25dLGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogU2hhZGVyIGNodW5rICIlcyIgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlICIlcyIgaW5zdGVhZC4nLHQsbik7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoIkNhbiBub3QgcmVzb2x2ZSAjaW5jbHVkZSA8Iit0KyI+Iil9cmV0dXJuIGtjKGUpfXZhciB6eD0vI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxzK2ZvclxzKlwoXHMqaW50XHMraVxzKj1ccyooXGQrKVxzKjtccyppXHMqPFxzKihcZCspXHMqO1xzKmlccypcK1wrXHMqXClccyp7KFtcc1xTXSs/KX1ccysjcHJhZ21hIHVucm9sbF9sb29wX2VuZC9nO2Z1bmN0aW9uIEp1KHMpe3JldHVybiBzLnJlcGxhY2UoengsVngpfWZ1bmN0aW9uIFZ4KHMsdCxlLG4pe2xldCBpPSIiO2ZvcihsZXQgcj1wYXJzZUludCh0KTtyPHBhcnNlSW50KGUpO3IrKylpKz1uLnJlcGxhY2UoL1xbXHMqaVxzKlxdL2csIlsgIityKyIgXSIpLnJlcGxhY2UoL1VOUk9MTEVEX0xPT1BfSU5ERVgvZyxyKTtyZXR1cm4gaX1mdW5jdGlvbiAkdShzKXtsZXQgdD1gcHJlY2lzaW9uICR7cy5wcmVjaXNpb259IGZsb2F0OwoJcHJlY2lzaW9uICR7cy5wcmVjaXNpb259IGludDsKCXByZWNpc2lvbiAke3MucHJlY2lzaW9ufSBzYW1wbGVyMkQ7CglwcmVjaXNpb24gJHtzLnByZWNpc2lvbn0gc2FtcGxlckN1YmU7CglgO3JldHVybiBzLmlzV2ViR0wyJiYodCs9YHByZWNpc2lvbiAke3MucHJlY2lzaW9ufSBzYW1wbGVyM0Q7CgkJcHJlY2lzaW9uICR7cy5wcmVjaXNpb259IHNhbXBsZXIyREFycmF5OwoJCXByZWNpc2lvbiAke3MucHJlY2lzaW9ufSBzYW1wbGVyMkRTaGFkb3c7CgkJcHJlY2lzaW9uICR7cy5wcmVjaXNpb259IHNhbXBsZXJDdWJlU2hhZG93OwoJCXByZWNpc2lvbiAke3MucHJlY2lzaW9ufSBzYW1wbGVyMkRBcnJheVNoYWRvdzsKCQlwcmVjaXNpb24gJHtzLnByZWNpc2lvbn0gaXNhbXBsZXIyRDsKCQlwcmVjaXNpb24gJHtzLnByZWNpc2lvbn0gaXNhbXBsZXIzRDsKCQlwcmVjaXNpb24gJHtzLnByZWNpc2lvbn0gaXNhbXBsZXJDdWJlOwoJCXByZWNpc2lvbiAke3MucHJlY2lzaW9ufSBpc2FtcGxlcjJEQXJyYXk7CgkJcHJlY2lzaW9uICR7cy5wcmVjaXNpb259IHVzYW1wbGVyMkQ7CgkJcHJlY2lzaW9uICR7cy5wcmVjaXNpb259IHVzYW1wbGVyM0Q7CgkJcHJlY2lzaW9uICR7cy5wcmVjaXNpb259IHVzYW1wbGVyQ3ViZTsKCQlwcmVjaXNpb24gJHtzLnByZWNpc2lvbn0gdXNhbXBsZXIyREFycmF5OwoJCWApLHMucHJlY2lzaW9uPT09ImhpZ2hwIj90Kz1gCiNkZWZpbmUgSElHSF9QUkVDSVNJT05gOnMucHJlY2lzaW9uPT09Im1lZGl1bXAiP3QrPWAKI2RlZmluZSBNRURJVU1fUFJFQ0lTSU9OYDpzLnByZWNpc2lvbj09PSJsb3dwIiYmKHQrPWAKI2RlZmluZSBMT1dfUFJFQ0lTSU9OYCksdH1mdW5jdGlvbiBreChzKXtsZXQgdD0iU0hBRE9XTUFQX1RZUEVfQkFTSUMiO3JldHVybiBzLnNoYWRvd01hcFR5cGU9PT1YaD90PSJTSEFET1dNQVBfVFlQRV9QQ0YiOnMuc2hhZG93TWFwVHlwZT09PVlkP3Q9IlNIQURPV01BUF9UWVBFX1BDRl9TT0ZUIjpzLnNoYWRvd01hcFR5cGU9PT11biYmKHQ9IlNIQURPV01BUF9UWVBFX1ZTTSIpLHR9ZnVuY3Rpb24gSHgocyl7bGV0IHQ9IkVOVk1BUF9UWVBFX0NVQkUiO2lmKHMuZW52TWFwKXN3aXRjaChzLmVudk1hcE1vZGUpe2Nhc2Ugem46Y2FzZSBlaTp0PSJFTlZNQVBfVFlQRV9DVUJFIjticmVhaztjYXNlIFRzOnQ9IkVOVk1BUF9UWVBFX0NVQkVfVVYiO2JyZWFrfXJldHVybiB0fWZ1bmN0aW9uIEd4KHMpe2xldCB0PSJFTlZNQVBfTU9ERV9SRUZMRUNUSU9OIjtpZihzLmVudk1hcClzd2l0Y2gocy5lbnZNYXBNb2RlKXtjYXNlIGVpOnQ9IkVOVk1BUF9NT0RFX1JFRlJBQ1RJT04iO2JyZWFrfXJldHVybiB0fWZ1bmN0aW9uIFd4KHMpe2xldCB0PSJFTlZNQVBfQkxFTkRJTkdfTk9ORSI7aWYocy5lbnZNYXApc3dpdGNoKHMuY29tYmluZSl7Y2FzZSBPcjp0PSJFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFkiO2JyZWFrO2Nhc2UgeGY6dD0iRU5WTUFQX0JMRU5ESU5HX01JWCI7YnJlYWs7Y2FzZSB2Zjp0PSJFTlZNQVBfQkxFTkRJTkdfQUREIjticmVha31yZXR1cm4gdH1mdW5jdGlvbiBYeChzKXtsZXQgdD1zLmVudk1hcEN1YmVVVkhlaWdodDtpZih0PT09bnVsbClyZXR1cm4gbnVsbDtsZXQgZT1NYXRoLmxvZzIodCktMixuPTEvdDtyZXR1cm57dGV4ZWxXaWR0aDoxLygzKk1hdGgubWF4KE1hdGgucG93KDIsZSksNyoxNikpLHRleGVsSGVpZ2h0Om4sbWF4TWlwOmV9fWZ1bmN0aW9uIHF4KHMsdCxlLG4pe2xldCBpPXMuZ2V0Q29udGV4dCgpLHI9ZS5kZWZpbmVzLGE9ZS52ZXJ0ZXhTaGFkZXIsbz1lLmZyYWdtZW50U2hhZGVyLGw9a3goZSksYz1IeChlKSxoPUd4KGUpLHU9V3goZSksZD1YeChlKSxmPWUuaXNXZWJHTDI/IiI6SXgoZSksbT1VeChlKSxfPUR4KHIpLGc9aS5jcmVhdGVQcm9ncmFtKCkscCx2LHg9ZS5nbHNsVmVyc2lvbj8iI3ZlcnNpb24gIitlLmdsc2xWZXJzaW9uK2AKYDoiIjtlLmlzUmF3U2hhZGVyTWF0ZXJpYWw/KHA9WyIjZGVmaW5lIFNIQURFUl9UWVBFICIrZS5zaGFkZXJUeXBlLCIjZGVmaW5lIFNIQURFUl9OQU1FICIrZS5zaGFkZXJOYW1lLF9dLmZpbHRlcihocykuam9pbihgCmApLHAubGVuZ3RoPjAmJihwKz1gCmApLHY9W2YsIiNkZWZpbmUgU0hBREVSX1RZUEUgIitlLnNoYWRlclR5cGUsIiNkZWZpbmUgU0hBREVSX05BTUUgIitlLnNoYWRlck5hbWUsX10uZmlsdGVyKGhzKS5qb2luKGAKYCksdi5sZW5ndGg+MCYmKHYrPWAKYCkpOihwPVskdShlKSwiI2RlZmluZSBTSEFERVJfVFlQRSAiK2Uuc2hhZGVyVHlwZSwiI2RlZmluZSBTSEFERVJfTkFNRSAiK2Uuc2hhZGVyTmFtZSxfLGUuZXh0ZW5zaW9uQ2xpcEN1bGxEaXN0YW5jZT8iI2RlZmluZSBVU0VfQ0xJUF9ESVNUQU5DRSI6IiIsZS5iYXRjaGluZz8iI2RlZmluZSBVU0VfQkFUQ0hJTkciOiIiLGUuaW5zdGFuY2luZz8iI2RlZmluZSBVU0VfSU5TVEFOQ0lORyI6IiIsZS5pbnN0YW5jaW5nQ29sb3I/IiNkZWZpbmUgVVNFX0lOU1RBTkNJTkdfQ09MT1IiOiIiLGUudXNlRm9nJiZlLmZvZz8iI2RlZmluZSBVU0VfRk9HIjoiIixlLnVzZUZvZyYmZS5mb2dFeHAyPyIjZGVmaW5lIEZPR19FWFAyIjoiIixlLm1hcD8iI2RlZmluZSBVU0VfTUFQIjoiIixlLmVudk1hcD8iI2RlZmluZSBVU0VfRU5WTUFQIjoiIixlLmVudk1hcD8iI2RlZmluZSAiK2g6IiIsZS5saWdodE1hcD8iI2RlZmluZSBVU0VfTElHSFRNQVAiOiIiLGUuYW9NYXA/IiNkZWZpbmUgVVNFX0FPTUFQIjoiIixlLmJ1bXBNYXA/IiNkZWZpbmUgVVNFX0JVTVBNQVAiOiIiLGUubm9ybWFsTWFwPyIjZGVmaW5lIFVTRV9OT1JNQUxNQVAiOiIiLGUubm9ybWFsTWFwT2JqZWN0U3BhY2U/IiNkZWZpbmUgVVNFX05PUk1BTE1BUF9PQkpFQ1RTUEFDRSI6IiIsZS5ub3JtYWxNYXBUYW5nZW50U3BhY2U/IiNkZWZpbmUgVVNFX05PUk1BTE1BUF9UQU5HRU5UU1BBQ0UiOiIiLGUuZGlzcGxhY2VtZW50TWFwPyIjZGVmaW5lIFVTRV9ESVNQTEFDRU1FTlRNQVAiOiIiLGUuZW1pc3NpdmVNYXA/IiNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQIjoiIixlLmFuaXNvdHJvcHk/IiNkZWZpbmUgVVNFX0FOSVNPVFJPUFkiOiIiLGUuYW5pc290cm9weU1hcD8iI2RlZmluZSBVU0VfQU5JU09UUk9QWU1BUCI6IiIsZS5jbGVhcmNvYXRNYXA/IiNkZWZpbmUgVVNFX0NMRUFSQ09BVE1BUCI6IiIsZS5jbGVhcmNvYXRSb3VnaG5lc3NNYXA/IiNkZWZpbmUgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAiOiIiLGUuY2xlYXJjb2F0Tm9ybWFsTWFwPyIjZGVmaW5lIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQIjoiIixlLmlyaWRlc2NlbmNlTWFwPyIjZGVmaW5lIFVTRV9JUklERVNDRU5DRU1BUCI6IiIsZS5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcD8iI2RlZmluZSBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQIjoiIixlLnNwZWN1bGFyTWFwPyIjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUCI6IiIsZS5zcGVjdWxhckNvbG9yTWFwPyIjZGVmaW5lIFVTRV9TUEVDVUxBUl9DT0xPUk1BUCI6IiIsZS5zcGVjdWxhckludGVuc2l0eU1hcD8iI2RlZmluZSBVU0VfU1BFQ1VMQVJfSU5URU5TSVRZTUFQIjoiIixlLnJvdWdobmVzc01hcD8iI2RlZmluZSBVU0VfUk9VR0hORVNTTUFQIjoiIixlLm1ldGFsbmVzc01hcD8iI2RlZmluZSBVU0VfTUVUQUxORVNTTUFQIjoiIixlLmFscGhhTWFwPyIjZGVmaW5lIFVTRV9BTFBIQU1BUCI6IiIsZS5hbHBoYUhhc2g/IiNkZWZpbmUgVVNFX0FMUEhBSEFTSCI6IiIsZS50cmFuc21pc3Npb24/IiNkZWZpbmUgVVNFX1RSQU5TTUlTU0lPTiI6IiIsZS50cmFuc21pc3Npb25NYXA/IiNkZWZpbmUgVVNFX1RSQU5TTUlTU0lPTk1BUCI6IiIsZS50aGlja25lc3NNYXA/IiNkZWZpbmUgVVNFX1RISUNLTkVTU01BUCI6IiIsZS5zaGVlbkNvbG9yTWFwPyIjZGVmaW5lIFVTRV9TSEVFTl9DT0xPUk1BUCI6IiIsZS5zaGVlblJvdWdobmVzc01hcD8iI2RlZmluZSBVU0VfU0hFRU5fUk9VR0hORVNTTUFQIjoiIixlLm1hcFV2PyIjZGVmaW5lIE1BUF9VViAiK2UubWFwVXY6IiIsZS5hbHBoYU1hcFV2PyIjZGVmaW5lIEFMUEhBTUFQX1VWICIrZS5hbHBoYU1hcFV2OiIiLGUubGlnaHRNYXBVdj8iI2RlZmluZSBMSUdIVE1BUF9VViAiK2UubGlnaHRNYXBVdjoiIixlLmFvTWFwVXY/IiNkZWZpbmUgQU9NQVBfVVYgIitlLmFvTWFwVXY6IiIsZS5lbWlzc2l2ZU1hcFV2PyIjZGVmaW5lIEVNSVNTSVZFTUFQX1VWICIrZS5lbWlzc2l2ZU1hcFV2OiIiLGUuYnVtcE1hcFV2PyIjZGVmaW5lIEJVTVBNQVBfVVYgIitlLmJ1bXBNYXBVdjoiIixlLm5vcm1hbE1hcFV2PyIjZGVmaW5lIE5PUk1BTE1BUF9VViAiK2Uubm9ybWFsTWFwVXY6IiIsZS5kaXNwbGFjZW1lbnRNYXBVdj8iI2RlZmluZSBESVNQTEFDRU1FTlRNQVBfVVYgIitlLmRpc3BsYWNlbWVudE1hcFV2OiIiLGUubWV0YWxuZXNzTWFwVXY/IiNkZWZpbmUgTUVUQUxORVNTTUFQX1VWICIrZS5tZXRhbG5lc3NNYXBVdjoiIixlLnJvdWdobmVzc01hcFV2PyIjZGVmaW5lIFJPVUdITkVTU01BUF9VViAiK2Uucm91Z2huZXNzTWFwVXY6IiIsZS5hbmlzb3Ryb3B5TWFwVXY/IiNkZWZpbmUgQU5JU09UUk9QWU1BUF9VViAiK2UuYW5pc290cm9weU1hcFV2OiIiLGUuY2xlYXJjb2F0TWFwVXY/IiNkZWZpbmUgQ0xFQVJDT0FUTUFQX1VWICIrZS5jbGVhcmNvYXRNYXBVdjoiIixlLmNsZWFyY29hdE5vcm1hbE1hcFV2PyIjZGVmaW5lIENMRUFSQ09BVF9OT1JNQUxNQVBfVVYgIitlLmNsZWFyY29hdE5vcm1hbE1hcFV2OiIiLGUuY2xlYXJjb2F0Um91Z2huZXNzTWFwVXY/IiNkZWZpbmUgQ0xFQVJDT0FUX1JPVUdITkVTU01BUF9VViAiK2UuY2xlYXJjb2F0Um91Z2huZXNzTWFwVXY6IiIsZS5pcmlkZXNjZW5jZU1hcFV2PyIjZGVmaW5lIElSSURFU0NFTkNFTUFQX1VWICIrZS5pcmlkZXNjZW5jZU1hcFV2OiIiLGUuaXJpZGVzY2VuY2VUaGlja25lc3NNYXBVdj8iI2RlZmluZSBJUklERVNDRU5DRV9USElDS05FU1NNQVBfVVYgIitlLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVXY6IiIsZS5zaGVlbkNvbG9yTWFwVXY/IiNkZWZpbmUgU0hFRU5fQ09MT1JNQVBfVVYgIitlLnNoZWVuQ29sb3JNYXBVdjoiIixlLnNoZWVuUm91Z2huZXNzTWFwVXY/IiNkZWZpbmUgU0hFRU5fUk9VR0hORVNTTUFQX1VWICIrZS5zaGVlblJvdWdobmVzc01hcFV2OiIiLGUuc3BlY3VsYXJNYXBVdj8iI2RlZmluZSBTUEVDVUxBUk1BUF9VViAiK2Uuc3BlY3VsYXJNYXBVdjoiIixlLnNwZWN1bGFyQ29sb3JNYXBVdj8iI2RlZmluZSBTUEVDVUxBUl9DT0xPUk1BUF9VViAiK2Uuc3BlY3VsYXJDb2xvck1hcFV2OiIiLGUuc3BlY3VsYXJJbnRlbnNpdHlNYXBVdj8iI2RlZmluZSBTUEVDVUxBUl9JTlRFTlNJVFlNQVBfVVYgIitlLnNwZWN1bGFySW50ZW5zaXR5TWFwVXY6IiIsZS50cmFuc21pc3Npb25NYXBVdj8iI2RlZmluZSBUUkFOU01JU1NJT05NQVBfVVYgIitlLnRyYW5zbWlzc2lvbk1hcFV2OiIiLGUudGhpY2tuZXNzTWFwVXY/IiNkZWZpbmUgVEhJQ0tORVNTTUFQX1VWICIrZS50aGlja25lc3NNYXBVdjoiIixlLnZlcnRleFRhbmdlbnRzJiZlLmZsYXRTaGFkaW5nPT09ITE/IiNkZWZpbmUgVVNFX1RBTkdFTlQiOiIiLGUudmVydGV4Q29sb3JzPyIjZGVmaW5lIFVTRV9DT0xPUiI6IiIsZS52ZXJ0ZXhBbHBoYXM/IiNkZWZpbmUgVVNFX0NPTE9SX0FMUEhBIjoiIixlLnZlcnRleFV2MXM/IiNkZWZpbmUgVVNFX1VWMSI6IiIsZS52ZXJ0ZXhVdjJzPyIjZGVmaW5lIFVTRV9VVjIiOiIiLGUudmVydGV4VXYzcz8iI2RlZmluZSBVU0VfVVYzIjoiIixlLnBvaW50c1V2cz8iI2RlZmluZSBVU0VfUE9JTlRTX1VWIjoiIixlLmZsYXRTaGFkaW5nPyIjZGVmaW5lIEZMQVRfU0hBREVEIjoiIixlLnNraW5uaW5nPyIjZGVmaW5lIFVTRV9TS0lOTklORyI6IiIsZS5tb3JwaFRhcmdldHM/IiNkZWZpbmUgVVNFX01PUlBIVEFSR0VUUyI6IiIsZS5tb3JwaE5vcm1hbHMmJmUuZmxhdFNoYWRpbmc9PT0hMT8iI2RlZmluZSBVU0VfTU9SUEhOT1JNQUxTIjoiIixlLm1vcnBoQ29sb3JzJiZlLmlzV2ViR0wyPyIjZGVmaW5lIFVTRV9NT1JQSENPTE9SUyI6IiIsZS5tb3JwaFRhcmdldHNDb3VudD4wJiZlLmlzV2ViR0wyPyIjZGVmaW5lIE1PUlBIVEFSR0VUU19URVhUVVJFIjoiIixlLm1vcnBoVGFyZ2V0c0NvdW50PjAmJmUuaXNXZWJHTDI/IiNkZWZpbmUgTU9SUEhUQVJHRVRTX1RFWFRVUkVfU1RSSURFICIrZS5tb3JwaFRleHR1cmVTdHJpZGU6IiIsZS5tb3JwaFRhcmdldHNDb3VudD4wJiZlLmlzV2ViR0wyPyIjZGVmaW5lIE1PUlBIVEFSR0VUU19DT1VOVCAiK2UubW9ycGhUYXJnZXRzQ291bnQ6IiIsZS5kb3VibGVTaWRlZD8iI2RlZmluZSBET1VCTEVfU0lERUQiOiIiLGUuZmxpcFNpZGVkPyIjZGVmaW5lIEZMSVBfU0lERUQiOiIiLGUuc2hhZG93TWFwRW5hYmxlZD8iI2RlZmluZSBVU0VfU0hBRE9XTUFQIjoiIixlLnNoYWRvd01hcEVuYWJsZWQ/IiNkZWZpbmUgIitsOiIiLGUuc2l6ZUF0dGVudWF0aW9uPyIjZGVmaW5lIFVTRV9TSVpFQVRURU5VQVRJT04iOiIiLGUubnVtTGlnaHRQcm9iZXM+MD8iI2RlZmluZSBVU0VfTElHSFRfUFJPQkVTIjoiIixlLnVzZUxlZ2FjeUxpZ2h0cz8iI2RlZmluZSBMRUdBQ1lfTElHSFRTIjoiIixlLmxvZ2FyaXRobWljRGVwdGhCdWZmZXI/IiNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGIjoiIixlLmxvZ2FyaXRobWljRGVwdGhCdWZmZXImJmUucmVuZGVyZXJFeHRlbnNpb25GcmFnRGVwdGg/IiNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCI6IiIsInVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDsiLCJ1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4OyIsInVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OyIsInVuaWZvcm0gbWF0NCB2aWV3TWF0cml4OyIsInVuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7IiwidW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uOyIsInVuaWZvcm0gYm9vbCBpc09ydGhvZ3JhcGhpYzsiLCIjaWZkZWYgVVNFX0lOU1RBTkNJTkciLCIJYXR0cmlidXRlIG1hdDQgaW5zdGFuY2VNYXRyaXg7IiwiI2VuZGlmIiwiI2lmZGVmIFVTRV9JTlNUQU5DSU5HX0NPTE9SIiwiCWF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlQ29sb3I7IiwiI2VuZGlmIiwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb247IiwiYXR0cmlidXRlIHZlYzMgbm9ybWFsOyIsImF0dHJpYnV0ZSB2ZWMyIHV2OyIsIiNpZmRlZiBVU0VfVVYxIiwiCWF0dHJpYnV0ZSB2ZWMyIHV2MTsiLCIjZW5kaWYiLCIjaWZkZWYgVVNFX1VWMiIsIglhdHRyaWJ1dGUgdmVjMiB1djI7IiwiI2VuZGlmIiwiI2lmZGVmIFVTRV9VVjMiLCIJYXR0cmlidXRlIHZlYzIgdXYzOyIsIiNlbmRpZiIsIiNpZmRlZiBVU0VfVEFOR0VOVCIsIglhdHRyaWJ1dGUgdmVjNCB0YW5nZW50OyIsIiNlbmRpZiIsIiNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKSIsIglhdHRyaWJ1dGUgdmVjNCBjb2xvcjsiLCIjZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKSIsIglhdHRyaWJ1dGUgdmVjMyBjb2xvcjsiLCIjZW5kaWYiLCIjaWYgKCBkZWZpbmVkKCBVU0VfTU9SUEhUQVJHRVRTICkgJiYgISBkZWZpbmVkKCBNT1JQSFRBUkdFVFNfVEVYVFVSRSApICkiLCIJYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQwOyIsIglhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDE7IiwiCWF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MjsiLCIJYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQzOyIsIgkjaWZkZWYgVVNFX01PUlBITk9STUFMUyIsIgkJYXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwwOyIsIgkJYXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwxOyIsIgkJYXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwyOyIsIgkJYXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwzOyIsIgkjZWxzZSIsIgkJYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ0OyIsIgkJYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ1OyIsIgkJYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ2OyIsIgkJYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ3OyIsIgkjZW5kaWYiLCIjZW5kaWYiLCIjaWZkZWYgVVNFX1NLSU5OSU5HIiwiCWF0dHJpYnV0ZSB2ZWM0IHNraW5JbmRleDsiLCIJYXR0cmlidXRlIHZlYzQgc2tpbldlaWdodDsiLCIjZW5kaWYiLGAKYF0uZmlsdGVyKGhzKS5qb2luKGAKYCksdj1bZiwkdShlKSwiI2RlZmluZSBTSEFERVJfVFlQRSAiK2Uuc2hhZGVyVHlwZSwiI2RlZmluZSBTSEFERVJfTkFNRSAiK2Uuc2hhZGVyTmFtZSxfLGUudXNlRm9nJiZlLmZvZz8iI2RlZmluZSBVU0VfRk9HIjoiIixlLnVzZUZvZyYmZS5mb2dFeHAyPyIjZGVmaW5lIEZPR19FWFAyIjoiIixlLmFscGhhVG9Db3ZlcmFnZT8iI2RlZmluZSBBTFBIQV9UT19DT1ZFUkFHRSI6IiIsZS5tYXA/IiNkZWZpbmUgVVNFX01BUCI6IiIsZS5tYXRjYXA/IiNkZWZpbmUgVVNFX01BVENBUCI6IiIsZS5lbnZNYXA/IiNkZWZpbmUgVVNFX0VOVk1BUCI6IiIsZS5lbnZNYXA/IiNkZWZpbmUgIitjOiIiLGUuZW52TWFwPyIjZGVmaW5lICIraDoiIixlLmVudk1hcD8iI2RlZmluZSAiK3U6IiIsZD8iI2RlZmluZSBDVUJFVVZfVEVYRUxfV0lEVEggIitkLnRleGVsV2lkdGg6IiIsZD8iI2RlZmluZSBDVUJFVVZfVEVYRUxfSEVJR0hUICIrZC50ZXhlbEhlaWdodDoiIixkPyIjZGVmaW5lIENVQkVVVl9NQVhfTUlQICIrZC5tYXhNaXArIi4wIjoiIixlLmxpZ2h0TWFwPyIjZGVmaW5lIFVTRV9MSUdIVE1BUCI6IiIsZS5hb01hcD8iI2RlZmluZSBVU0VfQU9NQVAiOiIiLGUuYnVtcE1hcD8iI2RlZmluZSBVU0VfQlVNUE1BUCI6IiIsZS5ub3JtYWxNYXA/IiNkZWZpbmUgVVNFX05PUk1BTE1BUCI6IiIsZS5ub3JtYWxNYXBPYmplY3RTcGFjZT8iI2RlZmluZSBVU0VfTk9STUFMTUFQX09CSkVDVFNQQUNFIjoiIixlLm5vcm1hbE1hcFRhbmdlbnRTcGFjZT8iI2RlZmluZSBVU0VfTk9STUFMTUFQX1RBTkdFTlRTUEFDRSI6IiIsZS5lbWlzc2l2ZU1hcD8iI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAiOiIiLGUuYW5pc290cm9weT8iI2RlZmluZSBVU0VfQU5JU09UUk9QWSI6IiIsZS5hbmlzb3Ryb3B5TWFwPyIjZGVmaW5lIFVTRV9BTklTT1RST1BZTUFQIjoiIixlLmNsZWFyY29hdD8iI2RlZmluZSBVU0VfQ0xFQVJDT0FUIjoiIixlLmNsZWFyY29hdE1hcD8iI2RlZmluZSBVU0VfQ0xFQVJDT0FUTUFQIjoiIixlLmNsZWFyY29hdFJvdWdobmVzc01hcD8iI2RlZmluZSBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUCI6IiIsZS5jbGVhcmNvYXROb3JtYWxNYXA/IiNkZWZpbmUgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAiOiIiLGUuaXJpZGVzY2VuY2U/IiNkZWZpbmUgVVNFX0lSSURFU0NFTkNFIjoiIixlLmlyaWRlc2NlbmNlTWFwPyIjZGVmaW5lIFVTRV9JUklERVNDRU5DRU1BUCI6IiIsZS5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcD8iI2RlZmluZSBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQIjoiIixlLnNwZWN1bGFyTWFwPyIjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUCI6IiIsZS5zcGVjdWxhckNvbG9yTWFwPyIjZGVmaW5lIFVTRV9TUEVDVUxBUl9DT0xPUk1BUCI6IiIsZS5zcGVjdWxhckludGVuc2l0eU1hcD8iI2RlZmluZSBVU0VfU1BFQ1VMQVJfSU5URU5TSVRZTUFQIjoiIixlLnJvdWdobmVzc01hcD8iI2RlZmluZSBVU0VfUk9VR0hORVNTTUFQIjoiIixlLm1ldGFsbmVzc01hcD8iI2RlZmluZSBVU0VfTUVUQUxORVNTTUFQIjoiIixlLmFscGhhTWFwPyIjZGVmaW5lIFVTRV9BTFBIQU1BUCI6IiIsZS5hbHBoYVRlc3Q/IiNkZWZpbmUgVVNFX0FMUEhBVEVTVCI6IiIsZS5hbHBoYUhhc2g/IiNkZWZpbmUgVVNFX0FMUEhBSEFTSCI6IiIsZS5zaGVlbj8iI2RlZmluZSBVU0VfU0hFRU4iOiIiLGUuc2hlZW5Db2xvck1hcD8iI2RlZmluZSBVU0VfU0hFRU5fQ09MT1JNQVAiOiIiLGUuc2hlZW5Sb3VnaG5lc3NNYXA/IiNkZWZpbmUgVVNFX1NIRUVOX1JPVUdITkVTU01BUCI6IiIsZS50cmFuc21pc3Npb24/IiNkZWZpbmUgVVNFX1RSQU5TTUlTU0lPTiI6IiIsZS50cmFuc21pc3Npb25NYXA/IiNkZWZpbmUgVVNFX1RSQU5TTUlTU0lPTk1BUCI6IiIsZS50aGlja25lc3NNYXA/IiNkZWZpbmUgVVNFX1RISUNLTkVTU01BUCI6IiIsZS52ZXJ0ZXhUYW5nZW50cyYmZS5mbGF0U2hhZGluZz09PSExPyIjZGVmaW5lIFVTRV9UQU5HRU5UIjoiIixlLnZlcnRleENvbG9yc3x8ZS5pbnN0YW5jaW5nQ29sb3I/IiNkZWZpbmUgVVNFX0NPTE9SIjoiIixlLnZlcnRleEFscGhhcz8iI2RlZmluZSBVU0VfQ09MT1JfQUxQSEEiOiIiLGUudmVydGV4VXYxcz8iI2RlZmluZSBVU0VfVVYxIjoiIixlLnZlcnRleFV2MnM/IiNkZWZpbmUgVVNFX1VWMiI6IiIsZS52ZXJ0ZXhVdjNzPyIjZGVmaW5lIFVTRV9VVjMiOiIiLGUucG9pbnRzVXZzPyIjZGVmaW5lIFVTRV9QT0lOVFNfVVYiOiIiLGUuZ3JhZGllbnRNYXA/IiNkZWZpbmUgVVNFX0dSQURJRU5UTUFQIjoiIixlLmZsYXRTaGFkaW5nPyIjZGVmaW5lIEZMQVRfU0hBREVEIjoiIixlLmRvdWJsZVNpZGVkPyIjZGVmaW5lIERPVUJMRV9TSURFRCI6IiIsZS5mbGlwU2lkZWQ/IiNkZWZpbmUgRkxJUF9TSURFRCI6IiIsZS5zaGFkb3dNYXBFbmFibGVkPyIjZGVmaW5lIFVTRV9TSEFET1dNQVAiOiIiLGUuc2hhZG93TWFwRW5hYmxlZD8iI2RlZmluZSAiK2w6IiIsZS5wcmVtdWx0aXBsaWVkQWxwaGE/IiNkZWZpbmUgUFJFTVVMVElQTElFRF9BTFBIQSI6IiIsZS5udW1MaWdodFByb2Jlcz4wPyIjZGVmaW5lIFVTRV9MSUdIVF9QUk9CRVMiOiIiLGUudXNlTGVnYWN5TGlnaHRzPyIjZGVmaW5lIExFR0FDWV9MSUdIVFMiOiIiLGUuZGVjb2RlVmlkZW9UZXh0dXJlPyIjZGVmaW5lIERFQ09ERV9WSURFT19URVhUVVJFIjoiIixlLmxvZ2FyaXRobWljRGVwdGhCdWZmZXI/IiNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGIjoiIixlLmxvZ2FyaXRobWljRGVwdGhCdWZmZXImJmUucmVuZGVyZXJFeHRlbnNpb25GcmFnRGVwdGg/IiNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCI6IiIsInVuaWZvcm0gbWF0NCB2aWV3TWF0cml4OyIsInVuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsiLCJ1bmlmb3JtIGJvb2wgaXNPcnRob2dyYXBoaWM7IixlLnRvbmVNYXBwaW5nIT09RG4/IiNkZWZpbmUgVE9ORV9NQVBQSU5HIjoiIixlLnRvbmVNYXBwaW5nIT09RG4/enQudG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudDoiIixlLnRvbmVNYXBwaW5nIT09RG4/THgoInRvbmVNYXBwaW5nIixlLnRvbmVNYXBwaW5nKToiIixlLmRpdGhlcmluZz8iI2RlZmluZSBESVRIRVJJTkciOiIiLGUub3BhcXVlPyIjZGVmaW5lIE9QQVFVRSI6IiIsenQuY29sb3JzcGFjZV9wYXJzX2ZyYWdtZW50LFB4KCJsaW5lYXJUb091dHB1dFRleGVsIixlLm91dHB1dENvbG9yU3BhY2UpLGUudXNlRGVwdGhQYWNraW5nPyIjZGVmaW5lIERFUFRIX1BBQ0tJTkcgIitlLmRlcHRoUGFja2luZzoiIixgCmBdLmZpbHRlcihocykuam9pbihgCmApKSxhPWtjKGEpLGE9WXUoYSxlKSxhPVp1KGEsZSksbz1rYyhvKSxvPVl1KG8sZSksbz1adShvLGUpLGE9SnUoYSksbz1KdShvKSxlLmlzV2ViR0wyJiZlLmlzUmF3U2hhZGVyTWF0ZXJpYWwhPT0hMCYmKHg9YCN2ZXJzaW9uIDMwMCBlcwpgLHA9W20sInByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyREFycmF5OyIsIiNkZWZpbmUgYXR0cmlidXRlIGluIiwiI2RlZmluZSB2YXJ5aW5nIG91dCIsIiNkZWZpbmUgdGV4dHVyZTJEIHRleHR1cmUiXS5qb2luKGAKYCkrYApgK3Asdj1bInByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyREFycmF5OyIsIiNkZWZpbmUgdmFyeWluZyBpbiIsZS5nbHNsVmVyc2lvbj09PVRjPyIiOiJsYXlvdXQobG9jYXRpb24gPSAwKSBvdXQgaGlnaHAgdmVjNCBwY19mcmFnQ29sb3I7IixlLmdsc2xWZXJzaW9uPT09VGM/IiI6IiNkZWZpbmUgZ2xfRnJhZ0NvbG9yIHBjX2ZyYWdDb2xvciIsIiNkZWZpbmUgZ2xfRnJhZ0RlcHRoRVhUIGdsX0ZyYWdEZXB0aCIsIiNkZWZpbmUgdGV4dHVyZTJEIHRleHR1cmUiLCIjZGVmaW5lIHRleHR1cmVDdWJlIHRleHR1cmUiLCIjZGVmaW5lIHRleHR1cmUyRFByb2ogdGV4dHVyZVByb2oiLCIjZGVmaW5lIHRleHR1cmUyRExvZEVYVCB0ZXh0dXJlTG9kIiwiI2RlZmluZSB0ZXh0dXJlMkRQcm9qTG9kRVhUIHRleHR1cmVQcm9qTG9kIiwiI2RlZmluZSB0ZXh0dXJlQ3ViZUxvZEVYVCB0ZXh0dXJlTG9kIiwiI2RlZmluZSB0ZXh0dXJlMkRHcmFkRVhUIHRleHR1cmVHcmFkIiwiI2RlZmluZSB0ZXh0dXJlMkRQcm9qR3JhZEVYVCB0ZXh0dXJlUHJvakdyYWQiLCIjZGVmaW5lIHRleHR1cmVDdWJlR3JhZEVYVCB0ZXh0dXJlR3JhZCJdLmpvaW4oYApgKStgCmArdik7bGV0IE09eCtwK2EsQz14K3YrbyxBPVh1KGksaS5WRVJURVhfU0hBREVSLE0pLFQ9WHUoaSxpLkZSQUdNRU5UX1NIQURFUixDKTtpLmF0dGFjaFNoYWRlcihnLEEpLGkuYXR0YWNoU2hhZGVyKGcsVCksZS5pbmRleDBBdHRyaWJ1dGVOYW1lIT09dm9pZCAwP2kuYmluZEF0dHJpYkxvY2F0aW9uKGcsMCxlLmluZGV4MEF0dHJpYnV0ZU5hbWUpOmUubW9ycGhUYXJnZXRzPT09ITAmJmkuYmluZEF0dHJpYkxvY2F0aW9uKGcsMCwicG9zaXRpb24iKSxpLmxpbmtQcm9ncmFtKGcpO2Z1bmN0aW9uIFUoRyl7aWYocy5kZWJ1Zy5jaGVja1NoYWRlckVycm9ycyl7bGV0IEo9aS5nZXRQcm9ncmFtSW5mb0xvZyhnKS50cmltKCksST1pLmdldFNoYWRlckluZm9Mb2coQSkudHJpbSgpLHo9aS5nZXRTaGFkZXJJbmZvTG9nKFQpLnRyaW0oKSxGPSEwLCQ9ITA7aWYoaS5nZXRQcm9ncmFtUGFyYW1ldGVyKGcsaS5MSU5LX1NUQVRVUyk9PT0hMSlpZihGPSExLHR5cGVvZiBzLmRlYnVnLm9uU2hhZGVyRXJyb3I9PSJmdW5jdGlvbiIpcy5kZWJ1Zy5vblNoYWRlckVycm9yKGksZyxBLFQpO2Vsc2V7bGV0IHE9cXUoaSxBLCJ2ZXJ0ZXgiKSxXPXF1KGksVCwiZnJhZ21lbnQiKTtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFByb2dyYW06IFNoYWRlciBFcnJvciAiK2kuZ2V0RXJyb3IoKSsiIC0gVkFMSURBVEVfU1RBVFVTICIraS5nZXRQcm9ncmFtUGFyYW1ldGVyKGcsaS5WQUxJREFURV9TVEFUVVMpK2AKCk1hdGVyaWFsIE5hbWU6IGArRy5uYW1lK2AKTWF0ZXJpYWwgVHlwZTogYCtHLnR5cGUrYAoKUHJvZ3JhbSBJbmZvIExvZzogYCtKK2AKYCtxK2AKYCtXKX1lbHNlIEohPT0iIj9jb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUHJvZ3JhbTogUHJvZ3JhbSBJbmZvIExvZzoiLEopOihJPT09IiJ8fHo9PT0iIikmJigkPSExKTskJiYoRy5kaWFnbm9zdGljcz17cnVubmFibGU6Rixwcm9ncmFtTG9nOkosdmVydGV4U2hhZGVyOntsb2c6SSxwcmVmaXg6cH0sZnJhZ21lbnRTaGFkZXI6e2xvZzp6LHByZWZpeDp2fX0pfWkuZGVsZXRlU2hhZGVyKEEpLGkuZGVsZXRlU2hhZGVyKFQpLGs9bmV3IGZzKGksZykseT1OeChpLGcpfWxldCBrO3RoaXMuZ2V0VW5pZm9ybXM9ZnVuY3Rpb24oKXtyZXR1cm4gaz09PXZvaWQgMCYmVSh0aGlzKSxrfTtsZXQgeTt0aGlzLmdldEF0dHJpYnV0ZXM9ZnVuY3Rpb24oKXtyZXR1cm4geT09PXZvaWQgMCYmVSh0aGlzKSx5fTtsZXQgdz1lLnJlbmRlcmVyRXh0ZW5zaW9uUGFyYWxsZWxTaGFkZXJDb21waWxlPT09ITE7cmV0dXJuIHRoaXMuaXNSZWFkeT1mdW5jdGlvbigpe3JldHVybiB3PT09ITEmJih3PWkuZ2V0UHJvZ3JhbVBhcmFtZXRlcihnLFR4KSksd30sdGhpcy5kZXN0cm95PWZ1bmN0aW9uKCl7bi5yZWxlYXNlU3RhdGVzT2ZQcm9ncmFtKHRoaXMpLGkuZGVsZXRlUHJvZ3JhbShnKSx0aGlzLnByb2dyYW09dm9pZCAwfSx0aGlzLnR5cGU9ZS5zaGFkZXJUeXBlLHRoaXMubmFtZT1lLnNoYWRlck5hbWUsdGhpcy5pZD13eCsrLHRoaXMuY2FjaGVLZXk9dCx0aGlzLnVzZWRUaW1lcz0xLHRoaXMucHJvZ3JhbT1nLHRoaXMudmVydGV4U2hhZGVyPUEsdGhpcy5mcmFnbWVudFNoYWRlcj1ULHRoaXN9dmFyIFl4PTAsSGM9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLnNoYWRlckNhY2hlPW5ldyBNYXAsdGhpcy5tYXRlcmlhbENhY2hlPW5ldyBNYXB9dXBkYXRlKHQpe2xldCBlPXQudmVydGV4U2hhZGVyLG49dC5mcmFnbWVudFNoYWRlcixpPXRoaXMuX2dldFNoYWRlclN0YWdlKGUpLHI9dGhpcy5fZ2V0U2hhZGVyU3RhZ2UobiksYT10aGlzLl9nZXRTaGFkZXJDYWNoZUZvck1hdGVyaWFsKHQpO3JldHVybiBhLmhhcyhpKT09PSExJiYoYS5hZGQoaSksaS51c2VkVGltZXMrKyksYS5oYXMocik9PT0hMSYmKGEuYWRkKHIpLHIudXNlZFRpbWVzKyspLHRoaXN9cmVtb3ZlKHQpe2xldCBlPXRoaXMubWF0ZXJpYWxDYWNoZS5nZXQodCk7Zm9yKGxldCBuIG9mIGUpbi51c2VkVGltZXMtLSxuLnVzZWRUaW1lcz09PTAmJnRoaXMuc2hhZGVyQ2FjaGUuZGVsZXRlKG4uY29kZSk7cmV0dXJuIHRoaXMubWF0ZXJpYWxDYWNoZS5kZWxldGUodCksdGhpc31nZXRWZXJ0ZXhTaGFkZXJJRCh0KXtyZXR1cm4gdGhpcy5fZ2V0U2hhZGVyU3RhZ2UodC52ZXJ0ZXhTaGFkZXIpLmlkfWdldEZyYWdtZW50U2hhZGVySUQodCl7cmV0dXJuIHRoaXMuX2dldFNoYWRlclN0YWdlKHQuZnJhZ21lbnRTaGFkZXIpLmlkfWRpc3Bvc2UoKXt0aGlzLnNoYWRlckNhY2hlLmNsZWFyKCksdGhpcy5tYXRlcmlhbENhY2hlLmNsZWFyKCl9X2dldFNoYWRlckNhY2hlRm9yTWF0ZXJpYWwodCl7bGV0IGU9dGhpcy5tYXRlcmlhbENhY2hlLG49ZS5nZXQodCk7cmV0dXJuIG49PT12b2lkIDAmJihuPW5ldyBTZXQsZS5zZXQodCxuKSksbn1fZ2V0U2hhZGVyU3RhZ2UodCl7bGV0IGU9dGhpcy5zaGFkZXJDYWNoZSxuPWUuZ2V0KHQpO3JldHVybiBuPT09dm9pZCAwJiYobj1uZXcgR2ModCksZS5zZXQodCxuKSksbn19LEdjPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuaWQ9WXgrKyx0aGlzLmNvZGU9dCx0aGlzLnVzZWRUaW1lcz0wfX07ZnVuY3Rpb24gWngocyx0LGUsbixpLHIsYSl7bGV0IG89bmV3IF9zLGw9bmV3IEhjLGM9bmV3IFNldCxoPVtdLHU9aS5pc1dlYkdMMixkPWkubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcixmPWkudmVydGV4VGV4dHVyZXMsbT1pLnByZWNpc2lvbixfPXtNZXNoRGVwdGhNYXRlcmlhbDoiZGVwdGgiLE1lc2hEaXN0YW5jZU1hdGVyaWFsOiJkaXN0YW5jZVJHQkEiLE1lc2hOb3JtYWxNYXRlcmlhbDoibm9ybWFsIixNZXNoQmFzaWNNYXRlcmlhbDoiYmFzaWMiLE1lc2hMYW1iZXJ0TWF0ZXJpYWw6ImxhbWJlcnQiLE1lc2hQaG9uZ01hdGVyaWFsOiJwaG9uZyIsTWVzaFRvb25NYXRlcmlhbDoidG9vbiIsTWVzaFN0YW5kYXJkTWF0ZXJpYWw6InBoeXNpY2FsIixNZXNoUGh5c2ljYWxNYXRlcmlhbDoicGh5c2ljYWwiLE1lc2hNYXRjYXBNYXRlcmlhbDoibWF0Y2FwIixMaW5lQmFzaWNNYXRlcmlhbDoiYmFzaWMiLExpbmVEYXNoZWRNYXRlcmlhbDoiZGFzaGVkIixQb2ludHNNYXRlcmlhbDoicG9pbnRzIixTaGFkb3dNYXRlcmlhbDoic2hhZG93IixTcHJpdGVNYXRlcmlhbDoic3ByaXRlIn07ZnVuY3Rpb24gZyh5KXtyZXR1cm4gYy5hZGQoeSkseT09PTA/InV2IjpgdXYke3l9YH1mdW5jdGlvbiBwKHksdyxHLEosSSl7bGV0IHo9Si5mb2csRj1JLmdlb21ldHJ5LCQ9eS5pc01lc2hTdGFuZGFyZE1hdGVyaWFsP0ouZW52aXJvbm1lbnQ6bnVsbCxxPSh5LmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWw/ZTp0KS5nZXQoeS5lbnZNYXB8fCQpLFc9cSYmcS5tYXBwaW5nPT09VHM/cS5pbWFnZS5oZWlnaHQ6bnVsbCxldD1fW3kudHlwZV07eS5wcmVjaXNpb24hPT1udWxsJiYobT1pLmdldE1heFByZWNpc2lvbih5LnByZWNpc2lvbiksbSE9PXkucHJlY2lzaW9uJiZjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUHJvZ3JhbS5nZXRQYXJhbWV0ZXJzOiIseS5wcmVjaXNpb24sIm5vdCBzdXBwb3J0ZWQsIHVzaW5nIixtLCJpbnN0ZWFkLiIpKTtsZXQgUT1GLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbnx8Ri5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsfHxGLm1vcnBoQXR0cmlidXRlcy5jb2xvcixmdD1RIT09dm9pZCAwP1EubGVuZ3RoOjAsUHQ9MDtGLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiE9PXZvaWQgMCYmKFB0PTEpLEYubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCE9PXZvaWQgMCYmKFB0PTIpLEYubW9ycGhBdHRyaWJ1dGVzLmNvbG9yIT09dm9pZCAwJiYoUHQ9Myk7bGV0IEgsaXQscHQsdnQ7aWYoZXQpe2xldCBuZT1vbltldF07SD1uZS52ZXJ0ZXhTaGFkZXIsaXQ9bmUuZnJhZ21lbnRTaGFkZXJ9ZWxzZSBIPXkudmVydGV4U2hhZGVyLGl0PXkuZnJhZ21lbnRTaGFkZXIsbC51cGRhdGUoeSkscHQ9bC5nZXRWZXJ0ZXhTaGFkZXJJRCh5KSx2dD1sLmdldEZyYWdtZW50U2hhZGVySUQoeSk7bGV0IEV0PXMuZ2V0UmVuZGVyVGFyZ2V0KCkseXQ9SS5pc0luc3RhbmNlZE1lc2g9PT0hMCxPdD1JLmlzQmF0Y2hlZE1lc2g9PT0hMCxBdD0hIXkubWFwLEw9ISF5Lm1hdGNhcCxvdD0hIXEsWD0hIXkuYW9NYXAsc3Q9ISF5LmxpZ2h0TWFwLFk9ISF5LmJ1bXBNYXAsYnQ9ISF5Lm5vcm1hbE1hcCxodD0hIXkuZGlzcGxhY2VtZW50TWFwLGI9ISF5LmVtaXNzaXZlTWFwLFM9ISF5Lm1ldGFsbmVzc01hcCxOPSEheS5yb3VnaG5lc3NNYXAsbnQ9eS5hbmlzb3Ryb3B5PjAsaj15LmNsZWFyY29hdD4wLEs9eS5pcmlkZXNjZW5jZT4wLHh0PXkuc2hlZW4+MCxjdD15LnRyYW5zbWlzc2lvbj4wLG10PW50JiYhIXkuYW5pc290cm9weU1hcCxSdD1qJiYhIXkuY2xlYXJjb2F0TWFwLEZ0PWomJiEheS5jbGVhcmNvYXROb3JtYWxNYXAsdHQ9aiYmISF5LmNsZWFyY29hdFJvdWdobmVzc01hcCxZdD1LJiYhIXkuaXJpZGVzY2VuY2VNYXAsWHQ9SyYmISF5LmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLFV0PXh0JiYhIXkuc2hlZW5Db2xvck1hcCxUdD14dCYmISF5LnNoZWVuUm91Z2huZXNzTWFwLF90PSEheS5zcGVjdWxhck1hcCxWdD0hIXkuc3BlY3VsYXJDb2xvck1hcCwkdD0hIXkuc3BlY3VsYXJJbnRlbnNpdHlNYXAscmU9Y3QmJiEheS50cmFuc21pc3Npb25NYXAscXQ9Y3QmJiEheS50aGlja25lc3NNYXAsZWU9ISF5LmdyYWRpZW50TWFwLFA9ISF5LmFscGhhTWFwLHJ0PXkuYWxwaGFUZXN0PjAsYXQ9ISF5LmFscGhhSGFzaCxNdD0hIXkuZXh0ZW5zaW9ucyx3dD1Ebjt5LnRvbmVNYXBwZWQmJihFdD09PW51bGx8fEV0LmlzWFJSZW5kZXJUYXJnZXQ9PT0hMCkmJih3dD1zLnRvbmVNYXBwaW5nKTtsZXQgS3Q9e2lzV2ViR0wyOnUsc2hhZGVySUQ6ZXQsc2hhZGVyVHlwZTp5LnR5cGUsc2hhZGVyTmFtZTp5Lm5hbWUsdmVydGV4U2hhZGVyOkgsZnJhZ21lbnRTaGFkZXI6aXQsZGVmaW5lczp5LmRlZmluZXMsY3VzdG9tVmVydGV4U2hhZGVySUQ6cHQsY3VzdG9tRnJhZ21lbnRTaGFkZXJJRDp2dCxpc1Jhd1NoYWRlck1hdGVyaWFsOnkuaXNSYXdTaGFkZXJNYXRlcmlhbD09PSEwLGdsc2xWZXJzaW9uOnkuZ2xzbFZlcnNpb24scHJlY2lzaW9uOm0sYmF0Y2hpbmc6T3QsaW5zdGFuY2luZzp5dCxpbnN0YW5jaW5nQ29sb3I6eXQmJkkuaW5zdGFuY2VDb2xvciE9PW51bGwsc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlczpmLG91dHB1dENvbG9yU3BhY2U6RXQ9PT1udWxsP3Mub3V0cHV0Q29sb3JTcGFjZTpFdC5pc1hSUmVuZGVyVGFyZ2V0PT09ITA/RXQudGV4dHVyZS5jb2xvclNwYWNlOl9uLGFscGhhVG9Db3ZlcmFnZTohIXkuYWxwaGFUb0NvdmVyYWdlLG1hcDpBdCxtYXRjYXA6TCxlbnZNYXA6b3QsZW52TWFwTW9kZTpvdCYmcS5tYXBwaW5nLGVudk1hcEN1YmVVVkhlaWdodDpXLGFvTWFwOlgsbGlnaHRNYXA6c3QsYnVtcE1hcDpZLG5vcm1hbE1hcDpidCxkaXNwbGFjZW1lbnRNYXA6ZiYmaHQsZW1pc3NpdmVNYXA6Yixub3JtYWxNYXBPYmplY3RTcGFjZTpidCYmeS5ub3JtYWxNYXBUeXBlPT09VmYsbm9ybWFsTWFwVGFuZ2VudFNwYWNlOmJ0JiZ5Lm5vcm1hbE1hcFR5cGU9PT1haSxtZXRhbG5lc3NNYXA6Uyxyb3VnaG5lc3NNYXA6Tixhbmlzb3Ryb3B5Om50LGFuaXNvdHJvcHlNYXA6bXQsY2xlYXJjb2F0OmosY2xlYXJjb2F0TWFwOlJ0LGNsZWFyY29hdE5vcm1hbE1hcDpGdCxjbGVhcmNvYXRSb3VnaG5lc3NNYXA6dHQsaXJpZGVzY2VuY2U6SyxpcmlkZXNjZW5jZU1hcDpZdCxpcmlkZXNjZW5jZVRoaWNrbmVzc01hcDpYdCxzaGVlbjp4dCxzaGVlbkNvbG9yTWFwOlV0LHNoZWVuUm91Z2huZXNzTWFwOlR0LHNwZWN1bGFyTWFwOl90LHNwZWN1bGFyQ29sb3JNYXA6VnQsc3BlY3VsYXJJbnRlbnNpdHlNYXA6JHQsdHJhbnNtaXNzaW9uOmN0LHRyYW5zbWlzc2lvbk1hcDpyZSx0aGlja25lc3NNYXA6cXQsZ3JhZGllbnRNYXA6ZWUsb3BhcXVlOnkudHJhbnNwYXJlbnQ9PT0hMSYmeS5ibGVuZGluZz09PVRpJiZ5LmFscGhhVG9Db3ZlcmFnZT09PSExLGFscGhhTWFwOlAsYWxwaGFUZXN0OnJ0LGFscGhhSGFzaDphdCxjb21iaW5lOnkuY29tYmluZSxtYXBVdjpBdCYmZyh5Lm1hcC5jaGFubmVsKSxhb01hcFV2OlgmJmcoeS5hb01hcC5jaGFubmVsKSxsaWdodE1hcFV2OnN0JiZnKHkubGlnaHRNYXAuY2hhbm5lbCksYnVtcE1hcFV2OlkmJmcoeS5idW1wTWFwLmNoYW5uZWwpLG5vcm1hbE1hcFV2OmJ0JiZnKHkubm9ybWFsTWFwLmNoYW5uZWwpLGRpc3BsYWNlbWVudE1hcFV2Omh0JiZnKHkuZGlzcGxhY2VtZW50TWFwLmNoYW5uZWwpLGVtaXNzaXZlTWFwVXY6YiYmZyh5LmVtaXNzaXZlTWFwLmNoYW5uZWwpLG1ldGFsbmVzc01hcFV2OlMmJmcoeS5tZXRhbG5lc3NNYXAuY2hhbm5lbCkscm91Z2huZXNzTWFwVXY6TiYmZyh5LnJvdWdobmVzc01hcC5jaGFubmVsKSxhbmlzb3Ryb3B5TWFwVXY6bXQmJmcoeS5hbmlzb3Ryb3B5TWFwLmNoYW5uZWwpLGNsZWFyY29hdE1hcFV2OlJ0JiZnKHkuY2xlYXJjb2F0TWFwLmNoYW5uZWwpLGNsZWFyY29hdE5vcm1hbE1hcFV2OkZ0JiZnKHkuY2xlYXJjb2F0Tm9ybWFsTWFwLmNoYW5uZWwpLGNsZWFyY29hdFJvdWdobmVzc01hcFV2OnR0JiZnKHkuY2xlYXJjb2F0Um91Z2huZXNzTWFwLmNoYW5uZWwpLGlyaWRlc2NlbmNlTWFwVXY6WXQmJmcoeS5pcmlkZXNjZW5jZU1hcC5jaGFubmVsKSxpcmlkZXNjZW5jZVRoaWNrbmVzc01hcFV2Olh0JiZnKHkuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAuY2hhbm5lbCksc2hlZW5Db2xvck1hcFV2OlV0JiZnKHkuc2hlZW5Db2xvck1hcC5jaGFubmVsKSxzaGVlblJvdWdobmVzc01hcFV2OlR0JiZnKHkuc2hlZW5Sb3VnaG5lc3NNYXAuY2hhbm5lbCksc3BlY3VsYXJNYXBVdjpfdCYmZyh5LnNwZWN1bGFyTWFwLmNoYW5uZWwpLHNwZWN1bGFyQ29sb3JNYXBVdjpWdCYmZyh5LnNwZWN1bGFyQ29sb3JNYXAuY2hhbm5lbCksc3BlY3VsYXJJbnRlbnNpdHlNYXBVdjokdCYmZyh5LnNwZWN1bGFySW50ZW5zaXR5TWFwLmNoYW5uZWwpLHRyYW5zbWlzc2lvbk1hcFV2OnJlJiZnKHkudHJhbnNtaXNzaW9uTWFwLmNoYW5uZWwpLHRoaWNrbmVzc01hcFV2OnF0JiZnKHkudGhpY2tuZXNzTWFwLmNoYW5uZWwpLGFscGhhTWFwVXY6UCYmZyh5LmFscGhhTWFwLmNoYW5uZWwpLHZlcnRleFRhbmdlbnRzOiEhRi5hdHRyaWJ1dGVzLnRhbmdlbnQmJihidHx8bnQpLHZlcnRleENvbG9yczp5LnZlcnRleENvbG9ycyx2ZXJ0ZXhBbHBoYXM6eS52ZXJ0ZXhDb2xvcnM9PT0hMCYmISFGLmF0dHJpYnV0ZXMuY29sb3ImJkYuYXR0cmlidXRlcy5jb2xvci5pdGVtU2l6ZT09PTQscG9pbnRzVXZzOkkuaXNQb2ludHM9PT0hMCYmISFGLmF0dHJpYnV0ZXMudXYmJihBdHx8UCksZm9nOiEheix1c2VGb2c6eS5mb2c9PT0hMCxmb2dFeHAyOiEheiYmei5pc0ZvZ0V4cDIsZmxhdFNoYWRpbmc6eS5mbGF0U2hhZGluZz09PSEwLHNpemVBdHRlbnVhdGlvbjp5LnNpemVBdHRlbnVhdGlvbj09PSEwLGxvZ2FyaXRobWljRGVwdGhCdWZmZXI6ZCxza2lubmluZzpJLmlzU2tpbm5lZE1lc2g9PT0hMCxtb3JwaFRhcmdldHM6Ri5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24hPT12b2lkIDAsbW9ycGhOb3JtYWxzOkYubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCE9PXZvaWQgMCxtb3JwaENvbG9yczpGLm1vcnBoQXR0cmlidXRlcy5jb2xvciE9PXZvaWQgMCxtb3JwaFRhcmdldHNDb3VudDpmdCxtb3JwaFRleHR1cmVTdHJpZGU6UHQsbnVtRGlyTGlnaHRzOncuZGlyZWN0aW9uYWwubGVuZ3RoLG51bVBvaW50TGlnaHRzOncucG9pbnQubGVuZ3RoLG51bVNwb3RMaWdodHM6dy5zcG90Lmxlbmd0aCxudW1TcG90TGlnaHRNYXBzOncuc3BvdExpZ2h0TWFwLmxlbmd0aCxudW1SZWN0QXJlYUxpZ2h0czp3LnJlY3RBcmVhLmxlbmd0aCxudW1IZW1pTGlnaHRzOncuaGVtaS5sZW5ndGgsbnVtRGlyTGlnaHRTaGFkb3dzOncuZGlyZWN0aW9uYWxTaGFkb3dNYXAubGVuZ3RoLG51bVBvaW50TGlnaHRTaGFkb3dzOncucG9pbnRTaGFkb3dNYXAubGVuZ3RoLG51bVNwb3RMaWdodFNoYWRvd3M6dy5zcG90U2hhZG93TWFwLmxlbmd0aCxudW1TcG90TGlnaHRTaGFkb3dzV2l0aE1hcHM6dy5udW1TcG90TGlnaHRTaGFkb3dzV2l0aE1hcHMsbnVtTGlnaHRQcm9iZXM6dy5udW1MaWdodFByb2JlcyxudW1DbGlwcGluZ1BsYW5lczphLm51bVBsYW5lcyxudW1DbGlwSW50ZXJzZWN0aW9uOmEubnVtSW50ZXJzZWN0aW9uLGRpdGhlcmluZzp5LmRpdGhlcmluZyxzaGFkb3dNYXBFbmFibGVkOnMuc2hhZG93TWFwLmVuYWJsZWQmJkcubGVuZ3RoPjAsc2hhZG93TWFwVHlwZTpzLnNoYWRvd01hcC50eXBlLHRvbmVNYXBwaW5nOnd0LHVzZUxlZ2FjeUxpZ2h0czpzLl91c2VMZWdhY3lMaWdodHMsZGVjb2RlVmlkZW9UZXh0dXJlOkF0JiZ5Lm1hcC5pc1ZpZGVvVGV4dHVyZT09PSEwJiZqdC5nZXRUcmFuc2Zlcih5Lm1hcC5jb2xvclNwYWNlKT09PXNlLHByZW11bHRpcGxpZWRBbHBoYTp5LnByZW11bHRpcGxpZWRBbHBoYSxkb3VibGVTaWRlZDp5LnNpZGU9PT1mbixmbGlwU2lkZWQ6eS5zaWRlPT09VmUsdXNlRGVwdGhQYWNraW5nOnkuZGVwdGhQYWNraW5nPj0wLGRlcHRoUGFja2luZzp5LmRlcHRoUGFja2luZ3x8MCxpbmRleDBBdHRyaWJ1dGVOYW1lOnkuaW5kZXgwQXR0cmlidXRlTmFtZSxleHRlbnNpb25EZXJpdmF0aXZlczpNdCYmeS5leHRlbnNpb25zLmRlcml2YXRpdmVzPT09ITAsZXh0ZW5zaW9uRnJhZ0RlcHRoOk10JiZ5LmV4dGVuc2lvbnMuZnJhZ0RlcHRoPT09ITAsZXh0ZW5zaW9uRHJhd0J1ZmZlcnM6TXQmJnkuZXh0ZW5zaW9ucy5kcmF3QnVmZmVycz09PSEwLGV4dGVuc2lvblNoYWRlclRleHR1cmVMT0Q6TXQmJnkuZXh0ZW5zaW9ucy5zaGFkZXJUZXh0dXJlTE9EPT09ITAsZXh0ZW5zaW9uQ2xpcEN1bGxEaXN0YW5jZTpNdCYmeS5leHRlbnNpb25zLmNsaXBDdWxsRGlzdGFuY2U9PT0hMCYmbi5oYXMoIldFQkdMX2NsaXBfY3VsbF9kaXN0YW5jZSIpLGV4dGVuc2lvbk11bHRpRHJhdzpNdCYmeS5leHRlbnNpb25zLm11bHRpRHJhdz09PSEwJiZuLmhhcygiV0VCR0xfbXVsdGlfZHJhdyIpLHJlbmRlcmVyRXh0ZW5zaW9uRnJhZ0RlcHRoOnV8fG4uaGFzKCJFWFRfZnJhZ19kZXB0aCIpLHJlbmRlcmVyRXh0ZW5zaW9uRHJhd0J1ZmZlcnM6dXx8bi5oYXMoIldFQkdMX2RyYXdfYnVmZmVycyIpLHJlbmRlcmVyRXh0ZW5zaW9uU2hhZGVyVGV4dHVyZUxvZDp1fHxuLmhhcygiRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCIpLHJlbmRlcmVyRXh0ZW5zaW9uUGFyYWxsZWxTaGFkZXJDb21waWxlOm4uaGFzKCJLSFJfcGFyYWxsZWxfc2hhZGVyX2NvbXBpbGUiKSxjdXN0b21Qcm9ncmFtQ2FjaGVLZXk6eS5jdXN0b21Qcm9ncmFtQ2FjaGVLZXkoKX07cmV0dXJuIEt0LnZlcnRleFV2MXM9Yy5oYXMoMSksS3QudmVydGV4VXYycz1jLmhhcygyKSxLdC52ZXJ0ZXhVdjNzPWMuaGFzKDMpLGMuY2xlYXIoKSxLdH1mdW5jdGlvbiB2KHkpe2xldCB3PVtdO2lmKHkuc2hhZGVySUQ/dy5wdXNoKHkuc2hhZGVySUQpOih3LnB1c2goeS5jdXN0b21WZXJ0ZXhTaGFkZXJJRCksdy5wdXNoKHkuY3VzdG9tRnJhZ21lbnRTaGFkZXJJRCkpLHkuZGVmaW5lcyE9PXZvaWQgMClmb3IobGV0IEcgaW4geS5kZWZpbmVzKXcucHVzaChHKSx3LnB1c2goeS5kZWZpbmVzW0ddKTtyZXR1cm4geS5pc1Jhd1NoYWRlck1hdGVyaWFsPT09ITEmJih4KHcseSksTSh3LHkpLHcucHVzaChzLm91dHB1dENvbG9yU3BhY2UpKSx3LnB1c2goeS5jdXN0b21Qcm9ncmFtQ2FjaGVLZXkpLHcuam9pbigpfWZ1bmN0aW9uIHgoeSx3KXt5LnB1c2gody5wcmVjaXNpb24pLHkucHVzaCh3Lm91dHB1dENvbG9yU3BhY2UpLHkucHVzaCh3LmVudk1hcE1vZGUpLHkucHVzaCh3LmVudk1hcEN1YmVVVkhlaWdodCkseS5wdXNoKHcubWFwVXYpLHkucHVzaCh3LmFscGhhTWFwVXYpLHkucHVzaCh3LmxpZ2h0TWFwVXYpLHkucHVzaCh3LmFvTWFwVXYpLHkucHVzaCh3LmJ1bXBNYXBVdikseS5wdXNoKHcubm9ybWFsTWFwVXYpLHkucHVzaCh3LmRpc3BsYWNlbWVudE1hcFV2KSx5LnB1c2gody5lbWlzc2l2ZU1hcFV2KSx5LnB1c2gody5tZXRhbG5lc3NNYXBVdikseS5wdXNoKHcucm91Z2huZXNzTWFwVXYpLHkucHVzaCh3LmFuaXNvdHJvcHlNYXBVdikseS5wdXNoKHcuY2xlYXJjb2F0TWFwVXYpLHkucHVzaCh3LmNsZWFyY29hdE5vcm1hbE1hcFV2KSx5LnB1c2gody5jbGVhcmNvYXRSb3VnaG5lc3NNYXBVdikseS5wdXNoKHcuaXJpZGVzY2VuY2VNYXBVdikseS5wdXNoKHcuaXJpZGVzY2VuY2VUaGlja25lc3NNYXBVdikseS5wdXNoKHcuc2hlZW5Db2xvck1hcFV2KSx5LnB1c2gody5zaGVlblJvdWdobmVzc01hcFV2KSx5LnB1c2gody5zcGVjdWxhck1hcFV2KSx5LnB1c2gody5zcGVjdWxhckNvbG9yTWFwVXYpLHkucHVzaCh3LnNwZWN1bGFySW50ZW5zaXR5TWFwVXYpLHkucHVzaCh3LnRyYW5zbWlzc2lvbk1hcFV2KSx5LnB1c2gody50aGlja25lc3NNYXBVdikseS5wdXNoKHcuY29tYmluZSkseS5wdXNoKHcuZm9nRXhwMikseS5wdXNoKHcuc2l6ZUF0dGVudWF0aW9uKSx5LnB1c2gody5tb3JwaFRhcmdldHNDb3VudCkseS5wdXNoKHcubW9ycGhBdHRyaWJ1dGVDb3VudCkseS5wdXNoKHcubnVtRGlyTGlnaHRzKSx5LnB1c2gody5udW1Qb2ludExpZ2h0cykseS5wdXNoKHcubnVtU3BvdExpZ2h0cykseS5wdXNoKHcubnVtU3BvdExpZ2h0TWFwcykseS5wdXNoKHcubnVtSGVtaUxpZ2h0cykseS5wdXNoKHcubnVtUmVjdEFyZWFMaWdodHMpLHkucHVzaCh3Lm51bURpckxpZ2h0U2hhZG93cykseS5wdXNoKHcubnVtUG9pbnRMaWdodFNoYWRvd3MpLHkucHVzaCh3Lm51bVNwb3RMaWdodFNoYWRvd3MpLHkucHVzaCh3Lm51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwcykseS5wdXNoKHcubnVtTGlnaHRQcm9iZXMpLHkucHVzaCh3LnNoYWRvd01hcFR5cGUpLHkucHVzaCh3LnRvbmVNYXBwaW5nKSx5LnB1c2gody5udW1DbGlwcGluZ1BsYW5lcykseS5wdXNoKHcubnVtQ2xpcEludGVyc2VjdGlvbikseS5wdXNoKHcuZGVwdGhQYWNraW5nKX1mdW5jdGlvbiBNKHksdyl7by5kaXNhYmxlQWxsKCksdy5pc1dlYkdMMiYmby5lbmFibGUoMCksdy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzJiZvLmVuYWJsZSgxKSx3Lmluc3RhbmNpbmcmJm8uZW5hYmxlKDIpLHcuaW5zdGFuY2luZ0NvbG9yJiZvLmVuYWJsZSgzKSx3Lm1hdGNhcCYmby5lbmFibGUoNCksdy5lbnZNYXAmJm8uZW5hYmxlKDUpLHcubm9ybWFsTWFwT2JqZWN0U3BhY2UmJm8uZW5hYmxlKDYpLHcubm9ybWFsTWFwVGFuZ2VudFNwYWNlJiZvLmVuYWJsZSg3KSx3LmNsZWFyY29hdCYmby5lbmFibGUoOCksdy5pcmlkZXNjZW5jZSYmby5lbmFibGUoOSksdy5hbHBoYVRlc3QmJm8uZW5hYmxlKDEwKSx3LnZlcnRleENvbG9ycyYmby5lbmFibGUoMTEpLHcudmVydGV4QWxwaGFzJiZvLmVuYWJsZSgxMiksdy52ZXJ0ZXhVdjFzJiZvLmVuYWJsZSgxMyksdy52ZXJ0ZXhVdjJzJiZvLmVuYWJsZSgxNCksdy52ZXJ0ZXhVdjNzJiZvLmVuYWJsZSgxNSksdy52ZXJ0ZXhUYW5nZW50cyYmby5lbmFibGUoMTYpLHcuYW5pc290cm9weSYmby5lbmFibGUoMTcpLHcuYWxwaGFIYXNoJiZvLmVuYWJsZSgxOCksdy5iYXRjaGluZyYmby5lbmFibGUoMTkpLHkucHVzaChvLm1hc2spLG8uZGlzYWJsZUFsbCgpLHcuZm9nJiZvLmVuYWJsZSgwKSx3LnVzZUZvZyYmby5lbmFibGUoMSksdy5mbGF0U2hhZGluZyYmby5lbmFibGUoMiksdy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyJiZvLmVuYWJsZSgzKSx3LnNraW5uaW5nJiZvLmVuYWJsZSg0KSx3Lm1vcnBoVGFyZ2V0cyYmby5lbmFibGUoNSksdy5tb3JwaE5vcm1hbHMmJm8uZW5hYmxlKDYpLHcubW9ycGhDb2xvcnMmJm8uZW5hYmxlKDcpLHcucHJlbXVsdGlwbGllZEFscGhhJiZvLmVuYWJsZSg4KSx3LnNoYWRvd01hcEVuYWJsZWQmJm8uZW5hYmxlKDkpLHcudXNlTGVnYWN5TGlnaHRzJiZvLmVuYWJsZSgxMCksdy5kb3VibGVTaWRlZCYmby5lbmFibGUoMTEpLHcuZmxpcFNpZGVkJiZvLmVuYWJsZSgxMiksdy51c2VEZXB0aFBhY2tpbmcmJm8uZW5hYmxlKDEzKSx3LmRpdGhlcmluZyYmby5lbmFibGUoMTQpLHcudHJhbnNtaXNzaW9uJiZvLmVuYWJsZSgxNSksdy5zaGVlbiYmby5lbmFibGUoMTYpLHcub3BhcXVlJiZvLmVuYWJsZSgxNyksdy5wb2ludHNVdnMmJm8uZW5hYmxlKDE4KSx3LmRlY29kZVZpZGVvVGV4dHVyZSYmby5lbmFibGUoMTkpLHcuYWxwaGFUb0NvdmVyYWdlJiZvLmVuYWJsZSgyMCkseS5wdXNoKG8ubWFzayl9ZnVuY3Rpb24gQyh5KXtsZXQgdz1fW3kudHlwZV0sRztpZih3KXtsZXQgSj1vblt3XTtHPVFmLmNsb25lKEoudW5pZm9ybXMpfWVsc2UgRz15LnVuaWZvcm1zO3JldHVybiBHfWZ1bmN0aW9uIEEoeSx3KXtsZXQgRztmb3IobGV0IEo9MCxJPWgubGVuZ3RoO0o8STtKKyspe2xldCB6PWhbSl07aWYoei5jYWNoZUtleT09PXcpe0c9eiwrK0cudXNlZFRpbWVzO2JyZWFrfX1yZXR1cm4gRz09PXZvaWQgMCYmKEc9bmV3IHF4KHMsdyx5LHIpLGgucHVzaChHKSksR31mdW5jdGlvbiBUKHkpe2lmKC0teS51c2VkVGltZXM9PT0wKXtsZXQgdz1oLmluZGV4T2YoeSk7aFt3XT1oW2gubGVuZ3RoLTFdLGgucG9wKCkseS5kZXN0cm95KCl9fWZ1bmN0aW9uIFUoeSl7bC5yZW1vdmUoeSl9ZnVuY3Rpb24gaygpe2wuZGlzcG9zZSgpfXJldHVybntnZXRQYXJhbWV0ZXJzOnAsZ2V0UHJvZ3JhbUNhY2hlS2V5OnYsZ2V0VW5pZm9ybXM6QyxhY3F1aXJlUHJvZ3JhbTpBLHJlbGVhc2VQcm9ncmFtOlQscmVsZWFzZVNoYWRlckNhY2hlOlUscHJvZ3JhbXM6aCxkaXNwb3NlOmt9fWZ1bmN0aW9uIEp4KCl7bGV0IHM9bmV3IFdlYWtNYXA7ZnVuY3Rpb24gdChyKXtsZXQgYT1zLmdldChyKTtyZXR1cm4gYT09PXZvaWQgMCYmKGE9e30scy5zZXQocixhKSksYX1mdW5jdGlvbiBlKHIpe3MuZGVsZXRlKHIpfWZ1bmN0aW9uIG4ocixhLG8pe3MuZ2V0KHIpW2FdPW99ZnVuY3Rpb24gaSgpe3M9bmV3IFdlYWtNYXB9cmV0dXJue2dldDp0LHJlbW92ZTplLHVwZGF0ZTpuLGRpc3Bvc2U6aX19ZnVuY3Rpb24gJHgocyx0KXtyZXR1cm4gcy5ncm91cE9yZGVyIT09dC5ncm91cE9yZGVyP3MuZ3JvdXBPcmRlci10Lmdyb3VwT3JkZXI6cy5yZW5kZXJPcmRlciE9PXQucmVuZGVyT3JkZXI/cy5yZW5kZXJPcmRlci10LnJlbmRlck9yZGVyOnMubWF0ZXJpYWwuaWQhPT10Lm1hdGVyaWFsLmlkP3MubWF0ZXJpYWwuaWQtdC5tYXRlcmlhbC5pZDpzLnohPT10Lno/cy56LXQuejpzLmlkLXQuaWR9ZnVuY3Rpb24gS3Uocyx0KXtyZXR1cm4gcy5ncm91cE9yZGVyIT09dC5ncm91cE9yZGVyP3MuZ3JvdXBPcmRlci10Lmdyb3VwT3JkZXI6cy5yZW5kZXJPcmRlciE9PXQucmVuZGVyT3JkZXI/cy5yZW5kZXJPcmRlci10LnJlbmRlck9yZGVyOnMueiE9PXQuej90Lnotcy56OnMuaWQtdC5pZH1mdW5jdGlvbiBRdSgpe2xldCBzPVtdLHQ9MCxlPVtdLG49W10saT1bXTtmdW5jdGlvbiByKCl7dD0wLGUubGVuZ3RoPTAsbi5sZW5ndGg9MCxpLmxlbmd0aD0wfWZ1bmN0aW9uIGEodSxkLGYsbSxfLGcpe2xldCBwPXNbdF07cmV0dXJuIHA9PT12b2lkIDA/KHA9e2lkOnUuaWQsb2JqZWN0OnUsZ2VvbWV0cnk6ZCxtYXRlcmlhbDpmLGdyb3VwT3JkZXI6bSxyZW5kZXJPcmRlcjp1LnJlbmRlck9yZGVyLHo6Xyxncm91cDpnfSxzW3RdPXApOihwLmlkPXUuaWQscC5vYmplY3Q9dSxwLmdlb21ldHJ5PWQscC5tYXRlcmlhbD1mLHAuZ3JvdXBPcmRlcj1tLHAucmVuZGVyT3JkZXI9dS5yZW5kZXJPcmRlcixwLno9XyxwLmdyb3VwPWcpLHQrKyxwfWZ1bmN0aW9uIG8odSxkLGYsbSxfLGcpe2xldCBwPWEodSxkLGYsbSxfLGcpO2YudHJhbnNtaXNzaW9uPjA/bi5wdXNoKHApOmYudHJhbnNwYXJlbnQ9PT0hMD9pLnB1c2gocCk6ZS5wdXNoKHApfWZ1bmN0aW9uIGwodSxkLGYsbSxfLGcpe2xldCBwPWEodSxkLGYsbSxfLGcpO2YudHJhbnNtaXNzaW9uPjA/bi51bnNoaWZ0KHApOmYudHJhbnNwYXJlbnQ9PT0hMD9pLnVuc2hpZnQocCk6ZS51bnNoaWZ0KHApfWZ1bmN0aW9uIGModSxkKXtlLmxlbmd0aD4xJiZlLnNvcnQodXx8JHgpLG4ubGVuZ3RoPjEmJm4uc29ydChkfHxLdSksaS5sZW5ndGg+MSYmaS5zb3J0KGR8fEt1KX1mdW5jdGlvbiBoKCl7Zm9yKGxldCB1PXQsZD1zLmxlbmd0aDt1PGQ7dSsrKXtsZXQgZj1zW3VdO2lmKGYuaWQ9PT1udWxsKWJyZWFrO2YuaWQ9bnVsbCxmLm9iamVjdD1udWxsLGYuZ2VvbWV0cnk9bnVsbCxmLm1hdGVyaWFsPW51bGwsZi5ncm91cD1udWxsfX1yZXR1cm57b3BhcXVlOmUsdHJhbnNtaXNzaXZlOm4sdHJhbnNwYXJlbnQ6aSxpbml0OnIscHVzaDpvLHVuc2hpZnQ6bCxmaW5pc2g6aCxzb3J0OmN9fWZ1bmN0aW9uIEt4KCl7bGV0IHM9bmV3IFdlYWtNYXA7ZnVuY3Rpb24gdChuLGkpe2xldCByPXMuZ2V0KG4pLGE7cmV0dXJuIHI9PT12b2lkIDA/KGE9bmV3IFF1LHMuc2V0KG4sW2FdKSk6aT49ci5sZW5ndGg/KGE9bmV3IFF1LHIucHVzaChhKSk6YT1yW2ldLGF9ZnVuY3Rpb24gZSgpe3M9bmV3IFdlYWtNYXB9cmV0dXJue2dldDp0LGRpc3Bvc2U6ZX19ZnVuY3Rpb24gUXgoKXtsZXQgcz17fTtyZXR1cm57Z2V0OmZ1bmN0aW9uKHQpe2lmKHNbdC5pZF0hPT12b2lkIDApcmV0dXJuIHNbdC5pZF07bGV0IGU7c3dpdGNoKHQudHlwZSl7Y2FzZSJEaXJlY3Rpb25hbExpZ2h0IjplPXtkaXJlY3Rpb246bmV3IFIsY29sb3I6bmV3IHV0fTticmVhaztjYXNlIlNwb3RMaWdodCI6ZT17cG9zaXRpb246bmV3IFIsZGlyZWN0aW9uOm5ldyBSLGNvbG9yOm5ldyB1dCxkaXN0YW5jZTowLGNvbmVDb3M6MCxwZW51bWJyYUNvczowLGRlY2F5OjB9O2JyZWFrO2Nhc2UiUG9pbnRMaWdodCI6ZT17cG9zaXRpb246bmV3IFIsY29sb3I6bmV3IHV0LGRpc3RhbmNlOjAsZGVjYXk6MH07YnJlYWs7Y2FzZSJIZW1pc3BoZXJlTGlnaHQiOmU9e2RpcmVjdGlvbjpuZXcgUixza3lDb2xvcjpuZXcgdXQsZ3JvdW5kQ29sb3I6bmV3IHV0fTticmVhaztjYXNlIlJlY3RBcmVhTGlnaHQiOmU9e2NvbG9yOm5ldyB1dCxwb3NpdGlvbjpuZXcgUixoYWxmV2lkdGg6bmV3IFIsaGFsZkhlaWdodDpuZXcgUn07YnJlYWt9cmV0dXJuIHNbdC5pZF09ZSxlfX19ZnVuY3Rpb24gangoKXtsZXQgcz17fTtyZXR1cm57Z2V0OmZ1bmN0aW9uKHQpe2lmKHNbdC5pZF0hPT12b2lkIDApcmV0dXJuIHNbdC5pZF07bGV0IGU7c3dpdGNoKHQudHlwZSl7Y2FzZSJEaXJlY3Rpb25hbExpZ2h0IjplPXtzaGFkb3dCaWFzOjAsc2hhZG93Tm9ybWFsQmlhczowLHNoYWRvd1JhZGl1czoxLHNoYWRvd01hcFNpemU6bmV3IFp9O2JyZWFrO2Nhc2UiU3BvdExpZ2h0IjplPXtzaGFkb3dCaWFzOjAsc2hhZG93Tm9ybWFsQmlhczowLHNoYWRvd1JhZGl1czoxLHNoYWRvd01hcFNpemU6bmV3IFp9O2JyZWFrO2Nhc2UiUG9pbnRMaWdodCI6ZT17c2hhZG93QmlhczowLHNoYWRvd05vcm1hbEJpYXM6MCxzaGFkb3dSYWRpdXM6MSxzaGFkb3dNYXBTaXplOm5ldyBaLHNoYWRvd0NhbWVyYU5lYXI6MSxzaGFkb3dDYW1lcmFGYXI6MWUzfTticmVha31yZXR1cm4gc1t0LmlkXT1lLGV9fX12YXIgdHY9MDtmdW5jdGlvbiBldihzLHQpe3JldHVybih0LmNhc3RTaGFkb3c/MjowKS0ocy5jYXN0U2hhZG93PzI6MCkrKHQubWFwPzE6MCktKHMubWFwPzE6MCl9ZnVuY3Rpb24gbnYocyx0KXtsZXQgZT1uZXcgUXgsbj1qeCgpLGk9e3ZlcnNpb246MCxoYXNoOntkaXJlY3Rpb25hbExlbmd0aDotMSxwb2ludExlbmd0aDotMSxzcG90TGVuZ3RoOi0xLHJlY3RBcmVhTGVuZ3RoOi0xLGhlbWlMZW5ndGg6LTEsbnVtRGlyZWN0aW9uYWxTaGFkb3dzOi0xLG51bVBvaW50U2hhZG93czotMSxudW1TcG90U2hhZG93czotMSxudW1TcG90TWFwczotMSxudW1MaWdodFByb2JlczotMX0sYW1iaWVudDpbMCwwLDBdLHByb2JlOltdLGRpcmVjdGlvbmFsOltdLGRpcmVjdGlvbmFsU2hhZG93OltdLGRpcmVjdGlvbmFsU2hhZG93TWFwOltdLGRpcmVjdGlvbmFsU2hhZG93TWF0cml4OltdLHNwb3Q6W10sc3BvdExpZ2h0TWFwOltdLHNwb3RTaGFkb3c6W10sc3BvdFNoYWRvd01hcDpbXSxzcG90TGlnaHRNYXRyaXg6W10scmVjdEFyZWE6W10scmVjdEFyZWFMVEMxOm51bGwscmVjdEFyZWFMVEMyOm51bGwscG9pbnQ6W10scG9pbnRTaGFkb3c6W10scG9pbnRTaGFkb3dNYXA6W10scG9pbnRTaGFkb3dNYXRyaXg6W10saGVtaTpbXSxudW1TcG90TGlnaHRTaGFkb3dzV2l0aE1hcHM6MCxudW1MaWdodFByb2JlczowfTtmb3IobGV0IGg9MDtoPDk7aCsrKWkucHJvYmUucHVzaChuZXcgUik7bGV0IHI9bmV3IFIsYT1uZXcgTHQsbz1uZXcgTHQ7ZnVuY3Rpb24gbChoLHUpe2xldCBkPTAsZj0wLG09MDtmb3IobGV0IEc9MDtHPDk7RysrKWkucHJvYmVbR10uc2V0KDAsMCwwKTtsZXQgXz0wLGc9MCxwPTAsdj0wLHg9MCxNPTAsQz0wLEE9MCxUPTAsVT0wLGs9MDtoLnNvcnQoZXYpO2xldCB5PXU9PT0hMD9NYXRoLlBJOjE7Zm9yKGxldCBHPTAsSj1oLmxlbmd0aDtHPEo7RysrKXtsZXQgST1oW0ddLHo9SS5jb2xvcixGPUkuaW50ZW5zaXR5LCQ9SS5kaXN0YW5jZSxxPUkuc2hhZG93JiZJLnNoYWRvdy5tYXA/SS5zaGFkb3cubWFwLnRleHR1cmU6bnVsbDtpZihJLmlzQW1iaWVudExpZ2h0KWQrPXoucipGKnksZis9ei5nKkYqeSxtKz16LmIqRip5O2Vsc2UgaWYoSS5pc0xpZ2h0UHJvYmUpe2ZvcihsZXQgVz0wO1c8OTtXKyspaS5wcm9iZVtXXS5hZGRTY2FsZWRWZWN0b3IoSS5zaC5jb2VmZmljaWVudHNbV10sRik7aysrfWVsc2UgaWYoSS5pc0RpcmVjdGlvbmFsTGlnaHQpe2xldCBXPWUuZ2V0KEkpO2lmKFcuY29sb3IuY29weShJLmNvbG9yKS5tdWx0aXBseVNjYWxhcihJLmludGVuc2l0eSp5KSxJLmNhc3RTaGFkb3cpe2xldCBldD1JLnNoYWRvdyxRPW4uZ2V0KEkpO1Euc2hhZG93Qmlhcz1ldC5iaWFzLFEuc2hhZG93Tm9ybWFsQmlhcz1ldC5ub3JtYWxCaWFzLFEuc2hhZG93UmFkaXVzPWV0LnJhZGl1cyxRLnNoYWRvd01hcFNpemU9ZXQubWFwU2l6ZSxpLmRpcmVjdGlvbmFsU2hhZG93W19dPVEsaS5kaXJlY3Rpb25hbFNoYWRvd01hcFtfXT1xLGkuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbX109SS5zaGFkb3cubWF0cml4LE0rK31pLmRpcmVjdGlvbmFsW19dPVcsXysrfWVsc2UgaWYoSS5pc1Nwb3RMaWdodCl7bGV0IFc9ZS5nZXQoSSk7Vy5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oSS5tYXRyaXhXb3JsZCksVy5jb2xvci5jb3B5KHopLm11bHRpcGx5U2NhbGFyKEYqeSksVy5kaXN0YW5jZT0kLFcuY29uZUNvcz1NYXRoLmNvcyhJLmFuZ2xlKSxXLnBlbnVtYnJhQ29zPU1hdGguY29zKEkuYW5nbGUqKDEtSS5wZW51bWJyYSkpLFcuZGVjYXk9SS5kZWNheSxpLnNwb3RbcF09VztsZXQgZXQ9SS5zaGFkb3c7aWYoSS5tYXAmJihpLnNwb3RMaWdodE1hcFtUXT1JLm1hcCxUKyssZXQudXBkYXRlTWF0cmljZXMoSSksSS5jYXN0U2hhZG93JiZVKyspLGkuc3BvdExpZ2h0TWF0cml4W3BdPWV0Lm1hdHJpeCxJLmNhc3RTaGFkb3cpe2xldCBRPW4uZ2V0KEkpO1Euc2hhZG93Qmlhcz1ldC5iaWFzLFEuc2hhZG93Tm9ybWFsQmlhcz1ldC5ub3JtYWxCaWFzLFEuc2hhZG93UmFkaXVzPWV0LnJhZGl1cyxRLnNoYWRvd01hcFNpemU9ZXQubWFwU2l6ZSxpLnNwb3RTaGFkb3dbcF09USxpLnNwb3RTaGFkb3dNYXBbcF09cSxBKyt9cCsrfWVsc2UgaWYoSS5pc1JlY3RBcmVhTGlnaHQpe2xldCBXPWUuZ2V0KEkpO1cuY29sb3IuY29weSh6KS5tdWx0aXBseVNjYWxhcihGKSxXLmhhbGZXaWR0aC5zZXQoSS53aWR0aCouNSwwLDApLFcuaGFsZkhlaWdodC5zZXQoMCxJLmhlaWdodCouNSwwKSxpLnJlY3RBcmVhW3ZdPVcsdisrfWVsc2UgaWYoSS5pc1BvaW50TGlnaHQpe2xldCBXPWUuZ2V0KEkpO2lmKFcuY29sb3IuY29weShJLmNvbG9yKS5tdWx0aXBseVNjYWxhcihJLmludGVuc2l0eSp5KSxXLmRpc3RhbmNlPUkuZGlzdGFuY2UsVy5kZWNheT1JLmRlY2F5LEkuY2FzdFNoYWRvdyl7bGV0IGV0PUkuc2hhZG93LFE9bi5nZXQoSSk7US5zaGFkb3dCaWFzPWV0LmJpYXMsUS5zaGFkb3dOb3JtYWxCaWFzPWV0Lm5vcm1hbEJpYXMsUS5zaGFkb3dSYWRpdXM9ZXQucmFkaXVzLFEuc2hhZG93TWFwU2l6ZT1ldC5tYXBTaXplLFEuc2hhZG93Q2FtZXJhTmVhcj1ldC5jYW1lcmEubmVhcixRLnNoYWRvd0NhbWVyYUZhcj1ldC5jYW1lcmEuZmFyLGkucG9pbnRTaGFkb3dbZ109USxpLnBvaW50U2hhZG93TWFwW2ddPXEsaS5wb2ludFNoYWRvd01hdHJpeFtnXT1JLnNoYWRvdy5tYXRyaXgsQysrfWkucG9pbnRbZ109VyxnKyt9ZWxzZSBpZihJLmlzSGVtaXNwaGVyZUxpZ2h0KXtsZXQgVz1lLmdldChJKTtXLnNreUNvbG9yLmNvcHkoSS5jb2xvcikubXVsdGlwbHlTY2FsYXIoRip5KSxXLmdyb3VuZENvbG9yLmNvcHkoSS5ncm91bmRDb2xvcikubXVsdGlwbHlTY2FsYXIoRip5KSxpLmhlbWlbeF09Vyx4Kyt9fXY+MCYmKHQuaXNXZWJHTDI/cy5oYXMoIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhciIpPT09ITA/KGkucmVjdEFyZWFMVEMxPWx0LkxUQ19GTE9BVF8xLGkucmVjdEFyZWFMVEMyPWx0LkxUQ19GTE9BVF8yKTooaS5yZWN0QXJlYUxUQzE9bHQuTFRDX0hBTEZfMSxpLnJlY3RBcmVhTFRDMj1sdC5MVENfSEFMRl8yKTpzLmhhcygiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyIik9PT0hMD8oaS5yZWN0QXJlYUxUQzE9bHQuTFRDX0ZMT0FUXzEsaS5yZWN0QXJlYUxUQzI9bHQuTFRDX0ZMT0FUXzIpOnMuaGFzKCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhciIpPT09ITA/KGkucmVjdEFyZWFMVEMxPWx0LkxUQ19IQUxGXzEsaS5yZWN0QXJlYUxUQzI9bHQuTFRDX0hBTEZfMik6Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xSZW5kZXJlcjogVW5hYmxlIHRvIHVzZSBSZWN0QXJlYUxpZ2h0LiBNaXNzaW5nIFdlYkdMIGV4dGVuc2lvbnMuIikpLGkuYW1iaWVudFswXT1kLGkuYW1iaWVudFsxXT1mLGkuYW1iaWVudFsyXT1tO2xldCB3PWkuaGFzaDsody5kaXJlY3Rpb25hbExlbmd0aCE9PV98fHcucG9pbnRMZW5ndGghPT1nfHx3LnNwb3RMZW5ndGghPT1wfHx3LnJlY3RBcmVhTGVuZ3RoIT09dnx8dy5oZW1pTGVuZ3RoIT09eHx8dy5udW1EaXJlY3Rpb25hbFNoYWRvd3MhPT1NfHx3Lm51bVBvaW50U2hhZG93cyE9PUN8fHcubnVtU3BvdFNoYWRvd3MhPT1BfHx3Lm51bVNwb3RNYXBzIT09VHx8dy5udW1MaWdodFByb2JlcyE9PWspJiYoaS5kaXJlY3Rpb25hbC5sZW5ndGg9XyxpLnNwb3QubGVuZ3RoPXAsaS5yZWN0QXJlYS5sZW5ndGg9dixpLnBvaW50Lmxlbmd0aD1nLGkuaGVtaS5sZW5ndGg9eCxpLmRpcmVjdGlvbmFsU2hhZG93Lmxlbmd0aD1NLGkuZGlyZWN0aW9uYWxTaGFkb3dNYXAubGVuZ3RoPU0saS5wb2ludFNoYWRvdy5sZW5ndGg9QyxpLnBvaW50U2hhZG93TWFwLmxlbmd0aD1DLGkuc3BvdFNoYWRvdy5sZW5ndGg9QSxpLnNwb3RTaGFkb3dNYXAubGVuZ3RoPUEsaS5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeC5sZW5ndGg9TSxpLnBvaW50U2hhZG93TWF0cml4Lmxlbmd0aD1DLGkuc3BvdExpZ2h0TWF0cml4Lmxlbmd0aD1BK1QtVSxpLnNwb3RMaWdodE1hcC5sZW5ndGg9VCxpLm51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwcz1VLGkubnVtTGlnaHRQcm9iZXM9ayx3LmRpcmVjdGlvbmFsTGVuZ3RoPV8sdy5wb2ludExlbmd0aD1nLHcuc3BvdExlbmd0aD1wLHcucmVjdEFyZWFMZW5ndGg9dix3LmhlbWlMZW5ndGg9eCx3Lm51bURpcmVjdGlvbmFsU2hhZG93cz1NLHcubnVtUG9pbnRTaGFkb3dzPUMsdy5udW1TcG90U2hhZG93cz1BLHcubnVtU3BvdE1hcHM9VCx3Lm51bUxpZ2h0UHJvYmVzPWssaS52ZXJzaW9uPXR2KyspfWZ1bmN0aW9uIGMoaCx1KXtsZXQgZD0wLGY9MCxtPTAsXz0wLGc9MCxwPXUubWF0cml4V29ybGRJbnZlcnNlO2ZvcihsZXQgdj0wLHg9aC5sZW5ndGg7djx4O3YrKyl7bGV0IE09aFt2XTtpZihNLmlzRGlyZWN0aW9uYWxMaWdodCl7bGV0IEM9aS5kaXJlY3Rpb25hbFtkXTtDLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oTS5tYXRyaXhXb3JsZCksci5zZXRGcm9tTWF0cml4UG9zaXRpb24oTS50YXJnZXQubWF0cml4V29ybGQpLEMuZGlyZWN0aW9uLnN1YihyKSxDLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24ocCksZCsrfWVsc2UgaWYoTS5pc1Nwb3RMaWdodCl7bGV0IEM9aS5zcG90W21dO0MucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKE0ubWF0cml4V29ybGQpLEMucG9zaXRpb24uYXBwbHlNYXRyaXg0KHApLEMuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihNLm1hdHJpeFdvcmxkKSxyLnNldEZyb21NYXRyaXhQb3NpdGlvbihNLnRhcmdldC5tYXRyaXhXb3JsZCksQy5kaXJlY3Rpb24uc3ViKHIpLEMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbihwKSxtKyt9ZWxzZSBpZihNLmlzUmVjdEFyZWFMaWdodCl7bGV0IEM9aS5yZWN0QXJlYVtfXTtDLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihNLm1hdHJpeFdvcmxkKSxDLnBvc2l0aW9uLmFwcGx5TWF0cml4NChwKSxvLmlkZW50aXR5KCksYS5jb3B5KE0ubWF0cml4V29ybGQpLGEucHJlbXVsdGlwbHkocCksby5leHRyYWN0Um90YXRpb24oYSksQy5oYWxmV2lkdGguc2V0KE0ud2lkdGgqLjUsMCwwKSxDLmhhbGZIZWlnaHQuc2V0KDAsTS5oZWlnaHQqLjUsMCksQy5oYWxmV2lkdGguYXBwbHlNYXRyaXg0KG8pLEMuaGFsZkhlaWdodC5hcHBseU1hdHJpeDQobyksXysrfWVsc2UgaWYoTS5pc1BvaW50TGlnaHQpe2xldCBDPWkucG9pbnRbZl07Qy5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oTS5tYXRyaXhXb3JsZCksQy5wb3NpdGlvbi5hcHBseU1hdHJpeDQocCksZisrfWVsc2UgaWYoTS5pc0hlbWlzcGhlcmVMaWdodCl7bGV0IEM9aS5oZW1pW2ddO0MuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihNLm1hdHJpeFdvcmxkKSxDLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24ocCksZysrfX19cmV0dXJue3NldHVwOmwsc2V0dXBWaWV3OmMsc3RhdGU6aX19ZnVuY3Rpb24ganUocyx0KXtsZXQgZT1uZXcgbnYocyx0KSxuPVtdLGk9W107ZnVuY3Rpb24gcigpe24ubGVuZ3RoPTAsaS5sZW5ndGg9MH1mdW5jdGlvbiBhKHUpe24ucHVzaCh1KX1mdW5jdGlvbiBvKHUpe2kucHVzaCh1KX1mdW5jdGlvbiBsKHUpe2Uuc2V0dXAobix1KX1mdW5jdGlvbiBjKHUpe2Uuc2V0dXBWaWV3KG4sdSl9cmV0dXJue2luaXQ6cixzdGF0ZTp7bGlnaHRzQXJyYXk6bixzaGFkb3dzQXJyYXk6aSxsaWdodHM6ZX0sc2V0dXBMaWdodHM6bCxzZXR1cExpZ2h0c1ZpZXc6YyxwdXNoTGlnaHQ6YSxwdXNoU2hhZG93Om99fWZ1bmN0aW9uIGl2KHMsdCl7bGV0IGU9bmV3IFdlYWtNYXA7ZnVuY3Rpb24gbihyLGE9MCl7bGV0IG89ZS5nZXQociksbDtyZXR1cm4gbz09PXZvaWQgMD8obD1uZXcganUocyx0KSxlLnNldChyLFtsXSkpOmE+PW8ubGVuZ3RoPyhsPW5ldyBqdShzLHQpLG8ucHVzaChsKSk6bD1vW2FdLGx9ZnVuY3Rpb24gaSgpe2U9bmV3IFdlYWtNYXB9cmV0dXJue2dldDpuLGRpc3Bvc2U6aX19dmFyIGZyPWNsYXNzIGV4dGVuZHMgQWV7Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLmlzTWVzaERlcHRoTWF0ZXJpYWw9ITAsdGhpcy50eXBlPSJNZXNoRGVwdGhNYXRlcmlhbCIsdGhpcy5kZXB0aFBhY2tpbmc9QmYsdGhpcy5tYXA9bnVsbCx0aGlzLmFscGhhTWFwPW51bGwsdGhpcy5kaXNwbGFjZW1lbnRNYXA9bnVsbCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPTEsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPTAsdGhpcy53aXJlZnJhbWU9ITEsdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg9MSx0aGlzLnNldFZhbHVlcyh0KX1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMuZGVwdGhQYWNraW5nPXQuZGVwdGhQYWNraW5nLHRoaXMubWFwPXQubWFwLHRoaXMuYWxwaGFNYXA9dC5hbHBoYU1hcCx0aGlzLmRpc3BsYWNlbWVudE1hcD10LmRpc3BsYWNlbWVudE1hcCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPXQuZGlzcGxhY2VtZW50U2NhbGUsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPXQuZGlzcGxhY2VtZW50Qmlhcyx0aGlzLndpcmVmcmFtZT10LndpcmVmcmFtZSx0aGlzLndpcmVmcmFtZUxpbmV3aWR0aD10LndpcmVmcmFtZUxpbmV3aWR0aCx0aGlzfX0scHI9Y2xhc3MgZXh0ZW5kcyBBZXtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuaXNNZXNoRGlzdGFuY2VNYXRlcmlhbD0hMCx0aGlzLnR5cGU9Ik1lc2hEaXN0YW5jZU1hdGVyaWFsIix0aGlzLm1hcD1udWxsLHRoaXMuYWxwaGFNYXA9bnVsbCx0aGlzLmRpc3BsYWNlbWVudE1hcD1udWxsLHRoaXMuZGlzcGxhY2VtZW50U2NhbGU9MSx0aGlzLmRpc3BsYWNlbWVudEJpYXM9MCx0aGlzLnNldFZhbHVlcyh0KX1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMubWFwPXQubWFwLHRoaXMuYWxwaGFNYXA9dC5hbHBoYU1hcCx0aGlzLmRpc3BsYWNlbWVudE1hcD10LmRpc3BsYWNlbWVudE1hcCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPXQuZGlzcGxhY2VtZW50U2NhbGUsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPXQuZGlzcGxhY2VtZW50Qmlhcyx0aGlzfX0sc3Y9YHZvaWQgbWFpbigpIHsKCWdsX1Bvc2l0aW9uID0gdmVjNCggcG9zaXRpb24sIDEuMCApOwp9YCxydj1gdW5pZm9ybSBzYW1wbGVyMkQgc2hhZG93X3Bhc3M7CnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uOwp1bmlmb3JtIGZsb2F0IHJhZGl1czsKI2luY2x1ZGUgPHBhY2tpbmc+CnZvaWQgbWFpbigpIHsKCWNvbnN0IGZsb2F0IHNhbXBsZXMgPSBmbG9hdCggVlNNX1NBTVBMRVMgKTsKCWZsb2F0IG1lYW4gPSAwLjA7CglmbG9hdCBzcXVhcmVkX21lYW4gPSAwLjA7CglmbG9hdCB1dlN0cmlkZSA9IHNhbXBsZXMgPD0gMS4wID8gMC4wIDogMi4wIC8gKCBzYW1wbGVzIC0gMS4wICk7CglmbG9hdCB1dlN0YXJ0ID0gc2FtcGxlcyA8PSAxLjAgPyAwLjAgOiAtIDEuMDsKCWZvciAoIGZsb2F0IGkgPSAwLjA7IGkgPCBzYW1wbGVzOyBpICsrICkgewoJCWZsb2F0IHV2T2Zmc2V0ID0gdXZTdGFydCArIGkgKiB1dlN0cmlkZTsKCQkjaWZkZWYgSE9SSVpPTlRBTF9QQVNTCgkJCXZlYzIgZGlzdHJpYnV0aW9uID0gdW5wYWNrUkdCQVRvMkhhbGYoIHRleHR1cmUyRCggc2hhZG93X3Bhc3MsICggZ2xfRnJhZ0Nvb3JkLnh5ICsgdmVjMiggdXZPZmZzZXQsIDAuMCApICogcmFkaXVzICkgLyByZXNvbHV0aW9uICkgKTsKCQkJbWVhbiArPSBkaXN0cmlidXRpb24ueDsKCQkJc3F1YXJlZF9tZWFuICs9IGRpc3RyaWJ1dGlvbi55ICogZGlzdHJpYnV0aW9uLnkgKyBkaXN0cmlidXRpb24ueCAqIGRpc3RyaWJ1dGlvbi54OwoJCSNlbHNlCgkJCWZsb2F0IGRlcHRoID0gdW5wYWNrUkdCQVRvRGVwdGgoIHRleHR1cmUyRCggc2hhZG93X3Bhc3MsICggZ2xfRnJhZ0Nvb3JkLnh5ICsgdmVjMiggMC4wLCB1dk9mZnNldCApICogcmFkaXVzICkgLyByZXNvbHV0aW9uICkgKTsKCQkJbWVhbiArPSBkZXB0aDsKCQkJc3F1YXJlZF9tZWFuICs9IGRlcHRoICogZGVwdGg7CgkJI2VuZGlmCgl9CgltZWFuID0gbWVhbiAvIHNhbXBsZXM7CglzcXVhcmVkX21lYW4gPSBzcXVhcmVkX21lYW4gLyBzYW1wbGVzOwoJZmxvYXQgc3RkX2RldiA9IHNxcnQoIHNxdWFyZWRfbWVhbiAtIG1lYW4gKiBtZWFuICk7CglnbF9GcmFnQ29sb3IgPSBwYWNrMkhhbGZUb1JHQkEoIHZlYzIoIG1lYW4sIHN0ZF9kZXYgKSApOwp9YDtmdW5jdGlvbiBhdihzLHQsZSl7bGV0IG49bmV3IElpLGk9bmV3IFoscj1uZXcgWixhPW5ldyB0ZSxvPW5ldyBmcih7ZGVwdGhQYWNraW5nOnpmfSksbD1uZXcgcHIsYz17fSxoPWUubWF4VGV4dHVyZVNpemUsdT17W0JuXTpWZSxbVmVdOkJuLFtmbl06Zm59LGQ9bmV3IEplKHtkZWZpbmVzOntWU01fU0FNUExFUzo4fSx1bmlmb3Jtczp7c2hhZG93X3Bhc3M6e3ZhbHVlOm51bGx9LHJlc29sdXRpb246e3ZhbHVlOm5ldyBafSxyYWRpdXM6e3ZhbHVlOjR9fSx2ZXJ0ZXhTaGFkZXI6c3YsZnJhZ21lbnRTaGFkZXI6cnZ9KSxmPWQuY2xvbmUoKTtmLmRlZmluZXMuSE9SSVpPTlRBTF9QQVNTPTE7bGV0IG09bmV3IEh0O20uc2V0QXR0cmlidXRlKCJwb3NpdGlvbiIsbmV3IFp0KG5ldyBGbG9hdDMyQXJyYXkoWy0xLC0xLC41LDMsLTEsLjUsLTEsMywuNV0pLDMpKTtsZXQgXz1uZXcgZGUobSxkKSxnPXRoaXM7dGhpcy5lbmFibGVkPSExLHRoaXMuYXV0b1VwZGF0ZT0hMCx0aGlzLm5lZWRzVXBkYXRlPSExLHRoaXMudHlwZT1YaDtsZXQgcD10aGlzLnR5cGU7dGhpcy5yZW5kZXI9ZnVuY3Rpb24oQSxULFUpe2lmKGcuZW5hYmxlZD09PSExfHxnLmF1dG9VcGRhdGU9PT0hMSYmZy5uZWVkc1VwZGF0ZT09PSExfHxBLmxlbmd0aD09PTApcmV0dXJuO2xldCBrPXMuZ2V0UmVuZGVyVGFyZ2V0KCkseT1zLmdldEFjdGl2ZUN1YmVGYWNlKCksdz1zLmdldEFjdGl2ZU1pcG1hcExldmVsKCksRz1zLnN0YXRlO0cuc2V0QmxlbmRpbmcoVW4pLEcuYnVmZmVycy5jb2xvci5zZXRDbGVhcigxLDEsMSwxKSxHLmJ1ZmZlcnMuZGVwdGguc2V0VGVzdCghMCksRy5zZXRTY2lzc29yVGVzdCghMSk7bGV0IEo9cCE9PXVuJiZ0aGlzLnR5cGU9PT11bixJPXA9PT11biYmdGhpcy50eXBlIT09dW47Zm9yKGxldCB6PTAsRj1BLmxlbmd0aDt6PEY7eisrKXtsZXQgJD1BW3pdLHE9JC5zaGFkb3c7aWYocT09PXZvaWQgMCl7Y29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFNoYWRvd01hcDoiLCQsImhhcyBubyBzaGFkb3cuIik7Y29udGludWV9aWYocS5hdXRvVXBkYXRlPT09ITEmJnEubmVlZHNVcGRhdGU9PT0hMSljb250aW51ZTtpLmNvcHkocS5tYXBTaXplKTtsZXQgVz1xLmdldEZyYW1lRXh0ZW50cygpO2lmKGkubXVsdGlwbHkoVyksci5jb3B5KHEubWFwU2l6ZSksKGkueD5ofHxpLnk+aCkmJihpLng+aCYmKHIueD1NYXRoLmZsb29yKGgvVy54KSxpLng9ci54KlcueCxxLm1hcFNpemUueD1yLngpLGkueT5oJiYoci55PU1hdGguZmxvb3IoaC9XLnkpLGkueT1yLnkqVy55LHEubWFwU2l6ZS55PXIueSkpLHEubWFwPT09bnVsbHx8Sj09PSEwfHxJPT09ITApe2xldCBRPXRoaXMudHlwZSE9PXVuP3ttaW5GaWx0ZXI6bWUsbWFnRmlsdGVyOm1lfTp7fTtxLm1hcCE9PW51bGwmJnEubWFwLmRpc3Bvc2UoKSxxLm1hcD1uZXcgWmUoaS54LGkueSxRKSxxLm1hcC50ZXh0dXJlLm5hbWU9JC5uYW1lKyIuc2hhZG93TWFwIixxLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9cy5zZXRSZW5kZXJUYXJnZXQocS5tYXApLHMuY2xlYXIoKTtsZXQgZXQ9cS5nZXRWaWV3cG9ydENvdW50KCk7Zm9yKGxldCBRPTA7UTxldDtRKyspe2xldCBmdD1xLmdldFZpZXdwb3J0KFEpO2Euc2V0KHIueCpmdC54LHIueSpmdC55LHIueCpmdC56LHIueSpmdC53KSxHLnZpZXdwb3J0KGEpLHEudXBkYXRlTWF0cmljZXMoJCxRKSxuPXEuZ2V0RnJ1c3R1bSgpLE0oVCxVLHEuY2FtZXJhLCQsdGhpcy50eXBlKX1xLmlzUG9pbnRMaWdodFNoYWRvdyE9PSEwJiZ0aGlzLnR5cGU9PT11biYmdihxLFUpLHEubmVlZHNVcGRhdGU9ITF9cD10aGlzLnR5cGUsZy5uZWVkc1VwZGF0ZT0hMSxzLnNldFJlbmRlclRhcmdldChrLHksdyl9O2Z1bmN0aW9uIHYoQSxUKXtsZXQgVT10LnVwZGF0ZShfKTtkLmRlZmluZXMuVlNNX1NBTVBMRVMhPT1BLmJsdXJTYW1wbGVzJiYoZC5kZWZpbmVzLlZTTV9TQU1QTEVTPUEuYmx1clNhbXBsZXMsZi5kZWZpbmVzLlZTTV9TQU1QTEVTPUEuYmx1clNhbXBsZXMsZC5uZWVkc1VwZGF0ZT0hMCxmLm5lZWRzVXBkYXRlPSEwKSxBLm1hcFBhc3M9PT1udWxsJiYoQS5tYXBQYXNzPW5ldyBaZShpLngsaS55KSksZC51bmlmb3Jtcy5zaGFkb3dfcGFzcy52YWx1ZT1BLm1hcC50ZXh0dXJlLGQudW5pZm9ybXMucmVzb2x1dGlvbi52YWx1ZT1BLm1hcFNpemUsZC51bmlmb3Jtcy5yYWRpdXMudmFsdWU9QS5yYWRpdXMscy5zZXRSZW5kZXJUYXJnZXQoQS5tYXBQYXNzKSxzLmNsZWFyKCkscy5yZW5kZXJCdWZmZXJEaXJlY3QoVCxudWxsLFUsZCxfLG51bGwpLGYudW5pZm9ybXMuc2hhZG93X3Bhc3MudmFsdWU9QS5tYXBQYXNzLnRleHR1cmUsZi51bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlPUEubWFwU2l6ZSxmLnVuaWZvcm1zLnJhZGl1cy52YWx1ZT1BLnJhZGl1cyxzLnNldFJlbmRlclRhcmdldChBLm1hcCkscy5jbGVhcigpLHMucmVuZGVyQnVmZmVyRGlyZWN0KFQsbnVsbCxVLGYsXyxudWxsKX1mdW5jdGlvbiB4KEEsVCxVLGspe2xldCB5PW51bGwsdz1VLmlzUG9pbnRMaWdodD09PSEwP0EuY3VzdG9tRGlzdGFuY2VNYXRlcmlhbDpBLmN1c3RvbURlcHRoTWF0ZXJpYWw7aWYodyE9PXZvaWQgMCl5PXc7ZWxzZSBpZih5PVUuaXNQb2ludExpZ2h0PT09ITA/bDpvLHMubG9jYWxDbGlwcGluZ0VuYWJsZWQmJlQuY2xpcFNoYWRvd3M9PT0hMCYmQXJyYXkuaXNBcnJheShULmNsaXBwaW5nUGxhbmVzKSYmVC5jbGlwcGluZ1BsYW5lcy5sZW5ndGghPT0wfHxULmRpc3BsYWNlbWVudE1hcCYmVC5kaXNwbGFjZW1lbnRTY2FsZSE9PTB8fFQuYWxwaGFNYXAmJlQuYWxwaGFUZXN0PjB8fFQubWFwJiZULmFscGhhVGVzdD4wKXtsZXQgRz15LnV1aWQsSj1ULnV1aWQsST1jW0ddO0k9PT12b2lkIDAmJihJPXt9LGNbR109SSk7bGV0IHo9SVtKXTt6PT09dm9pZCAwJiYoej15LmNsb25lKCksSVtKXT16LFQuYWRkRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsQykpLHk9en1pZih5LnZpc2libGU9VC52aXNpYmxlLHkud2lyZWZyYW1lPVQud2lyZWZyYW1lLGs9PT11bj95LnNpZGU9VC5zaGFkb3dTaWRlIT09bnVsbD9ULnNoYWRvd1NpZGU6VC5zaWRlOnkuc2lkZT1ULnNoYWRvd1NpZGUhPT1udWxsP1Quc2hhZG93U2lkZTp1W1Quc2lkZV0seS5hbHBoYU1hcD1ULmFscGhhTWFwLHkuYWxwaGFUZXN0PVQuYWxwaGFUZXN0LHkubWFwPVQubWFwLHkuY2xpcFNoYWRvd3M9VC5jbGlwU2hhZG93cyx5LmNsaXBwaW5nUGxhbmVzPVQuY2xpcHBpbmdQbGFuZXMseS5jbGlwSW50ZXJzZWN0aW9uPVQuY2xpcEludGVyc2VjdGlvbix5LmRpc3BsYWNlbWVudE1hcD1ULmRpc3BsYWNlbWVudE1hcCx5LmRpc3BsYWNlbWVudFNjYWxlPVQuZGlzcGxhY2VtZW50U2NhbGUseS5kaXNwbGFjZW1lbnRCaWFzPVQuZGlzcGxhY2VtZW50Qmlhcyx5LndpcmVmcmFtZUxpbmV3aWR0aD1ULndpcmVmcmFtZUxpbmV3aWR0aCx5LmxpbmV3aWR0aD1ULmxpbmV3aWR0aCxVLmlzUG9pbnRMaWdodD09PSEwJiZ5LmlzTWVzaERpc3RhbmNlTWF0ZXJpYWw9PT0hMCl7bGV0IEc9cy5wcm9wZXJ0aWVzLmdldCh5KTtHLmxpZ2h0PVV9cmV0dXJuIHl9ZnVuY3Rpb24gTShBLFQsVSxrLHkpe2lmKEEudmlzaWJsZT09PSExKXJldHVybjtpZihBLmxheWVycy50ZXN0KFQubGF5ZXJzKSYmKEEuaXNNZXNofHxBLmlzTGluZXx8QS5pc1BvaW50cykmJihBLmNhc3RTaGFkb3d8fEEucmVjZWl2ZVNoYWRvdyYmeT09PXVuKSYmKCFBLmZydXN0dW1DdWxsZWR8fG4uaW50ZXJzZWN0c09iamVjdChBKSkpe0EubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoVS5tYXRyaXhXb3JsZEludmVyc2UsQS5tYXRyaXhXb3JsZCk7bGV0IEo9dC51cGRhdGUoQSksST1BLm1hdGVyaWFsO2lmKEFycmF5LmlzQXJyYXkoSSkpe2xldCB6PUouZ3JvdXBzO2ZvcihsZXQgRj0wLCQ9ei5sZW5ndGg7RjwkO0YrKyl7bGV0IHE9eltGXSxXPUlbcS5tYXRlcmlhbEluZGV4XTtpZihXJiZXLnZpc2libGUpe2xldCBldD14KEEsVyxrLHkpO0Eub25CZWZvcmVTaGFkb3cocyxBLFQsVSxKLGV0LHEpLHMucmVuZGVyQnVmZmVyRGlyZWN0KFUsbnVsbCxKLGV0LEEscSksQS5vbkFmdGVyU2hhZG93KHMsQSxULFUsSixldCxxKX19fWVsc2UgaWYoSS52aXNpYmxlKXtsZXQgej14KEEsSSxrLHkpO0Eub25CZWZvcmVTaGFkb3cocyxBLFQsVSxKLHosbnVsbCkscy5yZW5kZXJCdWZmZXJEaXJlY3QoVSxudWxsLEoseixBLG51bGwpLEEub25BZnRlclNoYWRvdyhzLEEsVCxVLEoseixudWxsKX19bGV0IEc9QS5jaGlsZHJlbjtmb3IobGV0IEo9MCxJPUcubGVuZ3RoO0o8STtKKyspTShHW0pdLFQsVSxrLHkpfWZ1bmN0aW9uIEMoQSl7QS50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsQyk7Zm9yKGxldCBVIGluIGMpe2xldCBrPWNbVV0seT1BLnRhcmdldC51dWlkO3kgaW4gayYmKGtbeV0uZGlzcG9zZSgpLGRlbGV0ZSBrW3ldKX19fWZ1bmN0aW9uIG92KHMsdCxlKXtsZXQgbj1lLmlzV2ViR0wyO2Z1bmN0aW9uIGkoKXtsZXQgUD0hMSxydD1uZXcgdGUsYXQ9bnVsbCxNdD1uZXcgdGUoMCwwLDAsMCk7cmV0dXJue3NldE1hc2s6ZnVuY3Rpb24od3Qpe2F0IT09d3QmJiFQJiYocy5jb2xvck1hc2sod3Qsd3Qsd3Qsd3QpLGF0PXd0KX0sc2V0TG9ja2VkOmZ1bmN0aW9uKHd0KXtQPXd0fSxzZXRDbGVhcjpmdW5jdGlvbih3dCxLdCxuZSxUZSxRZSl7UWU9PT0hMCYmKHd0Kj1UZSxLdCo9VGUsbmUqPVRlKSxydC5zZXQod3QsS3QsbmUsVGUpLE10LmVxdWFscyhydCk9PT0hMSYmKHMuY2xlYXJDb2xvcih3dCxLdCxuZSxUZSksTXQuY29weShydCkpfSxyZXNldDpmdW5jdGlvbigpe1A9ITEsYXQ9bnVsbCxNdC5zZXQoLTEsMCwwLDApfX19ZnVuY3Rpb24gcigpe2xldCBQPSExLHJ0PW51bGwsYXQ9bnVsbCxNdD1udWxsO3JldHVybntzZXRUZXN0OmZ1bmN0aW9uKHd0KXt3dD95dChzLkRFUFRIX1RFU1QpOk90KHMuREVQVEhfVEVTVCl9LHNldE1hc2s6ZnVuY3Rpb24od3Qpe3J0IT09d3QmJiFQJiYocy5kZXB0aE1hc2sod3QpLHJ0PXd0KX0sc2V0RnVuYzpmdW5jdGlvbih3dCl7aWYoYXQhPT13dCl7c3dpdGNoKHd0KXtjYXNlIHVmOnMuZGVwdGhGdW5jKHMuTkVWRVIpO2JyZWFrO2Nhc2UgZGY6cy5kZXB0aEZ1bmMocy5BTFdBWVMpO2JyZWFrO2Nhc2UgZmY6cy5kZXB0aEZ1bmMocy5MRVNTKTticmVhaztjYXNlIHFzOnMuZGVwdGhGdW5jKHMuTEVRVUFMKTticmVhaztjYXNlIHBmOnMuZGVwdGhGdW5jKHMuRVFVQUwpO2JyZWFrO2Nhc2UgbWY6cy5kZXB0aEZ1bmMocy5HRVFVQUwpO2JyZWFrO2Nhc2UgZ2Y6cy5kZXB0aEZ1bmMocy5HUkVBVEVSKTticmVhaztjYXNlIF9mOnMuZGVwdGhGdW5jKHMuTk9URVFVQUwpO2JyZWFrO2RlZmF1bHQ6cy5kZXB0aEZ1bmMocy5MRVFVQUwpfWF0PXd0fX0sc2V0TG9ja2VkOmZ1bmN0aW9uKHd0KXtQPXd0fSxzZXRDbGVhcjpmdW5jdGlvbih3dCl7TXQhPT13dCYmKHMuY2xlYXJEZXB0aCh3dCksTXQ9d3QpfSxyZXNldDpmdW5jdGlvbigpe1A9ITEscnQ9bnVsbCxhdD1udWxsLE10PW51bGx9fX1mdW5jdGlvbiBhKCl7bGV0IFA9ITEscnQ9bnVsbCxhdD1udWxsLE10PW51bGwsd3Q9bnVsbCxLdD1udWxsLG5lPW51bGwsVGU9bnVsbCxRZT1udWxsO3JldHVybntzZXRUZXN0OmZ1bmN0aW9uKGllKXtQfHwoaWU/eXQocy5TVEVOQ0lMX1RFU1QpOk90KHMuU1RFTkNJTF9URVNUKSl9LHNldE1hc2s6ZnVuY3Rpb24oaWUpe3J0IT09aWUmJiFQJiYocy5zdGVuY2lsTWFzayhpZSkscnQ9aWUpfSxzZXRGdW5jOmZ1bmN0aW9uKGllLE9lLGhuKXsoYXQhPT1pZXx8TXQhPT1PZXx8d3QhPT1obikmJihzLnN0ZW5jaWxGdW5jKGllLE9lLGhuKSxhdD1pZSxNdD1PZSx3dD1obil9LHNldE9wOmZ1bmN0aW9uKGllLE9lLGhuKXsoS3QhPT1pZXx8bmUhPT1PZXx8VGUhPT1obikmJihzLnN0ZW5jaWxPcChpZSxPZSxobiksS3Q9aWUsbmU9T2UsVGU9aG4pfSxzZXRMb2NrZWQ6ZnVuY3Rpb24oaWUpe1A9aWV9LHNldENsZWFyOmZ1bmN0aW9uKGllKXtRZSE9PWllJiYocy5jbGVhclN0ZW5jaWwoaWUpLFFlPWllKX0scmVzZXQ6ZnVuY3Rpb24oKXtQPSExLHJ0PW51bGwsYXQ9bnVsbCxNdD1udWxsLHd0PW51bGwsS3Q9bnVsbCxuZT1udWxsLFRlPW51bGwsUWU9bnVsbH19fWxldCBvPW5ldyBpLGw9bmV3IHIsYz1uZXcgYSxoPW5ldyBXZWFrTWFwLHU9bmV3IFdlYWtNYXAsZD17fSxmPXt9LG09bmV3IFdlYWtNYXAsXz1bXSxnPW51bGwscD0hMSx2PW51bGwseD1udWxsLE09bnVsbCxDPW51bGwsQT1udWxsLFQ9bnVsbCxVPW51bGwsaz1uZXcgdXQoMCwwLDApLHk9MCx3PSExLEc9bnVsbCxKPW51bGwsST1udWxsLHo9bnVsbCxGPW51bGwsJD1zLmdldFBhcmFtZXRlcihzLk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTKSxxPSExLFc9MCxldD1zLmdldFBhcmFtZXRlcihzLlZFUlNJT04pO2V0LmluZGV4T2YoIldlYkdMIikhPT0tMT8oVz1wYXJzZUZsb2F0KC9eV2ViR0wgKFxkKS8uZXhlYyhldClbMV0pLHE9Vz49MSk6ZXQuaW5kZXhPZigiT3BlbkdMIEVTIikhPT0tMSYmKFc9cGFyc2VGbG9hdCgvXk9wZW5HTCBFUyAoXGQpLy5leGVjKGV0KVsxXSkscT1XPj0yKTtsZXQgUT1udWxsLGZ0PXt9LFB0PXMuZ2V0UGFyYW1ldGVyKHMuU0NJU1NPUl9CT1gpLEg9cy5nZXRQYXJhbWV0ZXIocy5WSUVXUE9SVCksaXQ9bmV3IHRlKCkuZnJvbUFycmF5KFB0KSxwdD1uZXcgdGUoKS5mcm9tQXJyYXkoSCk7ZnVuY3Rpb24gdnQoUCxydCxhdCxNdCl7bGV0IHd0PW5ldyBVaW50OEFycmF5KDQpLEt0PXMuY3JlYXRlVGV4dHVyZSgpO3MuYmluZFRleHR1cmUoUCxLdCkscy50ZXhQYXJhbWV0ZXJpKFAscy5URVhUVVJFX01JTl9GSUxURVIscy5ORUFSRVNUKSxzLnRleFBhcmFtZXRlcmkoUCxzLlRFWFRVUkVfTUFHX0ZJTFRFUixzLk5FQVJFU1QpO2ZvcihsZXQgbmU9MDtuZTxhdDtuZSsrKW4mJihQPT09cy5URVhUVVJFXzNEfHxQPT09cy5URVhUVVJFXzJEX0FSUkFZKT9zLnRleEltYWdlM0QocnQsMCxzLlJHQkEsMSwxLE10LDAscy5SR0JBLHMuVU5TSUdORURfQllURSx3dCk6cy50ZXhJbWFnZTJEKHJ0K25lLDAscy5SR0JBLDEsMSwwLHMuUkdCQSxzLlVOU0lHTkVEX0JZVEUsd3QpO3JldHVybiBLdH1sZXQgRXQ9e307RXRbcy5URVhUVVJFXzJEXT12dChzLlRFWFRVUkVfMkQscy5URVhUVVJFXzJELDEpLEV0W3MuVEVYVFVSRV9DVUJFX01BUF09dnQocy5URVhUVVJFX0NVQkVfTUFQLHMuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YLDYpLG4mJihFdFtzLlRFWFRVUkVfMkRfQVJSQVldPXZ0KHMuVEVYVFVSRV8yRF9BUlJBWSxzLlRFWFRVUkVfMkRfQVJSQVksMSwxKSxFdFtzLlRFWFRVUkVfM0RdPXZ0KHMuVEVYVFVSRV8zRCxzLlRFWFRVUkVfM0QsMSwxKSksby5zZXRDbGVhcigwLDAsMCwxKSxsLnNldENsZWFyKDEpLGMuc2V0Q2xlYXIoMCkseXQocy5ERVBUSF9URVNUKSxsLnNldEZ1bmMocXMpLGh0KCExKSxiKFlsKSx5dChzLkNVTExfRkFDRSksWShVbik7ZnVuY3Rpb24geXQoUCl7ZFtQXSE9PSEwJiYocy5lbmFibGUoUCksZFtQXT0hMCl9ZnVuY3Rpb24gT3QoUCl7ZFtQXSE9PSExJiYocy5kaXNhYmxlKFApLGRbUF09ITEpfWZ1bmN0aW9uIEF0KFAscnQpe3JldHVybiBmW1BdIT09cnQ/KHMuYmluZEZyYW1lYnVmZmVyKFAscnQpLGZbUF09cnQsbiYmKFA9PT1zLkRSQVdfRlJBTUVCVUZGRVImJihmW3MuRlJBTUVCVUZGRVJdPXJ0KSxQPT09cy5GUkFNRUJVRkZFUiYmKGZbcy5EUkFXX0ZSQU1FQlVGRkVSXT1ydCkpLCEwKTohMX1mdW5jdGlvbiBMKFAscnQpe2xldCBhdD1fLE10PSExO2lmKFApaWYoYXQ9bS5nZXQocnQpLGF0PT09dm9pZCAwJiYoYXQ9W10sbS5zZXQocnQsYXQpKSxQLmlzV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMpe2xldCB3dD1QLnRleHR1cmU7aWYoYXQubGVuZ3RoIT09d3QubGVuZ3RofHxhdFswXSE9PXMuQ09MT1JfQVRUQUNITUVOVDApe2ZvcihsZXQgS3Q9MCxuZT13dC5sZW5ndGg7S3Q8bmU7S3QrKylhdFtLdF09cy5DT0xPUl9BVFRBQ0hNRU5UMCtLdDthdC5sZW5ndGg9d3QubGVuZ3RoLE10PSEwfX1lbHNlIGF0WzBdIT09cy5DT0xPUl9BVFRBQ0hNRU5UMCYmKGF0WzBdPXMuQ09MT1JfQVRUQUNITUVOVDAsTXQ9ITApO2Vsc2UgYXRbMF0hPT1zLkJBQ0smJihhdFswXT1zLkJBQ0ssTXQ9ITApO010JiYoZS5pc1dlYkdMMj9zLmRyYXdCdWZmZXJzKGF0KTp0LmdldCgiV0VCR0xfZHJhd19idWZmZXJzIikuZHJhd0J1ZmZlcnNXRUJHTChhdCkpfWZ1bmN0aW9uIG90KFApe3JldHVybiBnIT09UD8ocy51c2VQcm9ncmFtKFApLGc9UCwhMCk6ITF9bGV0IFg9e1skbl06cy5GVU5DX0FERCxbSmRdOnMuRlVOQ19TVUJUUkFDVCxbJGRdOnMuRlVOQ19SRVZFUlNFX1NVQlRSQUNUfTtpZihuKVhbS2xdPXMuTUlOLFhbUWxdPXMuTUFYO2Vsc2V7bGV0IFA9dC5nZXQoIkVYVF9ibGVuZF9taW5tYXgiKTtQIT09bnVsbCYmKFhbS2xdPVAuTUlOX0VYVCxYW1FsXT1QLk1BWF9FWFQpfWxldCBzdD17W0tkXTpzLlpFUk8sW1FkXTpzLk9ORSxbamRdOnMuU1JDX0NPTE9SLFtGYV06cy5TUkNfQUxQSEEsW2FmXTpzLlNSQ19BTFBIQV9TQVRVUkFURSxbc2ZdOnMuRFNUX0NPTE9SLFtlZl06cy5EU1RfQUxQSEEsW3RmXTpzLk9ORV9NSU5VU19TUkNfQ09MT1IsW0JhXTpzLk9ORV9NSU5VU19TUkNfQUxQSEEsW3JmXTpzLk9ORV9NSU5VU19EU1RfQ09MT1IsW25mXTpzLk9ORV9NSU5VU19EU1RfQUxQSEEsW29mXTpzLkNPTlNUQU5UX0NPTE9SLFtsZl06cy5PTkVfTUlOVVNfQ09OU1RBTlRfQ09MT1IsW2NmXTpzLkNPTlNUQU5UX0FMUEhBLFtoZl06cy5PTkVfTUlOVVNfQ09OU1RBTlRfQUxQSEF9O2Z1bmN0aW9uIFkoUCxydCxhdCxNdCx3dCxLdCxuZSxUZSxRZSxpZSl7aWYoUD09PVVuKXtwPT09ITAmJihPdChzLkJMRU5EKSxwPSExKTtyZXR1cm59aWYocD09PSExJiYoeXQocy5CTEVORCkscD0hMCksUCE9PVpkKXtpZihQIT09dnx8aWUhPT13KXtpZigoeCE9PSRufHxBIT09JG4pJiYocy5ibGVuZEVxdWF0aW9uKHMuRlVOQ19BREQpLHg9JG4sQT0kbiksaWUpc3dpdGNoKFApe2Nhc2UgVGk6cy5ibGVuZEZ1bmNTZXBhcmF0ZShzLk9ORSxzLk9ORV9NSU5VU19TUkNfQUxQSEEscy5PTkUscy5PTkVfTUlOVVNfU1JDX0FMUEhBKTticmVhaztjYXNlIFpsOnMuYmxlbmRGdW5jKHMuT05FLHMuT05FKTticmVhaztjYXNlIEpsOnMuYmxlbmRGdW5jU2VwYXJhdGUocy5aRVJPLHMuT05FX01JTlVTX1NSQ19DT0xPUixzLlpFUk8scy5PTkUpO2JyZWFrO2Nhc2UgJGw6cy5ibGVuZEZ1bmNTZXBhcmF0ZShzLlpFUk8scy5TUkNfQ09MT1Iscy5aRVJPLHMuU1JDX0FMUEhBKTticmVhaztkZWZhdWx0OmNvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMU3RhdGU6IEludmFsaWQgYmxlbmRpbmc6ICIsUCk7YnJlYWt9ZWxzZSBzd2l0Y2goUCl7Y2FzZSBUaTpzLmJsZW5kRnVuY1NlcGFyYXRlKHMuU1JDX0FMUEhBLHMuT05FX01JTlVTX1NSQ19BTFBIQSxzLk9ORSxzLk9ORV9NSU5VU19TUkNfQUxQSEEpO2JyZWFrO2Nhc2UgWmw6cy5ibGVuZEZ1bmMocy5TUkNfQUxQSEEscy5PTkUpO2JyZWFrO2Nhc2UgSmw6cy5ibGVuZEZ1bmNTZXBhcmF0ZShzLlpFUk8scy5PTkVfTUlOVVNfU1JDX0NPTE9SLHMuWkVSTyxzLk9ORSk7YnJlYWs7Y2FzZSAkbDpzLmJsZW5kRnVuYyhzLlpFUk8scy5TUkNfQ09MT1IpO2JyZWFrO2RlZmF1bHQ6Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xTdGF0ZTogSW52YWxpZCBibGVuZGluZzogIixQKTticmVha31NPW51bGwsQz1udWxsLFQ9bnVsbCxVPW51bGwsay5zZXQoMCwwLDApLHk9MCx2PVAsdz1pZX1yZXR1cm59d3Q9d3R8fHJ0LEt0PUt0fHxhdCxuZT1uZXx8TXQsKHJ0IT09eHx8d3QhPT1BKSYmKHMuYmxlbmRFcXVhdGlvblNlcGFyYXRlKFhbcnRdLFhbd3RdKSx4PXJ0LEE9d3QpLChhdCE9PU18fE10IT09Q3x8S3QhPT1UfHxuZSE9PVUpJiYocy5ibGVuZEZ1bmNTZXBhcmF0ZShzdFthdF0sc3RbTXRdLHN0W0t0XSxzdFtuZV0pLE09YXQsQz1NdCxUPUt0LFU9bmUpLChUZS5lcXVhbHMoayk9PT0hMXx8UWUhPT15KSYmKHMuYmxlbmRDb2xvcihUZS5yLFRlLmcsVGUuYixRZSksay5jb3B5KFRlKSx5PVFlKSx2PVAsdz0hMX1mdW5jdGlvbiBidChQLHJ0KXtQLnNpZGU9PT1mbj9PdChzLkNVTExfRkFDRSk6eXQocy5DVUxMX0ZBQ0UpO2xldCBhdD1QLnNpZGU9PT1WZTtydCYmKGF0PSFhdCksaHQoYXQpLFAuYmxlbmRpbmc9PT1UaSYmUC50cmFuc3BhcmVudD09PSExP1koVW4pOlkoUC5ibGVuZGluZyxQLmJsZW5kRXF1YXRpb24sUC5ibGVuZFNyYyxQLmJsZW5kRHN0LFAuYmxlbmRFcXVhdGlvbkFscGhhLFAuYmxlbmRTcmNBbHBoYSxQLmJsZW5kRHN0QWxwaGEsUC5ibGVuZENvbG9yLFAuYmxlbmRBbHBoYSxQLnByZW11bHRpcGxpZWRBbHBoYSksbC5zZXRGdW5jKFAuZGVwdGhGdW5jKSxsLnNldFRlc3QoUC5kZXB0aFRlc3QpLGwuc2V0TWFzayhQLmRlcHRoV3JpdGUpLG8uc2V0TWFzayhQLmNvbG9yV3JpdGUpO2xldCBNdD1QLnN0ZW5jaWxXcml0ZTtjLnNldFRlc3QoTXQpLE10JiYoYy5zZXRNYXNrKFAuc3RlbmNpbFdyaXRlTWFzayksYy5zZXRGdW5jKFAuc3RlbmNpbEZ1bmMsUC5zdGVuY2lsUmVmLFAuc3RlbmNpbEZ1bmNNYXNrKSxjLnNldE9wKFAuc3RlbmNpbEZhaWwsUC5zdGVuY2lsWkZhaWwsUC5zdGVuY2lsWlBhc3MpKSxOKFAucG9seWdvbk9mZnNldCxQLnBvbHlnb25PZmZzZXRGYWN0b3IsUC5wb2x5Z29uT2Zmc2V0VW5pdHMpLFAuYWxwaGFUb0NvdmVyYWdlPT09ITA/eXQocy5TQU1QTEVfQUxQSEFfVE9fQ09WRVJBR0UpOk90KHMuU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFKX1mdW5jdGlvbiBodChQKXtHIT09UCYmKFA/cy5mcm9udEZhY2Uocy5DVyk6cy5mcm9udEZhY2Uocy5DQ1cpLEc9UCl9ZnVuY3Rpb24gYihQKXtQIT09WGQ/KHl0KHMuQ1VMTF9GQUNFKSxQIT09SiYmKFA9PT1ZbD9zLmN1bGxGYWNlKHMuQkFDSyk6UD09PXFkP3MuY3VsbEZhY2Uocy5GUk9OVCk6cy5jdWxsRmFjZShzLkZST05UX0FORF9CQUNLKSkpOk90KHMuQ1VMTF9GQUNFKSxKPVB9ZnVuY3Rpb24gUyhQKXtQIT09SSYmKHEmJnMubGluZVdpZHRoKFApLEk9UCl9ZnVuY3Rpb24gTihQLHJ0LGF0KXtQPyh5dChzLlBPTFlHT05fT0ZGU0VUX0ZJTEwpLCh6IT09cnR8fEYhPT1hdCkmJihzLnBvbHlnb25PZmZzZXQocnQsYXQpLHo9cnQsRj1hdCkpOk90KHMuUE9MWUdPTl9PRkZTRVRfRklMTCl9ZnVuY3Rpb24gbnQoUCl7UD95dChzLlNDSVNTT1JfVEVTVCk6T3Qocy5TQ0lTU09SX1RFU1QpfWZ1bmN0aW9uIGooUCl7UD09PXZvaWQgMCYmKFA9cy5URVhUVVJFMCskLTEpLFEhPT1QJiYocy5hY3RpdmVUZXh0dXJlKFApLFE9UCl9ZnVuY3Rpb24gSyhQLHJ0LGF0KXthdD09PXZvaWQgMCYmKFE9PT1udWxsP2F0PXMuVEVYVFVSRTArJC0xOmF0PVEpO2xldCBNdD1mdFthdF07TXQ9PT12b2lkIDAmJihNdD17dHlwZTp2b2lkIDAsdGV4dHVyZTp2b2lkIDB9LGZ0W2F0XT1NdCksKE10LnR5cGUhPT1QfHxNdC50ZXh0dXJlIT09cnQpJiYoUSE9PWF0JiYocy5hY3RpdmVUZXh0dXJlKGF0KSxRPWF0KSxzLmJpbmRUZXh0dXJlKFAscnR8fEV0W1BdKSxNdC50eXBlPVAsTXQudGV4dHVyZT1ydCl9ZnVuY3Rpb24geHQoKXtsZXQgUD1mdFtRXTtQIT09dm9pZCAwJiZQLnR5cGUhPT12b2lkIDAmJihzLmJpbmRUZXh0dXJlKFAudHlwZSxudWxsKSxQLnR5cGU9dm9pZCAwLFAudGV4dHVyZT12b2lkIDApfWZ1bmN0aW9uIGN0KCl7dHJ5e3MuY29tcHJlc3NlZFRleEltYWdlMkQuYXBwbHkocyxhcmd1bWVudHMpfWNhdGNoKFApe2NvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMU3RhdGU6IixQKX19ZnVuY3Rpb24gbXQoKXt0cnl7cy5jb21wcmVzc2VkVGV4SW1hZ2UzRC5hcHBseShzLGFyZ3VtZW50cyl9Y2F0Y2goUCl7Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xTdGF0ZToiLFApfX1mdW5jdGlvbiBSdCgpe3RyeXtzLnRleFN1YkltYWdlMkQuYXBwbHkocyxhcmd1bWVudHMpfWNhdGNoKFApe2NvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMU3RhdGU6IixQKX19ZnVuY3Rpb24gRnQoKXt0cnl7cy50ZXhTdWJJbWFnZTNELmFwcGx5KHMsYXJndW1lbnRzKX1jYXRjaChQKXtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFN0YXRlOiIsUCl9fWZ1bmN0aW9uIHR0KCl7dHJ5e3MuY29tcHJlc3NlZFRleFN1YkltYWdlMkQuYXBwbHkocyxhcmd1bWVudHMpfWNhdGNoKFApe2NvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMU3RhdGU6IixQKX19ZnVuY3Rpb24gWXQoKXt0cnl7cy5jb21wcmVzc2VkVGV4U3ViSW1hZ2UzRC5hcHBseShzLGFyZ3VtZW50cyl9Y2F0Y2goUCl7Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xTdGF0ZToiLFApfX1mdW5jdGlvbiBYdCgpe3RyeXtzLnRleFN0b3JhZ2UyRC5hcHBseShzLGFyZ3VtZW50cyl9Y2F0Y2goUCl7Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xTdGF0ZToiLFApfX1mdW5jdGlvbiBVdCgpe3RyeXtzLnRleFN0b3JhZ2UzRC5hcHBseShzLGFyZ3VtZW50cyl9Y2F0Y2goUCl7Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xTdGF0ZToiLFApfX1mdW5jdGlvbiBUdCgpe3RyeXtzLnRleEltYWdlMkQuYXBwbHkocyxhcmd1bWVudHMpfWNhdGNoKFApe2NvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMU3RhdGU6IixQKX19ZnVuY3Rpb24gX3QoKXt0cnl7cy50ZXhJbWFnZTNELmFwcGx5KHMsYXJndW1lbnRzKX1jYXRjaChQKXtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFN0YXRlOiIsUCl9fWZ1bmN0aW9uIFZ0KFApe2l0LmVxdWFscyhQKT09PSExJiYocy5zY2lzc29yKFAueCxQLnksUC56LFAudyksaXQuY29weShQKSl9ZnVuY3Rpb24gJHQoUCl7cHQuZXF1YWxzKFApPT09ITEmJihzLnZpZXdwb3J0KFAueCxQLnksUC56LFAudykscHQuY29weShQKSl9ZnVuY3Rpb24gcmUoUCxydCl7bGV0IGF0PXUuZ2V0KHJ0KTthdD09PXZvaWQgMCYmKGF0PW5ldyBXZWFrTWFwLHUuc2V0KHJ0LGF0KSk7bGV0IE10PWF0LmdldChQKTtNdD09PXZvaWQgMCYmKE10PXMuZ2V0VW5pZm9ybUJsb2NrSW5kZXgocnQsUC5uYW1lKSxhdC5zZXQoUCxNdCkpfWZ1bmN0aW9uIHF0KFAscnQpe2xldCBNdD11LmdldChydCkuZ2V0KFApO2guZ2V0KHJ0KSE9PU10JiYocy51bmlmb3JtQmxvY2tCaW5kaW5nKHJ0LE10LFAuX19iaW5kaW5nUG9pbnRJbmRleCksaC5zZXQocnQsTXQpKX1mdW5jdGlvbiBlZSgpe3MuZGlzYWJsZShzLkJMRU5EKSxzLmRpc2FibGUocy5DVUxMX0ZBQ0UpLHMuZGlzYWJsZShzLkRFUFRIX1RFU1QpLHMuZGlzYWJsZShzLlBPTFlHT05fT0ZGU0VUX0ZJTEwpLHMuZGlzYWJsZShzLlNDSVNTT1JfVEVTVCkscy5kaXNhYmxlKHMuU1RFTkNJTF9URVNUKSxzLmRpc2FibGUocy5TQU1QTEVfQUxQSEFfVE9fQ09WRVJBR0UpLHMuYmxlbmRFcXVhdGlvbihzLkZVTkNfQUREKSxzLmJsZW5kRnVuYyhzLk9ORSxzLlpFUk8pLHMuYmxlbmRGdW5jU2VwYXJhdGUocy5PTkUscy5aRVJPLHMuT05FLHMuWkVSTykscy5ibGVuZENvbG9yKDAsMCwwLDApLHMuY29sb3JNYXNrKCEwLCEwLCEwLCEwKSxzLmNsZWFyQ29sb3IoMCwwLDAsMCkscy5kZXB0aE1hc2soITApLHMuZGVwdGhGdW5jKHMuTEVTUykscy5jbGVhckRlcHRoKDEpLHMuc3RlbmNpbE1hc2soNDI5NDk2NzI5NSkscy5zdGVuY2lsRnVuYyhzLkFMV0FZUywwLDQyOTQ5NjcyOTUpLHMuc3RlbmNpbE9wKHMuS0VFUCxzLktFRVAscy5LRUVQKSxzLmNsZWFyU3RlbmNpbCgwKSxzLmN1bGxGYWNlKHMuQkFDSykscy5mcm9udEZhY2Uocy5DQ1cpLHMucG9seWdvbk9mZnNldCgwLDApLHMuYWN0aXZlVGV4dHVyZShzLlRFWFRVUkUwKSxzLmJpbmRGcmFtZWJ1ZmZlcihzLkZSQU1FQlVGRkVSLG51bGwpLG49PT0hMCYmKHMuYmluZEZyYW1lYnVmZmVyKHMuRFJBV19GUkFNRUJVRkZFUixudWxsKSxzLmJpbmRGcmFtZWJ1ZmZlcihzLlJFQURfRlJBTUVCVUZGRVIsbnVsbCkpLHMudXNlUHJvZ3JhbShudWxsKSxzLmxpbmVXaWR0aCgxKSxzLnNjaXNzb3IoMCwwLHMuY2FudmFzLndpZHRoLHMuY2FudmFzLmhlaWdodCkscy52aWV3cG9ydCgwLDAscy5jYW52YXMud2lkdGgscy5jYW52YXMuaGVpZ2h0KSxkPXt9LFE9bnVsbCxmdD17fSxmPXt9LG09bmV3IFdlYWtNYXAsXz1bXSxnPW51bGwscD0hMSx2PW51bGwseD1udWxsLE09bnVsbCxDPW51bGwsQT1udWxsLFQ9bnVsbCxVPW51bGwsaz1uZXcgdXQoMCwwLDApLHk9MCx3PSExLEc9bnVsbCxKPW51bGwsST1udWxsLHo9bnVsbCxGPW51bGwsaXQuc2V0KDAsMCxzLmNhbnZhcy53aWR0aCxzLmNhbnZhcy5oZWlnaHQpLHB0LnNldCgwLDAscy5jYW52YXMud2lkdGgscy5jYW52YXMuaGVpZ2h0KSxvLnJlc2V0KCksbC5yZXNldCgpLGMucmVzZXQoKX1yZXR1cm57YnVmZmVyczp7Y29sb3I6byxkZXB0aDpsLHN0ZW5jaWw6Y30sZW5hYmxlOnl0LGRpc2FibGU6T3QsYmluZEZyYW1lYnVmZmVyOkF0LGRyYXdCdWZmZXJzOkwsdXNlUHJvZ3JhbTpvdCxzZXRCbGVuZGluZzpZLHNldE1hdGVyaWFsOmJ0LHNldEZsaXBTaWRlZDpodCxzZXRDdWxsRmFjZTpiLHNldExpbmVXaWR0aDpTLHNldFBvbHlnb25PZmZzZXQ6TixzZXRTY2lzc29yVGVzdDpudCxhY3RpdmVUZXh0dXJlOmosYmluZFRleHR1cmU6Syx1bmJpbmRUZXh0dXJlOnh0LGNvbXByZXNzZWRUZXhJbWFnZTJEOmN0LGNvbXByZXNzZWRUZXhJbWFnZTNEOm10LHRleEltYWdlMkQ6VHQsdGV4SW1hZ2UzRDpfdCx1cGRhdGVVQk9NYXBwaW5nOnJlLHVuaWZvcm1CbG9ja0JpbmRpbmc6cXQsdGV4U3RvcmFnZTJEOlh0LHRleFN0b3JhZ2UzRDpVdCx0ZXhTdWJJbWFnZTJEOlJ0LHRleFN1YkltYWdlM0Q6RnQsY29tcHJlc3NlZFRleFN1YkltYWdlMkQ6dHQsY29tcHJlc3NlZFRleFN1YkltYWdlM0Q6WXQsc2Npc3NvcjpWdCx2aWV3cG9ydDokdCxyZXNldDplZX19ZnVuY3Rpb24gbHYocyx0LGUsbixpLHIsYSl7bGV0IG89aS5pc1dlYkdMMixsPXQuaGFzKCJXRUJHTF9tdWx0aXNhbXBsZWRfcmVuZGVyX3RvX3RleHR1cmUiKT90LmdldCgiV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlIik6bnVsbCxjPXR5cGVvZiBuYXZpZ2F0b3I+InUiPyExOi9PY3VsdXNCcm93c2VyL2cudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxoPW5ldyBXZWFrTWFwLHUsZD1uZXcgV2Vha01hcCxmPSExO3RyeXtmPXR5cGVvZiBPZmZzY3JlZW5DYW52YXM8InUiJiZuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsMSkuZ2V0Q29udGV4dCgiMmQiKSE9PW51bGx9Y2F0Y2h7fWZ1bmN0aW9uIG0oYixTKXtyZXR1cm4gZj9uZXcgT2Zmc2NyZWVuQ2FudmFzKGIsUyk6cnIoImNhbnZhcyIpfWZ1bmN0aW9uIF8oYixTLE4sbnQpe2xldCBqPTE7aWYoKGIud2lkdGg+bnR8fGIuaGVpZ2h0Pm50KSYmKGo9bnQvTWF0aC5tYXgoYi53aWR0aCxiLmhlaWdodCkpLGo8MXx8Uz09PSEwKWlmKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50PCJ1IiYmYiBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnR8fHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudDwidSImJmIgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudHx8dHlwZW9mIEltYWdlQml0bWFwPCJ1IiYmYiBpbnN0YW5jZW9mIEltYWdlQml0bWFwKXtsZXQgSz1TP2thOk1hdGguZmxvb3IseHQ9SyhqKmIud2lkdGgpLGN0PUsoaipiLmhlaWdodCk7dT09PXZvaWQgMCYmKHU9bSh4dCxjdCkpO2xldCBtdD1OP20oeHQsY3QpOnU7cmV0dXJuIG10LndpZHRoPXh0LG10LmhlaWdodD1jdCxtdC5nZXRDb250ZXh0KCIyZCIpLmRyYXdJbWFnZShiLDAsMCx4dCxjdCksY29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGhhcyBiZWVuIHJlc2l6ZWQgZnJvbSAoIitiLndpZHRoKyJ4IitiLmhlaWdodCsiKSB0byAoIit4dCsieCIrY3QrIikuIiksbXR9ZWxzZSByZXR1cm4iZGF0YSJpbiBiJiZjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUmVuZGVyZXI6IEltYWdlIGluIERhdGFUZXh0dXJlIGlzIHRvbyBiaWcgKCIrYi53aWR0aCsieCIrYi5oZWlnaHQrIikuIiksYjtyZXR1cm4gYn1mdW5jdGlvbiBnKGIpe3JldHVybiB3YyhiLndpZHRoKSYmd2MoYi5oZWlnaHQpfWZ1bmN0aW9uIHAoYil7cmV0dXJuIG8/ITE6Yi53cmFwUyE9PVVlfHxiLndyYXBUIT09VWV8fGIubWluRmlsdGVyIT09bWUmJmIubWluRmlsdGVyIT09b2V9ZnVuY3Rpb24gdihiLFMpe3JldHVybiBiLmdlbmVyYXRlTWlwbWFwcyYmUyYmYi5taW5GaWx0ZXIhPT1tZSYmYi5taW5GaWx0ZXIhPT1vZX1mdW5jdGlvbiB4KGIpe3MuZ2VuZXJhdGVNaXBtYXAoYil9ZnVuY3Rpb24gTShiLFMsTixudCxqPSExKXtpZihvPT09ITEpcmV0dXJuIFM7aWYoYiE9PW51bGwpe2lmKHNbYl0hPT12b2lkIDApcmV0dXJuIHNbYl07Y29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIHVzZSBub24tZXhpc3RpbmcgV2ViR0wgaW50ZXJuYWwgZm9ybWF0ICciK2IrIiciKX1sZXQgSz1TO2lmKFM9PT1zLlJFRCYmKE49PT1zLkZMT0FUJiYoSz1zLlIzMkYpLE49PT1zLkhBTEZfRkxPQVQmJihLPXMuUjE2RiksTj09PXMuVU5TSUdORURfQllURSYmKEs9cy5SOCkpLFM9PT1zLlJFRF9JTlRFR0VSJiYoTj09PXMuVU5TSUdORURfQllURSYmKEs9cy5SOFVJKSxOPT09cy5VTlNJR05FRF9TSE9SVCYmKEs9cy5SMTZVSSksTj09PXMuVU5TSUdORURfSU5UJiYoSz1zLlIzMlVJKSxOPT09cy5CWVRFJiYoSz1zLlI4SSksTj09PXMuU0hPUlQmJihLPXMuUjE2SSksTj09PXMuSU5UJiYoSz1zLlIzMkkpKSxTPT09cy5SRyYmKE49PT1zLkZMT0FUJiYoSz1zLlJHMzJGKSxOPT09cy5IQUxGX0ZMT0FUJiYoSz1zLlJHMTZGKSxOPT09cy5VTlNJR05FRF9CWVRFJiYoSz1zLlJHOCkpLFM9PT1zLlJHQkEpe2xldCB4dD1qP3RyOmp0LmdldFRyYW5zZmVyKG50KTtOPT09cy5GTE9BVCYmKEs9cy5SR0JBMzJGKSxOPT09cy5IQUxGX0ZMT0FUJiYoSz1zLlJHQkExNkYpLE49PT1zLlVOU0lHTkVEX0JZVEUmJihLPXh0PT09c2U/cy5TUkdCOF9BTFBIQTg6cy5SR0JBOCksTj09PXMuVU5TSUdORURfU0hPUlRfNF80XzRfNCYmKEs9cy5SR0JBNCksTj09PXMuVU5TSUdORURfU0hPUlRfNV81XzVfMSYmKEs9cy5SR0I1X0ExKX1yZXR1cm4oSz09PXMuUjE2Rnx8Sz09PXMuUjMyRnx8Sz09PXMuUkcxNkZ8fEs9PT1zLlJHMzJGfHxLPT09cy5SR0JBMTZGfHxLPT09cy5SR0JBMzJGKSYmdC5nZXQoIkVYVF9jb2xvcl9idWZmZXJfZmxvYXQiKSxLfWZ1bmN0aW9uIEMoYixTLE4pe3JldHVybiB2KGIsTik9PT0hMHx8Yi5pc0ZyYW1lYnVmZmVyVGV4dHVyZSYmYi5taW5GaWx0ZXIhPT1tZSYmYi5taW5GaWx0ZXIhPT1vZT9NYXRoLmxvZzIoTWF0aC5tYXgoUy53aWR0aCxTLmhlaWdodCkpKzE6Yi5taXBtYXBzIT09dm9pZCAwJiZiLm1pcG1hcHMubGVuZ3RoPjA/Yi5taXBtYXBzLmxlbmd0aDpiLmlzQ29tcHJlc3NlZFRleHR1cmUmJkFycmF5LmlzQXJyYXkoYi5pbWFnZSk/Uy5taXBtYXBzLmxlbmd0aDoxfWZ1bmN0aW9uIEEoYil7cmV0dXJuIGI9PT1tZXx8Yj09PXphfHxiPT09TWk/cy5ORUFSRVNUOnMuTElORUFSfWZ1bmN0aW9uIFQoYil7bGV0IFM9Yi50YXJnZXQ7Uy5yZW1vdmVFdmVudExpc3RlbmVyKCJkaXNwb3NlIixUKSxrKFMpLFMuaXNWaWRlb1RleHR1cmUmJmguZGVsZXRlKFMpfWZ1bmN0aW9uIFUoYil7bGV0IFM9Yi50YXJnZXQ7Uy5yZW1vdmVFdmVudExpc3RlbmVyKCJkaXNwb3NlIixVKSx3KFMpfWZ1bmN0aW9uIGsoYil7bGV0IFM9bi5nZXQoYik7aWYoUy5fX3dlYmdsSW5pdD09PXZvaWQgMClyZXR1cm47bGV0IE49Yi5zb3VyY2UsbnQ9ZC5nZXQoTik7aWYobnQpe2xldCBqPW50W1MuX19jYWNoZUtleV07ai51c2VkVGltZXMtLSxqLnVzZWRUaW1lcz09PTAmJnkoYiksT2JqZWN0LmtleXMobnQpLmxlbmd0aD09PTAmJmQuZGVsZXRlKE4pfW4ucmVtb3ZlKGIpfWZ1bmN0aW9uIHkoYil7bGV0IFM9bi5nZXQoYik7cy5kZWxldGVUZXh0dXJlKFMuX193ZWJnbFRleHR1cmUpO2xldCBOPWIuc291cmNlLG50PWQuZ2V0KE4pO2RlbGV0ZSBudFtTLl9fY2FjaGVLZXldLGEubWVtb3J5LnRleHR1cmVzLS19ZnVuY3Rpb24gdyhiKXtsZXQgUz1iLnRleHR1cmUsTj1uLmdldChiKSxudD1uLmdldChTKTtpZihudC5fX3dlYmdsVGV4dHVyZSE9PXZvaWQgMCYmKHMuZGVsZXRlVGV4dHVyZShudC5fX3dlYmdsVGV4dHVyZSksYS5tZW1vcnkudGV4dHVyZXMtLSksYi5kZXB0aFRleHR1cmUmJmIuZGVwdGhUZXh0dXJlLmRpc3Bvc2UoKSxiLmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0KWZvcihsZXQgaj0wO2o8NjtqKyspe2lmKEFycmF5LmlzQXJyYXkoTi5fX3dlYmdsRnJhbWVidWZmZXJbal0pKWZvcihsZXQgSz0wO0s8Ti5fX3dlYmdsRnJhbWVidWZmZXJbal0ubGVuZ3RoO0srKylzLmRlbGV0ZUZyYW1lYnVmZmVyKE4uX193ZWJnbEZyYW1lYnVmZmVyW2pdW0tdKTtlbHNlIHMuZGVsZXRlRnJhbWVidWZmZXIoTi5fX3dlYmdsRnJhbWVidWZmZXJbal0pO04uX193ZWJnbERlcHRoYnVmZmVyJiZzLmRlbGV0ZVJlbmRlcmJ1ZmZlcihOLl9fd2ViZ2xEZXB0aGJ1ZmZlcltqXSl9ZWxzZXtpZihBcnJheS5pc0FycmF5KE4uX193ZWJnbEZyYW1lYnVmZmVyKSlmb3IobGV0IGo9MDtqPE4uX193ZWJnbEZyYW1lYnVmZmVyLmxlbmd0aDtqKyspcy5kZWxldGVGcmFtZWJ1ZmZlcihOLl9fd2ViZ2xGcmFtZWJ1ZmZlcltqXSk7ZWxzZSBzLmRlbGV0ZUZyYW1lYnVmZmVyKE4uX193ZWJnbEZyYW1lYnVmZmVyKTtpZihOLl9fd2ViZ2xEZXB0aGJ1ZmZlciYmcy5kZWxldGVSZW5kZXJidWZmZXIoTi5fX3dlYmdsRGVwdGhidWZmZXIpLE4uX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyJiZzLmRlbGV0ZUZyYW1lYnVmZmVyKE4uX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyKSxOLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlcilmb3IobGV0IGo9MDtqPE4uX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyLmxlbmd0aDtqKyspTi5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbal0mJnMuZGVsZXRlUmVuZGVyYnVmZmVyKE4uX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyW2pdKTtOLl9fd2ViZ2xEZXB0aFJlbmRlcmJ1ZmZlciYmcy5kZWxldGVSZW5kZXJidWZmZXIoTi5fX3dlYmdsRGVwdGhSZW5kZXJidWZmZXIpfWlmKGIuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cylmb3IobGV0IGo9MCxLPVMubGVuZ3RoO2o8SztqKyspe2xldCB4dD1uLmdldChTW2pdKTt4dC5fX3dlYmdsVGV4dHVyZSYmKHMuZGVsZXRlVGV4dHVyZSh4dC5fX3dlYmdsVGV4dHVyZSksYS5tZW1vcnkudGV4dHVyZXMtLSksbi5yZW1vdmUoU1tqXSl9bi5yZW1vdmUoUyksbi5yZW1vdmUoYil9bGV0IEc9MDtmdW5jdGlvbiBKKCl7Rz0wfWZ1bmN0aW9uIEkoKXtsZXQgYj1HO3JldHVybiBiPj1pLm1heFRleHR1cmVzJiZjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMVGV4dHVyZXM6IFRyeWluZyB0byB1c2UgIitiKyIgdGV4dHVyZSB1bml0cyB3aGlsZSB0aGlzIEdQVSBzdXBwb3J0cyBvbmx5ICIraS5tYXhUZXh0dXJlcyksRys9MSxifWZ1bmN0aW9uIHooYil7bGV0IFM9W107cmV0dXJuIFMucHVzaChiLndyYXBTKSxTLnB1c2goYi53cmFwVCksUy5wdXNoKGIud3JhcFJ8fDApLFMucHVzaChiLm1hZ0ZpbHRlciksUy5wdXNoKGIubWluRmlsdGVyKSxTLnB1c2goYi5hbmlzb3Ryb3B5KSxTLnB1c2goYi5pbnRlcm5hbEZvcm1hdCksUy5wdXNoKGIuZm9ybWF0KSxTLnB1c2goYi50eXBlKSxTLnB1c2goYi5nZW5lcmF0ZU1pcG1hcHMpLFMucHVzaChiLnByZW11bHRpcGx5QWxwaGEpLFMucHVzaChiLmZsaXBZKSxTLnB1c2goYi51bnBhY2tBbGlnbm1lbnQpLFMucHVzaChiLmNvbG9yU3BhY2UpLFMuam9pbigpfWZ1bmN0aW9uIEYoYixTKXtsZXQgTj1uLmdldChiKTtpZihiLmlzVmlkZW9UZXh0dXJlJiZidChiKSxiLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT09PSExJiZiLnZlcnNpb24+MCYmTi5fX3ZlcnNpb24hPT1iLnZlcnNpb24pe2xldCBudD1iLmltYWdlO2lmKG50PT09bnVsbCljb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IG5vIGltYWdlIGRhdGEgZm91bmQuIik7ZWxzZSBpZihudC5jb21wbGV0ZT09PSExKWNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgaW5jb21wbGV0ZSIpO2Vsc2V7aXQoTixiLFMpO3JldHVybn19ZS5iaW5kVGV4dHVyZShzLlRFWFRVUkVfMkQsTi5fX3dlYmdsVGV4dHVyZSxzLlRFWFRVUkUwK1MpfWZ1bmN0aW9uICQoYixTKXtsZXQgTj1uLmdldChiKTtpZihiLnZlcnNpb24+MCYmTi5fX3ZlcnNpb24hPT1iLnZlcnNpb24pe2l0KE4sYixTKTtyZXR1cm59ZS5iaW5kVGV4dHVyZShzLlRFWFRVUkVfMkRfQVJSQVksTi5fX3dlYmdsVGV4dHVyZSxzLlRFWFRVUkUwK1MpfWZ1bmN0aW9uIHEoYixTKXtsZXQgTj1uLmdldChiKTtpZihiLnZlcnNpb24+MCYmTi5fX3ZlcnNpb24hPT1iLnZlcnNpb24pe2l0KE4sYixTKTtyZXR1cm59ZS5iaW5kVGV4dHVyZShzLlRFWFRVUkVfM0QsTi5fX3dlYmdsVGV4dHVyZSxzLlRFWFRVUkUwK1MpfWZ1bmN0aW9uIFcoYixTKXtsZXQgTj1uLmdldChiKTtpZihiLnZlcnNpb24+MCYmTi5fX3ZlcnNpb24hPT1iLnZlcnNpb24pe3B0KE4sYixTKTtyZXR1cm59ZS5iaW5kVGV4dHVyZShzLlRFWFRVUkVfQ1VCRV9NQVAsTi5fX3dlYmdsVGV4dHVyZSxzLlRFWFRVUkUwK1MpfWxldCBldD17W0pzXTpzLlJFUEVBVCxbVWVdOnMuQ0xBTVBfVE9fRURHRSxbJHNdOnMuTUlSUk9SRURfUkVQRUFUfSxRPXtbbWVdOnMuTkVBUkVTVCxbemFdOnMuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCxbTWldOnMuTkVBUkVTVF9NSVBNQVBfTElORUFSLFtvZV06cy5MSU5FQVIsW2tzXTpzLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCxbcG5dOnMuTElORUFSX01JUE1BUF9MSU5FQVJ9LGZ0PXtba2ZdOnMuTkVWRVIsW1lmXTpzLkFMV0FZUyxbSGZdOnMuTEVTUyxbZXVdOnMuTEVRVUFMLFtHZl06cy5FUVVBTCxbcWZdOnMuR0VRVUFMLFtXZl06cy5HUkVBVEVSLFtYZl06cy5OT1RFUVVBTH07ZnVuY3Rpb24gUHQoYixTLE4pe2lmKFMudHlwZT09PWVuJiZ0LmhhcygiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyIik9PT0hMSYmKFMubWFnRmlsdGVyPT09b2V8fFMubWFnRmlsdGVyPT09a3N8fFMubWFnRmlsdGVyPT09TWl8fFMubWFnRmlsdGVyPT09cG58fFMubWluRmlsdGVyPT09b2V8fFMubWluRmlsdGVyPT09a3N8fFMubWluRmlsdGVyPT09TWl8fFMubWluRmlsdGVyPT09cG4pJiZjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUmVuZGVyZXI6IFVuYWJsZSB0byB1c2UgbGluZWFyIGZpbHRlcmluZyB3aXRoIGZsb2F0aW5nIHBvaW50IHRleHR1cmVzLiBPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXIgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZS4iKSxOPyhzLnRleFBhcmFtZXRlcmkoYixzLlRFWFRVUkVfV1JBUF9TLGV0W1Mud3JhcFNdKSxzLnRleFBhcmFtZXRlcmkoYixzLlRFWFRVUkVfV1JBUF9ULGV0W1Mud3JhcFRdKSwoYj09PXMuVEVYVFVSRV8zRHx8Yj09PXMuVEVYVFVSRV8yRF9BUlJBWSkmJnMudGV4UGFyYW1ldGVyaShiLHMuVEVYVFVSRV9XUkFQX1IsZXRbUy53cmFwUl0pLHMudGV4UGFyYW1ldGVyaShiLHMuVEVYVFVSRV9NQUdfRklMVEVSLFFbUy5tYWdGaWx0ZXJdKSxzLnRleFBhcmFtZXRlcmkoYixzLlRFWFRVUkVfTUlOX0ZJTFRFUixRW1MubWluRmlsdGVyXSkpOihzLnRleFBhcmFtZXRlcmkoYixzLlRFWFRVUkVfV1JBUF9TLHMuQ0xBTVBfVE9fRURHRSkscy50ZXhQYXJhbWV0ZXJpKGIscy5URVhUVVJFX1dSQVBfVCxzLkNMQU1QX1RPX0VER0UpLChiPT09cy5URVhUVVJFXzNEfHxiPT09cy5URVhUVVJFXzJEX0FSUkFZKSYmcy50ZXhQYXJhbWV0ZXJpKGIscy5URVhUVVJFX1dSQVBfUixzLkNMQU1QX1RPX0VER0UpLChTLndyYXBTIT09VWV8fFMud3JhcFQhPT1VZSkmJmNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBpcyBub3QgcG93ZXIgb2YgdHdvLiBUZXh0dXJlLndyYXBTIGFuZCBUZXh0dXJlLndyYXBUIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZy4iKSxzLnRleFBhcmFtZXRlcmkoYixzLlRFWFRVUkVfTUFHX0ZJTFRFUixBKFMubWFnRmlsdGVyKSkscy50ZXhQYXJhbWV0ZXJpKGIscy5URVhUVVJFX01JTl9GSUxURVIsQShTLm1pbkZpbHRlcikpLFMubWluRmlsdGVyIT09bWUmJlMubWluRmlsdGVyIT09b2UmJmNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBpcyBub3QgcG93ZXIgb2YgdHdvLiBUZXh0dXJlLm1pbkZpbHRlciBzaG91bGQgYmUgc2V0IHRvIFRIUkVFLk5lYXJlc3RGaWx0ZXIgb3IgVEhSRUUuTGluZWFyRmlsdGVyLiIpKSxTLmNvbXBhcmVGdW5jdGlvbiYmKHMudGV4UGFyYW1ldGVyaShiLHMuVEVYVFVSRV9DT01QQVJFX01PREUscy5DT01QQVJFX1JFRl9UT19URVhUVVJFKSxzLnRleFBhcmFtZXRlcmkoYixzLlRFWFRVUkVfQ09NUEFSRV9GVU5DLGZ0W1MuY29tcGFyZUZ1bmN0aW9uXSkpLHQuaGFzKCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMiKT09PSEwKXtsZXQgbnQ9dC5nZXQoIkVYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyIpO2lmKFMubWFnRmlsdGVyPT09bWV8fFMubWluRmlsdGVyIT09TWkmJlMubWluRmlsdGVyIT09cG58fFMudHlwZT09PWVuJiZ0LmhhcygiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyIik9PT0hMXx8bz09PSExJiZTLnR5cGU9PT1wcyYmdC5oYXMoIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyIik9PT0hMSlyZXR1cm47KFMuYW5pc290cm9weT4xfHxuLmdldChTKS5fX2N1cnJlbnRBbmlzb3Ryb3B5KSYmKHMudGV4UGFyYW1ldGVyZihiLG50LlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULE1hdGgubWluKFMuYW5pc290cm9weSxpLmdldE1heEFuaXNvdHJvcHkoKSkpLG4uZ2V0KFMpLl9fY3VycmVudEFuaXNvdHJvcHk9Uy5hbmlzb3Ryb3B5KX19ZnVuY3Rpb24gSChiLFMpe2xldCBOPSExO2IuX193ZWJnbEluaXQ9PT12b2lkIDAmJihiLl9fd2ViZ2xJbml0PSEwLFMuYWRkRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsVCkpO2xldCBudD1TLnNvdXJjZSxqPWQuZ2V0KG50KTtqPT09dm9pZCAwJiYoaj17fSxkLnNldChudCxqKSk7bGV0IEs9eihTKTtpZihLIT09Yi5fX2NhY2hlS2V5KXtqW0tdPT09dm9pZCAwJiYoaltLXT17dGV4dHVyZTpzLmNyZWF0ZVRleHR1cmUoKSx1c2VkVGltZXM6MH0sYS5tZW1vcnkudGV4dHVyZXMrKyxOPSEwKSxqW0tdLnVzZWRUaW1lcysrO2xldCB4dD1qW2IuX19jYWNoZUtleV07eHQhPT12b2lkIDAmJihqW2IuX19jYWNoZUtleV0udXNlZFRpbWVzLS0seHQudXNlZFRpbWVzPT09MCYmeShTKSksYi5fX2NhY2hlS2V5PUssYi5fX3dlYmdsVGV4dHVyZT1qW0tdLnRleHR1cmV9cmV0dXJuIE59ZnVuY3Rpb24gaXQoYixTLE4pe2xldCBudD1zLlRFWFRVUkVfMkQ7KFMuaXNEYXRhQXJyYXlUZXh0dXJlfHxTLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSkmJihudD1zLlRFWFRVUkVfMkRfQVJSQVkpLFMuaXNEYXRhM0RUZXh0dXJlJiYobnQ9cy5URVhUVVJFXzNEKTtsZXQgaj1IKGIsUyksSz1TLnNvdXJjZTtlLmJpbmRUZXh0dXJlKG50LGIuX193ZWJnbFRleHR1cmUscy5URVhUVVJFMCtOKTtsZXQgeHQ9bi5nZXQoSyk7aWYoSy52ZXJzaW9uIT09eHQuX192ZXJzaW9ufHxqPT09ITApe2UuYWN0aXZlVGV4dHVyZShzLlRFWFRVUkUwK04pO2xldCBjdD1qdC5nZXRQcmltYXJpZXMoanQud29ya2luZ0NvbG9yU3BhY2UpLG10PVMuY29sb3JTcGFjZT09PXFlP251bGw6anQuZ2V0UHJpbWFyaWVzKFMuY29sb3JTcGFjZSksUnQ9Uy5jb2xvclNwYWNlPT09cWV8fGN0PT09bXQ/cy5OT05FOnMuQlJPV1NFUl9ERUZBVUxUX1dFQkdMO3MucGl4ZWxTdG9yZWkocy5VTlBBQ0tfRkxJUF9ZX1dFQkdMLFMuZmxpcFkpLHMucGl4ZWxTdG9yZWkocy5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsUy5wcmVtdWx0aXBseUFscGhhKSxzLnBpeGVsU3RvcmVpKHMuVU5QQUNLX0FMSUdOTUVOVCxTLnVucGFja0FsaWdubWVudCkscy5waXhlbFN0b3JlaShzLlVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wsUnQpO2xldCBGdD1wKFMpJiZnKFMuaW1hZ2UpPT09ITEsdHQ9XyhTLmltYWdlLEZ0LCExLGkubWF4VGV4dHVyZVNpemUpO3R0PWh0KFMsdHQpO2xldCBZdD1nKHR0KXx8byxYdD1yLmNvbnZlcnQoUy5mb3JtYXQsUy5jb2xvclNwYWNlKSxVdD1yLmNvbnZlcnQoUy50eXBlKSxUdD1NKFMuaW50ZXJuYWxGb3JtYXQsWHQsVXQsUy5jb2xvclNwYWNlLFMuaXNWaWRlb1RleHR1cmUpO1B0KG50LFMsWXQpO2xldCBfdCxWdD1TLm1pcG1hcHMsJHQ9byYmUy5pc1ZpZGVvVGV4dHVyZSE9PSEwJiZUdCE9PVFoLHJlPXh0Ll9fdmVyc2lvbj09PXZvaWQgMHx8aj09PSEwLHF0PUsuZGF0YVJlYWR5LGVlPUMoUyx0dCxZdCk7aWYoUy5pc0RlcHRoVGV4dHVyZSlUdD1zLkRFUFRIX0NPTVBPTkVOVCxvP1MudHlwZT09PWVuP1R0PXMuREVQVEhfQ09NUE9ORU5UMzJGOlMudHlwZT09PUNuP1R0PXMuREVQVEhfQ09NUE9ORU5UMjQ6Uy50eXBlPT09UW4/VHQ9cy5ERVBUSDI0X1NURU5DSUw4OlR0PXMuREVQVEhfQ09NUE9ORU5UMTY6Uy50eXBlPT09ZW4mJmNvbnNvbGUuZXJyb3IoIldlYkdMUmVuZGVyZXI6IEZsb2F0aW5nIHBvaW50IGRlcHRoIHRleHR1cmUgcmVxdWlyZXMgV2ViR0wyLiIpLFMuZm9ybWF0PT09am4mJlR0PT09cy5ERVBUSF9DT01QT05FTlQmJlMudHlwZSE9PWVsJiZTLnR5cGUhPT1DbiYmKGNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogVXNlIFVuc2lnbmVkU2hvcnRUeXBlIG9yIFVuc2lnbmVkSW50VHlwZSBmb3IgRGVwdGhGb3JtYXQgRGVwdGhUZXh0dXJlLiIpLFMudHlwZT1DbixVdD1yLmNvbnZlcnQoUy50eXBlKSksUy5mb3JtYXQ9PT1DaSYmVHQ9PT1zLkRFUFRIX0NPTVBPTkVOVCYmKFR0PXMuREVQVEhfU1RFTkNJTCxTLnR5cGUhPT1RbiYmKGNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogVXNlIFVuc2lnbmVkSW50MjQ4VHlwZSBmb3IgRGVwdGhTdGVuY2lsRm9ybWF0IERlcHRoVGV4dHVyZS4iKSxTLnR5cGU9UW4sVXQ9ci5jb252ZXJ0KFMudHlwZSkpKSxyZSYmKCR0P2UudGV4U3RvcmFnZTJEKHMuVEVYVFVSRV8yRCwxLFR0LHR0LndpZHRoLHR0LmhlaWdodCk6ZS50ZXhJbWFnZTJEKHMuVEVYVFVSRV8yRCwwLFR0LHR0LndpZHRoLHR0LmhlaWdodCwwLFh0LFV0LG51bGwpKTtlbHNlIGlmKFMuaXNEYXRhVGV4dHVyZSlpZihWdC5sZW5ndGg+MCYmWXQpeyR0JiZyZSYmZS50ZXhTdG9yYWdlMkQocy5URVhUVVJFXzJELGVlLFR0LFZ0WzBdLndpZHRoLFZ0WzBdLmhlaWdodCk7Zm9yKGxldCBQPTAscnQ9VnQubGVuZ3RoO1A8cnQ7UCsrKV90PVZ0W1BdLCR0P3F0JiZlLnRleFN1YkltYWdlMkQocy5URVhUVVJFXzJELFAsMCwwLF90LndpZHRoLF90LmhlaWdodCxYdCxVdCxfdC5kYXRhKTplLnRleEltYWdlMkQocy5URVhUVVJFXzJELFAsVHQsX3Qud2lkdGgsX3QuaGVpZ2h0LDAsWHQsVXQsX3QuZGF0YSk7Uy5nZW5lcmF0ZU1pcG1hcHM9ITF9ZWxzZSAkdD8ocmUmJmUudGV4U3RvcmFnZTJEKHMuVEVYVFVSRV8yRCxlZSxUdCx0dC53aWR0aCx0dC5oZWlnaHQpLHF0JiZlLnRleFN1YkltYWdlMkQocy5URVhUVVJFXzJELDAsMCwwLHR0LndpZHRoLHR0LmhlaWdodCxYdCxVdCx0dC5kYXRhKSk6ZS50ZXhJbWFnZTJEKHMuVEVYVFVSRV8yRCwwLFR0LHR0LndpZHRoLHR0LmhlaWdodCwwLFh0LFV0LHR0LmRhdGEpO2Vsc2UgaWYoUy5pc0NvbXByZXNzZWRUZXh0dXJlKWlmKFMuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlKXskdCYmcmUmJmUudGV4U3RvcmFnZTNEKHMuVEVYVFVSRV8yRF9BUlJBWSxlZSxUdCxWdFswXS53aWR0aCxWdFswXS5oZWlnaHQsdHQuZGVwdGgpO2ZvcihsZXQgUD0wLHJ0PVZ0Lmxlbmd0aDtQPHJ0O1ArKylfdD1WdFtQXSxTLmZvcm1hdCE9PUhlP1h0IT09bnVsbD8kdD9xdCYmZS5jb21wcmVzc2VkVGV4U3ViSW1hZ2UzRChzLlRFWFRVUkVfMkRfQVJSQVksUCwwLDAsMCxfdC53aWR0aCxfdC5oZWlnaHQsdHQuZGVwdGgsWHQsX3QuZGF0YSwwLDApOmUuY29tcHJlc3NlZFRleEltYWdlM0Qocy5URVhUVVJFXzJEX0FSUkFZLFAsVHQsX3Qud2lkdGgsX3QuaGVpZ2h0LHR0LmRlcHRoLDAsX3QuZGF0YSwwLDApOmNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnVwbG9hZFRleHR1cmUoKSIpOiR0P3F0JiZlLnRleFN1YkltYWdlM0Qocy5URVhUVVJFXzJEX0FSUkFZLFAsMCwwLDAsX3Qud2lkdGgsX3QuaGVpZ2h0LHR0LmRlcHRoLFh0LFV0LF90LmRhdGEpOmUudGV4SW1hZ2UzRChzLlRFWFRVUkVfMkRfQVJSQVksUCxUdCxfdC53aWR0aCxfdC5oZWlnaHQsdHQuZGVwdGgsMCxYdCxVdCxfdC5kYXRhKX1lbHNleyR0JiZyZSYmZS50ZXhTdG9yYWdlMkQocy5URVhUVVJFXzJELGVlLFR0LFZ0WzBdLndpZHRoLFZ0WzBdLmhlaWdodCk7Zm9yKGxldCBQPTAscnQ9VnQubGVuZ3RoO1A8cnQ7UCsrKV90PVZ0W1BdLFMuZm9ybWF0IT09SGU/WHQhPT1udWxsPyR0P3F0JiZlLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKHMuVEVYVFVSRV8yRCxQLDAsMCxfdC53aWR0aCxfdC5oZWlnaHQsWHQsX3QuZGF0YSk6ZS5jb21wcmVzc2VkVGV4SW1hZ2UyRChzLlRFWFRVUkVfMkQsUCxUdCxfdC53aWR0aCxfdC5oZWlnaHQsMCxfdC5kYXRhKTpjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gbG9hZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGluIC51cGxvYWRUZXh0dXJlKCkiKTokdD9xdCYmZS50ZXhTdWJJbWFnZTJEKHMuVEVYVFVSRV8yRCxQLDAsMCxfdC53aWR0aCxfdC5oZWlnaHQsWHQsVXQsX3QuZGF0YSk6ZS50ZXhJbWFnZTJEKHMuVEVYVFVSRV8yRCxQLFR0LF90LndpZHRoLF90LmhlaWdodCwwLFh0LFV0LF90LmRhdGEpfWVsc2UgaWYoUy5pc0RhdGFBcnJheVRleHR1cmUpJHQ/KHJlJiZlLnRleFN0b3JhZ2UzRChzLlRFWFRVUkVfMkRfQVJSQVksZWUsVHQsdHQud2lkdGgsdHQuaGVpZ2h0LHR0LmRlcHRoKSxxdCYmZS50ZXhTdWJJbWFnZTNEKHMuVEVYVFVSRV8yRF9BUlJBWSwwLDAsMCwwLHR0LndpZHRoLHR0LmhlaWdodCx0dC5kZXB0aCxYdCxVdCx0dC5kYXRhKSk6ZS50ZXhJbWFnZTNEKHMuVEVYVFVSRV8yRF9BUlJBWSwwLFR0LHR0LndpZHRoLHR0LmhlaWdodCx0dC5kZXB0aCwwLFh0LFV0LHR0LmRhdGEpO2Vsc2UgaWYoUy5pc0RhdGEzRFRleHR1cmUpJHQ/KHJlJiZlLnRleFN0b3JhZ2UzRChzLlRFWFRVUkVfM0QsZWUsVHQsdHQud2lkdGgsdHQuaGVpZ2h0LHR0LmRlcHRoKSxxdCYmZS50ZXhTdWJJbWFnZTNEKHMuVEVYVFVSRV8zRCwwLDAsMCwwLHR0LndpZHRoLHR0LmhlaWdodCx0dC5kZXB0aCxYdCxVdCx0dC5kYXRhKSk6ZS50ZXhJbWFnZTNEKHMuVEVYVFVSRV8zRCwwLFR0LHR0LndpZHRoLHR0LmhlaWdodCx0dC5kZXB0aCwwLFh0LFV0LHR0LmRhdGEpO2Vsc2UgaWYoUy5pc0ZyYW1lYnVmZmVyVGV4dHVyZSl7aWYocmUpaWYoJHQpZS50ZXhTdG9yYWdlMkQocy5URVhUVVJFXzJELGVlLFR0LHR0LndpZHRoLHR0LmhlaWdodCk7ZWxzZXtsZXQgUD10dC53aWR0aCxydD10dC5oZWlnaHQ7Zm9yKGxldCBhdD0wO2F0PGVlO2F0KyspZS50ZXhJbWFnZTJEKHMuVEVYVFVSRV8yRCxhdCxUdCxQLHJ0LDAsWHQsVXQsbnVsbCksUD4+PTEscnQ+Pj0xfX1lbHNlIGlmKFZ0Lmxlbmd0aD4wJiZZdCl7JHQmJnJlJiZlLnRleFN0b3JhZ2UyRChzLlRFWFRVUkVfMkQsZWUsVHQsVnRbMF0ud2lkdGgsVnRbMF0uaGVpZ2h0KTtmb3IobGV0IFA9MCxydD1WdC5sZW5ndGg7UDxydDtQKyspX3Q9VnRbUF0sJHQ/cXQmJmUudGV4U3ViSW1hZ2UyRChzLlRFWFRVUkVfMkQsUCwwLDAsWHQsVXQsX3QpOmUudGV4SW1hZ2UyRChzLlRFWFRVUkVfMkQsUCxUdCxYdCxVdCxfdCk7Uy5nZW5lcmF0ZU1pcG1hcHM9ITF9ZWxzZSAkdD8ocmUmJmUudGV4U3RvcmFnZTJEKHMuVEVYVFVSRV8yRCxlZSxUdCx0dC53aWR0aCx0dC5oZWlnaHQpLHF0JiZlLnRleFN1YkltYWdlMkQocy5URVhUVVJFXzJELDAsMCwwLFh0LFV0LHR0KSk6ZS50ZXhJbWFnZTJEKHMuVEVYVFVSRV8yRCwwLFR0LFh0LFV0LHR0KTt2KFMsWXQpJiZ4KG50KSx4dC5fX3ZlcnNpb249Sy52ZXJzaW9uLFMub25VcGRhdGUmJlMub25VcGRhdGUoUyl9Yi5fX3ZlcnNpb249Uy52ZXJzaW9ufWZ1bmN0aW9uIHB0KGIsUyxOKXtpZihTLmltYWdlLmxlbmd0aCE9PTYpcmV0dXJuO2xldCBudD1IKGIsUyksaj1TLnNvdXJjZTtlLmJpbmRUZXh0dXJlKHMuVEVYVFVSRV9DVUJFX01BUCxiLl9fd2ViZ2xUZXh0dXJlLHMuVEVYVFVSRTArTik7bGV0IEs9bi5nZXQoaik7aWYoai52ZXJzaW9uIT09Sy5fX3ZlcnNpb258fG50PT09ITApe2UuYWN0aXZlVGV4dHVyZShzLlRFWFRVUkUwK04pO2xldCB4dD1qdC5nZXRQcmltYXJpZXMoanQud29ya2luZ0NvbG9yU3BhY2UpLGN0PVMuY29sb3JTcGFjZT09PXFlP251bGw6anQuZ2V0UHJpbWFyaWVzKFMuY29sb3JTcGFjZSksbXQ9Uy5jb2xvclNwYWNlPT09cWV8fHh0PT09Y3Q/cy5OT05FOnMuQlJPV1NFUl9ERUZBVUxUX1dFQkdMO3MucGl4ZWxTdG9yZWkocy5VTlBBQ0tfRkxJUF9ZX1dFQkdMLFMuZmxpcFkpLHMucGl4ZWxTdG9yZWkocy5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsUy5wcmVtdWx0aXBseUFscGhhKSxzLnBpeGVsU3RvcmVpKHMuVU5QQUNLX0FMSUdOTUVOVCxTLnVucGFja0FsaWdubWVudCkscy5waXhlbFN0b3JlaShzLlVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wsbXQpO2xldCBSdD1TLmlzQ29tcHJlc3NlZFRleHR1cmV8fFMuaW1hZ2VbMF0uaXNDb21wcmVzc2VkVGV4dHVyZSxGdD1TLmltYWdlWzBdJiZTLmltYWdlWzBdLmlzRGF0YVRleHR1cmUsdHQ9W107Zm9yKGxldCBQPTA7UDw2O1ArKykhUnQmJiFGdD90dFtQXT1fKFMuaW1hZ2VbUF0sITEsITAsaS5tYXhDdWJlbWFwU2l6ZSk6dHRbUF09RnQ/Uy5pbWFnZVtQXS5pbWFnZTpTLmltYWdlW1BdLHR0W1BdPWh0KFMsdHRbUF0pO2xldCBZdD10dFswXSxYdD1nKFl0KXx8byxVdD1yLmNvbnZlcnQoUy5mb3JtYXQsUy5jb2xvclNwYWNlKSxUdD1yLmNvbnZlcnQoUy50eXBlKSxfdD1NKFMuaW50ZXJuYWxGb3JtYXQsVXQsVHQsUy5jb2xvclNwYWNlKSxWdD1vJiZTLmlzVmlkZW9UZXh0dXJlIT09ITAsJHQ9Sy5fX3ZlcnNpb249PT12b2lkIDB8fG50PT09ITAscmU9ai5kYXRhUmVhZHkscXQ9QyhTLFl0LFh0KTtQdChzLlRFWFRVUkVfQ1VCRV9NQVAsUyxYdCk7bGV0IGVlO2lmKFJ0KXtWdCYmJHQmJmUudGV4U3RvcmFnZTJEKHMuVEVYVFVSRV9DVUJFX01BUCxxdCxfdCxZdC53aWR0aCxZdC5oZWlnaHQpO2ZvcihsZXQgUD0wO1A8NjtQKyspe2VlPXR0W1BdLm1pcG1hcHM7Zm9yKGxldCBydD0wO3J0PGVlLmxlbmd0aDtydCsrKXtsZXQgYXQ9ZWVbcnRdO1MuZm9ybWF0IT09SGU/VXQhPT1udWxsP1Z0P3JlJiZlLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKHMuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YK1AscnQsMCwwLGF0LndpZHRoLGF0LmhlaWdodCxVdCxhdC5kYXRhKTplLmNvbXByZXNzZWRUZXhJbWFnZTJEKHMuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YK1AscnQsX3QsYXQud2lkdGgsYXQuaGVpZ2h0LDAsYXQuZGF0YSk6Y29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAuc2V0VGV4dHVyZUN1YmUoKSIpOlZ0P3JlJiZlLnRleFN1YkltYWdlMkQocy5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grUCxydCwwLDAsYXQud2lkdGgsYXQuaGVpZ2h0LFV0LFR0LGF0LmRhdGEpOmUudGV4SW1hZ2UyRChzLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCtQLHJ0LF90LGF0LndpZHRoLGF0LmhlaWdodCwwLFV0LFR0LGF0LmRhdGEpfX19ZWxzZXtlZT1TLm1pcG1hcHMsVnQmJiR0JiYoZWUubGVuZ3RoPjAmJnF0KyssZS50ZXhTdG9yYWdlMkQocy5URVhUVVJFX0NVQkVfTUFQLHF0LF90LHR0WzBdLndpZHRoLHR0WzBdLmhlaWdodCkpO2ZvcihsZXQgUD0wO1A8NjtQKyspaWYoRnQpe1Z0P3JlJiZlLnRleFN1YkltYWdlMkQocy5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grUCwwLDAsMCx0dFtQXS53aWR0aCx0dFtQXS5oZWlnaHQsVXQsVHQsdHRbUF0uZGF0YSk6ZS50ZXhJbWFnZTJEKHMuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YK1AsMCxfdCx0dFtQXS53aWR0aCx0dFtQXS5oZWlnaHQsMCxVdCxUdCx0dFtQXS5kYXRhKTtmb3IobGV0IHJ0PTA7cnQ8ZWUubGVuZ3RoO3J0Kyspe2xldCBNdD1lZVtydF0uaW1hZ2VbUF0uaW1hZ2U7VnQ/cmUmJmUudGV4U3ViSW1hZ2UyRChzLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCtQLHJ0KzEsMCwwLE10LndpZHRoLE10LmhlaWdodCxVdCxUdCxNdC5kYXRhKTplLnRleEltYWdlMkQocy5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grUCxydCsxLF90LE10LndpZHRoLE10LmhlaWdodCwwLFV0LFR0LE10LmRhdGEpfX1lbHNle1Z0P3JlJiZlLnRleFN1YkltYWdlMkQocy5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grUCwwLDAsMCxVdCxUdCx0dFtQXSk6ZS50ZXhJbWFnZTJEKHMuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YK1AsMCxfdCxVdCxUdCx0dFtQXSk7Zm9yKGxldCBydD0wO3J0PGVlLmxlbmd0aDtydCsrKXtsZXQgYXQ9ZWVbcnRdO1Z0P3JlJiZlLnRleFN1YkltYWdlMkQocy5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grUCxydCsxLDAsMCxVdCxUdCxhdC5pbWFnZVtQXSk6ZS50ZXhJbWFnZTJEKHMuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YK1AscnQrMSxfdCxVdCxUdCxhdC5pbWFnZVtQXSl9fX12KFMsWHQpJiZ4KHMuVEVYVFVSRV9DVUJFX01BUCksSy5fX3ZlcnNpb249ai52ZXJzaW9uLFMub25VcGRhdGUmJlMub25VcGRhdGUoUyl9Yi5fX3ZlcnNpb249Uy52ZXJzaW9ufWZ1bmN0aW9uIHZ0KGIsUyxOLG50LGosSyl7bGV0IHh0PXIuY29udmVydChOLmZvcm1hdCxOLmNvbG9yU3BhY2UpLGN0PXIuY29udmVydChOLnR5cGUpLG10PU0oTi5pbnRlcm5hbEZvcm1hdCx4dCxjdCxOLmNvbG9yU3BhY2UpO2lmKCFuLmdldChTKS5fX2hhc0V4dGVybmFsVGV4dHVyZXMpe2xldCBGdD1NYXRoLm1heCgxLFMud2lkdGg+PkspLHR0PU1hdGgubWF4KDEsUy5oZWlnaHQ+PkspO2o9PT1zLlRFWFRVUkVfM0R8fGo9PT1zLlRFWFRVUkVfMkRfQVJSQVk/ZS50ZXhJbWFnZTNEKGosSyxtdCxGdCx0dCxTLmRlcHRoLDAseHQsY3QsbnVsbCk6ZS50ZXhJbWFnZTJEKGosSyxtdCxGdCx0dCwwLHh0LGN0LG51bGwpfWUuYmluZEZyYW1lYnVmZmVyKHMuRlJBTUVCVUZGRVIsYiksWShTKT9sLmZyYW1lYnVmZmVyVGV4dHVyZTJETXVsdGlzYW1wbGVFWFQocy5GUkFNRUJVRkZFUixudCxqLG4uZ2V0KE4pLl9fd2ViZ2xUZXh0dXJlLDAsc3QoUykpOihqPT09cy5URVhUVVJFXzJEfHxqPj1zLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCYmajw9cy5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1opJiZzLmZyYW1lYnVmZmVyVGV4dHVyZTJEKHMuRlJBTUVCVUZGRVIsbnQsaixuLmdldChOKS5fX3dlYmdsVGV4dHVyZSxLKSxlLmJpbmRGcmFtZWJ1ZmZlcihzLkZSQU1FQlVGRkVSLG51bGwpfWZ1bmN0aW9uIEV0KGIsUyxOKXtpZihzLmJpbmRSZW5kZXJidWZmZXIocy5SRU5ERVJCVUZGRVIsYiksUy5kZXB0aEJ1ZmZlciYmIVMuc3RlbmNpbEJ1ZmZlcil7bGV0IG50PW89PT0hMD9zLkRFUFRIX0NPTVBPTkVOVDI0OnMuREVQVEhfQ09NUE9ORU5UMTY7aWYoTnx8WShTKSl7bGV0IGo9Uy5kZXB0aFRleHR1cmU7aiYmai5pc0RlcHRoVGV4dHVyZSYmKGoudHlwZT09PWVuP250PXMuREVQVEhfQ09NUE9ORU5UMzJGOmoudHlwZT09PUNuJiYobnQ9cy5ERVBUSF9DT01QT05FTlQyNCkpO2xldCBLPXN0KFMpO1koUyk/bC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGVFWFQocy5SRU5ERVJCVUZGRVIsSyxudCxTLndpZHRoLFMuaGVpZ2h0KTpzLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZShzLlJFTkRFUkJVRkZFUixLLG50LFMud2lkdGgsUy5oZWlnaHQpfWVsc2Ugcy5yZW5kZXJidWZmZXJTdG9yYWdlKHMuUkVOREVSQlVGRkVSLG50LFMud2lkdGgsUy5oZWlnaHQpO3MuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIocy5GUkFNRUJVRkZFUixzLkRFUFRIX0FUVEFDSE1FTlQscy5SRU5ERVJCVUZGRVIsYil9ZWxzZSBpZihTLmRlcHRoQnVmZmVyJiZTLnN0ZW5jaWxCdWZmZXIpe2xldCBudD1zdChTKTtOJiZZKFMpPT09ITE/cy5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUocy5SRU5ERVJCVUZGRVIsbnQscy5ERVBUSDI0X1NURU5DSUw4LFMud2lkdGgsUy5oZWlnaHQpOlkoUyk/bC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGVFWFQocy5SRU5ERVJCVUZGRVIsbnQscy5ERVBUSDI0X1NURU5DSUw4LFMud2lkdGgsUy5oZWlnaHQpOnMucmVuZGVyYnVmZmVyU3RvcmFnZShzLlJFTkRFUkJVRkZFUixzLkRFUFRIX1NURU5DSUwsUy53aWR0aCxTLmhlaWdodCkscy5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihzLkZSQU1FQlVGRkVSLHMuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULHMuUkVOREVSQlVGRkVSLGIpfWVsc2V7bGV0IG50PVMuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cz09PSEwP1MudGV4dHVyZTpbUy50ZXh0dXJlXTtmb3IobGV0IGo9MDtqPG50Lmxlbmd0aDtqKyspe2xldCBLPW50W2pdLHh0PXIuY29udmVydChLLmZvcm1hdCxLLmNvbG9yU3BhY2UpLGN0PXIuY29udmVydChLLnR5cGUpLG10PU0oSy5pbnRlcm5hbEZvcm1hdCx4dCxjdCxLLmNvbG9yU3BhY2UpLFJ0PXN0KFMpO04mJlkoUyk9PT0hMT9zLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZShzLlJFTkRFUkJVRkZFUixSdCxtdCxTLndpZHRoLFMuaGVpZ2h0KTpZKFMpP2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlRVhUKHMuUkVOREVSQlVGRkVSLFJ0LG10LFMud2lkdGgsUy5oZWlnaHQpOnMucmVuZGVyYnVmZmVyU3RvcmFnZShzLlJFTkRFUkJVRkZFUixtdCxTLndpZHRoLFMuaGVpZ2h0KX19cy5iaW5kUmVuZGVyYnVmZmVyKHMuUkVOREVSQlVGRkVSLG51bGwpfWZ1bmN0aW9uIHl0KGIsUyl7aWYoUyYmUy5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCl0aHJvdyBuZXcgRXJyb3IoIkRlcHRoIFRleHR1cmUgd2l0aCBjdWJlIHJlbmRlciB0YXJnZXRzIGlzIG5vdCBzdXBwb3J0ZWQiKTtpZihlLmJpbmRGcmFtZWJ1ZmZlcihzLkZSQU1FQlVGRkVSLGIpLCEoUy5kZXB0aFRleHR1cmUmJlMuZGVwdGhUZXh0dXJlLmlzRGVwdGhUZXh0dXJlKSl0aHJvdyBuZXcgRXJyb3IoInJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBUSFJFRS5EZXB0aFRleHR1cmUiKTsoIW4uZ2V0KFMuZGVwdGhUZXh0dXJlKS5fX3dlYmdsVGV4dHVyZXx8Uy5kZXB0aFRleHR1cmUuaW1hZ2Uud2lkdGghPT1TLndpZHRofHxTLmRlcHRoVGV4dHVyZS5pbWFnZS5oZWlnaHQhPT1TLmhlaWdodCkmJihTLmRlcHRoVGV4dHVyZS5pbWFnZS53aWR0aD1TLndpZHRoLFMuZGVwdGhUZXh0dXJlLmltYWdlLmhlaWdodD1TLmhlaWdodCxTLmRlcHRoVGV4dHVyZS5uZWVkc1VwZGF0ZT0hMCksRihTLmRlcHRoVGV4dHVyZSwwKTtsZXQgbnQ9bi5nZXQoUy5kZXB0aFRleHR1cmUpLl9fd2ViZ2xUZXh0dXJlLGo9c3QoUyk7aWYoUy5kZXB0aFRleHR1cmUuZm9ybWF0PT09am4pWShTKT9sLmZyYW1lYnVmZmVyVGV4dHVyZTJETXVsdGlzYW1wbGVFWFQocy5GUkFNRUJVRkZFUixzLkRFUFRIX0FUVEFDSE1FTlQscy5URVhUVVJFXzJELG50LDAsaik6cy5mcmFtZWJ1ZmZlclRleHR1cmUyRChzLkZSQU1FQlVGRkVSLHMuREVQVEhfQVRUQUNITUVOVCxzLlRFWFRVUkVfMkQsbnQsMCk7ZWxzZSBpZihTLmRlcHRoVGV4dHVyZS5mb3JtYXQ9PT1DaSlZKFMpP2wuZnJhbWVidWZmZXJUZXh0dXJlMkRNdWx0aXNhbXBsZUVYVChzLkZSQU1FQlVGRkVSLHMuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULHMuVEVYVFVSRV8yRCxudCwwLGopOnMuZnJhbWVidWZmZXJUZXh0dXJlMkQocy5GUkFNRUJVRkZFUixzLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCxzLlRFWFRVUkVfMkQsbnQsMCk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoIlVua25vd24gZGVwdGhUZXh0dXJlIGZvcm1hdCIpfWZ1bmN0aW9uIE90KGIpe2xldCBTPW4uZ2V0KGIpLE49Yi5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldD09PSEwO2lmKGIuZGVwdGhUZXh0dXJlJiYhUy5fX2F1dG9BbGxvY2F0ZURlcHRoQnVmZmVyKXtpZihOKXRocm93IG5ldyBFcnJvcigidGFyZ2V0LmRlcHRoVGV4dHVyZSBub3Qgc3VwcG9ydGVkIGluIEN1YmUgcmVuZGVyIHRhcmdldHMiKTt5dChTLl9fd2ViZ2xGcmFtZWJ1ZmZlcixiKX1lbHNlIGlmKE4pe1MuX193ZWJnbERlcHRoYnVmZmVyPVtdO2ZvcihsZXQgbnQ9MDtudDw2O250KyspZS5iaW5kRnJhbWVidWZmZXIocy5GUkFNRUJVRkZFUixTLl9fd2ViZ2xGcmFtZWJ1ZmZlcltudF0pLFMuX193ZWJnbERlcHRoYnVmZmVyW250XT1zLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpLEV0KFMuX193ZWJnbERlcHRoYnVmZmVyW250XSxiLCExKX1lbHNlIGUuYmluZEZyYW1lYnVmZmVyKHMuRlJBTUVCVUZGRVIsUy5fX3dlYmdsRnJhbWVidWZmZXIpLFMuX193ZWJnbERlcHRoYnVmZmVyPXMuY3JlYXRlUmVuZGVyYnVmZmVyKCksRXQoUy5fX3dlYmdsRGVwdGhidWZmZXIsYiwhMSk7ZS5iaW5kRnJhbWVidWZmZXIocy5GUkFNRUJVRkZFUixudWxsKX1mdW5jdGlvbiBBdChiLFMsTil7bGV0IG50PW4uZ2V0KGIpO1MhPT12b2lkIDAmJnZ0KG50Ll9fd2ViZ2xGcmFtZWJ1ZmZlcixiLGIudGV4dHVyZSxzLkNPTE9SX0FUVEFDSE1FTlQwLHMuVEVYVFVSRV8yRCwwKSxOIT09dm9pZCAwJiZPdChiKX1mdW5jdGlvbiBMKGIpe2xldCBTPWIudGV4dHVyZSxOPW4uZ2V0KGIpLG50PW4uZ2V0KFMpO2IuYWRkRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsVSksYi5pc1dlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzIT09ITAmJihudC5fX3dlYmdsVGV4dHVyZT09PXZvaWQgMCYmKG50Ll9fd2ViZ2xUZXh0dXJlPXMuY3JlYXRlVGV4dHVyZSgpKSxudC5fX3ZlcnNpb249Uy52ZXJzaW9uLGEubWVtb3J5LnRleHR1cmVzKyspO2xldCBqPWIuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQ9PT0hMCxLPWIuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cz09PSEwLHh0PWcoYil8fG87aWYoail7Ti5fX3dlYmdsRnJhbWVidWZmZXI9W107Zm9yKGxldCBjdD0wO2N0PDY7Y3QrKylpZihvJiZTLm1pcG1hcHMmJlMubWlwbWFwcy5sZW5ndGg+MCl7Ti5fX3dlYmdsRnJhbWVidWZmZXJbY3RdPVtdO2ZvcihsZXQgbXQ9MDttdDxTLm1pcG1hcHMubGVuZ3RoO210KyspTi5fX3dlYmdsRnJhbWVidWZmZXJbY3RdW210XT1zLmNyZWF0ZUZyYW1lYnVmZmVyKCl9ZWxzZSBOLl9fd2ViZ2xGcmFtZWJ1ZmZlcltjdF09cy5jcmVhdGVGcmFtZWJ1ZmZlcigpfWVsc2V7aWYobyYmUy5taXBtYXBzJiZTLm1pcG1hcHMubGVuZ3RoPjApe04uX193ZWJnbEZyYW1lYnVmZmVyPVtdO2ZvcihsZXQgY3Q9MDtjdDxTLm1pcG1hcHMubGVuZ3RoO2N0KyspTi5fX3dlYmdsRnJhbWVidWZmZXJbY3RdPXMuY3JlYXRlRnJhbWVidWZmZXIoKX1lbHNlIE4uX193ZWJnbEZyYW1lYnVmZmVyPXMuY3JlYXRlRnJhbWVidWZmZXIoKTtpZihLKWlmKGkuZHJhd0J1ZmZlcnMpe2xldCBjdD1iLnRleHR1cmU7Zm9yKGxldCBtdD0wLFJ0PWN0Lmxlbmd0aDttdDxSdDttdCsrKXtsZXQgRnQ9bi5nZXQoY3RbbXRdKTtGdC5fX3dlYmdsVGV4dHVyZT09PXZvaWQgMCYmKEZ0Ll9fd2ViZ2xUZXh0dXJlPXMuY3JlYXRlVGV4dHVyZSgpLGEubWVtb3J5LnRleHR1cmVzKyspfX1lbHNlIGNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIFdlYkdMMiBvciBXRUJHTF9kcmF3X2J1ZmZlcnMgZXh0ZW5zaW9uLiIpO2lmKG8mJmIuc2FtcGxlcz4wJiZZKGIpPT09ITEpe2xldCBjdD1LP1M6W1NdO04uX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyPXMuY3JlYXRlRnJhbWVidWZmZXIoKSxOLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlcj1bXSxlLmJpbmRGcmFtZWJ1ZmZlcihzLkZSQU1FQlVGRkVSLE4uX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyKTtmb3IobGV0IG10PTA7bXQ8Y3QubGVuZ3RoO210Kyspe2xldCBSdD1jdFttdF07Ti5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbbXRdPXMuY3JlYXRlUmVuZGVyYnVmZmVyKCkscy5iaW5kUmVuZGVyYnVmZmVyKHMuUkVOREVSQlVGRkVSLE4uX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyW210XSk7bGV0IEZ0PXIuY29udmVydChSdC5mb3JtYXQsUnQuY29sb3JTcGFjZSksdHQ9ci5jb252ZXJ0KFJ0LnR5cGUpLFl0PU0oUnQuaW50ZXJuYWxGb3JtYXQsRnQsdHQsUnQuY29sb3JTcGFjZSxiLmlzWFJSZW5kZXJUYXJnZXQ9PT0hMCksWHQ9c3QoYik7cy5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUocy5SRU5ERVJCVUZGRVIsWHQsWXQsYi53aWR0aCxiLmhlaWdodCkscy5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihzLkZSQU1FQlVGRkVSLHMuQ09MT1JfQVRUQUNITUVOVDArbXQscy5SRU5ERVJCVUZGRVIsTi5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbbXRdKX1zLmJpbmRSZW5kZXJidWZmZXIocy5SRU5ERVJCVUZGRVIsbnVsbCksYi5kZXB0aEJ1ZmZlciYmKE4uX193ZWJnbERlcHRoUmVuZGVyYnVmZmVyPXMuY3JlYXRlUmVuZGVyYnVmZmVyKCksRXQoTi5fX3dlYmdsRGVwdGhSZW5kZXJidWZmZXIsYiwhMCkpLGUuYmluZEZyYW1lYnVmZmVyKHMuRlJBTUVCVUZGRVIsbnVsbCl9fWlmKGope2UuYmluZFRleHR1cmUocy5URVhUVVJFX0NVQkVfTUFQLG50Ll9fd2ViZ2xUZXh0dXJlKSxQdChzLlRFWFRVUkVfQ1VCRV9NQVAsUyx4dCk7Zm9yKGxldCBjdD0wO2N0PDY7Y3QrKylpZihvJiZTLm1pcG1hcHMmJlMubWlwbWFwcy5sZW5ndGg+MClmb3IobGV0IG10PTA7bXQ8Uy5taXBtYXBzLmxlbmd0aDttdCsrKXZ0KE4uX193ZWJnbEZyYW1lYnVmZmVyW2N0XVttdF0sYixTLHMuQ09MT1JfQVRUQUNITUVOVDAscy5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grY3QsbXQpO2Vsc2UgdnQoTi5fX3dlYmdsRnJhbWVidWZmZXJbY3RdLGIsUyxzLkNPTE9SX0FUVEFDSE1FTlQwLHMuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YK2N0LDApO3YoUyx4dCkmJngocy5URVhUVVJFX0NVQkVfTUFQKSxlLnVuYmluZFRleHR1cmUoKX1lbHNlIGlmKEspe2xldCBjdD1iLnRleHR1cmU7Zm9yKGxldCBtdD0wLFJ0PWN0Lmxlbmd0aDttdDxSdDttdCsrKXtsZXQgRnQ9Y3RbbXRdLHR0PW4uZ2V0KEZ0KTtlLmJpbmRUZXh0dXJlKHMuVEVYVFVSRV8yRCx0dC5fX3dlYmdsVGV4dHVyZSksUHQocy5URVhUVVJFXzJELEZ0LHh0KSx2dChOLl9fd2ViZ2xGcmFtZWJ1ZmZlcixiLEZ0LHMuQ09MT1JfQVRUQUNITUVOVDArbXQscy5URVhUVVJFXzJELDApLHYoRnQseHQpJiZ4KHMuVEVYVFVSRV8yRCl9ZS51bmJpbmRUZXh0dXJlKCl9ZWxzZXtsZXQgY3Q9cy5URVhUVVJFXzJEO2lmKChiLmlzV2ViR0wzRFJlbmRlclRhcmdldHx8Yi5pc1dlYkdMQXJyYXlSZW5kZXJUYXJnZXQpJiYobz9jdD1iLmlzV2ViR0wzRFJlbmRlclRhcmdldD9zLlRFWFRVUkVfM0Q6cy5URVhUVVJFXzJEX0FSUkFZOmNvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMVGV4dHVyZXM6IFRIUkVFLkRhdGEzRFRleHR1cmUgYW5kIFRIUkVFLkRhdGFBcnJheVRleHR1cmUgb25seSBzdXBwb3J0ZWQgd2l0aCBXZWJHTDIuIikpLGUuYmluZFRleHR1cmUoY3QsbnQuX193ZWJnbFRleHR1cmUpLFB0KGN0LFMseHQpLG8mJlMubWlwbWFwcyYmUy5taXBtYXBzLmxlbmd0aD4wKWZvcihsZXQgbXQ9MDttdDxTLm1pcG1hcHMubGVuZ3RoO210KyspdnQoTi5fX3dlYmdsRnJhbWVidWZmZXJbbXRdLGIsUyxzLkNPTE9SX0FUVEFDSE1FTlQwLGN0LG10KTtlbHNlIHZ0KE4uX193ZWJnbEZyYW1lYnVmZmVyLGIsUyxzLkNPTE9SX0FUVEFDSE1FTlQwLGN0LDApO3YoUyx4dCkmJngoY3QpLGUudW5iaW5kVGV4dHVyZSgpfWIuZGVwdGhCdWZmZXImJk90KGIpfWZ1bmN0aW9uIG90KGIpe2xldCBTPWcoYil8fG8sTj1iLmlzV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHM9PT0hMD9iLnRleHR1cmU6W2IudGV4dHVyZV07Zm9yKGxldCBudD0wLGo9Ti5sZW5ndGg7bnQ8ajtudCsrKXtsZXQgSz1OW250XTtpZih2KEssUykpe2xldCB4dD1iLmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0P3MuVEVYVFVSRV9DVUJFX01BUDpzLlRFWFRVUkVfMkQsY3Q9bi5nZXQoSykuX193ZWJnbFRleHR1cmU7ZS5iaW5kVGV4dHVyZSh4dCxjdCkseCh4dCksZS51bmJpbmRUZXh0dXJlKCl9fX1mdW5jdGlvbiBYKGIpe2lmKG8mJmIuc2FtcGxlcz4wJiZZKGIpPT09ITEpe2xldCBTPWIuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cz9iLnRleHR1cmU6W2IudGV4dHVyZV0sTj1iLndpZHRoLG50PWIuaGVpZ2h0LGo9cy5DT0xPUl9CVUZGRVJfQklULEs9W10seHQ9Yi5zdGVuY2lsQnVmZmVyP3MuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UOnMuREVQVEhfQVRUQUNITUVOVCxjdD1uLmdldChiKSxtdD1iLmlzV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHM9PT0hMDtpZihtdClmb3IobGV0IFJ0PTA7UnQ8Uy5sZW5ndGg7UnQrKyllLmJpbmRGcmFtZWJ1ZmZlcihzLkZSQU1FQlVGRkVSLGN0Ll9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlcikscy5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihzLkZSQU1FQlVGRkVSLHMuQ09MT1JfQVRUQUNITUVOVDArUnQscy5SRU5ERVJCVUZGRVIsbnVsbCksZS5iaW5kRnJhbWVidWZmZXIocy5GUkFNRUJVRkZFUixjdC5fX3dlYmdsRnJhbWVidWZmZXIpLHMuZnJhbWVidWZmZXJUZXh0dXJlMkQocy5EUkFXX0ZSQU1FQlVGRkVSLHMuQ09MT1JfQVRUQUNITUVOVDArUnQscy5URVhUVVJFXzJELG51bGwsMCk7ZS5iaW5kRnJhbWVidWZmZXIocy5SRUFEX0ZSQU1FQlVGRkVSLGN0Ll9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlciksZS5iaW5kRnJhbWVidWZmZXIocy5EUkFXX0ZSQU1FQlVGRkVSLGN0Ll9fd2ViZ2xGcmFtZWJ1ZmZlcik7Zm9yKGxldCBSdD0wO1J0PFMubGVuZ3RoO1J0Kyspe0sucHVzaChzLkNPTE9SX0FUVEFDSE1FTlQwK1J0KSxiLmRlcHRoQnVmZmVyJiZLLnB1c2goeHQpO2xldCBGdD1jdC5fX2lnbm9yZURlcHRoVmFsdWVzIT09dm9pZCAwP2N0Ll9faWdub3JlRGVwdGhWYWx1ZXM6ITE7aWYoRnQ9PT0hMSYmKGIuZGVwdGhCdWZmZXImJihqfD1zLkRFUFRIX0JVRkZFUl9CSVQpLGIuc3RlbmNpbEJ1ZmZlciYmKGp8PXMuU1RFTkNJTF9CVUZGRVJfQklUKSksbXQmJnMuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIocy5SRUFEX0ZSQU1FQlVGRkVSLHMuQ09MT1JfQVRUQUNITUVOVDAscy5SRU5ERVJCVUZGRVIsY3QuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyW1J0XSksRnQ9PT0hMCYmKHMuaW52YWxpZGF0ZUZyYW1lYnVmZmVyKHMuUkVBRF9GUkFNRUJVRkZFUixbeHRdKSxzLmludmFsaWRhdGVGcmFtZWJ1ZmZlcihzLkRSQVdfRlJBTUVCVUZGRVIsW3h0XSkpLG10KXtsZXQgdHQ9bi5nZXQoU1tSdF0pLl9fd2ViZ2xUZXh0dXJlO3MuZnJhbWVidWZmZXJUZXh0dXJlMkQocy5EUkFXX0ZSQU1FQlVGRkVSLHMuQ09MT1JfQVRUQUNITUVOVDAscy5URVhUVVJFXzJELHR0LDApfXMuYmxpdEZyYW1lYnVmZmVyKDAsMCxOLG50LDAsMCxOLG50LGoscy5ORUFSRVNUKSxjJiZzLmludmFsaWRhdGVGcmFtZWJ1ZmZlcihzLlJFQURfRlJBTUVCVUZGRVIsSyl9aWYoZS5iaW5kRnJhbWVidWZmZXIocy5SRUFEX0ZSQU1FQlVGRkVSLG51bGwpLGUuYmluZEZyYW1lYnVmZmVyKHMuRFJBV19GUkFNRUJVRkZFUixudWxsKSxtdClmb3IobGV0IFJ0PTA7UnQ8Uy5sZW5ndGg7UnQrKyl7ZS5iaW5kRnJhbWVidWZmZXIocy5GUkFNRUJVRkZFUixjdC5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIpLHMuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIocy5GUkFNRUJVRkZFUixzLkNPTE9SX0FUVEFDSE1FTlQwK1J0LHMuUkVOREVSQlVGRkVSLGN0Ll9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlcltSdF0pO2xldCBGdD1uLmdldChTW1J0XSkuX193ZWJnbFRleHR1cmU7ZS5iaW5kRnJhbWVidWZmZXIocy5GUkFNRUJVRkZFUixjdC5fX3dlYmdsRnJhbWVidWZmZXIpLHMuZnJhbWVidWZmZXJUZXh0dXJlMkQocy5EUkFXX0ZSQU1FQlVGRkVSLHMuQ09MT1JfQVRUQUNITUVOVDArUnQscy5URVhUVVJFXzJELEZ0LDApfWUuYmluZEZyYW1lYnVmZmVyKHMuRFJBV19GUkFNRUJVRkZFUixjdC5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIpfX1mdW5jdGlvbiBzdChiKXtyZXR1cm4gTWF0aC5taW4oaS5tYXhTYW1wbGVzLGIuc2FtcGxlcyl9ZnVuY3Rpb24gWShiKXtsZXQgUz1uLmdldChiKTtyZXR1cm4gbyYmYi5zYW1wbGVzPjAmJnQuaGFzKCJXRUJHTF9tdWx0aXNhbXBsZWRfcmVuZGVyX3RvX3RleHR1cmUiKT09PSEwJiZTLl9fdXNlUmVuZGVyVG9UZXh0dXJlIT09ITF9ZnVuY3Rpb24gYnQoYil7bGV0IFM9YS5yZW5kZXIuZnJhbWU7aC5nZXQoYikhPT1TJiYoaC5zZXQoYixTKSxiLnVwZGF0ZSgpKX1mdW5jdGlvbiBodChiLFMpe2xldCBOPWIuY29sb3JTcGFjZSxudD1iLmZvcm1hdCxqPWIudHlwZTtyZXR1cm4gYi5pc0NvbXByZXNzZWRUZXh0dXJlPT09ITB8fGIuaXNWaWRlb1RleHR1cmU9PT0hMHx8Yi5mb3JtYXQ9PT1WYXx8TiE9PV9uJiZOIT09cWUmJihqdC5nZXRUcmFuc2ZlcihOKT09PXNlP289PT0hMT90LmhhcygiRVhUX3NSR0IiKT09PSEwJiZudD09PUhlPyhiLmZvcm1hdD1WYSxiLm1pbkZpbHRlcj1vZSxiLmdlbmVyYXRlTWlwbWFwcz0hMSk6Uz1hci5zUkdCVG9MaW5lYXIoUyk6KG50IT09SGV8fGohPT1ObikmJmNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xUZXh0dXJlczogc1JHQiBlbmNvZGVkIHRleHR1cmVzIGhhdmUgdG8gdXNlIFJHQkFGb3JtYXQgYW5kIFVuc2lnbmVkQnl0ZVR5cGUuIik6Y29uc29sZS5lcnJvcigiVEhSRUUuV2ViR0xUZXh0dXJlczogVW5zdXBwb3J0ZWQgdGV4dHVyZSBjb2xvciBzcGFjZToiLE4pKSxTfXRoaXMuYWxsb2NhdGVUZXh0dXJlVW5pdD1JLHRoaXMucmVzZXRUZXh0dXJlVW5pdHM9Six0aGlzLnNldFRleHR1cmUyRD1GLHRoaXMuc2V0VGV4dHVyZTJEQXJyYXk9JCx0aGlzLnNldFRleHR1cmUzRD1xLHRoaXMuc2V0VGV4dHVyZUN1YmU9Vyx0aGlzLnJlYmluZFRleHR1cmVzPUF0LHRoaXMuc2V0dXBSZW5kZXJUYXJnZXQ9TCx0aGlzLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcD1vdCx0aGlzLnVwZGF0ZU11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0PVgsdGhpcy5zZXR1cERlcHRoUmVuZGVyYnVmZmVyPU90LHRoaXMuc2V0dXBGcmFtZUJ1ZmZlclRleHR1cmU9dnQsdGhpcy51c2VNdWx0aXNhbXBsZWRSVFQ9WX1mdW5jdGlvbiBycChzLHQsZSl7bGV0IG49ZS5pc1dlYkdMMjtmdW5jdGlvbiBpKHIsYT1xZSl7bGV0IG8sbD1qdC5nZXRUcmFuc2ZlcihhKTtpZihyPT09Tm4pcmV0dXJuIHMuVU5TSUdORURfQllURTtpZihyPT09WWgpcmV0dXJuIHMuVU5TSUdORURfU0hPUlRfNF80XzRfNDtpZihyPT09WmgpcmV0dXJuIHMuVU5TSUdORURfU0hPUlRfNV81XzVfMTtpZihyPT09d2YpcmV0dXJuIHMuQllURTtpZihyPT09UmYpcmV0dXJuIHMuU0hPUlQ7aWYocj09PWVsKXJldHVybiBzLlVOU0lHTkVEX1NIT1JUO2lmKHI9PT1xaClyZXR1cm4gcy5JTlQ7aWYocj09PUNuKXJldHVybiBzLlVOU0lHTkVEX0lOVDtpZihyPT09ZW4pcmV0dXJuIHMuRkxPQVQ7aWYocj09PXBzKXJldHVybiBuP3MuSEFMRl9GTE9BVDoobz10LmdldCgiT0VTX3RleHR1cmVfaGFsZl9mbG9hdCIpLG8hPT1udWxsP28uSEFMRl9GTE9BVF9PRVM6bnVsbCk7aWYocj09PUNmKXJldHVybiBzLkFMUEhBO2lmKHI9PT1IZSlyZXR1cm4gcy5SR0JBO2lmKHI9PT1QZilyZXR1cm4gcy5MVU1JTkFOQ0U7aWYocj09PUxmKXJldHVybiBzLkxVTUlOQU5DRV9BTFBIQTtpZihyPT09am4pcmV0dXJuIHMuREVQVEhfQ09NUE9ORU5UO2lmKHI9PT1DaSlyZXR1cm4gcy5ERVBUSF9TVEVOQ0lMO2lmKHI9PT1WYSlyZXR1cm4gbz10LmdldCgiRVhUX3NSR0IiKSxvIT09bnVsbD9vLlNSR0JfQUxQSEFfRVhUOm51bGw7aWYocj09PUlmKXJldHVybiBzLlJFRDtpZihyPT09SmgpcmV0dXJuIHMuUkVEX0lOVEVHRVI7aWYocj09PVVmKXJldHVybiBzLlJHO2lmKHI9PT0kaClyZXR1cm4gcy5SR19JTlRFR0VSO2lmKHI9PT1LaClyZXR1cm4gcy5SR0JBX0lOVEVHRVI7aWYocj09PUxhfHxyPT09SWF8fHI9PT1VYXx8cj09PURhKWlmKGw9PT1zZSlpZihvPXQuZ2V0KCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y19zcmdiIiksbyE9PW51bGwpe2lmKHI9PT1MYSlyZXR1cm4gby5DT01QUkVTU0VEX1NSR0JfUzNUQ19EWFQxX0VYVDtpZihyPT09SWEpcmV0dXJuIG8uQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUMV9FWFQ7aWYocj09PVVhKXJldHVybiBvLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDNfRVhUO2lmKHI9PT1EYSlyZXR1cm4gby5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQ1X0VYVH1lbHNlIHJldHVybiBudWxsO2Vsc2UgaWYobz10LmdldCgiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMiKSxvIT09bnVsbCl7aWYocj09PUxhKXJldHVybiBvLkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFQ7aWYocj09PUlhKXJldHVybiBvLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUO2lmKHI9PT1VYSlyZXR1cm4gby5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVDtpZihyPT09RGEpcmV0dXJuIG8uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFR9ZWxzZSByZXR1cm4gbnVsbDtpZihyPT09dGN8fHI9PT1lY3x8cj09PW5jfHxyPT09aWMpaWYobz10LmdldCgiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjIiksbyE9PW51bGwpe2lmKHI9PT10YylyZXR1cm4gby5DT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HO2lmKHI9PT1lYylyZXR1cm4gby5DT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HO2lmKHI9PT1uYylyZXR1cm4gby5DT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNRztpZihyPT09aWMpcmV0dXJuIG8uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUd9ZWxzZSByZXR1cm4gbnVsbDtpZihyPT09UWgpcmV0dXJuIG89dC5nZXQoIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxIiksbyE9PW51bGw/by5DT01QUkVTU0VEX1JHQl9FVEMxX1dFQkdMOm51bGw7aWYocj09PXNjfHxyPT09cmMpaWYobz10LmdldCgiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YyIpLG8hPT1udWxsKXtpZihyPT09c2MpcmV0dXJuIGw9PT1zZT9vLkNPTVBSRVNTRURfU1JHQjhfRVRDMjpvLkNPTVBSRVNTRURfUkdCOF9FVEMyO2lmKHI9PT1yYylyZXR1cm4gbD09PXNlP28uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfRVRDMl9FQUM6by5DT01QUkVTU0VEX1JHQkE4X0VUQzJfRUFDfWVsc2UgcmV0dXJuIG51bGw7aWYocj09PWFjfHxyPT09b2N8fHI9PT1sY3x8cj09PWNjfHxyPT09aGN8fHI9PT11Y3x8cj09PWRjfHxyPT09ZmN8fHI9PT1wY3x8cj09PW1jfHxyPT09Z2N8fHI9PT1fY3x8cj09PXhjfHxyPT09dmMpaWYobz10LmdldCgiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2FzdGMiKSxvIT09bnVsbCl7aWYocj09PWFjKXJldHVybiBsPT09c2U/by5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzR4NF9LSFI6by5DT01QUkVTU0VEX1JHQkFfQVNUQ180eDRfS0hSO2lmKHI9PT1vYylyZXR1cm4gbD09PXNlP28uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ181eDRfS0hSOm8uQ09NUFJFU1NFRF9SR0JBX0FTVENfNXg0X0tIUjtpZihyPT09bGMpcmV0dXJuIGw9PT1zZT9vLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNXg1X0tIUjpvLkNPTVBSRVNTRURfUkdCQV9BU1RDXzV4NV9LSFI7aWYocj09PWNjKXJldHVybiBsPT09c2U/by5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzZ4NV9LSFI6by5DT01QUkVTU0VEX1JHQkFfQVNUQ182eDVfS0hSO2lmKHI9PT1oYylyZXR1cm4gbD09PXNlP28uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ182eDZfS0hSOm8uQ09NUFJFU1NFRF9SR0JBX0FTVENfNng2X0tIUjtpZihyPT09dWMpcmV0dXJuIGw9PT1zZT9vLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfOHg1X0tIUjpvLkNPTVBSRVNTRURfUkdCQV9BU1RDXzh4NV9LSFI7aWYocj09PWRjKXJldHVybiBsPT09c2U/by5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzh4Nl9LSFI6by5DT01QUkVTU0VEX1JHQkFfQVNUQ184eDZfS0hSO2lmKHI9PT1mYylyZXR1cm4gbD09PXNlP28uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ184eDhfS0hSOm8uQ09NUFJFU1NFRF9SR0JBX0FTVENfOHg4X0tIUjtpZihyPT09cGMpcmV0dXJuIGw9PT1zZT9vLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTB4NV9LSFI6by5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMHg1X0tIUjtpZihyPT09bWMpcmV0dXJuIGw9PT1zZT9vLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTB4Nl9LSFI6by5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMHg2X0tIUjtpZihyPT09Z2MpcmV0dXJuIGw9PT1zZT9vLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTB4OF9LSFI6by5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMHg4X0tIUjtpZihyPT09X2MpcmV0dXJuIGw9PT1zZT9vLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTB4MTBfS0hSOm8uQ09NUFJFU1NFRF9SR0JBX0FTVENfMTB4MTBfS0hSO2lmKHI9PT14YylyZXR1cm4gbD09PXNlP28uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMngxMF9LSFI6by5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMngxMF9LSFI7aWYocj09PXZjKXJldHVybiBsPT09c2U/by5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEyeDEyX0tIUjpvLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEyeDEyX0tIUn1lbHNlIHJldHVybiBudWxsO2lmKHI9PT1OYXx8cj09PXljfHxyPT09TWMpaWYobz10LmdldCgiRVhUX3RleHR1cmVfY29tcHJlc3Npb25fYnB0YyIpLG8hPT1udWxsKXtpZihyPT09TmEpcmV0dXJuIGw9PT1zZT9vLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9CUFRDX1VOT1JNX0VYVDpvLkNPTVBSRVNTRURfUkdCQV9CUFRDX1VOT1JNX0VYVDtpZihyPT09eWMpcmV0dXJuIG8uQ09NUFJFU1NFRF9SR0JfQlBUQ19TSUdORURfRkxPQVRfRVhUO2lmKHI9PT1NYylyZXR1cm4gby5DT01QUkVTU0VEX1JHQl9CUFRDX1VOU0lHTkVEX0ZMT0FUX0VYVH1lbHNlIHJldHVybiBudWxsO2lmKHI9PT1EZnx8cj09PVNjfHxyPT09YmN8fHI9PT1FYylpZihvPXQuZ2V0KCJFWFRfdGV4dHVyZV9jb21wcmVzc2lvbl9yZ3RjIiksbyE9PW51bGwpe2lmKHI9PT1OYSlyZXR1cm4gby5DT01QUkVTU0VEX1JFRF9SR1RDMV9FWFQ7aWYocj09PVNjKXJldHVybiBvLkNPTVBSRVNTRURfU0lHTkVEX1JFRF9SR1RDMV9FWFQ7aWYocj09PWJjKXJldHVybiBvLkNPTVBSRVNTRURfUkVEX0dSRUVOX1JHVEMyX0VYVDtpZihyPT09RWMpcmV0dXJuIG8uQ09NUFJFU1NFRF9TSUdORURfUkVEX0dSRUVOX1JHVEMyX0VYVH1lbHNlIHJldHVybiBudWxsO3JldHVybiByPT09UW4/bj9zLlVOU0lHTkVEX0lOVF8yNF84OihvPXQuZ2V0KCJXRUJHTF9kZXB0aF90ZXh0dXJlIiksbyE9PW51bGw/by5VTlNJR05FRF9JTlRfMjRfOF9XRUJHTDpudWxsKTpzW3JdIT09dm9pZCAwP3Nbcl06bnVsbH1yZXR1cm57Y29udmVydDppfX12YXIgWGE9Y2xhc3MgZXh0ZW5kcyB2ZXtjb25zdHJ1Y3Rvcih0PVtdKXtzdXBlcigpLHRoaXMuaXNBcnJheUNhbWVyYT0hMCx0aGlzLmNhbWVyYXM9dH19LEtuPWNsYXNzIGV4dGVuZHMgSnR7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuaXNHcm91cD0hMCx0aGlzLnR5cGU9Ikdyb3VwIn19LGN2PXt0eXBlOiJtb3ZlIn0sR3M9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLl90YXJnZXRSYXk9bnVsbCx0aGlzLl9ncmlwPW51bGwsdGhpcy5faGFuZD1udWxsfWdldEhhbmRTcGFjZSgpe3JldHVybiB0aGlzLl9oYW5kPT09bnVsbCYmKHRoaXMuX2hhbmQ9bmV3IEtuLHRoaXMuX2hhbmQubWF0cml4QXV0b1VwZGF0ZT0hMSx0aGlzLl9oYW5kLnZpc2libGU9ITEsdGhpcy5faGFuZC5qb2ludHM9e30sdGhpcy5faGFuZC5pbnB1dFN0YXRlPXtwaW5jaGluZzohMX0pLHRoaXMuX2hhbmR9Z2V0VGFyZ2V0UmF5U3BhY2UoKXtyZXR1cm4gdGhpcy5fdGFyZ2V0UmF5PT09bnVsbCYmKHRoaXMuX3RhcmdldFJheT1uZXcgS24sdGhpcy5fdGFyZ2V0UmF5Lm1hdHJpeEF1dG9VcGRhdGU9ITEsdGhpcy5fdGFyZ2V0UmF5LnZpc2libGU9ITEsdGhpcy5fdGFyZ2V0UmF5Lmhhc0xpbmVhclZlbG9jaXR5PSExLHRoaXMuX3RhcmdldFJheS5saW5lYXJWZWxvY2l0eT1uZXcgUix0aGlzLl90YXJnZXRSYXkuaGFzQW5ndWxhclZlbG9jaXR5PSExLHRoaXMuX3RhcmdldFJheS5hbmd1bGFyVmVsb2NpdHk9bmV3IFIpLHRoaXMuX3RhcmdldFJheX1nZXRHcmlwU3BhY2UoKXtyZXR1cm4gdGhpcy5fZ3JpcD09PW51bGwmJih0aGlzLl9ncmlwPW5ldyBLbix0aGlzLl9ncmlwLm1hdHJpeEF1dG9VcGRhdGU9ITEsdGhpcy5fZ3JpcC52aXNpYmxlPSExLHRoaXMuX2dyaXAuaGFzTGluZWFyVmVsb2NpdHk9ITEsdGhpcy5fZ3JpcC5saW5lYXJWZWxvY2l0eT1uZXcgUix0aGlzLl9ncmlwLmhhc0FuZ3VsYXJWZWxvY2l0eT0hMSx0aGlzLl9ncmlwLmFuZ3VsYXJWZWxvY2l0eT1uZXcgUiksdGhpcy5fZ3JpcH1kaXNwYXRjaEV2ZW50KHQpe3JldHVybiB0aGlzLl90YXJnZXRSYXkhPT1udWxsJiZ0aGlzLl90YXJnZXRSYXkuZGlzcGF0Y2hFdmVudCh0KSx0aGlzLl9ncmlwIT09bnVsbCYmdGhpcy5fZ3JpcC5kaXNwYXRjaEV2ZW50KHQpLHRoaXMuX2hhbmQhPT1udWxsJiZ0aGlzLl9oYW5kLmRpc3BhdGNoRXZlbnQodCksdGhpc31jb25uZWN0KHQpe2lmKHQmJnQuaGFuZCl7bGV0IGU9dGhpcy5faGFuZDtpZihlKWZvcihsZXQgbiBvZiB0LmhhbmQudmFsdWVzKCkpdGhpcy5fZ2V0SGFuZEpvaW50KGUsbil9cmV0dXJuIHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToiY29ubmVjdGVkIixkYXRhOnR9KSx0aGlzfWRpc2Nvbm5lY3QodCl7cmV0dXJuIHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToiZGlzY29ubmVjdGVkIixkYXRhOnR9KSx0aGlzLl90YXJnZXRSYXkhPT1udWxsJiYodGhpcy5fdGFyZ2V0UmF5LnZpc2libGU9ITEpLHRoaXMuX2dyaXAhPT1udWxsJiYodGhpcy5fZ3JpcC52aXNpYmxlPSExKSx0aGlzLl9oYW5kIT09bnVsbCYmKHRoaXMuX2hhbmQudmlzaWJsZT0hMSksdGhpc311cGRhdGUodCxlLG4pe2xldCBpPW51bGwscj1udWxsLGE9bnVsbCxvPXRoaXMuX3RhcmdldFJheSxsPXRoaXMuX2dyaXAsYz10aGlzLl9oYW5kO2lmKHQmJmUuc2Vzc2lvbi52aXNpYmlsaXR5U3RhdGUhPT0idmlzaWJsZS1ibHVycmVkIil7aWYoYyYmdC5oYW5kKXthPSEwO2ZvcihsZXQgXyBvZiB0LmhhbmQudmFsdWVzKCkpe2xldCBnPWUuZ2V0Sm9pbnRQb3NlKF8sbikscD10aGlzLl9nZXRIYW5kSm9pbnQoYyxfKTtnIT09bnVsbCYmKHAubWF0cml4LmZyb21BcnJheShnLnRyYW5zZm9ybS5tYXRyaXgpLHAubWF0cml4LmRlY29tcG9zZShwLnBvc2l0aW9uLHAucm90YXRpb24scC5zY2FsZSkscC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPSEwLHAuam9pbnRSYWRpdXM9Zy5yYWRpdXMpLHAudmlzaWJsZT1nIT09bnVsbH1sZXQgaD1jLmpvaW50c1siaW5kZXgtZmluZ2VyLXRpcCJdLHU9Yy5qb2ludHNbInRodW1iLXRpcCJdLGQ9aC5wb3NpdGlvbi5kaXN0YW5jZVRvKHUucG9zaXRpb24pLGY9LjAyLG09LjAwNTtjLmlucHV0U3RhdGUucGluY2hpbmcmJmQ+ZittPyhjLmlucHV0U3RhdGUucGluY2hpbmc9ITEsdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJwaW5jaGVuZCIsaGFuZGVkbmVzczp0LmhhbmRlZG5lc3MsdGFyZ2V0OnRoaXN9KSk6IWMuaW5wdXRTdGF0ZS5waW5jaGluZyYmZDw9Zi1tJiYoYy5pbnB1dFN0YXRlLnBpbmNoaW5nPSEwLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToicGluY2hzdGFydCIsaGFuZGVkbmVzczp0LmhhbmRlZG5lc3MsdGFyZ2V0OnRoaXN9KSl9ZWxzZSBsIT09bnVsbCYmdC5ncmlwU3BhY2UmJihyPWUuZ2V0UG9zZSh0LmdyaXBTcGFjZSxuKSxyIT09bnVsbCYmKGwubWF0cml4LmZyb21BcnJheShyLnRyYW5zZm9ybS5tYXRyaXgpLGwubWF0cml4LmRlY29tcG9zZShsLnBvc2l0aW9uLGwucm90YXRpb24sbC5zY2FsZSksbC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPSEwLHIubGluZWFyVmVsb2NpdHk/KGwuaGFzTGluZWFyVmVsb2NpdHk9ITAsbC5saW5lYXJWZWxvY2l0eS5jb3B5KHIubGluZWFyVmVsb2NpdHkpKTpsLmhhc0xpbmVhclZlbG9jaXR5PSExLHIuYW5ndWxhclZlbG9jaXR5PyhsLmhhc0FuZ3VsYXJWZWxvY2l0eT0hMCxsLmFuZ3VsYXJWZWxvY2l0eS5jb3B5KHIuYW5ndWxhclZlbG9jaXR5KSk6bC5oYXNBbmd1bGFyVmVsb2NpdHk9ITEpKTtvIT09bnVsbCYmKGk9ZS5nZXRQb3NlKHQudGFyZ2V0UmF5U3BhY2UsbiksaT09PW51bGwmJnIhPT1udWxsJiYoaT1yKSxpIT09bnVsbCYmKG8ubWF0cml4LmZyb21BcnJheShpLnRyYW5zZm9ybS5tYXRyaXgpLG8ubWF0cml4LmRlY29tcG9zZShvLnBvc2l0aW9uLG8ucm90YXRpb24sby5zY2FsZSksby5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPSEwLGkubGluZWFyVmVsb2NpdHk/KG8uaGFzTGluZWFyVmVsb2NpdHk9ITAsby5saW5lYXJWZWxvY2l0eS5jb3B5KGkubGluZWFyVmVsb2NpdHkpKTpvLmhhc0xpbmVhclZlbG9jaXR5PSExLGkuYW5ndWxhclZlbG9jaXR5PyhvLmhhc0FuZ3VsYXJWZWxvY2l0eT0hMCxvLmFuZ3VsYXJWZWxvY2l0eS5jb3B5KGkuYW5ndWxhclZlbG9jaXR5KSk6by5oYXNBbmd1bGFyVmVsb2NpdHk9ITEsdGhpcy5kaXNwYXRjaEV2ZW50KGN2KSkpfXJldHVybiBvIT09bnVsbCYmKG8udmlzaWJsZT1pIT09bnVsbCksbCE9PW51bGwmJihsLnZpc2libGU9ciE9PW51bGwpLGMhPT1udWxsJiYoYy52aXNpYmxlPWEhPT1udWxsKSx0aGlzfV9nZXRIYW5kSm9pbnQodCxlKXtpZih0LmpvaW50c1tlLmpvaW50TmFtZV09PT12b2lkIDApe2xldCBuPW5ldyBLbjtuLm1hdHJpeEF1dG9VcGRhdGU9ITEsbi52aXNpYmxlPSExLHQuam9pbnRzW2Uuam9pbnROYW1lXT1uLHQuYWRkKG4pfXJldHVybiB0LmpvaW50c1tlLmpvaW50TmFtZV19fSxodj1gCnZvaWQgbWFpbigpIHsKCglnbF9Qb3NpdGlvbiA9IHZlYzQoIHBvc2l0aW9uLCAxLjAgKTsKCn1gLHV2PWAKdW5pZm9ybSBzYW1wbGVyMkRBcnJheSBkZXB0aENvbG9yOwp1bmlmb3JtIGZsb2F0IGRlcHRoV2lkdGg7CnVuaWZvcm0gZmxvYXQgZGVwdGhIZWlnaHQ7Cgp2b2lkIG1haW4oKSB7CgoJdmVjMiBjb29yZCA9IHZlYzIoIGdsX0ZyYWdDb29yZC54IC8gZGVwdGhXaWR0aCwgZ2xfRnJhZ0Nvb3JkLnkgLyBkZXB0aEhlaWdodCApOwoKCWlmICggY29vcmQueCA+PSAxLjAgKSB7CgoJCWdsX0ZyYWdEZXB0aEVYVCA9IHRleHR1cmUoIGRlcHRoQ29sb3IsIHZlYzMoIGNvb3JkLnggLSAxLjAsIGNvb3JkLnksIDEgKSApLnI7CgoJfSBlbHNlIHsKCgkJZ2xfRnJhZ0RlcHRoRVhUID0gdGV4dHVyZSggZGVwdGhDb2xvciwgdmVjMyggY29vcmQueCwgY29vcmQueSwgMCApICkucjsKCgl9Cgp9YCxXYz1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMudGV4dHVyZT1udWxsLHRoaXMubWVzaD1udWxsLHRoaXMuZGVwdGhOZWFyPTAsdGhpcy5kZXB0aEZhcj0wfWluaXQodCxlLG4pe2lmKHRoaXMudGV4dHVyZT09PW51bGwpe2xldCBpPW5ldyBfZSxyPXQucHJvcGVydGllcy5nZXQoaSk7ci5fX3dlYmdsVGV4dHVyZT1lLnRleHR1cmUsKGUuZGVwdGhOZWFyIT1uLmRlcHRoTmVhcnx8ZS5kZXB0aEZhciE9bi5kZXB0aEZhcikmJih0aGlzLmRlcHRoTmVhcj1lLmRlcHRoTmVhcix0aGlzLmRlcHRoRmFyPWUuZGVwdGhGYXIpLHRoaXMudGV4dHVyZT1pfX1yZW5kZXIodCxlKXtpZih0aGlzLnRleHR1cmUhPT1udWxsKXtpZih0aGlzLm1lc2g9PT1udWxsKXtsZXQgbj1lLmNhbWVyYXNbMF0udmlld3BvcnQsaT1uZXcgSmUoe2V4dGVuc2lvbnM6e2ZyYWdEZXB0aDohMH0sdmVydGV4U2hhZGVyOmh2LGZyYWdtZW50U2hhZGVyOnV2LHVuaWZvcm1zOntkZXB0aENvbG9yOnt2YWx1ZTp0aGlzLnRleHR1cmV9LGRlcHRoV2lkdGg6e3ZhbHVlOm4uen0sZGVwdGhIZWlnaHQ6e3ZhbHVlOm4ud319fSk7dGhpcy5tZXNoPW5ldyBkZShuZXcgeXMoMjAsMjApLGkpfXQucmVuZGVyKHRoaXMubWVzaCxlKX19cmVzZXQoKXt0aGlzLnRleHR1cmU9bnVsbCx0aGlzLm1lc2g9bnVsbH19LFhjPWNsYXNzIGV4dGVuZHMgbG57Y29uc3RydWN0b3IodCxlKXtzdXBlcigpO2xldCBuPXRoaXMsaT1udWxsLHI9MSxhPW51bGwsbz0ibG9jYWwtZmxvb3IiLGw9MSxjPW51bGwsaD1udWxsLHU9bnVsbCxkPW51bGwsZj1udWxsLG09bnVsbCxfPW5ldyBXYyxnPWUuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKSxwPW51bGwsdj1udWxsLHg9W10sTT1bXSxDPW5ldyBaLEE9bnVsbCxUPW5ldyB2ZTtULmxheWVycy5lbmFibGUoMSksVC52aWV3cG9ydD1uZXcgdGU7bGV0IFU9bmV3IHZlO1UubGF5ZXJzLmVuYWJsZSgyKSxVLnZpZXdwb3J0PW5ldyB0ZTtsZXQgaz1bVCxVXSx5PW5ldyBYYTt5LmxheWVycy5lbmFibGUoMSkseS5sYXllcnMuZW5hYmxlKDIpO2xldCB3PW51bGwsRz1udWxsO3RoaXMuY2FtZXJhQXV0b1VwZGF0ZT0hMCx0aGlzLmVuYWJsZWQ9ITEsdGhpcy5pc1ByZXNlbnRpbmc9ITEsdGhpcy5nZXRDb250cm9sbGVyPWZ1bmN0aW9uKEgpe2xldCBpdD14W0hdO3JldHVybiBpdD09PXZvaWQgMCYmKGl0PW5ldyBHcyx4W0hdPWl0KSxpdC5nZXRUYXJnZXRSYXlTcGFjZSgpfSx0aGlzLmdldENvbnRyb2xsZXJHcmlwPWZ1bmN0aW9uKEgpe2xldCBpdD14W0hdO3JldHVybiBpdD09PXZvaWQgMCYmKGl0PW5ldyBHcyx4W0hdPWl0KSxpdC5nZXRHcmlwU3BhY2UoKX0sdGhpcy5nZXRIYW5kPWZ1bmN0aW9uKEgpe2xldCBpdD14W0hdO3JldHVybiBpdD09PXZvaWQgMCYmKGl0PW5ldyBHcyx4W0hdPWl0KSxpdC5nZXRIYW5kU3BhY2UoKX07ZnVuY3Rpb24gSihIKXtsZXQgaXQ9TS5pbmRleE9mKEguaW5wdXRTb3VyY2UpO2lmKGl0PT09LTEpcmV0dXJuO2xldCBwdD14W2l0XTtwdCE9PXZvaWQgMCYmKHB0LnVwZGF0ZShILmlucHV0U291cmNlLEguZnJhbWUsY3x8YSkscHQuZGlzcGF0Y2hFdmVudCh7dHlwZTpILnR5cGUsZGF0YTpILmlucHV0U291cmNlfSkpfWZ1bmN0aW9uIEkoKXtpLnJlbW92ZUV2ZW50TGlzdGVuZXIoInNlbGVjdCIsSiksaS5yZW1vdmVFdmVudExpc3RlbmVyKCJzZWxlY3RzdGFydCIsSiksaS5yZW1vdmVFdmVudExpc3RlbmVyKCJzZWxlY3RlbmQiLEopLGkucmVtb3ZlRXZlbnRMaXN0ZW5lcigic3F1ZWV6ZSIsSiksaS5yZW1vdmVFdmVudExpc3RlbmVyKCJzcXVlZXplc3RhcnQiLEopLGkucmVtb3ZlRXZlbnRMaXN0ZW5lcigic3F1ZWV6ZWVuZCIsSiksaS5yZW1vdmVFdmVudExpc3RlbmVyKCJlbmQiLEkpLGkucmVtb3ZlRXZlbnRMaXN0ZW5lcigiaW5wdXRzb3VyY2VzY2hhbmdlIix6KTtmb3IobGV0IEg9MDtIPHgubGVuZ3RoO0grKyl7bGV0IGl0PU1bSF07aXQhPT1udWxsJiYoTVtIXT1udWxsLHhbSF0uZGlzY29ubmVjdChpdCkpfXc9bnVsbCxHPW51bGwsXy5yZXNldCgpLHQuc2V0UmVuZGVyVGFyZ2V0KHApLGY9bnVsbCxkPW51bGwsdT1udWxsLGk9bnVsbCx2PW51bGwsUHQuc3RvcCgpLG4uaXNQcmVzZW50aW5nPSExLHQuc2V0UGl4ZWxSYXRpbyhBKSx0LnNldFNpemUoQy53aWR0aCxDLmhlaWdodCwhMSksbi5kaXNwYXRjaEV2ZW50KHt0eXBlOiJzZXNzaW9uZW5kIn0pfXRoaXMuc2V0RnJhbWVidWZmZXJTY2FsZUZhY3Rvcj1mdW5jdGlvbihIKXtyPUgsbi5pc1ByZXNlbnRpbmc9PT0hMCYmY29uc29sZS53YXJuKCJUSFJFRS5XZWJYUk1hbmFnZXI6IENhbm5vdCBjaGFuZ2UgZnJhbWVidWZmZXIgc2NhbGUgd2hpbGUgcHJlc2VudGluZy4iKX0sdGhpcy5zZXRSZWZlcmVuY2VTcGFjZVR5cGU9ZnVuY3Rpb24oSCl7bz1ILG4uaXNQcmVzZW50aW5nPT09ITAmJmNvbnNvbGUud2FybigiVEhSRUUuV2ViWFJNYW5hZ2VyOiBDYW5ub3QgY2hhbmdlIHJlZmVyZW5jZSBzcGFjZSB0eXBlIHdoaWxlIHByZXNlbnRpbmcuIil9LHRoaXMuZ2V0UmVmZXJlbmNlU3BhY2U9ZnVuY3Rpb24oKXtyZXR1cm4gY3x8YX0sdGhpcy5zZXRSZWZlcmVuY2VTcGFjZT1mdW5jdGlvbihIKXtjPUh9LHRoaXMuZ2V0QmFzZUxheWVyPWZ1bmN0aW9uKCl7cmV0dXJuIGQhPT1udWxsP2Q6Zn0sdGhpcy5nZXRCaW5kaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHV9LHRoaXMuZ2V0RnJhbWU9ZnVuY3Rpb24oKXtyZXR1cm4gbX0sdGhpcy5nZXRTZXNzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGl9LHRoaXMuc2V0U2Vzc2lvbj1hc3luYyBmdW5jdGlvbihIKXtpZihpPUgsaSE9PW51bGwpe2lmKHA9dC5nZXRSZW5kZXJUYXJnZXQoKSxpLmFkZEV2ZW50TGlzdGVuZXIoInNlbGVjdCIsSiksaS5hZGRFdmVudExpc3RlbmVyKCJzZWxlY3RzdGFydCIsSiksaS5hZGRFdmVudExpc3RlbmVyKCJzZWxlY3RlbmQiLEopLGkuYWRkRXZlbnRMaXN0ZW5lcigic3F1ZWV6ZSIsSiksaS5hZGRFdmVudExpc3RlbmVyKCJzcXVlZXplc3RhcnQiLEopLGkuYWRkRXZlbnRMaXN0ZW5lcigic3F1ZWV6ZWVuZCIsSiksaS5hZGRFdmVudExpc3RlbmVyKCJlbmQiLEkpLGkuYWRkRXZlbnRMaXN0ZW5lcigiaW5wdXRzb3VyY2VzY2hhbmdlIix6KSxnLnhyQ29tcGF0aWJsZSE9PSEwJiZhd2FpdCBlLm1ha2VYUkNvbXBhdGlibGUoKSxBPXQuZ2V0UGl4ZWxSYXRpbygpLHQuZ2V0U2l6ZShDKSxpLnJlbmRlclN0YXRlLmxheWVycz09PXZvaWQgMHx8dC5jYXBhYmlsaXRpZXMuaXNXZWJHTDI9PT0hMSl7bGV0IGl0PXthbnRpYWxpYXM6aS5yZW5kZXJTdGF0ZS5sYXllcnM9PT12b2lkIDA/Zy5hbnRpYWxpYXM6ITAsYWxwaGE6ITAsZGVwdGg6Zy5kZXB0aCxzdGVuY2lsOmcuc3RlbmNpbCxmcmFtZWJ1ZmZlclNjYWxlRmFjdG9yOnJ9O2Y9bmV3IFhSV2ViR0xMYXllcihpLGUsaXQpLGkudXBkYXRlUmVuZGVyU3RhdGUoe2Jhc2VMYXllcjpmfSksdC5zZXRQaXhlbFJhdGlvKDEpLHQuc2V0U2l6ZShmLmZyYW1lYnVmZmVyV2lkdGgsZi5mcmFtZWJ1ZmZlckhlaWdodCwhMSksdj1uZXcgWmUoZi5mcmFtZWJ1ZmZlcldpZHRoLGYuZnJhbWVidWZmZXJIZWlnaHQse2Zvcm1hdDpIZSx0eXBlOk5uLGNvbG9yU3BhY2U6dC5vdXRwdXRDb2xvclNwYWNlLHN0ZW5jaWxCdWZmZXI6Zy5zdGVuY2lsfSl9ZWxzZXtsZXQgaXQ9bnVsbCxwdD1udWxsLHZ0PW51bGw7Zy5kZXB0aCYmKHZ0PWcuc3RlbmNpbD9lLkRFUFRIMjRfU1RFTkNJTDg6ZS5ERVBUSF9DT01QT05FTlQyNCxpdD1nLnN0ZW5jaWw/Q2k6am4scHQ9Zy5zdGVuY2lsP1FuOkNuKTtsZXQgRXQ9e2NvbG9yRm9ybWF0OmUuUkdCQTgsZGVwdGhGb3JtYXQ6dnQsc2NhbGVGYWN0b3I6cn07dT1uZXcgWFJXZWJHTEJpbmRpbmcoaSxlKSxkPXUuY3JlYXRlUHJvamVjdGlvbkxheWVyKEV0KSxpLnVwZGF0ZVJlbmRlclN0YXRlKHtsYXllcnM6W2RdfSksdC5zZXRQaXhlbFJhdGlvKDEpLHQuc2V0U2l6ZShkLnRleHR1cmVXaWR0aCxkLnRleHR1cmVIZWlnaHQsITEpLHY9bmV3IFplKGQudGV4dHVyZVdpZHRoLGQudGV4dHVyZUhlaWdodCx7Zm9ybWF0OkhlLHR5cGU6Tm4sZGVwdGhUZXh0dXJlOm5ldyBkcihkLnRleHR1cmVXaWR0aCxkLnRleHR1cmVIZWlnaHQscHQsdm9pZCAwLHZvaWQgMCx2b2lkIDAsdm9pZCAwLHZvaWQgMCx2b2lkIDAsaXQpLHN0ZW5jaWxCdWZmZXI6Zy5zdGVuY2lsLGNvbG9yU3BhY2U6dC5vdXRwdXRDb2xvclNwYWNlLHNhbXBsZXM6Zy5hbnRpYWxpYXM/NDowfSk7bGV0IHl0PXQucHJvcGVydGllcy5nZXQodik7eXQuX19pZ25vcmVEZXB0aFZhbHVlcz1kLmlnbm9yZURlcHRoVmFsdWVzfXYuaXNYUlJlbmRlclRhcmdldD0hMCx0aGlzLnNldEZvdmVhdGlvbihsKSxjPW51bGwsYT1hd2FpdCBpLnJlcXVlc3RSZWZlcmVuY2VTcGFjZShvKSxQdC5zZXRDb250ZXh0KGkpLFB0LnN0YXJ0KCksbi5pc1ByZXNlbnRpbmc9ITAsbi5kaXNwYXRjaEV2ZW50KHt0eXBlOiJzZXNzaW9uc3RhcnQifSl9fSx0aGlzLmdldEVudmlyb25tZW50QmxlbmRNb2RlPWZ1bmN0aW9uKCl7aWYoaSE9PW51bGwpcmV0dXJuIGkuZW52aXJvbm1lbnRCbGVuZE1vZGV9O2Z1bmN0aW9uIHooSCl7Zm9yKGxldCBpdD0wO2l0PEgucmVtb3ZlZC5sZW5ndGg7aXQrKyl7bGV0IHB0PUgucmVtb3ZlZFtpdF0sdnQ9TS5pbmRleE9mKHB0KTt2dD49MCYmKE1bdnRdPW51bGwseFt2dF0uZGlzY29ubmVjdChwdCkpfWZvcihsZXQgaXQ9MDtpdDxILmFkZGVkLmxlbmd0aDtpdCsrKXtsZXQgcHQ9SC5hZGRlZFtpdF0sdnQ9TS5pbmRleE9mKHB0KTtpZih2dD09PS0xKXtmb3IobGV0IHl0PTA7eXQ8eC5sZW5ndGg7eXQrKylpZih5dD49TS5sZW5ndGgpe00ucHVzaChwdCksdnQ9eXQ7YnJlYWt9ZWxzZSBpZihNW3l0XT09PW51bGwpe01beXRdPXB0LHZ0PXl0O2JyZWFrfWlmKHZ0PT09LTEpYnJlYWt9bGV0IEV0PXhbdnRdO0V0JiZFdC5jb25uZWN0KHB0KX19bGV0IEY9bmV3IFIsJD1uZXcgUjtmdW5jdGlvbiBxKEgsaXQscHQpe0Yuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGl0Lm1hdHJpeFdvcmxkKSwkLnNldEZyb21NYXRyaXhQb3NpdGlvbihwdC5tYXRyaXhXb3JsZCk7bGV0IHZ0PUYuZGlzdGFuY2VUbygkKSxFdD1pdC5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzLHl0PXB0LnByb2plY3Rpb25NYXRyaXguZWxlbWVudHMsT3Q9RXRbMTRdLyhFdFsxMF0tMSksQXQ9RXRbMTRdLyhFdFsxMF0rMSksTD0oRXRbOV0rMSkvRXRbNV0sb3Q9KEV0WzldLTEpL0V0WzVdLFg9KEV0WzhdLTEpL0V0WzBdLHN0PSh5dFs4XSsxKS95dFswXSxZPU90KlgsYnQ9T3Qqc3QsaHQ9dnQvKC1YK3N0KSxiPWh0Ki1YO2l0Lm1hdHJpeFdvcmxkLmRlY29tcG9zZShILnBvc2l0aW9uLEgucXVhdGVybmlvbixILnNjYWxlKSxILnRyYW5zbGF0ZVgoYiksSC50cmFuc2xhdGVaKGh0KSxILm1hdHJpeFdvcmxkLmNvbXBvc2UoSC5wb3NpdGlvbixILnF1YXRlcm5pb24sSC5zY2FsZSksSC5tYXRyaXhXb3JsZEludmVyc2UuY29weShILm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtsZXQgUz1PdCtodCxOPUF0K2h0LG50PVktYixqPWJ0Kyh2dC1iKSxLPUwqQXQvTipTLHh0PW90KkF0L04qUztILnByb2plY3Rpb25NYXRyaXgubWFrZVBlcnNwZWN0aXZlKG50LGosSyx4dCxTLE4pLEgucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weShILnByb2plY3Rpb25NYXRyaXgpLmludmVydCgpfWZ1bmN0aW9uIFcoSCxpdCl7aXQ9PT1udWxsP0gubWF0cml4V29ybGQuY29weShILm1hdHJpeCk6SC5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKGl0Lm1hdHJpeFdvcmxkLEgubWF0cml4KSxILm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KEgubWF0cml4V29ybGQpLmludmVydCgpfXRoaXMudXBkYXRlQ2FtZXJhPWZ1bmN0aW9uKEgpe2lmKGk9PT1udWxsKXJldHVybjtfLnRleHR1cmUhPT1udWxsJiYoSC5uZWFyPV8uZGVwdGhOZWFyLEguZmFyPV8uZGVwdGhGYXIpLHkubmVhcj1VLm5lYXI9VC5uZWFyPUgubmVhcix5LmZhcj1VLmZhcj1ULmZhcj1ILmZhciwodyE9PXkubmVhcnx8RyE9PXkuZmFyKSYmKGkudXBkYXRlUmVuZGVyU3RhdGUoe2RlcHRoTmVhcjp5Lm5lYXIsZGVwdGhGYXI6eS5mYXJ9KSx3PXkubmVhcixHPXkuZmFyLFQubmVhcj13LFQuZmFyPUcsVS5uZWFyPXcsVS5mYXI9RyxULnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKSxVLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKSxILnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKSk7bGV0IGl0PUgucGFyZW50LHB0PXkuY2FtZXJhcztXKHksaXQpO2ZvcihsZXQgdnQ9MDt2dDxwdC5sZW5ndGg7dnQrKylXKHB0W3Z0XSxpdCk7cHQubGVuZ3RoPT09Mj9xKHksVCxVKTp5LnByb2plY3Rpb25NYXRyaXguY29weShULnByb2plY3Rpb25NYXRyaXgpLGV0KEgseSxpdCl9O2Z1bmN0aW9uIGV0KEgsaXQscHQpe3B0PT09bnVsbD9ILm1hdHJpeC5jb3B5KGl0Lm1hdHJpeFdvcmxkKTooSC5tYXRyaXguY29weShwdC5tYXRyaXhXb3JsZCksSC5tYXRyaXguaW52ZXJ0KCksSC5tYXRyaXgubXVsdGlwbHkoaXQubWF0cml4V29ybGQpKSxILm1hdHJpeC5kZWNvbXBvc2UoSC5wb3NpdGlvbixILnF1YXRlcm5pb24sSC5zY2FsZSksSC51cGRhdGVNYXRyaXhXb3JsZCghMCksSC5wcm9qZWN0aW9uTWF0cml4LmNvcHkoaXQucHJvamVjdGlvbk1hdHJpeCksSC5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KGl0LnByb2plY3Rpb25NYXRyaXhJbnZlcnNlKSxILmlzUGVyc3BlY3RpdmVDYW1lcmEmJihILmZvdj1tcyoyKk1hdGguYXRhbigxL0gucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1s1XSksSC56b29tPTEpfXRoaXMuZ2V0Q2FtZXJhPWZ1bmN0aW9uKCl7cmV0dXJuIHl9LHRoaXMuZ2V0Rm92ZWF0aW9uPWZ1bmN0aW9uKCl7aWYoIShkPT09bnVsbCYmZj09PW51bGwpKXJldHVybiBsfSx0aGlzLnNldEZvdmVhdGlvbj1mdW5jdGlvbihIKXtsPUgsZCE9PW51bGwmJihkLmZpeGVkRm92ZWF0aW9uPUgpLGYhPT1udWxsJiZmLmZpeGVkRm92ZWF0aW9uIT09dm9pZCAwJiYoZi5maXhlZEZvdmVhdGlvbj1IKX0sdGhpcy5oYXNEZXB0aFNlbnNpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gXy50ZXh0dXJlIT09bnVsbH07bGV0IFE9bnVsbDtmdW5jdGlvbiBmdChILGl0KXtpZihoPWl0LmdldFZpZXdlclBvc2UoY3x8YSksbT1pdCxoIT09bnVsbCl7bGV0IHB0PWgudmlld3M7ZiE9PW51bGwmJih0LnNldFJlbmRlclRhcmdldEZyYW1lYnVmZmVyKHYsZi5mcmFtZWJ1ZmZlciksdC5zZXRSZW5kZXJUYXJnZXQodikpO2xldCB2dD0hMTtwdC5sZW5ndGghPT15LmNhbWVyYXMubGVuZ3RoJiYoeS5jYW1lcmFzLmxlbmd0aD0wLHZ0PSEwKTtmb3IobGV0IHl0PTA7eXQ8cHQubGVuZ3RoO3l0Kyspe2xldCBPdD1wdFt5dF0sQXQ9bnVsbDtpZihmIT09bnVsbClBdD1mLmdldFZpZXdwb3J0KE90KTtlbHNle2xldCBvdD11LmdldFZpZXdTdWJJbWFnZShkLE90KTtBdD1vdC52aWV3cG9ydCx5dD09PTAmJih0LnNldFJlbmRlclRhcmdldFRleHR1cmVzKHYsb3QuY29sb3JUZXh0dXJlLGQuaWdub3JlRGVwdGhWYWx1ZXM/dm9pZCAwOm90LmRlcHRoU3RlbmNpbFRleHR1cmUpLHQuc2V0UmVuZGVyVGFyZ2V0KHYpKX1sZXQgTD1rW3l0XTtMPT09dm9pZCAwJiYoTD1uZXcgdmUsTC5sYXllcnMuZW5hYmxlKHl0KSxMLnZpZXdwb3J0PW5ldyB0ZSxrW3l0XT1MKSxMLm1hdHJpeC5mcm9tQXJyYXkoT3QudHJhbnNmb3JtLm1hdHJpeCksTC5tYXRyaXguZGVjb21wb3NlKEwucG9zaXRpb24sTC5xdWF0ZXJuaW9uLEwuc2NhbGUpLEwucHJvamVjdGlvbk1hdHJpeC5mcm9tQXJyYXkoT3QucHJvamVjdGlvbk1hdHJpeCksTC5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KEwucHJvamVjdGlvbk1hdHJpeCkuaW52ZXJ0KCksTC52aWV3cG9ydC5zZXQoQXQueCxBdC55LEF0LndpZHRoLEF0LmhlaWdodCkseXQ9PT0wJiYoeS5tYXRyaXguY29weShMLm1hdHJpeCkseS5tYXRyaXguZGVjb21wb3NlKHkucG9zaXRpb24seS5xdWF0ZXJuaW9uLHkuc2NhbGUpKSx2dD09PSEwJiZ5LmNhbWVyYXMucHVzaChMKX1sZXQgRXQ9aS5lbmFibGVkRmVhdHVyZXM7aWYoRXQmJkV0LmluY2x1ZGVzKCJkZXB0aC1zZW5zaW5nIikpe2xldCB5dD11LmdldERlcHRoSW5mb3JtYXRpb24ocHRbMF0pO3l0JiZ5dC5pc1ZhbGlkJiZ5dC50ZXh0dXJlJiZfLmluaXQodCx5dCxpLnJlbmRlclN0YXRlKX19Zm9yKGxldCBwdD0wO3B0PHgubGVuZ3RoO3B0Kyspe2xldCB2dD1NW3B0XSxFdD14W3B0XTt2dCE9PW51bGwmJkV0IT09dm9pZCAwJiZFdC51cGRhdGUodnQsaXQsY3x8YSl9Xy5yZW5kZXIodCx5KSxRJiZRKEgsaXQpLGl0LmRldGVjdGVkUGxhbmVzJiZuLmRpc3BhdGNoRXZlbnQoe3R5cGU6InBsYW5lc2RldGVjdGVkIixkYXRhOml0fSksbT1udWxsfWxldCBQdD1uZXcgamY7UHQuc2V0QW5pbWF0aW9uTG9vcChmdCksdGhpcy5zZXRBbmltYXRpb25Mb29wPWZ1bmN0aW9uKEgpe1E9SH0sdGhpcy5kaXNwb3NlPWZ1bmN0aW9uKCl7fX19O2Z1bmN0aW9uIGR2KHMsdCl7ZnVuY3Rpb24gZShnLHApe2cubWF0cml4QXV0b1VwZGF0ZT09PSEwJiZnLnVwZGF0ZU1hdHJpeCgpLHAudmFsdWUuY29weShnLm1hdHJpeCl9ZnVuY3Rpb24gbihnLHApe3AuY29sb3IuZ2V0UkdCKGcuZm9nQ29sb3IudmFsdWUsS2YocykpLHAuaXNGb2c/KGcuZm9nTmVhci52YWx1ZT1wLm5lYXIsZy5mb2dGYXIudmFsdWU9cC5mYXIpOnAuaXNGb2dFeHAyJiYoZy5mb2dEZW5zaXR5LnZhbHVlPXAuZGVuc2l0eSl9ZnVuY3Rpb24gaShnLHAsdix4LE0pe3AuaXNNZXNoQmFzaWNNYXRlcmlhbHx8cC5pc01lc2hMYW1iZXJ0TWF0ZXJpYWw/cihnLHApOnAuaXNNZXNoVG9vbk1hdGVyaWFsPyhyKGcscCksdShnLHApKTpwLmlzTWVzaFBob25nTWF0ZXJpYWw/KHIoZyxwKSxoKGcscCkpOnAuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbD8ocihnLHApLGQoZyxwKSxwLmlzTWVzaFBoeXNpY2FsTWF0ZXJpYWwmJmYoZyxwLE0pKTpwLmlzTWVzaE1hdGNhcE1hdGVyaWFsPyhyKGcscCksbShnLHApKTpwLmlzTWVzaERlcHRoTWF0ZXJpYWw/cihnLHApOnAuaXNNZXNoRGlzdGFuY2VNYXRlcmlhbD8ocihnLHApLF8oZyxwKSk6cC5pc01lc2hOb3JtYWxNYXRlcmlhbD9yKGcscCk6cC5pc0xpbmVCYXNpY01hdGVyaWFsPyhhKGcscCkscC5pc0xpbmVEYXNoZWRNYXRlcmlhbCYmbyhnLHApKTpwLmlzUG9pbnRzTWF0ZXJpYWw/bChnLHAsdix4KTpwLmlzU3ByaXRlTWF0ZXJpYWw/YyhnLHApOnAuaXNTaGFkb3dNYXRlcmlhbD8oZy5jb2xvci52YWx1ZS5jb3B5KHAuY29sb3IpLGcub3BhY2l0eS52YWx1ZT1wLm9wYWNpdHkpOnAuaXNTaGFkZXJNYXRlcmlhbCYmKHAudW5pZm9ybXNOZWVkVXBkYXRlPSExKX1mdW5jdGlvbiByKGcscCl7Zy5vcGFjaXR5LnZhbHVlPXAub3BhY2l0eSxwLmNvbG9yJiZnLmRpZmZ1c2UudmFsdWUuY29weShwLmNvbG9yKSxwLmVtaXNzaXZlJiZnLmVtaXNzaXZlLnZhbHVlLmNvcHkocC5lbWlzc2l2ZSkubXVsdGlwbHlTY2FsYXIocC5lbWlzc2l2ZUludGVuc2l0eSkscC5tYXAmJihnLm1hcC52YWx1ZT1wLm1hcCxlKHAubWFwLGcubWFwVHJhbnNmb3JtKSkscC5hbHBoYU1hcCYmKGcuYWxwaGFNYXAudmFsdWU9cC5hbHBoYU1hcCxlKHAuYWxwaGFNYXAsZy5hbHBoYU1hcFRyYW5zZm9ybSkpLHAuYnVtcE1hcCYmKGcuYnVtcE1hcC52YWx1ZT1wLmJ1bXBNYXAsZShwLmJ1bXBNYXAsZy5idW1wTWFwVHJhbnNmb3JtKSxnLmJ1bXBTY2FsZS52YWx1ZT1wLmJ1bXBTY2FsZSxwLnNpZGU9PT1WZSYmKGcuYnVtcFNjYWxlLnZhbHVlKj0tMSkpLHAubm9ybWFsTWFwJiYoZy5ub3JtYWxNYXAudmFsdWU9cC5ub3JtYWxNYXAsZShwLm5vcm1hbE1hcCxnLm5vcm1hbE1hcFRyYW5zZm9ybSksZy5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KHAubm9ybWFsU2NhbGUpLHAuc2lkZT09PVZlJiZnLm5vcm1hbFNjYWxlLnZhbHVlLm5lZ2F0ZSgpKSxwLmRpc3BsYWNlbWVudE1hcCYmKGcuZGlzcGxhY2VtZW50TWFwLnZhbHVlPXAuZGlzcGxhY2VtZW50TWFwLGUocC5kaXNwbGFjZW1lbnRNYXAsZy5kaXNwbGFjZW1lbnRNYXBUcmFuc2Zvcm0pLGcuZGlzcGxhY2VtZW50U2NhbGUudmFsdWU9cC5kaXNwbGFjZW1lbnRTY2FsZSxnLmRpc3BsYWNlbWVudEJpYXMudmFsdWU9cC5kaXNwbGFjZW1lbnRCaWFzKSxwLmVtaXNzaXZlTWFwJiYoZy5lbWlzc2l2ZU1hcC52YWx1ZT1wLmVtaXNzaXZlTWFwLGUocC5lbWlzc2l2ZU1hcCxnLmVtaXNzaXZlTWFwVHJhbnNmb3JtKSkscC5zcGVjdWxhck1hcCYmKGcuc3BlY3VsYXJNYXAudmFsdWU9cC5zcGVjdWxhck1hcCxlKHAuc3BlY3VsYXJNYXAsZy5zcGVjdWxhck1hcFRyYW5zZm9ybSkpLHAuYWxwaGFUZXN0PjAmJihnLmFscGhhVGVzdC52YWx1ZT1wLmFscGhhVGVzdCk7bGV0IHY9dC5nZXQocCkuZW52TWFwO2lmKHYmJihnLmVudk1hcC52YWx1ZT12LGcuZmxpcEVudk1hcC52YWx1ZT12LmlzQ3ViZVRleHR1cmUmJnYuaXNSZW5kZXJUYXJnZXRUZXh0dXJlPT09ITE/LTE6MSxnLnJlZmxlY3Rpdml0eS52YWx1ZT1wLnJlZmxlY3Rpdml0eSxnLmlvci52YWx1ZT1wLmlvcixnLnJlZnJhY3Rpb25SYXRpby52YWx1ZT1wLnJlZnJhY3Rpb25SYXRpbykscC5saWdodE1hcCl7Zy5saWdodE1hcC52YWx1ZT1wLmxpZ2h0TWFwO2xldCB4PXMuX3VzZUxlZ2FjeUxpZ2h0cz09PSEwP01hdGguUEk6MTtnLmxpZ2h0TWFwSW50ZW5zaXR5LnZhbHVlPXAubGlnaHRNYXBJbnRlbnNpdHkqeCxlKHAubGlnaHRNYXAsZy5saWdodE1hcFRyYW5zZm9ybSl9cC5hb01hcCYmKGcuYW9NYXAudmFsdWU9cC5hb01hcCxnLmFvTWFwSW50ZW5zaXR5LnZhbHVlPXAuYW9NYXBJbnRlbnNpdHksZShwLmFvTWFwLGcuYW9NYXBUcmFuc2Zvcm0pKX1mdW5jdGlvbiBhKGcscCl7Zy5kaWZmdXNlLnZhbHVlLmNvcHkocC5jb2xvciksZy5vcGFjaXR5LnZhbHVlPXAub3BhY2l0eSxwLm1hcCYmKGcubWFwLnZhbHVlPXAubWFwLGUocC5tYXAsZy5tYXBUcmFuc2Zvcm0pKX1mdW5jdGlvbiBvKGcscCl7Zy5kYXNoU2l6ZS52YWx1ZT1wLmRhc2hTaXplLGcudG90YWxTaXplLnZhbHVlPXAuZGFzaFNpemUrcC5nYXBTaXplLGcuc2NhbGUudmFsdWU9cC5zY2FsZX1mdW5jdGlvbiBsKGcscCx2LHgpe2cuZGlmZnVzZS52YWx1ZS5jb3B5KHAuY29sb3IpLGcub3BhY2l0eS52YWx1ZT1wLm9wYWNpdHksZy5zaXplLnZhbHVlPXAuc2l6ZSp2LGcuc2NhbGUudmFsdWU9eCouNSxwLm1hcCYmKGcubWFwLnZhbHVlPXAubWFwLGUocC5tYXAsZy51dlRyYW5zZm9ybSkpLHAuYWxwaGFNYXAmJihnLmFscGhhTWFwLnZhbHVlPXAuYWxwaGFNYXAsZShwLmFscGhhTWFwLGcuYWxwaGFNYXBUcmFuc2Zvcm0pKSxwLmFscGhhVGVzdD4wJiYoZy5hbHBoYVRlc3QudmFsdWU9cC5hbHBoYVRlc3QpfWZ1bmN0aW9uIGMoZyxwKXtnLmRpZmZ1c2UudmFsdWUuY29weShwLmNvbG9yKSxnLm9wYWNpdHkudmFsdWU9cC5vcGFjaXR5LGcucm90YXRpb24udmFsdWU9cC5yb3RhdGlvbixwLm1hcCYmKGcubWFwLnZhbHVlPXAubWFwLGUocC5tYXAsZy5tYXBUcmFuc2Zvcm0pKSxwLmFscGhhTWFwJiYoZy5hbHBoYU1hcC52YWx1ZT1wLmFscGhhTWFwLGUocC5hbHBoYU1hcCxnLmFscGhhTWFwVHJhbnNmb3JtKSkscC5hbHBoYVRlc3Q+MCYmKGcuYWxwaGFUZXN0LnZhbHVlPXAuYWxwaGFUZXN0KX1mdW5jdGlvbiBoKGcscCl7Zy5zcGVjdWxhci52YWx1ZS5jb3B5KHAuc3BlY3VsYXIpLGcuc2hpbmluZXNzLnZhbHVlPU1hdGgubWF4KHAuc2hpbmluZXNzLDFlLTQpfWZ1bmN0aW9uIHUoZyxwKXtwLmdyYWRpZW50TWFwJiYoZy5ncmFkaWVudE1hcC52YWx1ZT1wLmdyYWRpZW50TWFwKX1mdW5jdGlvbiBkKGcscCl7Zy5tZXRhbG5lc3MudmFsdWU9cC5tZXRhbG5lc3MscC5tZXRhbG5lc3NNYXAmJihnLm1ldGFsbmVzc01hcC52YWx1ZT1wLm1ldGFsbmVzc01hcCxlKHAubWV0YWxuZXNzTWFwLGcubWV0YWxuZXNzTWFwVHJhbnNmb3JtKSksZy5yb3VnaG5lc3MudmFsdWU9cC5yb3VnaG5lc3MscC5yb3VnaG5lc3NNYXAmJihnLnJvdWdobmVzc01hcC52YWx1ZT1wLnJvdWdobmVzc01hcCxlKHAucm91Z2huZXNzTWFwLGcucm91Z2huZXNzTWFwVHJhbnNmb3JtKSksdC5nZXQocCkuZW52TWFwJiYoZy5lbnZNYXBJbnRlbnNpdHkudmFsdWU9cC5lbnZNYXBJbnRlbnNpdHkpfWZ1bmN0aW9uIGYoZyxwLHYpe2cuaW9yLnZhbHVlPXAuaW9yLHAuc2hlZW4+MCYmKGcuc2hlZW5Db2xvci52YWx1ZS5jb3B5KHAuc2hlZW5Db2xvcikubXVsdGlwbHlTY2FsYXIocC5zaGVlbiksZy5zaGVlblJvdWdobmVzcy52YWx1ZT1wLnNoZWVuUm91Z2huZXNzLHAuc2hlZW5Db2xvck1hcCYmKGcuc2hlZW5Db2xvck1hcC52YWx1ZT1wLnNoZWVuQ29sb3JNYXAsZShwLnNoZWVuQ29sb3JNYXAsZy5zaGVlbkNvbG9yTWFwVHJhbnNmb3JtKSkscC5zaGVlblJvdWdobmVzc01hcCYmKGcuc2hlZW5Sb3VnaG5lc3NNYXAudmFsdWU9cC5zaGVlblJvdWdobmVzc01hcCxlKHAuc2hlZW5Sb3VnaG5lc3NNYXAsZy5zaGVlblJvdWdobmVzc01hcFRyYW5zZm9ybSkpKSxwLmNsZWFyY29hdD4wJiYoZy5jbGVhcmNvYXQudmFsdWU9cC5jbGVhcmNvYXQsZy5jbGVhcmNvYXRSb3VnaG5lc3MudmFsdWU9cC5jbGVhcmNvYXRSb3VnaG5lc3MscC5jbGVhcmNvYXRNYXAmJihnLmNsZWFyY29hdE1hcC52YWx1ZT1wLmNsZWFyY29hdE1hcCxlKHAuY2xlYXJjb2F0TWFwLGcuY2xlYXJjb2F0TWFwVHJhbnNmb3JtKSkscC5jbGVhcmNvYXRSb3VnaG5lc3NNYXAmJihnLmNsZWFyY29hdFJvdWdobmVzc01hcC52YWx1ZT1wLmNsZWFyY29hdFJvdWdobmVzc01hcCxlKHAuY2xlYXJjb2F0Um91Z2huZXNzTWFwLGcuY2xlYXJjb2F0Um91Z2huZXNzTWFwVHJhbnNmb3JtKSkscC5jbGVhcmNvYXROb3JtYWxNYXAmJihnLmNsZWFyY29hdE5vcm1hbE1hcC52YWx1ZT1wLmNsZWFyY29hdE5vcm1hbE1hcCxlKHAuY2xlYXJjb2F0Tm9ybWFsTWFwLGcuY2xlYXJjb2F0Tm9ybWFsTWFwVHJhbnNmb3JtKSxnLmNsZWFyY29hdE5vcm1hbFNjYWxlLnZhbHVlLmNvcHkocC5jbGVhcmNvYXROb3JtYWxTY2FsZSkscC5zaWRlPT09VmUmJmcuY2xlYXJjb2F0Tm9ybWFsU2NhbGUudmFsdWUubmVnYXRlKCkpKSxwLmlyaWRlc2NlbmNlPjAmJihnLmlyaWRlc2NlbmNlLnZhbHVlPXAuaXJpZGVzY2VuY2UsZy5pcmlkZXNjZW5jZUlPUi52YWx1ZT1wLmlyaWRlc2NlbmNlSU9SLGcuaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtLnZhbHVlPXAuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZVswXSxnLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bS52YWx1ZT1wLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2VbMV0scC5pcmlkZXNjZW5jZU1hcCYmKGcuaXJpZGVzY2VuY2VNYXAudmFsdWU9cC5pcmlkZXNjZW5jZU1hcCxlKHAuaXJpZGVzY2VuY2VNYXAsZy5pcmlkZXNjZW5jZU1hcFRyYW5zZm9ybSkpLHAuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAmJihnLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLnZhbHVlPXAuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAsZShwLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLGcuaXJpZGVzY2VuY2VUaGlja25lc3NNYXBUcmFuc2Zvcm0pKSkscC50cmFuc21pc3Npb24+MCYmKGcudHJhbnNtaXNzaW9uLnZhbHVlPXAudHJhbnNtaXNzaW9uLGcudHJhbnNtaXNzaW9uU2FtcGxlck1hcC52YWx1ZT12LnRleHR1cmUsZy50cmFuc21pc3Npb25TYW1wbGVyU2l6ZS52YWx1ZS5zZXQodi53aWR0aCx2LmhlaWdodCkscC50cmFuc21pc3Npb25NYXAmJihnLnRyYW5zbWlzc2lvbk1hcC52YWx1ZT1wLnRyYW5zbWlzc2lvbk1hcCxlKHAudHJhbnNtaXNzaW9uTWFwLGcudHJhbnNtaXNzaW9uTWFwVHJhbnNmb3JtKSksZy50aGlja25lc3MudmFsdWU9cC50aGlja25lc3MscC50aGlja25lc3NNYXAmJihnLnRoaWNrbmVzc01hcC52YWx1ZT1wLnRoaWNrbmVzc01hcCxlKHAudGhpY2tuZXNzTWFwLGcudGhpY2tuZXNzTWFwVHJhbnNmb3JtKSksZy5hdHRlbnVhdGlvbkRpc3RhbmNlLnZhbHVlPXAuYXR0ZW51YXRpb25EaXN0YW5jZSxnLmF0dGVudWF0aW9uQ29sb3IudmFsdWUuY29weShwLmF0dGVudWF0aW9uQ29sb3IpKSxwLmFuaXNvdHJvcHk+MCYmKGcuYW5pc290cm9weVZlY3Rvci52YWx1ZS5zZXQocC5hbmlzb3Ryb3B5Kk1hdGguY29zKHAuYW5pc290cm9weVJvdGF0aW9uKSxwLmFuaXNvdHJvcHkqTWF0aC5zaW4ocC5hbmlzb3Ryb3B5Um90YXRpb24pKSxwLmFuaXNvdHJvcHlNYXAmJihnLmFuaXNvdHJvcHlNYXAudmFsdWU9cC5hbmlzb3Ryb3B5TWFwLGUocC5hbmlzb3Ryb3B5TWFwLGcuYW5pc290cm9weU1hcFRyYW5zZm9ybSkpKSxnLnNwZWN1bGFySW50ZW5zaXR5LnZhbHVlPXAuc3BlY3VsYXJJbnRlbnNpdHksZy5zcGVjdWxhckNvbG9yLnZhbHVlLmNvcHkocC5zcGVjdWxhckNvbG9yKSxwLnNwZWN1bGFyQ29sb3JNYXAmJihnLnNwZWN1bGFyQ29sb3JNYXAudmFsdWU9cC5zcGVjdWxhckNvbG9yTWFwLGUocC5zcGVjdWxhckNvbG9yTWFwLGcuc3BlY3VsYXJDb2xvck1hcFRyYW5zZm9ybSkpLHAuc3BlY3VsYXJJbnRlbnNpdHlNYXAmJihnLnNwZWN1bGFySW50ZW5zaXR5TWFwLnZhbHVlPXAuc3BlY3VsYXJJbnRlbnNpdHlNYXAsZShwLnNwZWN1bGFySW50ZW5zaXR5TWFwLGcuc3BlY3VsYXJJbnRlbnNpdHlNYXBUcmFuc2Zvcm0pKX1mdW5jdGlvbiBtKGcscCl7cC5tYXRjYXAmJihnLm1hdGNhcC52YWx1ZT1wLm1hdGNhcCl9ZnVuY3Rpb24gXyhnLHApe2xldCB2PXQuZ2V0KHApLmxpZ2h0O2cucmVmZXJlbmNlUG9zaXRpb24udmFsdWUuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHYubWF0cml4V29ybGQpLGcubmVhckRpc3RhbmNlLnZhbHVlPXYuc2hhZG93LmNhbWVyYS5uZWFyLGcuZmFyRGlzdGFuY2UudmFsdWU9di5zaGFkb3cuY2FtZXJhLmZhcn1yZXR1cm57cmVmcmVzaEZvZ1VuaWZvcm1zOm4scmVmcmVzaE1hdGVyaWFsVW5pZm9ybXM6aX19ZnVuY3Rpb24gZnYocyx0LGUsbil7bGV0IGk9e30scj17fSxhPVtdLG89ZS5pc1dlYkdMMj9zLmdldFBhcmFtZXRlcihzLk1BWF9VTklGT1JNX0JVRkZFUl9CSU5ESU5HUyk6MDtmdW5jdGlvbiBsKHYseCl7bGV0IE09eC5wcm9ncmFtO24udW5pZm9ybUJsb2NrQmluZGluZyh2LE0pfWZ1bmN0aW9uIGModix4KXtsZXQgTT1pW3YuaWRdO009PT12b2lkIDAmJihtKHYpLE09aCh2KSxpW3YuaWRdPU0sdi5hZGRFdmVudExpc3RlbmVyKCJkaXNwb3NlIixnKSk7bGV0IEM9eC5wcm9ncmFtO24udXBkYXRlVUJPTWFwcGluZyh2LEMpO2xldCBBPXQucmVuZGVyLmZyYW1lO3Jbdi5pZF0hPT1BJiYoZCh2KSxyW3YuaWRdPUEpfWZ1bmN0aW9uIGgodil7bGV0IHg9dSgpO3YuX19iaW5kaW5nUG9pbnRJbmRleD14O2xldCBNPXMuY3JlYXRlQnVmZmVyKCksQz12Ll9fc2l6ZSxBPXYudXNhZ2U7cmV0dXJuIHMuYmluZEJ1ZmZlcihzLlVOSUZPUk1fQlVGRkVSLE0pLHMuYnVmZmVyRGF0YShzLlVOSUZPUk1fQlVGRkVSLEMsQSkscy5iaW5kQnVmZmVyKHMuVU5JRk9STV9CVUZGRVIsbnVsbCkscy5iaW5kQnVmZmVyQmFzZShzLlVOSUZPUk1fQlVGRkVSLHgsTSksTX1mdW5jdGlvbiB1KCl7Zm9yKGxldCB2PTA7djxvO3YrKylpZihhLmluZGV4T2Yodik9PT0tMSlyZXR1cm4gYS5wdXNoKHYpLHY7cmV0dXJuIGNvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMUmVuZGVyZXI6IE1heGltdW0gbnVtYmVyIG9mIHNpbXVsdGFuZW91c2x5IHVzYWJsZSB1bmlmb3JtcyBncm91cHMgcmVhY2hlZC4iKSwwfWZ1bmN0aW9uIGQodil7bGV0IHg9aVt2LmlkXSxNPXYudW5pZm9ybXMsQz12Ll9fY2FjaGU7cy5iaW5kQnVmZmVyKHMuVU5JRk9STV9CVUZGRVIseCk7Zm9yKGxldCBBPTAsVD1NLmxlbmd0aDtBPFQ7QSsrKXtsZXQgVT1BcnJheS5pc0FycmF5KE1bQV0pP01bQV06W01bQV1dO2ZvcihsZXQgaz0wLHk9VS5sZW5ndGg7azx5O2srKyl7bGV0IHc9VVtrXTtpZihmKHcsQSxrLEMpPT09ITApe2xldCBHPXcuX19vZmZzZXQsSj1BcnJheS5pc0FycmF5KHcudmFsdWUpP3cudmFsdWU6W3cudmFsdWVdLEk9MDtmb3IobGV0IHo9MDt6PEoubGVuZ3RoO3orKyl7bGV0IEY9Slt6XSwkPV8oRik7dHlwZW9mIEY9PSJudW1iZXIifHx0eXBlb2YgRj09ImJvb2xlYW4iPyh3Ll9fZGF0YVswXT1GLHMuYnVmZmVyU3ViRGF0YShzLlVOSUZPUk1fQlVGRkVSLEcrSSx3Ll9fZGF0YSkpOkYuaXNNYXRyaXgzPyh3Ll9fZGF0YVswXT1GLmVsZW1lbnRzWzBdLHcuX19kYXRhWzFdPUYuZWxlbWVudHNbMV0sdy5fX2RhdGFbMl09Ri5lbGVtZW50c1syXSx3Ll9fZGF0YVszXT0wLHcuX19kYXRhWzRdPUYuZWxlbWVudHNbM10sdy5fX2RhdGFbNV09Ri5lbGVtZW50c1s0XSx3Ll9fZGF0YVs2XT1GLmVsZW1lbnRzWzVdLHcuX19kYXRhWzddPTAsdy5fX2RhdGFbOF09Ri5lbGVtZW50c1s2XSx3Ll9fZGF0YVs5XT1GLmVsZW1lbnRzWzddLHcuX19kYXRhWzEwXT1GLmVsZW1lbnRzWzhdLHcuX19kYXRhWzExXT0wKTooRi50b0FycmF5KHcuX19kYXRhLEkpLEkrPSQuc3RvcmFnZS9GbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQpfXMuYnVmZmVyU3ViRGF0YShzLlVOSUZPUk1fQlVGRkVSLEcsdy5fX2RhdGEpfX19cy5iaW5kQnVmZmVyKHMuVU5JRk9STV9CVUZGRVIsbnVsbCl9ZnVuY3Rpb24gZih2LHgsTSxDKXtsZXQgQT12LnZhbHVlLFQ9eCsiXyIrTTtpZihDW1RdPT09dm9pZCAwKXJldHVybiB0eXBlb2YgQT09Im51bWJlciJ8fHR5cGVvZiBBPT0iYm9vbGVhbiI/Q1tUXT1BOkNbVF09QS5jbG9uZSgpLCEwO3tsZXQgVT1DW1RdO2lmKHR5cGVvZiBBPT0ibnVtYmVyInx8dHlwZW9mIEE9PSJib29sZWFuIil7aWYoVSE9PUEpcmV0dXJuIENbVF09QSwhMH1lbHNlIGlmKFUuZXF1YWxzKEEpPT09ITEpcmV0dXJuIFUuY29weShBKSwhMH1yZXR1cm4hMX1mdW5jdGlvbiBtKHYpe2xldCB4PXYudW5pZm9ybXMsTT0wLEM9MTY7Zm9yKGxldCBUPTAsVT14Lmxlbmd0aDtUPFU7VCsrKXtsZXQgaz1BcnJheS5pc0FycmF5KHhbVF0pP3hbVF06W3hbVF1dO2ZvcihsZXQgeT0wLHc9ay5sZW5ndGg7eTx3O3krKyl7bGV0IEc9a1t5XSxKPUFycmF5LmlzQXJyYXkoRy52YWx1ZSk/Ry52YWx1ZTpbRy52YWx1ZV07Zm9yKGxldCBJPTAsej1KLmxlbmd0aDtJPHo7SSsrKXtsZXQgRj1KW0ldLCQ9XyhGKSxxPU0lQztxIT09MCYmQy1xPCQuYm91bmRhcnkmJihNKz1DLXEpLEcuX19kYXRhPW5ldyBGbG9hdDMyQXJyYXkoJC5zdG9yYWdlL0Zsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCksRy5fX29mZnNldD1NLE0rPSQuc3RvcmFnZX19fWxldCBBPU0lQztyZXR1cm4gQT4wJiYoTSs9Qy1BKSx2Ll9fc2l6ZT1NLHYuX19jYWNoZT17fSx0aGlzfWZ1bmN0aW9uIF8odil7bGV0IHg9e2JvdW5kYXJ5OjAsc3RvcmFnZTowfTtyZXR1cm4gdHlwZW9mIHY9PSJudW1iZXIifHx0eXBlb2Ygdj09ImJvb2xlYW4iPyh4LmJvdW5kYXJ5PTQseC5zdG9yYWdlPTQpOnYuaXNWZWN0b3IyPyh4LmJvdW5kYXJ5PTgseC5zdG9yYWdlPTgpOnYuaXNWZWN0b3IzfHx2LmlzQ29sb3I/KHguYm91bmRhcnk9MTYseC5zdG9yYWdlPTEyKTp2LmlzVmVjdG9yND8oeC5ib3VuZGFyeT0xNix4LnN0b3JhZ2U9MTYpOnYuaXNNYXRyaXgzPyh4LmJvdW5kYXJ5PTQ4LHguc3RvcmFnZT00OCk6di5pc01hdHJpeDQ/KHguYm91bmRhcnk9NjQseC5zdG9yYWdlPTY0KTp2LmlzVGV4dHVyZT9jb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgc2FtcGxlcnMgY2FuIG5vdCBiZSBwYXJ0IG9mIGFuIHVuaWZvcm1zIGdyb3VwLiIpOmNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogVW5zdXBwb3J0ZWQgdW5pZm9ybSB2YWx1ZSB0eXBlLiIsdikseH1mdW5jdGlvbiBnKHYpe2xldCB4PXYudGFyZ2V0O3gucmVtb3ZlRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsZyk7bGV0IE09YS5pbmRleE9mKHguX19iaW5kaW5nUG9pbnRJbmRleCk7YS5zcGxpY2UoTSwxKSxzLmRlbGV0ZUJ1ZmZlcihpW3guaWRdKSxkZWxldGUgaVt4LmlkXSxkZWxldGUgclt4LmlkXX1mdW5jdGlvbiBwKCl7Zm9yKGxldCB2IGluIGkpcy5kZWxldGVCdWZmZXIoaVt2XSk7YT1bXSxpPXt9LHI9e319cmV0dXJue2JpbmQ6bCx1cGRhdGU6YyxkaXNwb3NlOnB9fXZhciBxYT1jbGFzc3tjb25zdHJ1Y3Rvcih0PXt9KXtsZXR7Y2FudmFzOmU9SmYoKSxjb250ZXh0Om49bnVsbCxkZXB0aDppPSEwLHN0ZW5jaWw6cj0hMCxhbHBoYTphPSExLGFudGlhbGlhczpvPSExLHByZW11bHRpcGxpZWRBbHBoYTpsPSEwLHByZXNlcnZlRHJhd2luZ0J1ZmZlcjpjPSExLHBvd2VyUHJlZmVyZW5jZTpoPSJkZWZhdWx0IixmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OnU9ITF9PXQ7dGhpcy5pc1dlYkdMUmVuZGVyZXI9ITA7bGV0IGQ7biE9PW51bGw/ZD1uLmdldENvbnRleHRBdHRyaWJ1dGVzKCkuYWxwaGE6ZD1hO2xldCBmPW5ldyBVaW50MzJBcnJheSg0KSxtPW5ldyBJbnQzMkFycmF5KDQpLF89bnVsbCxnPW51bGwscD1bXSx2PVtdO3RoaXMuZG9tRWxlbWVudD1lLHRoaXMuZGVidWc9e2NoZWNrU2hhZGVyRXJyb3JzOiEwLG9uU2hhZGVyRXJyb3I6bnVsbH0sdGhpcy5hdXRvQ2xlYXI9ITAsdGhpcy5hdXRvQ2xlYXJDb2xvcj0hMCx0aGlzLmF1dG9DbGVhckRlcHRoPSEwLHRoaXMuYXV0b0NsZWFyU3RlbmNpbD0hMCx0aGlzLnNvcnRPYmplY3RzPSEwLHRoaXMuY2xpcHBpbmdQbGFuZXM9W10sdGhpcy5sb2NhbENsaXBwaW5nRW5hYmxlZD0hMSx0aGlzLl9vdXRwdXRDb2xvclNwYWNlPXhlLHRoaXMuX3VzZUxlZ2FjeUxpZ2h0cz0hMSx0aGlzLnRvbmVNYXBwaW5nPURuLHRoaXMudG9uZU1hcHBpbmdFeHBvc3VyZT0xO2xldCB4PXRoaXMsTT0hMSxDPTAsQT0wLFQ9bnVsbCxVPS0xLGs9bnVsbCx5PW5ldyB0ZSx3PW5ldyB0ZSxHPW51bGwsSj1uZXcgdXQoMCksST0wLHo9ZS53aWR0aCxGPWUuaGVpZ2h0LCQ9MSxxPW51bGwsVz1udWxsLGV0PW5ldyB0ZSgwLDAseixGKSxRPW5ldyB0ZSgwLDAseixGKSxmdD0hMSxQdD1uZXcgSWksSD0hMSxpdD0hMSxwdD1udWxsLHZ0PW5ldyBMdCxFdD1uZXcgWix5dD1uZXcgUixPdD17YmFja2dyb3VuZDpudWxsLGZvZzpudWxsLGVudmlyb25tZW50Om51bGwsb3ZlcnJpZGVNYXRlcmlhbDpudWxsLGlzU2NlbmU6ITB9O2Z1bmN0aW9uIEF0KCl7cmV0dXJuIFQ9PT1udWxsPyQ6MX1sZXQgTD1uO2Z1bmN0aW9uIG90KEUsRCl7Zm9yKGxldCBCPTA7QjxFLmxlbmd0aDtCKyspe2xldCBWPUVbQl0sTz1lLmdldENvbnRleHQoVixEKTtpZihPIT09bnVsbClyZXR1cm4gT31yZXR1cm4gbnVsbH10cnl7bGV0IEU9e2FscGhhOiEwLGRlcHRoOmksc3RlbmNpbDpyLGFudGlhbGlhczpvLHByZW11bHRpcGxpZWRBbHBoYTpsLHByZXNlcnZlRHJhd2luZ0J1ZmZlcjpjLHBvd2VyUHJlZmVyZW5jZTpoLGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6dX07aWYoInNldEF0dHJpYnV0ZSJpbiBlJiZlLnNldEF0dHJpYnV0ZSgiZGF0YS1lbmdpbmUiLGB0aHJlZS5qcyByJHtqb31gKSxlLmFkZEV2ZW50TGlzdGVuZXIoIndlYmdsY29udGV4dGxvc3QiLGVlLCExKSxlLmFkZEV2ZW50TGlzdGVuZXIoIndlYmdsY29udGV4dHJlc3RvcmVkIixQLCExKSxlLmFkZEV2ZW50TGlzdGVuZXIoIndlYmdsY29udGV4dGNyZWF0aW9uZXJyb3IiLHJ0LCExKSxMPT09bnVsbCl7bGV0IEQ9WyJ3ZWJnbDIiLCJ3ZWJnbCIsImV4cGVyaW1lbnRhbC13ZWJnbCJdO2lmKHguaXNXZWJHTDFSZW5kZXJlcj09PSEwJiZELnNoaWZ0KCksTD1vdChELEUpLEw9PT1udWxsKXRocm93IG90KEQpP25ldyBFcnJvcigiRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dCB3aXRoIHlvdXIgc2VsZWN0ZWQgYXR0cmlidXRlcy4iKTpuZXcgRXJyb3IoIkVycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQuIil9dHlwZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dDwidSImJkwgaW5zdGFuY2VvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQmJmNvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogV2ViR0wgMSBzdXBwb3J0IHdhcyBkZXByZWNhdGVkIGluIHIxNTMgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiByMTYzLiIpLEwuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0PT09dm9pZCAwJiYoTC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQ9ZnVuY3Rpb24oKXtyZXR1cm57cmFuZ2VNaW46MSxyYW5nZU1heDoxLHByZWNpc2lvbjoxfX0pfWNhdGNoKEUpe3Rocm93IGNvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMUmVuZGVyZXI6ICIrRS5tZXNzYWdlKSxFfWxldCBYLHN0LFksYnQsaHQsYixTLE4sbnQsaixLLHh0LGN0LG10LFJ0LEZ0LHR0LFl0LFh0LFV0LFR0LF90LFZ0LCR0O2Z1bmN0aW9uIHJlKCl7WD1uZXcgTDAoTCksc3Q9bmV3IEEwKEwsWCx0KSxYLmluaXQoc3QpLF90PW5ldyBycChMLFgsc3QpLFk9bmV3IG92KEwsWCxzdCksYnQ9bmV3IEQwKEwpLGh0PW5ldyBKeCxiPW5ldyBsdihMLFgsWSxodCxzdCxfdCxidCksUz1uZXcgdzAoeCksTj1uZXcgUDAoeCksbnQ9bmV3IEhtKEwsc3QpLFZ0PW5ldyBiMChMLFgsbnQsc3QpLGo9bmV3IEkwKEwsbnQsYnQsVnQpLEs9bmV3IEIwKEwsaixudCxidCksWHQ9bmV3IEYwKEwsc3QsYiksRnQ9bmV3IFQwKGh0KSx4dD1uZXcgWngoeCxTLE4sWCxzdCxWdCxGdCksY3Q9bmV3IGR2KHgsaHQpLG10PW5ldyBLeCxSdD1uZXcgaXYoWCxzdCksWXQ9bmV3IFMwKHgsUyxOLFksSyxkLGwpLHR0PW5ldyBhdih4LEssc3QpLCR0PW5ldyBmdihMLGJ0LHN0LFkpLFV0PW5ldyBFMChMLFgsYnQsc3QpLFR0PW5ldyBVMChMLFgsYnQsc3QpLGJ0LnByb2dyYW1zPXh0LnByb2dyYW1zLHguY2FwYWJpbGl0aWVzPXN0LHguZXh0ZW5zaW9ucz1YLHgucHJvcGVydGllcz1odCx4LnJlbmRlckxpc3RzPW10LHguc2hhZG93TWFwPXR0LHguc3RhdGU9WSx4LmluZm89YnR9cmUoKTtsZXQgcXQ9bmV3IFhjKHgsTCk7dGhpcy54cj1xdCx0aGlzLmdldENvbnRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gTH0sdGhpcy5nZXRDb250ZXh0QXR0cmlidXRlcz1mdW5jdGlvbigpe3JldHVybiBMLmdldENvbnRleHRBdHRyaWJ1dGVzKCl9LHRoaXMuZm9yY2VDb250ZXh0TG9zcz1mdW5jdGlvbigpe2xldCBFPVguZ2V0KCJXRUJHTF9sb3NlX2NvbnRleHQiKTtFJiZFLmxvc2VDb250ZXh0KCl9LHRoaXMuZm9yY2VDb250ZXh0UmVzdG9yZT1mdW5jdGlvbigpe2xldCBFPVguZ2V0KCJXRUJHTF9sb3NlX2NvbnRleHQiKTtFJiZFLnJlc3RvcmVDb250ZXh0KCl9LHRoaXMuZ2V0UGl4ZWxSYXRpbz1mdW5jdGlvbigpe3JldHVybiAkfSx0aGlzLnNldFBpeGVsUmF0aW89ZnVuY3Rpb24oRSl7RSE9PXZvaWQgMCYmKCQ9RSx0aGlzLnNldFNpemUoeixGLCExKSl9LHRoaXMuZ2V0U2l6ZT1mdW5jdGlvbihFKXtyZXR1cm4gRS5zZXQoeixGKX0sdGhpcy5zZXRTaXplPWZ1bmN0aW9uKEUsRCxCPSEwKXtpZihxdC5pc1ByZXNlbnRpbmcpe2NvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogQ2FuJ3QgY2hhbmdlIHNpemUgd2hpbGUgVlIgZGV2aWNlIGlzIHByZXNlbnRpbmcuIik7cmV0dXJufXo9RSxGPUQsZS53aWR0aD1NYXRoLmZsb29yKEUqJCksZS5oZWlnaHQ9TWF0aC5mbG9vcihEKiQpLEI9PT0hMCYmKGUuc3R5bGUud2lkdGg9RSsicHgiLGUuc3R5bGUuaGVpZ2h0PUQrInB4IiksdGhpcy5zZXRWaWV3cG9ydCgwLDAsRSxEKX0sdGhpcy5nZXREcmF3aW5nQnVmZmVyU2l6ZT1mdW5jdGlvbihFKXtyZXR1cm4gRS5zZXQoeiokLEYqJCkuZmxvb3IoKX0sdGhpcy5zZXREcmF3aW5nQnVmZmVyU2l6ZT1mdW5jdGlvbihFLEQsQil7ej1FLEY9RCwkPUIsZS53aWR0aD1NYXRoLmZsb29yKEUqQiksZS5oZWlnaHQ9TWF0aC5mbG9vcihEKkIpLHRoaXMuc2V0Vmlld3BvcnQoMCwwLEUsRCl9LHRoaXMuZ2V0Q3VycmVudFZpZXdwb3J0PWZ1bmN0aW9uKEUpe3JldHVybiBFLmNvcHkoeSl9LHRoaXMuZ2V0Vmlld3BvcnQ9ZnVuY3Rpb24oRSl7cmV0dXJuIEUuY29weShldCl9LHRoaXMuc2V0Vmlld3BvcnQ9ZnVuY3Rpb24oRSxELEIsVil7RS5pc1ZlY3RvcjQ/ZXQuc2V0KEUueCxFLnksRS56LEUudyk6ZXQuc2V0KEUsRCxCLFYpLFkudmlld3BvcnQoeS5jb3B5KGV0KS5tdWx0aXBseVNjYWxhcigkKS5mbG9vcigpKX0sdGhpcy5nZXRTY2lzc29yPWZ1bmN0aW9uKEUpe3JldHVybiBFLmNvcHkoUSl9LHRoaXMuc2V0U2Npc3Nvcj1mdW5jdGlvbihFLEQsQixWKXtFLmlzVmVjdG9yND9RLnNldChFLngsRS55LEUueixFLncpOlEuc2V0KEUsRCxCLFYpLFkuc2Npc3Nvcih3LmNvcHkoUSkubXVsdGlwbHlTY2FsYXIoJCkuZmxvb3IoKSl9LHRoaXMuZ2V0U2Npc3NvclRlc3Q9ZnVuY3Rpb24oKXtyZXR1cm4gZnR9LHRoaXMuc2V0U2Npc3NvclRlc3Q9ZnVuY3Rpb24oRSl7WS5zZXRTY2lzc29yVGVzdChmdD1FKX0sdGhpcy5zZXRPcGFxdWVTb3J0PWZ1bmN0aW9uKEUpe3E9RX0sdGhpcy5zZXRUcmFuc3BhcmVudFNvcnQ9ZnVuY3Rpb24oRSl7Vz1FfSx0aGlzLmdldENsZWFyQ29sb3I9ZnVuY3Rpb24oRSl7cmV0dXJuIEUuY29weShZdC5nZXRDbGVhckNvbG9yKCkpfSx0aGlzLnNldENsZWFyQ29sb3I9ZnVuY3Rpb24oKXtZdC5zZXRDbGVhckNvbG9yLmFwcGx5KFl0LGFyZ3VtZW50cyl9LHRoaXMuZ2V0Q2xlYXJBbHBoYT1mdW5jdGlvbigpe3JldHVybiBZdC5nZXRDbGVhckFscGhhKCl9LHRoaXMuc2V0Q2xlYXJBbHBoYT1mdW5jdGlvbigpe1l0LnNldENsZWFyQWxwaGEuYXBwbHkoWXQsYXJndW1lbnRzKX0sdGhpcy5jbGVhcj1mdW5jdGlvbihFPSEwLEQ9ITAsQj0hMCl7bGV0IFY9MDtpZihFKXtsZXQgTz0hMTtpZihUIT09bnVsbCl7bGV0IGR0PVQudGV4dHVyZS5mb3JtYXQ7Tz1kdD09PUtofHxkdD09PSRofHxkdD09PUpofWlmKE8pe2xldCBkdD1ULnRleHR1cmUudHlwZSxTdD1kdD09PU5ufHxkdD09PUNufHxkdD09PWVsfHxkdD09PVFufHxkdD09PVlofHxkdD09PVpoLEN0PVl0LmdldENsZWFyQ29sb3IoKSxJdD1ZdC5nZXRDbGVhckFscGhhKCksR3Q9Q3QucixEdD1DdC5nLEJ0PUN0LmI7U3Q/KGZbMF09R3QsZlsxXT1EdCxmWzJdPUJ0LGZbM109SXQsTC5jbGVhckJ1ZmZlcnVpdihMLkNPTE9SLDAsZikpOihtWzBdPUd0LG1bMV09RHQsbVsyXT1CdCxtWzNdPUl0LEwuY2xlYXJCdWZmZXJpdihMLkNPTE9SLDAsbSkpfWVsc2UgVnw9TC5DT0xPUl9CVUZGRVJfQklUfUQmJihWfD1MLkRFUFRIX0JVRkZFUl9CSVQpLEImJihWfD1MLlNURU5DSUxfQlVGRkVSX0JJVCx0aGlzLnN0YXRlLmJ1ZmZlcnMuc3RlbmNpbC5zZXRNYXNrKDQyOTQ5NjcyOTUpKSxMLmNsZWFyKFYpfSx0aGlzLmNsZWFyQ29sb3I9ZnVuY3Rpb24oKXt0aGlzLmNsZWFyKCEwLCExLCExKX0sdGhpcy5jbGVhckRlcHRoPWZ1bmN0aW9uKCl7dGhpcy5jbGVhcighMSwhMCwhMSl9LHRoaXMuY2xlYXJTdGVuY2lsPWZ1bmN0aW9uKCl7dGhpcy5jbGVhcighMSwhMSwhMCl9LHRoaXMuZGlzcG9zZT1mdW5jdGlvbigpe2UucmVtb3ZlRXZlbnRMaXN0ZW5lcigid2ViZ2xjb250ZXh0bG9zdCIsZWUsITEpLGUucmVtb3ZlRXZlbnRMaXN0ZW5lcigid2ViZ2xjb250ZXh0cmVzdG9yZWQiLFAsITEpLGUucmVtb3ZlRXZlbnRMaXN0ZW5lcigid2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvciIscnQsITEpLG10LmRpc3Bvc2UoKSxSdC5kaXNwb3NlKCksaHQuZGlzcG9zZSgpLFMuZGlzcG9zZSgpLE4uZGlzcG9zZSgpLEsuZGlzcG9zZSgpLFZ0LmRpc3Bvc2UoKSwkdC5kaXNwb3NlKCkseHQuZGlzcG9zZSgpLHF0LmRpc3Bvc2UoKSxxdC5yZW1vdmVFdmVudExpc3RlbmVyKCJzZXNzaW9uc3RhcnQiLFFlKSxxdC5yZW1vdmVFdmVudExpc3RlbmVyKCJzZXNzaW9uZW5kIixpZSkscHQmJihwdC5kaXNwb3NlKCkscHQ9bnVsbCksT2Uuc3RvcCgpfTtmdW5jdGlvbiBlZShFKXtFLnByZXZlbnREZWZhdWx0KCksY29uc29sZS5sb2coIlRIUkVFLldlYkdMUmVuZGVyZXI6IENvbnRleHQgTG9zdC4iKSxNPSEwfWZ1bmN0aW9uIFAoKXtjb25zb2xlLmxvZygiVEhSRUUuV2ViR0xSZW5kZXJlcjogQ29udGV4dCBSZXN0b3JlZC4iKSxNPSExO2xldCBFPWJ0LmF1dG9SZXNldCxEPXR0LmVuYWJsZWQsQj10dC5hdXRvVXBkYXRlLFY9dHQubmVlZHNVcGRhdGUsTz10dC50eXBlO3JlKCksYnQuYXV0b1Jlc2V0PUUsdHQuZW5hYmxlZD1ELHR0LmF1dG9VcGRhdGU9Qix0dC5uZWVkc1VwZGF0ZT1WLHR0LnR5cGU9T31mdW5jdGlvbiBydChFKXtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBIFdlYkdMIGNvbnRleHQgY291bGQgbm90IGJlIGNyZWF0ZWQuIFJlYXNvbjogIixFLnN0YXR1c01lc3NhZ2UpfWZ1bmN0aW9uIGF0KEUpe2xldCBEPUUudGFyZ2V0O0QucmVtb3ZlRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsYXQpLE10KEQpfWZ1bmN0aW9uIE10KEUpe3d0KEUpLGh0LnJlbW92ZShFKX1mdW5jdGlvbiB3dChFKXtsZXQgRD1odC5nZXQoRSkucHJvZ3JhbXM7RCE9PXZvaWQgMCYmKEQuZm9yRWFjaChmdW5jdGlvbihCKXt4dC5yZWxlYXNlUHJvZ3JhbShCKX0pLEUuaXNTaGFkZXJNYXRlcmlhbCYmeHQucmVsZWFzZVNoYWRlckNhY2hlKEUpKX10aGlzLnJlbmRlckJ1ZmZlckRpcmVjdD1mdW5jdGlvbihFLEQsQixWLE8sZHQpe0Q9PT1udWxsJiYoRD1PdCk7bGV0IFN0PU8uaXNNZXNoJiZPLm1hdHJpeFdvcmxkLmRldGVybWluYW50KCk8MCxDdD1tcChFLEQsQixWLE8pO1kuc2V0TWF0ZXJpYWwoVixTdCk7bGV0IEl0PUIuaW5kZXgsR3Q9MTtpZihWLndpcmVmcmFtZT09PSEwKXtpZihJdD1qLmdldFdpcmVmcmFtZUF0dHJpYnV0ZShCKSxJdD09PXZvaWQgMClyZXR1cm47R3Q9Mn1sZXQgRHQ9Qi5kcmF3UmFuZ2UsQnQ9Qi5hdHRyaWJ1dGVzLnBvc2l0aW9uLGZlPUR0LnN0YXJ0Kkd0LEdlPShEdC5zdGFydCtEdC5jb3VudCkqR3Q7ZHQhPT1udWxsJiYoZmU9TWF0aC5tYXgoZmUsZHQuc3RhcnQqR3QpLEdlPU1hdGgubWluKEdlLChkdC5zdGFydCtkdC5jb3VudCkqR3QpKSxJdCE9PW51bGw/KGZlPU1hdGgubWF4KGZlLDApLEdlPU1hdGgubWluKEdlLEl0LmNvdW50KSk6QnQhPW51bGwmJihmZT1NYXRoLm1heChmZSwwKSxHZT1NYXRoLm1pbihHZSxCdC5jb3VudCkpO2xldCBTZT1HZS1mZTtpZihTZTwwfHxTZT09PTEvMClyZXR1cm47VnQuc2V0dXAoTyxWLEN0LEIsSXQpO2xldCBNbixhZT1VdDtpZihJdCE9PW51bGwmJihNbj1udC5nZXQoSXQpLGFlPVR0LGFlLnNldEluZGV4KE1uKSksTy5pc01lc2gpVi53aXJlZnJhbWU9PT0hMD8oWS5zZXRMaW5lV2lkdGgoVi53aXJlZnJhbWVMaW5ld2lkdGgqQXQoKSksYWUuc2V0TW9kZShMLkxJTkVTKSk6YWUuc2V0TW9kZShMLlRSSUFOR0xFUyk7ZWxzZSBpZihPLmlzTGluZSl7bGV0IFd0PVYubGluZXdpZHRoO1d0PT09dm9pZCAwJiYoV3Q9MSksWS5zZXRMaW5lV2lkdGgoV3QqQXQoKSksTy5pc0xpbmVTZWdtZW50cz9hZS5zZXRNb2RlKEwuTElORVMpOk8uaXNMaW5lTG9vcD9hZS5zZXRNb2RlKEwuTElORV9MT09QKTphZS5zZXRNb2RlKEwuTElORV9TVFJJUCl9ZWxzZSBPLmlzUG9pbnRzP2FlLnNldE1vZGUoTC5QT0lOVFMpOk8uaXNTcHJpdGUmJmFlLnNldE1vZGUoTC5UUklBTkdMRVMpO2lmKE8uaXNCYXRjaGVkTWVzaClhZS5yZW5kZXJNdWx0aURyYXcoTy5fbXVsdGlEcmF3U3RhcnRzLE8uX211bHRpRHJhd0NvdW50cyxPLl9tdWx0aURyYXdDb3VudCk7ZWxzZSBpZihPLmlzSW5zdGFuY2VkTWVzaClhZS5yZW5kZXJJbnN0YW5jZXMoZmUsU2UsTy5jb3VudCk7ZWxzZSBpZihCLmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkpe2xldCBXdD1CLl9tYXhJbnN0YW5jZUNvdW50IT09dm9pZCAwP0IuX21heEluc3RhbmNlQ291bnQ6MS8wLGFsPU1hdGgubWluKEIuaW5zdGFuY2VDb3VudCxXdCk7YWUucmVuZGVySW5zdGFuY2VzKGZlLFNlLGFsKX1lbHNlIGFlLnJlbmRlcihmZSxTZSl9O2Z1bmN0aW9uIEt0KEUsRCxCKXtFLnRyYW5zcGFyZW50PT09ITAmJkUuc2lkZT09PWZuJiZFLmZvcmNlU2luZ2xlUGFzcz09PSExPyhFLnNpZGU9VmUsRS5uZWVkc1VwZGF0ZT0hMCx6cihFLEQsQiksRS5zaWRlPUJuLEUubmVlZHNVcGRhdGU9ITAsenIoRSxELEIpLEUuc2lkZT1mbik6enIoRSxELEIpfXRoaXMuY29tcGlsZT1mdW5jdGlvbihFLEQsQj1udWxsKXtCPT09bnVsbCYmKEI9RSksZz1SdC5nZXQoQiksZy5pbml0KCksdi5wdXNoKGcpLEIudHJhdmVyc2VWaXNpYmxlKGZ1bmN0aW9uKE8pe08uaXNMaWdodCYmTy5sYXllcnMudGVzdChELmxheWVycykmJihnLnB1c2hMaWdodChPKSxPLmNhc3RTaGFkb3cmJmcucHVzaFNoYWRvdyhPKSl9KSxFIT09QiYmRS50cmF2ZXJzZVZpc2libGUoZnVuY3Rpb24oTyl7Ty5pc0xpZ2h0JiZPLmxheWVycy50ZXN0KEQubGF5ZXJzKSYmKGcucHVzaExpZ2h0KE8pLE8uY2FzdFNoYWRvdyYmZy5wdXNoU2hhZG93KE8pKX0pLGcuc2V0dXBMaWdodHMoeC5fdXNlTGVnYWN5TGlnaHRzKTtsZXQgVj1uZXcgU2V0O3JldHVybiBFLnRyYXZlcnNlKGZ1bmN0aW9uKE8pe2xldCBkdD1PLm1hdGVyaWFsO2lmKGR0KWlmKEFycmF5LmlzQXJyYXkoZHQpKWZvcihsZXQgU3Q9MDtTdDxkdC5sZW5ndGg7U3QrKyl7bGV0IEN0PWR0W1N0XTtLdChDdCxCLE8pLFYuYWRkKEN0KX1lbHNlIEt0KGR0LEIsTyksVi5hZGQoZHQpfSksdi5wb3AoKSxnPW51bGwsVn0sdGhpcy5jb21waWxlQXN5bmM9ZnVuY3Rpb24oRSxELEI9bnVsbCl7bGV0IFY9dGhpcy5jb21waWxlKEUsRCxCKTtyZXR1cm4gbmV3IFByb21pc2UoTz0+e2Z1bmN0aW9uIGR0KCl7aWYoVi5mb3JFYWNoKGZ1bmN0aW9uKFN0KXtodC5nZXQoU3QpLmN1cnJlbnRQcm9ncmFtLmlzUmVhZHkoKSYmVi5kZWxldGUoU3QpfSksVi5zaXplPT09MCl7TyhFKTtyZXR1cm59c2V0VGltZW91dChkdCwxMCl9WC5nZXQoIktIUl9wYXJhbGxlbF9zaGFkZXJfY29tcGlsZSIpIT09bnVsbD9kdCgpOnNldFRpbWVvdXQoZHQsMTApfSl9O2xldCBuZT1udWxsO2Z1bmN0aW9uIFRlKEUpe25lJiZuZShFKX1mdW5jdGlvbiBRZSgpe09lLnN0b3AoKX1mdW5jdGlvbiBpZSgpe09lLnN0YXJ0KCl9bGV0IE9lPW5ldyBqZjtPZS5zZXRBbmltYXRpb25Mb29wKFRlKSx0eXBlb2Ygc2VsZjwidSImJk9lLnNldENvbnRleHQoc2VsZiksdGhpcy5zZXRBbmltYXRpb25Mb29wPWZ1bmN0aW9uKEUpe25lPUUscXQuc2V0QW5pbWF0aW9uTG9vcChFKSxFPT09bnVsbD9PZS5zdG9wKCk6T2Uuc3RhcnQoKX0scXQuYWRkRXZlbnRMaXN0ZW5lcigic2Vzc2lvbnN0YXJ0IixRZSkscXQuYWRkRXZlbnRMaXN0ZW5lcigic2Vzc2lvbmVuZCIsaWUpLHRoaXMucmVuZGVyPWZ1bmN0aW9uKEUsRCl7aWYoRCE9PXZvaWQgMCYmRC5pc0NhbWVyYSE9PSEwKXtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFJlbmRlcmVyLnJlbmRlcjogY2FtZXJhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5DYW1lcmEuIik7cmV0dXJufWlmKE09PT0hMClyZXR1cm47RS5tYXRyaXhXb3JsZEF1dG9VcGRhdGU9PT0hMCYmRS51cGRhdGVNYXRyaXhXb3JsZCgpLEQucGFyZW50PT09bnVsbCYmRC5tYXRyaXhXb3JsZEF1dG9VcGRhdGU9PT0hMCYmRC51cGRhdGVNYXRyaXhXb3JsZCgpLHF0LmVuYWJsZWQ9PT0hMCYmcXQuaXNQcmVzZW50aW5nPT09ITAmJihxdC5jYW1lcmFBdXRvVXBkYXRlPT09ITAmJnF0LnVwZGF0ZUNhbWVyYShEKSxEPXF0LmdldENhbWVyYSgpKSxFLmlzU2NlbmU9PT0hMCYmRS5vbkJlZm9yZVJlbmRlcih4LEUsRCxUKSxnPVJ0LmdldChFLHYubGVuZ3RoKSxnLmluaXQoKSx2LnB1c2goZyksdnQubXVsdGlwbHlNYXRyaWNlcyhELnByb2plY3Rpb25NYXRyaXgsRC5tYXRyaXhXb3JsZEludmVyc2UpLFB0LnNldEZyb21Qcm9qZWN0aW9uTWF0cml4KHZ0KSxpdD10aGlzLmxvY2FsQ2xpcHBpbmdFbmFibGVkLEg9RnQuaW5pdCh0aGlzLmNsaXBwaW5nUGxhbmVzLGl0KSxfPW10LmdldChFLHAubGVuZ3RoKSxfLmluaXQoKSxwLnB1c2goXyksaG4oRSxELDAseC5zb3J0T2JqZWN0cyksXy5maW5pc2goKSx4LnNvcnRPYmplY3RzPT09ITAmJl8uc29ydChxLFcpLHRoaXMuaW5mby5yZW5kZXIuZnJhbWUrKyxIPT09ITAmJkZ0LmJlZ2luU2hhZG93cygpO2xldCBCPWcuc3RhdGUuc2hhZG93c0FycmF5O2lmKHR0LnJlbmRlcihCLEUsRCksSD09PSEwJiZGdC5lbmRTaGFkb3dzKCksdGhpcy5pbmZvLmF1dG9SZXNldD09PSEwJiZ0aGlzLmluZm8ucmVzZXQoKSwocXQuZW5hYmxlZD09PSExfHxxdC5pc1ByZXNlbnRpbmc9PT0hMXx8cXQuaGFzRGVwdGhTZW5zaW5nKCk9PT0hMSkmJll0LnJlbmRlcihfLEUpLGcuc2V0dXBMaWdodHMoeC5fdXNlTGVnYWN5TGlnaHRzKSxELmlzQXJyYXlDYW1lcmEpe2xldCBWPUQuY2FtZXJhcztmb3IobGV0IE89MCxkdD1WLmxlbmd0aDtPPGR0O08rKyl7bGV0IFN0PVZbT107bHUoXyxFLFN0LFN0LnZpZXdwb3J0KX19ZWxzZSBsdShfLEUsRCk7VCE9PW51bGwmJihiLnVwZGF0ZU11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0KFQpLGIudXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKFQpKSxFLmlzU2NlbmU9PT0hMCYmRS5vbkFmdGVyUmVuZGVyKHgsRSxEKSxWdC5yZXNldERlZmF1bHRTdGF0ZSgpLFU9LTEsaz1udWxsLHYucG9wKCksdi5sZW5ndGg+MD9nPXZbdi5sZW5ndGgtMV06Zz1udWxsLHAucG9wKCkscC5sZW5ndGg+MD9fPXBbcC5sZW5ndGgtMV06Xz1udWxsfTtmdW5jdGlvbiBobihFLEQsQixWKXtpZihFLnZpc2libGU9PT0hMSlyZXR1cm47aWYoRS5sYXllcnMudGVzdChELmxheWVycykpe2lmKEUuaXNHcm91cClCPUUucmVuZGVyT3JkZXI7ZWxzZSBpZihFLmlzTE9EKUUuYXV0b1VwZGF0ZT09PSEwJiZFLnVwZGF0ZShEKTtlbHNlIGlmKEUuaXNMaWdodClnLnB1c2hMaWdodChFKSxFLmNhc3RTaGFkb3cmJmcucHVzaFNoYWRvdyhFKTtlbHNlIGlmKEUuaXNTcHJpdGUpe2lmKCFFLmZydXN0dW1DdWxsZWR8fFB0LmludGVyc2VjdHNTcHJpdGUoRSkpe1YmJnl0LnNldEZyb21NYXRyaXhQb3NpdGlvbihFLm1hdHJpeFdvcmxkKS5hcHBseU1hdHJpeDQodnQpO2xldCBTdD1LLnVwZGF0ZShFKSxDdD1FLm1hdGVyaWFsO0N0LnZpc2libGUmJl8ucHVzaChFLFN0LEN0LEIseXQueixudWxsKX19ZWxzZSBpZigoRS5pc01lc2h8fEUuaXNMaW5lfHxFLmlzUG9pbnRzKSYmKCFFLmZydXN0dW1DdWxsZWR8fFB0LmludGVyc2VjdHNPYmplY3QoRSkpKXtsZXQgU3Q9Sy51cGRhdGUoRSksQ3Q9RS5tYXRlcmlhbDtpZihWJiYoRS5ib3VuZGluZ1NwaGVyZSE9PXZvaWQgMD8oRS5ib3VuZGluZ1NwaGVyZT09PW51bGwmJkUuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCkseXQuY29weShFLmJvdW5kaW5nU3BoZXJlLmNlbnRlcikpOihTdC5ib3VuZGluZ1NwaGVyZT09PW51bGwmJlN0LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpLHl0LmNvcHkoU3QuYm91bmRpbmdTcGhlcmUuY2VudGVyKSkseXQuYXBwbHlNYXRyaXg0KEUubWF0cml4V29ybGQpLmFwcGx5TWF0cml4NCh2dCkpLEFycmF5LmlzQXJyYXkoQ3QpKXtsZXQgSXQ9U3QuZ3JvdXBzO2ZvcihsZXQgR3Q9MCxEdD1JdC5sZW5ndGg7R3Q8RHQ7R3QrKyl7bGV0IEJ0PUl0W0d0XSxmZT1DdFtCdC5tYXRlcmlhbEluZGV4XTtmZSYmZmUudmlzaWJsZSYmXy5wdXNoKEUsU3QsZmUsQix5dC56LEJ0KX19ZWxzZSBDdC52aXNpYmxlJiZfLnB1c2goRSxTdCxDdCxCLHl0LnosbnVsbCl9fWxldCBkdD1FLmNoaWxkcmVuO2ZvcihsZXQgU3Q9MCxDdD1kdC5sZW5ndGg7U3Q8Q3Q7U3QrKylobihkdFtTdF0sRCxCLFYpfWZ1bmN0aW9uIGx1KEUsRCxCLFYpe2xldCBPPUUub3BhcXVlLGR0PUUudHJhbnNtaXNzaXZlLFN0PUUudHJhbnNwYXJlbnQ7Zy5zZXR1cExpZ2h0c1ZpZXcoQiksSD09PSEwJiZGdC5zZXRHbG9iYWxTdGF0ZSh4LmNsaXBwaW5nUGxhbmVzLEIpLGR0Lmxlbmd0aD4wJiZwcChPLGR0LEQsQiksViYmWS52aWV3cG9ydCh5LmNvcHkoVikpLE8ubGVuZ3RoPjAmJkJyKE8sRCxCKSxkdC5sZW5ndGg+MCYmQnIoZHQsRCxCKSxTdC5sZW5ndGg+MCYmQnIoU3QsRCxCKSxZLmJ1ZmZlcnMuZGVwdGguc2V0VGVzdCghMCksWS5idWZmZXJzLmRlcHRoLnNldE1hc2soITApLFkuYnVmZmVycy5jb2xvci5zZXRNYXNrKCEwKSxZLnNldFBvbHlnb25PZmZzZXQoITEpfWZ1bmN0aW9uIHBwKEUsRCxCLFYpe2lmKChCLmlzU2NlbmU9PT0hMD9CLm92ZXJyaWRlTWF0ZXJpYWw6bnVsbCkhPT1udWxsKXJldHVybjtsZXQgZHQ9c3QuaXNXZWJHTDI7cHQ9PT1udWxsJiYocHQ9bmV3IFplKDEsMSx7Z2VuZXJhdGVNaXBtYXBzOiEwLHR5cGU6WC5oYXMoIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCIpP3BzOk5uLG1pbkZpbHRlcjpwbixzYW1wbGVzOmR0PzQ6MH0pKSx4LmdldERyYXdpbmdCdWZmZXJTaXplKEV0KSxkdD9wdC5zZXRTaXplKEV0LngsRXQueSk6cHQuc2V0U2l6ZShrYShFdC54KSxrYShFdC55KSk7bGV0IFN0PXguZ2V0UmVuZGVyVGFyZ2V0KCk7eC5zZXRSZW5kZXJUYXJnZXQocHQpLHguZ2V0Q2xlYXJDb2xvcihKKSxJPXguZ2V0Q2xlYXJBbHBoYSgpLEk8MSYmeC5zZXRDbGVhckNvbG9yKDE2Nzc3MjE1LC41KSx4LmNsZWFyKCk7bGV0IEN0PXgudG9uZU1hcHBpbmc7eC50b25lTWFwcGluZz1EbixCcihFLEIsViksYi51cGRhdGVNdWx0aXNhbXBsZVJlbmRlclRhcmdldChwdCksYi51cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAocHQpO2xldCBJdD0hMTtmb3IobGV0IEd0PTAsRHQ9RC5sZW5ndGg7R3Q8RHQ7R3QrKyl7bGV0IEJ0PURbR3RdLGZlPUJ0Lm9iamVjdCxHZT1CdC5nZW9tZXRyeSxTZT1CdC5tYXRlcmlhbCxNbj1CdC5ncm91cDtpZihTZS5zaWRlPT09Zm4mJmZlLmxheWVycy50ZXN0KFYubGF5ZXJzKSl7bGV0IGFlPVNlLnNpZGU7U2Uuc2lkZT1WZSxTZS5uZWVkc1VwZGF0ZT0hMCxjdShmZSxCLFYsR2UsU2UsTW4pLFNlLnNpZGU9YWUsU2UubmVlZHNVcGRhdGU9ITAsSXQ9ITB9fUl0PT09ITAmJihiLnVwZGF0ZU11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0KHB0KSxiLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcChwdCkpLHguc2V0UmVuZGVyVGFyZ2V0KFN0KSx4LnNldENsZWFyQ29sb3IoSixJKSx4LnRvbmVNYXBwaW5nPUN0fWZ1bmN0aW9uIEJyKEUsRCxCKXtsZXQgVj1ELmlzU2NlbmU9PT0hMD9ELm92ZXJyaWRlTWF0ZXJpYWw6bnVsbDtmb3IobGV0IE89MCxkdD1FLmxlbmd0aDtPPGR0O08rKyl7bGV0IFN0PUVbT10sQ3Q9U3Qub2JqZWN0LEl0PVN0Lmdlb21ldHJ5LEd0PVY9PT1udWxsP1N0Lm1hdGVyaWFsOlYsRHQ9U3QuZ3JvdXA7Q3QubGF5ZXJzLnRlc3QoQi5sYXllcnMpJiZjdShDdCxELEIsSXQsR3QsRHQpfX1mdW5jdGlvbiBjdShFLEQsQixWLE8sZHQpe0Uub25CZWZvcmVSZW5kZXIoeCxELEIsVixPLGR0KSxFLm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKEIubWF0cml4V29ybGRJbnZlcnNlLEUubWF0cml4V29ybGQpLEUubm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeChFLm1vZGVsVmlld01hdHJpeCksTy5vbkJlZm9yZVJlbmRlcih4LEQsQixWLEUsZHQpLE8udHJhbnNwYXJlbnQ9PT0hMCYmTy5zaWRlPT09Zm4mJk8uZm9yY2VTaW5nbGVQYXNzPT09ITE/KE8uc2lkZT1WZSxPLm5lZWRzVXBkYXRlPSEwLHgucmVuZGVyQnVmZmVyRGlyZWN0KEIsRCxWLE8sRSxkdCksTy5zaWRlPUJuLE8ubmVlZHNVcGRhdGU9ITAseC5yZW5kZXJCdWZmZXJEaXJlY3QoQixELFYsTyxFLGR0KSxPLnNpZGU9Zm4pOngucmVuZGVyQnVmZmVyRGlyZWN0KEIsRCxWLE8sRSxkdCksRS5vbkFmdGVyUmVuZGVyKHgsRCxCLFYsTyxkdCl9ZnVuY3Rpb24genIoRSxELEIpe0QuaXNTY2VuZSE9PSEwJiYoRD1PdCk7bGV0IFY9aHQuZ2V0KEUpLE89Zy5zdGF0ZS5saWdodHMsZHQ9Zy5zdGF0ZS5zaGFkb3dzQXJyYXksU3Q9Ty5zdGF0ZS52ZXJzaW9uLEN0PXh0LmdldFBhcmFtZXRlcnMoRSxPLnN0YXRlLGR0LEQsQiksSXQ9eHQuZ2V0UHJvZ3JhbUNhY2hlS2V5KEN0KSxHdD1WLnByb2dyYW1zO1YuZW52aXJvbm1lbnQ9RS5pc01lc2hTdGFuZGFyZE1hdGVyaWFsP0QuZW52aXJvbm1lbnQ6bnVsbCxWLmZvZz1ELmZvZyxWLmVudk1hcD0oRS5pc01lc2hTdGFuZGFyZE1hdGVyaWFsP046UykuZ2V0KEUuZW52TWFwfHxWLmVudmlyb25tZW50KSxHdD09PXZvaWQgMCYmKEUuYWRkRXZlbnRMaXN0ZW5lcigiZGlzcG9zZSIsYXQpLEd0PW5ldyBNYXAsVi5wcm9ncmFtcz1HdCk7bGV0IER0PUd0LmdldChJdCk7aWYoRHQhPT12b2lkIDApe2lmKFYuY3VycmVudFByb2dyYW09PT1EdCYmVi5saWdodHNTdGF0ZVZlcnNpb249PT1TdClyZXR1cm4gdXUoRSxDdCksRHR9ZWxzZSBDdC51bmlmb3Jtcz14dC5nZXRVbmlmb3JtcyhFKSxFLm9uQnVpbGQoQixDdCx4KSxFLm9uQmVmb3JlQ29tcGlsZShDdCx4KSxEdD14dC5hY3F1aXJlUHJvZ3JhbShDdCxJdCksR3Quc2V0KEl0LER0KSxWLnVuaWZvcm1zPUN0LnVuaWZvcm1zO2xldCBCdD1WLnVuaWZvcm1zO3JldHVybighRS5pc1NoYWRlck1hdGVyaWFsJiYhRS5pc1Jhd1NoYWRlck1hdGVyaWFsfHxFLmNsaXBwaW5nPT09ITApJiYoQnQuY2xpcHBpbmdQbGFuZXM9RnQudW5pZm9ybSksdXUoRSxDdCksVi5uZWVkc0xpZ2h0cz1fcChFKSxWLmxpZ2h0c1N0YXRlVmVyc2lvbj1TdCxWLm5lZWRzTGlnaHRzJiYoQnQuYW1iaWVudExpZ2h0Q29sb3IudmFsdWU9Ty5zdGF0ZS5hbWJpZW50LEJ0LmxpZ2h0UHJvYmUudmFsdWU9Ty5zdGF0ZS5wcm9iZSxCdC5kaXJlY3Rpb25hbExpZ2h0cy52YWx1ZT1PLnN0YXRlLmRpcmVjdGlvbmFsLEJ0LmRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzLnZhbHVlPU8uc3RhdGUuZGlyZWN0aW9uYWxTaGFkb3csQnQuc3BvdExpZ2h0cy52YWx1ZT1PLnN0YXRlLnNwb3QsQnQuc3BvdExpZ2h0U2hhZG93cy52YWx1ZT1PLnN0YXRlLnNwb3RTaGFkb3csQnQucmVjdEFyZWFMaWdodHMudmFsdWU9Ty5zdGF0ZS5yZWN0QXJlYSxCdC5sdGNfMS52YWx1ZT1PLnN0YXRlLnJlY3RBcmVhTFRDMSxCdC5sdGNfMi52YWx1ZT1PLnN0YXRlLnJlY3RBcmVhTFRDMixCdC5wb2ludExpZ2h0cy52YWx1ZT1PLnN0YXRlLnBvaW50LEJ0LnBvaW50TGlnaHRTaGFkb3dzLnZhbHVlPU8uc3RhdGUucG9pbnRTaGFkb3csQnQuaGVtaXNwaGVyZUxpZ2h0cy52YWx1ZT1PLnN0YXRlLmhlbWksQnQuZGlyZWN0aW9uYWxTaGFkb3dNYXAudmFsdWU9Ty5zdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hcCxCdC5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeC52YWx1ZT1PLnN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4LEJ0LnNwb3RTaGFkb3dNYXAudmFsdWU9Ty5zdGF0ZS5zcG90U2hhZG93TWFwLEJ0LnNwb3RMaWdodE1hdHJpeC52YWx1ZT1PLnN0YXRlLnNwb3RMaWdodE1hdHJpeCxCdC5zcG90TGlnaHRNYXAudmFsdWU9Ty5zdGF0ZS5zcG90TGlnaHRNYXAsQnQucG9pbnRTaGFkb3dNYXAudmFsdWU9Ty5zdGF0ZS5wb2ludFNoYWRvd01hcCxCdC5wb2ludFNoYWRvd01hdHJpeC52YWx1ZT1PLnN0YXRlLnBvaW50U2hhZG93TWF0cml4KSxWLmN1cnJlbnRQcm9ncmFtPUR0LFYudW5pZm9ybXNMaXN0PW51bGwsRHR9ZnVuY3Rpb24gaHUoRSl7aWYoRS51bmlmb3Jtc0xpc3Q9PT1udWxsKXtsZXQgRD1FLmN1cnJlbnRQcm9ncmFtLmdldFVuaWZvcm1zKCk7RS51bmlmb3Jtc0xpc3Q9ZnMuc2VxV2l0aFZhbHVlKEQuc2VxLEUudW5pZm9ybXMpfXJldHVybiBFLnVuaWZvcm1zTGlzdH1mdW5jdGlvbiB1dShFLEQpe2xldCBCPWh0LmdldChFKTtCLm91dHB1dENvbG9yU3BhY2U9RC5vdXRwdXRDb2xvclNwYWNlLEIuYmF0Y2hpbmc9RC5iYXRjaGluZyxCLmluc3RhbmNpbmc9RC5pbnN0YW5jaW5nLEIuaW5zdGFuY2luZ0NvbG9yPUQuaW5zdGFuY2luZ0NvbG9yLEIuc2tpbm5pbmc9RC5za2lubmluZyxCLm1vcnBoVGFyZ2V0cz1ELm1vcnBoVGFyZ2V0cyxCLm1vcnBoTm9ybWFscz1ELm1vcnBoTm9ybWFscyxCLm1vcnBoQ29sb3JzPUQubW9ycGhDb2xvcnMsQi5tb3JwaFRhcmdldHNDb3VudD1ELm1vcnBoVGFyZ2V0c0NvdW50LEIubnVtQ2xpcHBpbmdQbGFuZXM9RC5udW1DbGlwcGluZ1BsYW5lcyxCLm51bUludGVyc2VjdGlvbj1ELm51bUNsaXBJbnRlcnNlY3Rpb24sQi52ZXJ0ZXhBbHBoYXM9RC52ZXJ0ZXhBbHBoYXMsQi52ZXJ0ZXhUYW5nZW50cz1ELnZlcnRleFRhbmdlbnRzLEIudG9uZU1hcHBpbmc9RC50b25lTWFwcGluZ31mdW5jdGlvbiBtcChFLEQsQixWLE8pe0QuaXNTY2VuZSE9PSEwJiYoRD1PdCksYi5yZXNldFRleHR1cmVVbml0cygpO2xldCBkdD1ELmZvZyxTdD1WLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWw/RC5lbnZpcm9ubWVudDpudWxsLEN0PVQ9PT1udWxsP3gub3V0cHV0Q29sb3JTcGFjZTpULmlzWFJSZW5kZXJUYXJnZXQ9PT0hMD9ULnRleHR1cmUuY29sb3JTcGFjZTpfbixJdD0oVi5pc01lc2hTdGFuZGFyZE1hdGVyaWFsP046UykuZ2V0KFYuZW52TWFwfHxTdCksR3Q9Vi52ZXJ0ZXhDb2xvcnM9PT0hMCYmISFCLmF0dHJpYnV0ZXMuY29sb3ImJkIuYXR0cmlidXRlcy5jb2xvci5pdGVtU2l6ZT09PTQsRHQ9ISFCLmF0dHJpYnV0ZXMudGFuZ2VudCYmKCEhVi5ub3JtYWxNYXB8fFYuYW5pc290cm9weT4wKSxCdD0hIUIubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uLGZlPSEhQi5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsLEdlPSEhQi5tb3JwaEF0dHJpYnV0ZXMuY29sb3IsU2U9RG47Vi50b25lTWFwcGVkJiYoVD09PW51bGx8fFQuaXNYUlJlbmRlclRhcmdldD09PSEwKSYmKFNlPXgudG9uZU1hcHBpbmcpO2xldCBNbj1CLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbnx8Qi5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsfHxCLm1vcnBoQXR0cmlidXRlcy5jb2xvcixhZT1NbiE9PXZvaWQgMD9Nbi5sZW5ndGg6MCxXdD1odC5nZXQoViksYWw9Zy5zdGF0ZS5saWdodHM7aWYoSD09PSEwJiYoaXQ9PT0hMHx8RSE9PWspKXtsZXQgamU9RT09PWsmJlYuaWQ9PT1VO0Z0LnNldFN0YXRlKFYsRSxqZSl9bGV0IGNlPSExO1YudmVyc2lvbj09PVd0Ll9fdmVyc2lvbj8oV3QubmVlZHNMaWdodHMmJld0LmxpZ2h0c1N0YXRlVmVyc2lvbiE9PWFsLnN0YXRlLnZlcnNpb258fFd0Lm91dHB1dENvbG9yU3BhY2UhPT1DdHx8Ty5pc0JhdGNoZWRNZXNoJiZXdC5iYXRjaGluZz09PSExfHwhTy5pc0JhdGNoZWRNZXNoJiZXdC5iYXRjaGluZz09PSEwfHxPLmlzSW5zdGFuY2VkTWVzaCYmV3QuaW5zdGFuY2luZz09PSExfHwhTy5pc0luc3RhbmNlZE1lc2gmJld0Lmluc3RhbmNpbmc9PT0hMHx8Ty5pc1NraW5uZWRNZXNoJiZXdC5za2lubmluZz09PSExfHwhTy5pc1NraW5uZWRNZXNoJiZXdC5za2lubmluZz09PSEwfHxPLmlzSW5zdGFuY2VkTWVzaCYmV3QuaW5zdGFuY2luZ0NvbG9yPT09ITAmJk8uaW5zdGFuY2VDb2xvcj09PW51bGx8fE8uaXNJbnN0YW5jZWRNZXNoJiZXdC5pbnN0YW5jaW5nQ29sb3I9PT0hMSYmTy5pbnN0YW5jZUNvbG9yIT09bnVsbHx8V3QuZW52TWFwIT09SXR8fFYuZm9nPT09ITAmJld0LmZvZyE9PWR0fHxXdC5udW1DbGlwcGluZ1BsYW5lcyE9PXZvaWQgMCYmKFd0Lm51bUNsaXBwaW5nUGxhbmVzIT09RnQubnVtUGxhbmVzfHxXdC5udW1JbnRlcnNlY3Rpb24hPT1GdC5udW1JbnRlcnNlY3Rpb24pfHxXdC52ZXJ0ZXhBbHBoYXMhPT1HdHx8V3QudmVydGV4VGFuZ2VudHMhPT1EdHx8V3QubW9ycGhUYXJnZXRzIT09QnR8fFd0Lm1vcnBoTm9ybWFscyE9PWZlfHxXdC5tb3JwaENvbG9ycyE9PUdlfHxXdC50b25lTWFwcGluZyE9PVNlfHxzdC5pc1dlYkdMMj09PSEwJiZXdC5tb3JwaFRhcmdldHNDb3VudCE9PWFlKSYmKGNlPSEwKTooY2U9ITAsV3QuX192ZXJzaW9uPVYudmVyc2lvbik7bGV0IG9pPVd0LmN1cnJlbnRQcm9ncmFtO2NlPT09ITAmJihvaT16cihWLEQsTykpO2xldCBkdT0hMSxScz0hMSxvbD0hMSxDZT1vaS5nZXRVbmlmb3JtcygpLGxpPVd0LnVuaWZvcm1zO2lmKFkudXNlUHJvZ3JhbShvaS5wcm9ncmFtKSYmKGR1PSEwLFJzPSEwLG9sPSEwKSxWLmlkIT09VSYmKFU9Vi5pZCxScz0hMCksZHV8fGshPT1FKXtDZS5zZXRWYWx1ZShMLCJwcm9qZWN0aW9uTWF0cml4IixFLnByb2plY3Rpb25NYXRyaXgpLENlLnNldFZhbHVlKEwsInZpZXdNYXRyaXgiLEUubWF0cml4V29ybGRJbnZlcnNlKTtsZXQgamU9Q2UubWFwLmNhbWVyYVBvc2l0aW9uO2plIT09dm9pZCAwJiZqZS5zZXRWYWx1ZShMLHl0LnNldEZyb21NYXRyaXhQb3NpdGlvbihFLm1hdHJpeFdvcmxkKSksc3QubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciYmQ2Uuc2V0VmFsdWUoTCwibG9nRGVwdGhCdWZGQyIsMi8oTWF0aC5sb2coRS5mYXIrMSkvTWF0aC5MTjIpKSwoVi5pc01lc2hQaG9uZ01hdGVyaWFsfHxWLmlzTWVzaFRvb25NYXRlcmlhbHx8Vi5pc01lc2hMYW1iZXJ0TWF0ZXJpYWx8fFYuaXNNZXNoQmFzaWNNYXRlcmlhbHx8Vi5pc01lc2hTdGFuZGFyZE1hdGVyaWFsfHxWLmlzU2hhZGVyTWF0ZXJpYWwpJiZDZS5zZXRWYWx1ZShMLCJpc09ydGhvZ3JhcGhpYyIsRS5pc09ydGhvZ3JhcGhpY0NhbWVyYT09PSEwKSxrIT09RSYmKGs9RSxScz0hMCxvbD0hMCl9aWYoTy5pc1NraW5uZWRNZXNoKXtDZS5zZXRPcHRpb25hbChMLE8sImJpbmRNYXRyaXgiKSxDZS5zZXRPcHRpb25hbChMLE8sImJpbmRNYXRyaXhJbnZlcnNlIik7bGV0IGplPU8uc2tlbGV0b247amUmJihzdC5mbG9hdFZlcnRleFRleHR1cmVzPyhqZS5ib25lVGV4dHVyZT09PW51bGwmJmplLmNvbXB1dGVCb25lVGV4dHVyZSgpLENlLnNldFZhbHVlKEwsImJvbmVUZXh0dXJlIixqZS5ib25lVGV4dHVyZSxiKSk6Y29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBTa2lubmVkTWVzaCBjYW4gb25seSBiZSB1c2VkIHdpdGggV2ViR0wgMi4gV2l0aCBXZWJHTCAxIE9FU190ZXh0dXJlX2Zsb2F0IGFuZCB2ZXJ0ZXggdGV4dHVyZXMgc3VwcG9ydCBpcyByZXF1aXJlZC4iKSl9Ty5pc0JhdGNoZWRNZXNoJiYoQ2Uuc2V0T3B0aW9uYWwoTCxPLCJiYXRjaGluZ1RleHR1cmUiKSxDZS5zZXRWYWx1ZShMLCJiYXRjaGluZ1RleHR1cmUiLE8uX21hdHJpY2VzVGV4dHVyZSxiKSk7bGV0IGxsPUIubW9ycGhBdHRyaWJ1dGVzO2lmKChsbC5wb3NpdGlvbiE9PXZvaWQgMHx8bGwubm9ybWFsIT09dm9pZCAwfHxsbC5jb2xvciE9PXZvaWQgMCYmc3QuaXNXZWJHTDI9PT0hMCkmJlh0LnVwZGF0ZShPLEIsb2kpLChSc3x8V3QucmVjZWl2ZVNoYWRvdyE9PU8ucmVjZWl2ZVNoYWRvdykmJihXdC5yZWNlaXZlU2hhZG93PU8ucmVjZWl2ZVNoYWRvdyxDZS5zZXRWYWx1ZShMLCJyZWNlaXZlU2hhZG93IixPLnJlY2VpdmVTaGFkb3cpKSxWLmlzTWVzaEdvdXJhdWRNYXRlcmlhbCYmVi5lbnZNYXAhPT1udWxsJiYobGkuZW52TWFwLnZhbHVlPUl0LGxpLmZsaXBFbnZNYXAudmFsdWU9SXQuaXNDdWJlVGV4dHVyZSYmSXQuaXNSZW5kZXJUYXJnZXRUZXh0dXJlPT09ITE/LTE6MSksUnMmJihDZS5zZXRWYWx1ZShMLCJ0b25lTWFwcGluZ0V4cG9zdXJlIix4LnRvbmVNYXBwaW5nRXhwb3N1cmUpLFd0Lm5lZWRzTGlnaHRzJiZncChsaSxvbCksZHQmJlYuZm9nPT09ITAmJmN0LnJlZnJlc2hGb2dVbmlmb3JtcyhsaSxkdCksY3QucmVmcmVzaE1hdGVyaWFsVW5pZm9ybXMobGksViwkLEYscHQpLGZzLnVwbG9hZChMLGh1KFd0KSxsaSxiKSksVi5pc1NoYWRlck1hdGVyaWFsJiZWLnVuaWZvcm1zTmVlZFVwZGF0ZT09PSEwJiYoZnMudXBsb2FkKEwsaHUoV3QpLGxpLGIpLFYudW5pZm9ybXNOZWVkVXBkYXRlPSExKSxWLmlzU3ByaXRlTWF0ZXJpYWwmJkNlLnNldFZhbHVlKEwsImNlbnRlciIsTy5jZW50ZXIpLENlLnNldFZhbHVlKEwsIm1vZGVsVmlld01hdHJpeCIsTy5tb2RlbFZpZXdNYXRyaXgpLENlLnNldFZhbHVlKEwsIm5vcm1hbE1hdHJpeCIsTy5ub3JtYWxNYXRyaXgpLENlLnNldFZhbHVlKEwsIm1vZGVsTWF0cml4IixPLm1hdHJpeFdvcmxkKSxWLmlzU2hhZGVyTWF0ZXJpYWx8fFYuaXNSYXdTaGFkZXJNYXRlcmlhbCl7bGV0IGplPVYudW5pZm9ybXNHcm91cHM7Zm9yKGxldCBjbD0wLHhwPWplLmxlbmd0aDtjbDx4cDtjbCsrKWlmKHN0LmlzV2ViR0wyKXtsZXQgZnU9amVbY2xdOyR0LnVwZGF0ZShmdSxvaSksJHQuYmluZChmdSxvaSl9ZWxzZSBjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUmVuZGVyZXI6IFVuaWZvcm0gQnVmZmVyIE9iamVjdHMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIFdlYkdMIDIuIil9cmV0dXJuIG9pfWZ1bmN0aW9uIGdwKEUsRCl7RS5hbWJpZW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZT1ELEUubGlnaHRQcm9iZS5uZWVkc1VwZGF0ZT1ELEUuZGlyZWN0aW9uYWxMaWdodHMubmVlZHNVcGRhdGU9RCxFLmRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzLm5lZWRzVXBkYXRlPUQsRS5wb2ludExpZ2h0cy5uZWVkc1VwZGF0ZT1ELEUucG9pbnRMaWdodFNoYWRvd3MubmVlZHNVcGRhdGU9RCxFLnNwb3RMaWdodHMubmVlZHNVcGRhdGU9RCxFLnNwb3RMaWdodFNoYWRvd3MubmVlZHNVcGRhdGU9RCxFLnJlY3RBcmVhTGlnaHRzLm5lZWRzVXBkYXRlPUQsRS5oZW1pc3BoZXJlTGlnaHRzLm5lZWRzVXBkYXRlPUR9ZnVuY3Rpb24gX3AoRSl7cmV0dXJuIEUuaXNNZXNoTGFtYmVydE1hdGVyaWFsfHxFLmlzTWVzaFRvb25NYXRlcmlhbHx8RS5pc01lc2hQaG9uZ01hdGVyaWFsfHxFLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWx8fEUuaXNTaGFkb3dNYXRlcmlhbHx8RS5pc1NoYWRlck1hdGVyaWFsJiZFLmxpZ2h0cz09PSEwfXRoaXMuZ2V0QWN0aXZlQ3ViZUZhY2U9ZnVuY3Rpb24oKXtyZXR1cm4gQ30sdGhpcy5nZXRBY3RpdmVNaXBtYXBMZXZlbD1mdW5jdGlvbigpe3JldHVybiBBfSx0aGlzLmdldFJlbmRlclRhcmdldD1mdW5jdGlvbigpe3JldHVybiBUfSx0aGlzLnNldFJlbmRlclRhcmdldFRleHR1cmVzPWZ1bmN0aW9uKEUsRCxCKXtodC5nZXQoRS50ZXh0dXJlKS5fX3dlYmdsVGV4dHVyZT1ELGh0LmdldChFLmRlcHRoVGV4dHVyZSkuX193ZWJnbFRleHR1cmU9QjtsZXQgVj1odC5nZXQoRSk7Vi5fX2hhc0V4dGVybmFsVGV4dHVyZXM9ITAsVi5fX2hhc0V4dGVybmFsVGV4dHVyZXMmJihWLl9fYXV0b0FsbG9jYXRlRGVwdGhCdWZmZXI9Qj09PXZvaWQgMCxWLl9fYXV0b0FsbG9jYXRlRGVwdGhCdWZmZXJ8fFguaGFzKCJXRUJHTF9tdWx0aXNhbXBsZWRfcmVuZGVyX3RvX3RleHR1cmUiKT09PSEwJiYoY29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBSZW5kZXItdG8tdGV4dHVyZSBleHRlbnNpb24gd2FzIGRpc2FibGVkIGJlY2F1c2UgYW4gZXh0ZXJuYWwgdGV4dHVyZSB3YXMgcHJvdmlkZWQiKSxWLl9fdXNlUmVuZGVyVG9UZXh0dXJlPSExKSl9LHRoaXMuc2V0UmVuZGVyVGFyZ2V0RnJhbWVidWZmZXI9ZnVuY3Rpb24oRSxEKXtsZXQgQj1odC5nZXQoRSk7Qi5fX3dlYmdsRnJhbWVidWZmZXI9RCxCLl9fdXNlRGVmYXVsdEZyYW1lYnVmZmVyPUQ9PT12b2lkIDB9LHRoaXMuc2V0UmVuZGVyVGFyZ2V0PWZ1bmN0aW9uKEUsRD0wLEI9MCl7VD1FLEM9RCxBPUI7bGV0IFY9ITAsTz1udWxsLGR0PSExLFN0PSExO2lmKEUpe2xldCBJdD1odC5nZXQoRSk7SXQuX191c2VEZWZhdWx0RnJhbWVidWZmZXIhPT12b2lkIDA/KFkuYmluZEZyYW1lYnVmZmVyKEwuRlJBTUVCVUZGRVIsbnVsbCksVj0hMSk6SXQuX193ZWJnbEZyYW1lYnVmZmVyPT09dm9pZCAwP2Iuc2V0dXBSZW5kZXJUYXJnZXQoRSk6SXQuX19oYXNFeHRlcm5hbFRleHR1cmVzJiZiLnJlYmluZFRleHR1cmVzKEUsaHQuZ2V0KEUudGV4dHVyZSkuX193ZWJnbFRleHR1cmUsaHQuZ2V0KEUuZGVwdGhUZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSk7bGV0IEd0PUUudGV4dHVyZTsoR3QuaXNEYXRhM0RUZXh0dXJlfHxHdC5pc0RhdGFBcnJheVRleHR1cmV8fEd0LmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSkmJihTdD0hMCk7bGV0IER0PWh0LmdldChFKS5fX3dlYmdsRnJhbWVidWZmZXI7RS5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldD8oQXJyYXkuaXNBcnJheShEdFtEXSk/Tz1EdFtEXVtCXTpPPUR0W0RdLGR0PSEwKTpzdC5pc1dlYkdMMiYmRS5zYW1wbGVzPjAmJmIudXNlTXVsdGlzYW1wbGVkUlRUKEUpPT09ITE/Tz1odC5nZXQoRSkuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyOkFycmF5LmlzQXJyYXkoRHQpP089RHRbQl06Tz1EdCx5LmNvcHkoRS52aWV3cG9ydCksdy5jb3B5KEUuc2Npc3NvciksRz1FLnNjaXNzb3JUZXN0fWVsc2UgeS5jb3B5KGV0KS5tdWx0aXBseVNjYWxhcigkKS5mbG9vcigpLHcuY29weShRKS5tdWx0aXBseVNjYWxhcigkKS5mbG9vcigpLEc9ZnQ7aWYoWS5iaW5kRnJhbWVidWZmZXIoTC5GUkFNRUJVRkZFUixPKSYmc3QuZHJhd0J1ZmZlcnMmJlYmJlkuZHJhd0J1ZmZlcnMoRSxPKSxZLnZpZXdwb3J0KHkpLFkuc2Npc3Nvcih3KSxZLnNldFNjaXNzb3JUZXN0KEcpLGR0KXtsZXQgSXQ9aHQuZ2V0KEUudGV4dHVyZSk7TC5mcmFtZWJ1ZmZlclRleHR1cmUyRChMLkZSQU1FQlVGRkVSLEwuQ09MT1JfQVRUQUNITUVOVDAsTC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grRCxJdC5fX3dlYmdsVGV4dHVyZSxCKX1lbHNlIGlmKFN0KXtsZXQgSXQ9aHQuZ2V0KEUudGV4dHVyZSksR3Q9RHx8MDtMLmZyYW1lYnVmZmVyVGV4dHVyZUxheWVyKEwuRlJBTUVCVUZGRVIsTC5DT0xPUl9BVFRBQ0hNRU5UMCxJdC5fX3dlYmdsVGV4dHVyZSxCfHwwLEd0KX1VPS0xfSx0aGlzLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM9ZnVuY3Rpb24oRSxELEIsVixPLGR0LFN0KXtpZighKEUmJkUuaXNXZWJHTFJlbmRlclRhcmdldCkpe2NvbnNvbGUuZXJyb3IoIlRIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC4iKTtyZXR1cm59bGV0IEN0PWh0LmdldChFKS5fX3dlYmdsRnJhbWVidWZmZXI7aWYoRS5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCYmU3QhPT12b2lkIDAmJihDdD1DdFtTdF0pLEN0KXtZLmJpbmRGcmFtZWJ1ZmZlcihMLkZSQU1FQlVGRkVSLEN0KTt0cnl7bGV0IEl0PUUudGV4dHVyZSxHdD1JdC5mb3JtYXQsRHQ9SXQudHlwZTtpZihHdCE9PUhlJiZfdC5jb252ZXJ0KEd0KSE9PUwuZ2V0UGFyYW1ldGVyKEwuSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9GT1JNQVQpKXtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gUkdCQSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIGZvcm1hdC4iKTtyZXR1cm59bGV0IEJ0PUR0PT09cHMmJihYLmhhcygiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0Iil8fHN0LmlzV2ViR0wyJiZYLmhhcygiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCIpKTtpZihEdCE9PU5uJiZfdC5jb252ZXJ0KER0KSE9PUwuZ2V0UGFyYW1ldGVyKEwuSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9UWVBFKSYmIShEdD09PWVuJiYoc3QuaXNXZWJHTDJ8fFguaGFzKCJPRVNfdGV4dHVyZV9mbG9hdCIpfHxYLmhhcygiV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0IikpKSYmIUJ0KXtjb25zb2xlLmVycm9yKCJUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gVW5zaWduZWRCeXRlVHlwZSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIHR5cGUuIik7cmV0dXJufUQ+PTAmJkQ8PUUud2lkdGgtViYmQj49MCYmQjw9RS5oZWlnaHQtTyYmTC5yZWFkUGl4ZWxzKEQsQixWLE8sX3QuY29udmVydChHdCksX3QuY29udmVydChEdCksZHQpfWZpbmFsbHl7bGV0IEl0PVQhPT1udWxsP2h0LmdldChUKS5fX3dlYmdsRnJhbWVidWZmZXI6bnVsbDtZLmJpbmRGcmFtZWJ1ZmZlcihMLkZSQU1FQlVGRkVSLEl0KX19fSx0aGlzLmNvcHlGcmFtZWJ1ZmZlclRvVGV4dHVyZT1mdW5jdGlvbihFLEQsQj0wKXtsZXQgVj1NYXRoLnBvdygyLC1CKSxPPU1hdGguZmxvb3IoRC5pbWFnZS53aWR0aCpWKSxkdD1NYXRoLmZsb29yKEQuaW1hZ2UuaGVpZ2h0KlYpO2Iuc2V0VGV4dHVyZTJEKEQsMCksTC5jb3B5VGV4U3ViSW1hZ2UyRChMLlRFWFRVUkVfMkQsQiwwLDAsRS54LEUueSxPLGR0KSxZLnVuYmluZFRleHR1cmUoKX0sdGhpcy5jb3B5VGV4dHVyZVRvVGV4dHVyZT1mdW5jdGlvbihFLEQsQixWPTApe2xldCBPPUQuaW1hZ2Uud2lkdGgsZHQ9RC5pbWFnZS5oZWlnaHQsU3Q9X3QuY29udmVydChCLmZvcm1hdCksQ3Q9X3QuY29udmVydChCLnR5cGUpO2Iuc2V0VGV4dHVyZTJEKEIsMCksTC5waXhlbFN0b3JlaShMLlVOUEFDS19GTElQX1lfV0VCR0wsQi5mbGlwWSksTC5waXhlbFN0b3JlaShMLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCxCLnByZW11bHRpcGx5QWxwaGEpLEwucGl4ZWxTdG9yZWkoTC5VTlBBQ0tfQUxJR05NRU5ULEIudW5wYWNrQWxpZ25tZW50KSxELmlzRGF0YVRleHR1cmU/TC50ZXhTdWJJbWFnZTJEKEwuVEVYVFVSRV8yRCxWLEUueCxFLnksTyxkdCxTdCxDdCxELmltYWdlLmRhdGEpOkQuaXNDb21wcmVzc2VkVGV4dHVyZT9MLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKEwuVEVYVFVSRV8yRCxWLEUueCxFLnksRC5taXBtYXBzWzBdLndpZHRoLEQubWlwbWFwc1swXS5oZWlnaHQsU3QsRC5taXBtYXBzWzBdLmRhdGEpOkwudGV4U3ViSW1hZ2UyRChMLlRFWFRVUkVfMkQsVixFLngsRS55LFN0LEN0LEQuaW1hZ2UpLFY9PT0wJiZCLmdlbmVyYXRlTWlwbWFwcyYmTC5nZW5lcmF0ZU1pcG1hcChMLlRFWFRVUkVfMkQpLFkudW5iaW5kVGV4dHVyZSgpfSx0aGlzLmNvcHlUZXh0dXJlVG9UZXh0dXJlM0Q9ZnVuY3Rpb24oRSxELEIsVixPPTApe2lmKHguaXNXZWJHTDFSZW5kZXJlcil7Y29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyLmNvcHlUZXh0dXJlVG9UZXh0dXJlM0Q6IGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBXZWJHTDIuIik7cmV0dXJufWxldCBkdD1FLm1heC54LUUubWluLngrMSxTdD1FLm1heC55LUUubWluLnkrMSxDdD1FLm1heC56LUUubWluLnorMSxJdD1fdC5jb252ZXJ0KFYuZm9ybWF0KSxHdD1fdC5jb252ZXJ0KFYudHlwZSksRHQ7aWYoVi5pc0RhdGEzRFRleHR1cmUpYi5zZXRUZXh0dXJlM0QoViwwKSxEdD1MLlRFWFRVUkVfM0Q7ZWxzZSBpZihWLmlzRGF0YUFycmF5VGV4dHVyZXx8Vi5pc0NvbXByZXNzZWRBcnJheVRleHR1cmUpYi5zZXRUZXh0dXJlMkRBcnJheShWLDApLER0PUwuVEVYVFVSRV8yRF9BUlJBWTtlbHNle2NvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlci5jb3B5VGV4dHVyZVRvVGV4dHVyZTNEOiBvbmx5IHN1cHBvcnRzIFRIUkVFLkRhdGFUZXh0dXJlM0QgYW5kIFRIUkVFLkRhdGFUZXh0dXJlMkRBcnJheS4iKTtyZXR1cm59TC5waXhlbFN0b3JlaShMLlVOUEFDS19GTElQX1lfV0VCR0wsVi5mbGlwWSksTC5waXhlbFN0b3JlaShMLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCxWLnByZW11bHRpcGx5QWxwaGEpLEwucGl4ZWxTdG9yZWkoTC5VTlBBQ0tfQUxJR05NRU5ULFYudW5wYWNrQWxpZ25tZW50KTtsZXQgQnQ9TC5nZXRQYXJhbWV0ZXIoTC5VTlBBQ0tfUk9XX0xFTkdUSCksZmU9TC5nZXRQYXJhbWV0ZXIoTC5VTlBBQ0tfSU1BR0VfSEVJR0hUKSxHZT1MLmdldFBhcmFtZXRlcihMLlVOUEFDS19TS0lQX1BJWEVMUyksU2U9TC5nZXRQYXJhbWV0ZXIoTC5VTlBBQ0tfU0tJUF9ST1dTKSxNbj1MLmdldFBhcmFtZXRlcihMLlVOUEFDS19TS0lQX0lNQUdFUyksYWU9Qi5pc0NvbXByZXNzZWRUZXh0dXJlP0IubWlwbWFwc1tPXTpCLmltYWdlO0wucGl4ZWxTdG9yZWkoTC5VTlBBQ0tfUk9XX0xFTkdUSCxhZS53aWR0aCksTC5waXhlbFN0b3JlaShMLlVOUEFDS19JTUFHRV9IRUlHSFQsYWUuaGVpZ2h0KSxMLnBpeGVsU3RvcmVpKEwuVU5QQUNLX1NLSVBfUElYRUxTLEUubWluLngpLEwucGl4ZWxTdG9yZWkoTC5VTlBBQ0tfU0tJUF9ST1dTLEUubWluLnkpLEwucGl4ZWxTdG9yZWkoTC5VTlBBQ0tfU0tJUF9JTUFHRVMsRS5taW4ueiksQi5pc0RhdGFUZXh0dXJlfHxCLmlzRGF0YTNEVGV4dHVyZT9MLnRleFN1YkltYWdlM0QoRHQsTyxELngsRC55LEQueixkdCxTdCxDdCxJdCxHdCxhZS5kYXRhKTpCLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZT8oY29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyLmNvcHlUZXh0dXJlVG9UZXh0dXJlM0Q6IHVudGVzdGVkIHN1cHBvcnQgZm9yIGNvbXByZXNzZWQgc3JjVGV4dHVyZS4iKSxMLmNvbXByZXNzZWRUZXhTdWJJbWFnZTNEKER0LE8sRC54LEQueSxELnosZHQsU3QsQ3QsSXQsYWUuZGF0YSkpOkwudGV4U3ViSW1hZ2UzRChEdCxPLEQueCxELnksRC56LGR0LFN0LEN0LEl0LEd0LGFlKSxMLnBpeGVsU3RvcmVpKEwuVU5QQUNLX1JPV19MRU5HVEgsQnQpLEwucGl4ZWxTdG9yZWkoTC5VTlBBQ0tfSU1BR0VfSEVJR0hULGZlKSxMLnBpeGVsU3RvcmVpKEwuVU5QQUNLX1NLSVBfUElYRUxTLEdlKSxMLnBpeGVsU3RvcmVpKEwuVU5QQUNLX1NLSVBfUk9XUyxTZSksTC5waXhlbFN0b3JlaShMLlVOUEFDS19TS0lQX0lNQUdFUyxNbiksTz09PTAmJlYuZ2VuZXJhdGVNaXBtYXBzJiZMLmdlbmVyYXRlTWlwbWFwKER0KSxZLnVuYmluZFRleHR1cmUoKX0sdGhpcy5pbml0VGV4dHVyZT1mdW5jdGlvbihFKXtFLmlzQ3ViZVRleHR1cmU/Yi5zZXRUZXh0dXJlQ3ViZShFLDApOkUuaXNEYXRhM0RUZXh0dXJlP2Iuc2V0VGV4dHVyZTNEKEUsMCk6RS5pc0RhdGFBcnJheVRleHR1cmV8fEUuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlP2Iuc2V0VGV4dHVyZTJEQXJyYXkoRSwwKTpiLnNldFRleHR1cmUyRChFLDApLFkudW5iaW5kVGV4dHVyZSgpfSx0aGlzLnJlc2V0U3RhdGU9ZnVuY3Rpb24oKXtDPTAsQT0wLFQ9bnVsbCxZLnJlc2V0KCksVnQucmVzZXQoKX0sdHlwZW9mIF9fVEhSRUVfREVWVE9PTFNfXzwidSImJl9fVEhSRUVfREVWVE9PTFNfXy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgib2JzZXJ2ZSIse2RldGFpbDp0aGlzfSkpfWdldCBjb29yZGluYXRlU3lzdGVtKCl7cmV0dXJuIG1ufWdldCBvdXRwdXRDb2xvclNwYWNlKCl7cmV0dXJuIHRoaXMuX291dHB1dENvbG9yU3BhY2V9c2V0IG91dHB1dENvbG9yU3BhY2UodCl7dGhpcy5fb3V0cHV0Q29sb3JTcGFjZT10O2xldCBlPXRoaXMuZ2V0Q29udGV4dCgpO2UuZHJhd2luZ0J1ZmZlckNvbG9yU3BhY2U9dD09PWlsPyJkaXNwbGF5LXAzIjoic3JnYiIsZS51bnBhY2tDb2xvclNwYWNlPWp0LndvcmtpbmdDb2xvclNwYWNlPT09RnI/ImRpc3BsYXktcDMiOiJzcmdiIn1nZXQgb3V0cHV0RW5jb2RpbmcoKXtyZXR1cm4gY29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBQcm9wZXJ0eSAub3V0cHV0RW5jb2RpbmcgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC5vdXRwdXRDb2xvclNwYWNlIGluc3RlYWQuIiksdGhpcy5vdXRwdXRDb2xvclNwYWNlPT09eGU/dGk6dHV9c2V0IG91dHB1dEVuY29kaW5nKHQpe2NvbnNvbGUud2FybigiVEhSRUUuV2ViR0xSZW5kZXJlcjogUHJvcGVydHkgLm91dHB1dEVuY29kaW5nIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAub3V0cHV0Q29sb3JTcGFjZSBpbnN0ZWFkLiIpLHRoaXMub3V0cHV0Q29sb3JTcGFjZT10PT09dGk/eGU6X259Z2V0IHVzZUxlZ2FjeUxpZ2h0cygpe3JldHVybiBjb25zb2xlLndhcm4oIlRIUkVFLldlYkdMUmVuZGVyZXI6IFRoZSBwcm9wZXJ0eSAudXNlTGVnYWN5TGlnaHRzIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIE1pZ3JhdGUgeW91ciBsaWdodGluZyBhY2NvcmRpbmcgdG8gdGhlIGZvbGxvd2luZyBndWlkZTogaHR0cHM6Ly9kaXNjb3Vyc2UudGhyZWVqcy5vcmcvdC91cGRhdGVzLXRvLWxpZ2h0aW5nLWluLXRocmVlLWpzLXIxNTUvNTM3MzMuIiksdGhpcy5fdXNlTGVnYWN5TGlnaHRzfXNldCB1c2VMZWdhY3lMaWdodHModCl7Y29uc29sZS53YXJuKCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBUaGUgcHJvcGVydHkgLnVzZUxlZ2FjeUxpZ2h0cyBoYXMgYmVlbiBkZXByZWNhdGVkLiBNaWdyYXRlIHlvdXIgbGlnaHRpbmcgYWNjb3JkaW5nIHRvIHRoZSBmb2xsb3dpbmcgZ3VpZGU6IGh0dHBzOi8vZGlzY291cnNlLnRocmVlanMub3JnL3QvdXBkYXRlcy10by1saWdodGluZy1pbi10aHJlZS1qcy1yMTU1LzUzNzMzLiIpLHRoaXMuX3VzZUxlZ2FjeUxpZ2h0cz10fX0sWWE9Y2xhc3MgZXh0ZW5kcyBxYXt9O1lhLnByb3RvdHlwZS5pc1dlYkdMMVJlbmRlcmVyPSEwO3ZhciBaYT1jbGFzcyBze2NvbnN0cnVjdG9yKHQsZT0yNWUtNSl7dGhpcy5pc0ZvZ0V4cDI9ITAsdGhpcy5uYW1lPSIiLHRoaXMuY29sb3I9bmV3IHV0KHQpLHRoaXMuZGVuc2l0eT1lfWNsb25lKCl7cmV0dXJuIG5ldyBzKHRoaXMuY29sb3IsdGhpcy5kZW5zaXR5KX10b0pTT04oKXtyZXR1cm57dHlwZToiRm9nRXhwMiIsbmFtZTp0aGlzLm5hbWUsY29sb3I6dGhpcy5jb2xvci5nZXRIZXgoKSxkZW5zaXR5OnRoaXMuZGVuc2l0eX19fSxKYT1jbGFzcyBze2NvbnN0cnVjdG9yKHQsZT0xLG49MWUzKXt0aGlzLmlzRm9nPSEwLHRoaXMubmFtZT0iIix0aGlzLmNvbG9yPW5ldyB1dCh0KSx0aGlzLm5lYXI9ZSx0aGlzLmZhcj1ufWNsb25lKCl7cmV0dXJuIG5ldyBzKHRoaXMuY29sb3IsdGhpcy5uZWFyLHRoaXMuZmFyKX10b0pTT04oKXtyZXR1cm57dHlwZToiRm9nIixuYW1lOnRoaXMubmFtZSxjb2xvcjp0aGlzLmNvbG9yLmdldEhleCgpLG5lYXI6dGhpcy5uZWFyLGZhcjp0aGlzLmZhcn19fSwkYT1jbGFzcyBleHRlbmRzIEp0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLmlzU2NlbmU9ITAsdGhpcy50eXBlPSJTY2VuZSIsdGhpcy5iYWNrZ3JvdW5kPW51bGwsdGhpcy5lbnZpcm9ubWVudD1udWxsLHRoaXMuZm9nPW51bGwsdGhpcy5iYWNrZ3JvdW5kQmx1cnJpbmVzcz0wLHRoaXMuYmFja2dyb3VuZEludGVuc2l0eT0xLHRoaXMub3ZlcnJpZGVNYXRlcmlhbD1udWxsLHR5cGVvZiBfX1RIUkVFX0RFVlRPT0xTX188InUiJiZfX1RIUkVFX0RFVlRPT0xTX18uZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoIm9ic2VydmUiLHtkZXRhaWw6dGhpc30pKX1jb3B5KHQsZSl7cmV0dXJuIHN1cGVyLmNvcHkodCxlKSx0LmJhY2tncm91bmQhPT1udWxsJiYodGhpcy5iYWNrZ3JvdW5kPXQuYmFja2dyb3VuZC5jbG9uZSgpKSx0LmVudmlyb25tZW50IT09bnVsbCYmKHRoaXMuZW52aXJvbm1lbnQ9dC5lbnZpcm9ubWVudC5jbG9uZSgpKSx0LmZvZyE9PW51bGwmJih0aGlzLmZvZz10LmZvZy5jbG9uZSgpKSx0aGlzLmJhY2tncm91bmRCbHVycmluZXNzPXQuYmFja2dyb3VuZEJsdXJyaW5lc3MsdGhpcy5iYWNrZ3JvdW5kSW50ZW5zaXR5PXQuYmFja2dyb3VuZEludGVuc2l0eSx0Lm92ZXJyaWRlTWF0ZXJpYWwhPT1udWxsJiYodGhpcy5vdmVycmlkZU1hdGVyaWFsPXQub3ZlcnJpZGVNYXRlcmlhbC5jbG9uZSgpKSx0aGlzLm1hdHJpeEF1dG9VcGRhdGU9dC5tYXRyaXhBdXRvVXBkYXRlLHRoaXN9dG9KU09OKHQpe2xldCBlPXN1cGVyLnRvSlNPTih0KTtyZXR1cm4gdGhpcy5mb2chPT1udWxsJiYoZS5vYmplY3QuZm9nPXRoaXMuZm9nLnRvSlNPTigpKSx0aGlzLmJhY2tncm91bmRCbHVycmluZXNzPjAmJihlLm9iamVjdC5iYWNrZ3JvdW5kQmx1cnJpbmVzcz10aGlzLmJhY2tncm91bmRCbHVycmluZXNzKSx0aGlzLmJhY2tncm91bmRJbnRlbnNpdHkhPT0xJiYoZS5vYmplY3QuYmFja2dyb3VuZEludGVuc2l0eT10aGlzLmJhY2tncm91bmRJbnRlbnNpdHkpLGV9fSxTcz1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuaXNJbnRlcmxlYXZlZEJ1ZmZlcj0hMCx0aGlzLmFycmF5PXQsdGhpcy5zdHJpZGU9ZSx0aGlzLmNvdW50PXQhPT12b2lkIDA/dC5sZW5ndGgvZTowLHRoaXMudXNhZ2U9aXIsdGhpcy5fdXBkYXRlUmFuZ2U9e29mZnNldDowLGNvdW50Oi0xfSx0aGlzLnVwZGF0ZVJhbmdlcz1bXSx0aGlzLnZlcnNpb249MCx0aGlzLnV1aWQ9WWUoKX1vblVwbG9hZENhbGxiYWNrKCl7fXNldCBuZWVkc1VwZGF0ZSh0KXt0PT09ITAmJnRoaXMudmVyc2lvbisrfWdldCB1cGRhdGVSYW5nZSgpe3JldHVybiBSaSgiVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXI6IHVwZGF0ZVJhbmdlKCkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHIxNjkuIFVzZSBhZGRVcGRhdGVSYW5nZSgpIGluc3RlYWQuIiksdGhpcy5fdXBkYXRlUmFuZ2V9c2V0VXNhZ2UodCl7cmV0dXJuIHRoaXMudXNhZ2U9dCx0aGlzfWFkZFVwZGF0ZVJhbmdlKHQsZSl7dGhpcy51cGRhdGVSYW5nZXMucHVzaCh7c3RhcnQ6dCxjb3VudDplfSl9Y2xlYXJVcGRhdGVSYW5nZXMoKXt0aGlzLnVwZGF0ZVJhbmdlcy5sZW5ndGg9MH1jb3B5KHQpe3JldHVybiB0aGlzLmFycmF5PW5ldyB0LmFycmF5LmNvbnN0cnVjdG9yKHQuYXJyYXkpLHRoaXMuY291bnQ9dC5jb3VudCx0aGlzLnN0cmlkZT10LnN0cmlkZSx0aGlzLnVzYWdlPXQudXNhZ2UsdGhpc31jb3B5QXQodCxlLG4pe3QqPXRoaXMuc3RyaWRlLG4qPWUuc3RyaWRlO2ZvcihsZXQgaT0wLHI9dGhpcy5zdHJpZGU7aTxyO2krKyl0aGlzLmFycmF5W3QraV09ZS5hcnJheVtuK2ldO3JldHVybiB0aGlzfXNldCh0LGU9MCl7cmV0dXJuIHRoaXMuYXJyYXkuc2V0KHQsZSksdGhpc31jbG9uZSh0KXt0LmFycmF5QnVmZmVycz09PXZvaWQgMCYmKHQuYXJyYXlCdWZmZXJzPXt9KSx0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZD09PXZvaWQgMCYmKHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkPVllKCkpLHQuYXJyYXlCdWZmZXJzW3RoaXMuYXJyYXkuYnVmZmVyLl91dWlkXT09PXZvaWQgMCYmKHQuYXJyYXlCdWZmZXJzW3RoaXMuYXJyYXkuYnVmZmVyLl91dWlkXT10aGlzLmFycmF5LnNsaWNlKDApLmJ1ZmZlcik7bGV0IGU9bmV3IHRoaXMuYXJyYXkuY29uc3RydWN0b3IodC5hcnJheUJ1ZmZlcnNbdGhpcy5hcnJheS5idWZmZXIuX3V1aWRdKSxuPW5ldyB0aGlzLmNvbnN0cnVjdG9yKGUsdGhpcy5zdHJpZGUpO3JldHVybiBuLnNldFVzYWdlKHRoaXMudXNhZ2UpLG59b25VcGxvYWQodCl7cmV0dXJuIHRoaXMub25VcGxvYWRDYWxsYmFjaz10LHRoaXN9dG9KU09OKHQpe3JldHVybiB0LmFycmF5QnVmZmVycz09PXZvaWQgMCYmKHQuYXJyYXlCdWZmZXJzPXt9KSx0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZD09PXZvaWQgMCYmKHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkPVllKCkpLHQuYXJyYXlCdWZmZXJzW3RoaXMuYXJyYXkuYnVmZmVyLl91dWlkXT09PXZvaWQgMCYmKHQuYXJyYXlCdWZmZXJzW3RoaXMuYXJyYXkuYnVmZmVyLl91dWlkXT1BcnJheS5mcm9tKG5ldyBVaW50MzJBcnJheSh0aGlzLmFycmF5LmJ1ZmZlcikpKSx7dXVpZDp0aGlzLnV1aWQsYnVmZmVyOnRoaXMuYXJyYXkuYnVmZmVyLl91dWlkLHR5cGU6dGhpcy5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLHN0cmlkZTp0aGlzLnN0cmlkZX19fSxGZT1uZXcgUixVaT1jbGFzcyBze2NvbnN0cnVjdG9yKHQsZSxuLGk9ITEpe3RoaXMuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZT0hMCx0aGlzLm5hbWU9IiIsdGhpcy5kYXRhPXQsdGhpcy5pdGVtU2l6ZT1lLHRoaXMub2Zmc2V0PW4sdGhpcy5ub3JtYWxpemVkPWl9Z2V0IGNvdW50KCl7cmV0dXJuIHRoaXMuZGF0YS5jb3VudH1nZXQgYXJyYXkoKXtyZXR1cm4gdGhpcy5kYXRhLmFycmF5fXNldCBuZWVkc1VwZGF0ZSh0KXt0aGlzLmRhdGEubmVlZHNVcGRhdGU9dH1hcHBseU1hdHJpeDQodCl7Zm9yKGxldCBlPTAsbj10aGlzLmRhdGEuY291bnQ7ZTxuO2UrKylGZS5mcm9tQnVmZmVyQXR0cmlidXRlKHRoaXMsZSksRmUuYXBwbHlNYXRyaXg0KHQpLHRoaXMuc2V0WFlaKGUsRmUueCxGZS55LEZlLnopO3JldHVybiB0aGlzfWFwcGx5Tm9ybWFsTWF0cml4KHQpe2ZvcihsZXQgZT0wLG49dGhpcy5jb3VudDtlPG47ZSsrKUZlLmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcyxlKSxGZS5hcHBseU5vcm1hbE1hdHJpeCh0KSx0aGlzLnNldFhZWihlLEZlLngsRmUueSxGZS56KTtyZXR1cm4gdGhpc310cmFuc2Zvcm1EaXJlY3Rpb24odCl7Zm9yKGxldCBlPTAsbj10aGlzLmNvdW50O2U8bjtlKyspRmUuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0aGlzLGUpLEZlLnRyYW5zZm9ybURpcmVjdGlvbih0KSx0aGlzLnNldFhZWihlLEZlLngsRmUueSxGZS56KTtyZXR1cm4gdGhpc31nZXRDb21wb25lbnQodCxlKXtsZXQgbj10aGlzLmFycmF5W3QqdGhpcy5kYXRhLnN0cmlkZSt0aGlzLm9mZnNldCtlXTtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYobj16ZShuLHRoaXMuYXJyYXkpKSxufXNldENvbXBvbmVudCh0LGUsbil7cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKG49TnQobix0aGlzLmFycmF5KSksdGhpcy5kYXRhLmFycmF5W3QqdGhpcy5kYXRhLnN0cmlkZSt0aGlzLm9mZnNldCtlXT1uLHRoaXN9c2V0WCh0LGUpe3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihlPU50KGUsdGhpcy5hcnJheSkpLHRoaXMuZGF0YS5hcnJheVt0KnRoaXMuZGF0YS5zdHJpZGUrdGhpcy5vZmZzZXRdPWUsdGhpc31zZXRZKHQsZSl7cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKGU9TnQoZSx0aGlzLmFycmF5KSksdGhpcy5kYXRhLmFycmF5W3QqdGhpcy5kYXRhLnN0cmlkZSt0aGlzLm9mZnNldCsxXT1lLHRoaXN9c2V0Wih0LGUpe3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihlPU50KGUsdGhpcy5hcnJheSkpLHRoaXMuZGF0YS5hcnJheVt0KnRoaXMuZGF0YS5zdHJpZGUrdGhpcy5vZmZzZXQrMl09ZSx0aGlzfXNldFcodCxlKXtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYoZT1OdChlLHRoaXMuYXJyYXkpKSx0aGlzLmRhdGEuYXJyYXlbdCp0aGlzLmRhdGEuc3RyaWRlK3RoaXMub2Zmc2V0KzNdPWUsdGhpc31nZXRYKHQpe2xldCBlPXRoaXMuZGF0YS5hcnJheVt0KnRoaXMuZGF0YS5zdHJpZGUrdGhpcy5vZmZzZXRdO3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihlPXplKGUsdGhpcy5hcnJheSkpLGV9Z2V0WSh0KXtsZXQgZT10aGlzLmRhdGEuYXJyYXlbdCp0aGlzLmRhdGEuc3RyaWRlK3RoaXMub2Zmc2V0KzFdO3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihlPXplKGUsdGhpcy5hcnJheSkpLGV9Z2V0Wih0KXtsZXQgZT10aGlzLmRhdGEuYXJyYXlbdCp0aGlzLmRhdGEuc3RyaWRlK3RoaXMub2Zmc2V0KzJdO3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihlPXplKGUsdGhpcy5hcnJheSkpLGV9Z2V0Vyh0KXtsZXQgZT10aGlzLmRhdGEuYXJyYXlbdCp0aGlzLmRhdGEuc3RyaWRlK3RoaXMub2Zmc2V0KzNdO3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihlPXplKGUsdGhpcy5hcnJheSkpLGV9c2V0WFkodCxlLG4pe3JldHVybiB0PXQqdGhpcy5kYXRhLnN0cmlkZSt0aGlzLm9mZnNldCx0aGlzLm5vcm1hbGl6ZWQmJihlPU50KGUsdGhpcy5hcnJheSksbj1OdChuLHRoaXMuYXJyYXkpKSx0aGlzLmRhdGEuYXJyYXlbdCswXT1lLHRoaXMuZGF0YS5hcnJheVt0KzFdPW4sdGhpc31zZXRYWVoodCxlLG4saSl7cmV0dXJuIHQ9dCp0aGlzLmRhdGEuc3RyaWRlK3RoaXMub2Zmc2V0LHRoaXMubm9ybWFsaXplZCYmKGU9TnQoZSx0aGlzLmFycmF5KSxuPU50KG4sdGhpcy5hcnJheSksaT1OdChpLHRoaXMuYXJyYXkpKSx0aGlzLmRhdGEuYXJyYXlbdCswXT1lLHRoaXMuZGF0YS5hcnJheVt0KzFdPW4sdGhpcy5kYXRhLmFycmF5W3QrMl09aSx0aGlzfXNldFhZWlcodCxlLG4saSxyKXtyZXR1cm4gdD10KnRoaXMuZGF0YS5zdHJpZGUrdGhpcy5vZmZzZXQsdGhpcy5ub3JtYWxpemVkJiYoZT1OdChlLHRoaXMuYXJyYXkpLG49TnQobix0aGlzLmFycmF5KSxpPU50KGksdGhpcy5hcnJheSkscj1OdChyLHRoaXMuYXJyYXkpKSx0aGlzLmRhdGEuYXJyYXlbdCswXT1lLHRoaXMuZGF0YS5hcnJheVt0KzFdPW4sdGhpcy5kYXRhLmFycmF5W3QrMl09aSx0aGlzLmRhdGEuYXJyYXlbdCszXT1yLHRoaXN9Y2xvbmUodCl7aWYodD09PXZvaWQgMCl7Y29uc29sZS5sb2coIlRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLmNsb25lKCk6IENsb25pbmcgYW4gaW50ZXJsZWF2ZWQgYnVmZmVyIGF0dHJpYnV0ZSB3aWxsIGRlLWludGVybGVhdmUgYnVmZmVyIGRhdGEuIik7bGV0IGU9W107Zm9yKGxldCBuPTA7bjx0aGlzLmNvdW50O24rKyl7bGV0IGk9bip0aGlzLmRhdGEuc3RyaWRlK3RoaXMub2Zmc2V0O2ZvcihsZXQgcj0wO3I8dGhpcy5pdGVtU2l6ZTtyKyspZS5wdXNoKHRoaXMuZGF0YS5hcnJheVtpK3JdKX1yZXR1cm4gbmV3IFp0KG5ldyB0aGlzLmFycmF5LmNvbnN0cnVjdG9yKGUpLHRoaXMuaXRlbVNpemUsdGhpcy5ub3JtYWxpemVkKX1lbHNlIHJldHVybiB0LmludGVybGVhdmVkQnVmZmVycz09PXZvaWQgMCYmKHQuaW50ZXJsZWF2ZWRCdWZmZXJzPXt9KSx0LmludGVybGVhdmVkQnVmZmVyc1t0aGlzLmRhdGEudXVpZF09PT12b2lkIDAmJih0LmludGVybGVhdmVkQnVmZmVyc1t0aGlzLmRhdGEudXVpZF09dGhpcy5kYXRhLmNsb25lKHQpKSxuZXcgcyh0LmludGVybGVhdmVkQnVmZmVyc1t0aGlzLmRhdGEudXVpZF0sdGhpcy5pdGVtU2l6ZSx0aGlzLm9mZnNldCx0aGlzLm5vcm1hbGl6ZWQpfXRvSlNPTih0KXtpZih0PT09dm9pZCAwKXtjb25zb2xlLmxvZygiVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUudG9KU09OKCk6IFNlcmlhbGl6aW5nIGFuIGludGVybGVhdmVkIGJ1ZmZlciBhdHRyaWJ1dGUgd2lsbCBkZS1pbnRlcmxlYXZlIGJ1ZmZlciBkYXRhLiIpO2xldCBlPVtdO2ZvcihsZXQgbj0wO248dGhpcy5jb3VudDtuKyspe2xldCBpPW4qdGhpcy5kYXRhLnN0cmlkZSt0aGlzLm9mZnNldDtmb3IobGV0IHI9MDtyPHRoaXMuaXRlbVNpemU7cisrKWUucHVzaCh0aGlzLmRhdGEuYXJyYXlbaStyXSl9cmV0dXJue2l0ZW1TaXplOnRoaXMuaXRlbVNpemUsdHlwZTp0aGlzLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsYXJyYXk6ZSxub3JtYWxpemVkOnRoaXMubm9ybWFsaXplZH19ZWxzZSByZXR1cm4gdC5pbnRlcmxlYXZlZEJ1ZmZlcnM9PT12b2lkIDAmJih0LmludGVybGVhdmVkQnVmZmVycz17fSksdC5pbnRlcmxlYXZlZEJ1ZmZlcnNbdGhpcy5kYXRhLnV1aWRdPT09dm9pZCAwJiYodC5pbnRlcmxlYXZlZEJ1ZmZlcnNbdGhpcy5kYXRhLnV1aWRdPXRoaXMuZGF0YS50b0pTT04odCkpLHtpc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlOiEwLGl0ZW1TaXplOnRoaXMuaXRlbVNpemUsZGF0YTp0aGlzLmRhdGEudXVpZCxvZmZzZXQ6dGhpcy5vZmZzZXQsbm9ybWFsaXplZDp0aGlzLm5vcm1hbGl6ZWR9fX0sbXI9Y2xhc3MgZXh0ZW5kcyBBZXtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuaXNTcHJpdGVNYXRlcmlhbD0hMCx0aGlzLnR5cGU9IlNwcml0ZU1hdGVyaWFsIix0aGlzLmNvbG9yPW5ldyB1dCgxNjc3NzIxNSksdGhpcy5tYXA9bnVsbCx0aGlzLmFscGhhTWFwPW51bGwsdGhpcy5yb3RhdGlvbj0wLHRoaXMuc2l6ZUF0dGVudWF0aW9uPSEwLHRoaXMudHJhbnNwYXJlbnQ9ITAsdGhpcy5mb2c9ITAsdGhpcy5zZXRWYWx1ZXModCl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLmNvbG9yLmNvcHkodC5jb2xvciksdGhpcy5tYXA9dC5tYXAsdGhpcy5hbHBoYU1hcD10LmFscGhhTWFwLHRoaXMucm90YXRpb249dC5yb3RhdGlvbix0aGlzLnNpemVBdHRlbnVhdGlvbj10LnNpemVBdHRlbnVhdGlvbix0aGlzLmZvZz10LmZvZyx0aGlzfX0sbnMsVXM9bmV3IFIsaXM9bmV3IFIsc3M9bmV3IFIscnM9bmV3IFosRHM9bmV3IFosYXA9bmV3IEx0LG9hPW5ldyBSLE5zPW5ldyBSLGxhPW5ldyBSLHRkPW5ldyBaLFVsPW5ldyBaLGVkPW5ldyBaLEthPWNsYXNzIGV4dGVuZHMgSnR7Y29uc3RydWN0b3IodD1uZXcgbXIpe2lmKHN1cGVyKCksdGhpcy5pc1Nwcml0ZT0hMCx0aGlzLnR5cGU9IlNwcml0ZSIsbnM9PT12b2lkIDApe25zPW5ldyBIdDtsZXQgZT1uZXcgRmxvYXQzMkFycmF5KFstLjUsLS41LDAsMCwwLC41LC0uNSwwLDEsMCwuNSwuNSwwLDEsMSwtLjUsLjUsMCwwLDFdKSxuPW5ldyBTcyhlLDUpO25zLnNldEluZGV4KFswLDEsMiwwLDIsM10pLG5zLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBVaShuLDMsMCwhMSkpLG5zLnNldEF0dHJpYnV0ZSgidXYiLG5ldyBVaShuLDIsMywhMSkpfXRoaXMuZ2VvbWV0cnk9bnMsdGhpcy5tYXRlcmlhbD10LHRoaXMuY2VudGVyPW5ldyBaKC41LC41KX1yYXljYXN0KHQsZSl7dC5jYW1lcmE9PT1udWxsJiZjb25zb2xlLmVycm9yKCdUSFJFRS5TcHJpdGU6ICJSYXljYXN0ZXIuY2FtZXJhIiBuZWVkcyB0byBiZSBzZXQgaW4gb3JkZXIgdG8gcmF5Y2FzdCBhZ2FpbnN0IHNwcml0ZXMuJyksaXMuc2V0RnJvbU1hdHJpeFNjYWxlKHRoaXMubWF0cml4V29ybGQpLGFwLmNvcHkodC5jYW1lcmEubWF0cml4V29ybGQpLHRoaXMubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXModC5jYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLHRoaXMubWF0cml4V29ybGQpLHNzLnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLm1vZGVsVmlld01hdHJpeCksdC5jYW1lcmEuaXNQZXJzcGVjdGl2ZUNhbWVyYSYmdGhpcy5tYXRlcmlhbC5zaXplQXR0ZW51YXRpb249PT0hMSYmaXMubXVsdGlwbHlTY2FsYXIoLXNzLnopO2xldCBuPXRoaXMubWF0ZXJpYWwucm90YXRpb24saSxyO24hPT0wJiYocj1NYXRoLmNvcyhuKSxpPU1hdGguc2luKG4pKTtsZXQgYT10aGlzLmNlbnRlcjtjYShvYS5zZXQoLS41LC0uNSwwKSxzcyxhLGlzLGksciksY2EoTnMuc2V0KC41LC0uNSwwKSxzcyxhLGlzLGksciksY2EobGEuc2V0KC41LC41LDApLHNzLGEsaXMsaSxyKSx0ZC5zZXQoMCwwKSxVbC5zZXQoMSwwKSxlZC5zZXQoMSwxKTtsZXQgbz10LnJheS5pbnRlcnNlY3RUcmlhbmdsZShvYSxOcyxsYSwhMSxVcyk7aWYobz09PW51bGwmJihjYShOcy5zZXQoLS41LC41LDApLHNzLGEsaXMsaSxyKSxVbC5zZXQoMCwxKSxvPXQucmF5LmludGVyc2VjdFRyaWFuZ2xlKG9hLGxhLE5zLCExLFVzKSxvPT09bnVsbCkpcmV0dXJuO2xldCBsPXQucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKFVzKTtsPHQubmVhcnx8bD50LmZhcnx8ZS5wdXNoKHtkaXN0YW5jZTpsLHBvaW50OlVzLmNsb25lKCksdXY6TG4uZ2V0SW50ZXJwb2xhdGlvbihVcyxvYSxOcyxsYSx0ZCxVbCxlZCxuZXcgWiksZmFjZTpudWxsLG9iamVjdDp0aGlzfSl9Y29weSh0LGUpe3JldHVybiBzdXBlci5jb3B5KHQsZSksdC5jZW50ZXIhPT12b2lkIDAmJnRoaXMuY2VudGVyLmNvcHkodC5jZW50ZXIpLHRoaXMubWF0ZXJpYWw9dC5tYXRlcmlhbCx0aGlzfX07ZnVuY3Rpb24gY2Eocyx0LGUsbixpLHIpe3JzLnN1YlZlY3RvcnMocyxlKS5hZGRTY2FsYXIoLjUpLm11bHRpcGx5KG4pLGkhPT12b2lkIDA/KERzLng9cipycy54LWkqcnMueSxEcy55PWkqcnMueCtyKnJzLnkpOkRzLmNvcHkocnMpLHMuY29weSh0KSxzLngrPURzLngscy55Kz1Ecy55LHMuYXBwbHlNYXRyaXg0KGFwKX12YXIgaGE9bmV3IFIsbmQ9bmV3IFIsUWE9Y2xhc3MgZXh0ZW5kcyBKdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5fY3VycmVudExldmVsPTAsdGhpcy50eXBlPSJMT0QiLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMse2xldmVsczp7ZW51bWVyYWJsZTohMCx2YWx1ZTpbXX0saXNMT0Q6e3ZhbHVlOiEwfX0pLHRoaXMuYXV0b1VwZGF0ZT0hMH1jb3B5KHQpe3N1cGVyLmNvcHkodCwhMSk7bGV0IGU9dC5sZXZlbHM7Zm9yKGxldCBuPTAsaT1lLmxlbmd0aDtuPGk7bisrKXtsZXQgcj1lW25dO3RoaXMuYWRkTGV2ZWwoci5vYmplY3QuY2xvbmUoKSxyLmRpc3RhbmNlLHIuaHlzdGVyZXNpcyl9cmV0dXJuIHRoaXMuYXV0b1VwZGF0ZT10LmF1dG9VcGRhdGUsdGhpc31hZGRMZXZlbCh0LGU9MCxuPTApe2U9TWF0aC5hYnMoZSk7bGV0IGk9dGhpcy5sZXZlbHMscjtmb3Iocj0wO3I8aS5sZW5ndGgmJiEoZTxpW3JdLmRpc3RhbmNlKTtyKyspO3JldHVybiBpLnNwbGljZShyLDAse2Rpc3RhbmNlOmUsaHlzdGVyZXNpczpuLG9iamVjdDp0fSksdGhpcy5hZGQodCksdGhpc31nZXRDdXJyZW50TGV2ZWwoKXtyZXR1cm4gdGhpcy5fY3VycmVudExldmVsfWdldE9iamVjdEZvckRpc3RhbmNlKHQpe2xldCBlPXRoaXMubGV2ZWxzO2lmKGUubGVuZ3RoPjApe2xldCBuLGk7Zm9yKG49MSxpPWUubGVuZ3RoO248aTtuKyspe2xldCByPWVbbl0uZGlzdGFuY2U7aWYoZVtuXS5vYmplY3QudmlzaWJsZSYmKHItPXIqZVtuXS5oeXN0ZXJlc2lzKSx0PHIpYnJlYWt9cmV0dXJuIGVbbi0xXS5vYmplY3R9cmV0dXJuIG51bGx9cmF5Y2FzdCh0LGUpe2lmKHRoaXMubGV2ZWxzLmxlbmd0aD4wKXtoYS5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5tYXRyaXhXb3JsZCk7bGV0IGk9dC5yYXkub3JpZ2luLmRpc3RhbmNlVG8oaGEpO3RoaXMuZ2V0T2JqZWN0Rm9yRGlzdGFuY2UoaSkucmF5Y2FzdCh0LGUpfX11cGRhdGUodCl7bGV0IGU9dGhpcy5sZXZlbHM7aWYoZS5sZW5ndGg+MSl7aGEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHQubWF0cml4V29ybGQpLG5kLnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLm1hdHJpeFdvcmxkKTtsZXQgbj1oYS5kaXN0YW5jZVRvKG5kKS90Lnpvb207ZVswXS5vYmplY3QudmlzaWJsZT0hMDtsZXQgaSxyO2ZvcihpPTEscj1lLmxlbmd0aDtpPHI7aSsrKXtsZXQgYT1lW2ldLmRpc3RhbmNlO2lmKGVbaV0ub2JqZWN0LnZpc2libGUmJihhLT1hKmVbaV0uaHlzdGVyZXNpcyksbj49YSllW2ktMV0ub2JqZWN0LnZpc2libGU9ITEsZVtpXS5vYmplY3QudmlzaWJsZT0hMDtlbHNlIGJyZWFrfWZvcih0aGlzLl9jdXJyZW50TGV2ZWw9aS0xO2k8cjtpKyspZVtpXS5vYmplY3QudmlzaWJsZT0hMX19dG9KU09OKHQpe2xldCBlPXN1cGVyLnRvSlNPTih0KTt0aGlzLmF1dG9VcGRhdGU9PT0hMSYmKGUub2JqZWN0LmF1dG9VcGRhdGU9ITEpLGUub2JqZWN0LmxldmVscz1bXTtsZXQgbj10aGlzLmxldmVscztmb3IobGV0IGk9MCxyPW4ubGVuZ3RoO2k8cjtpKyspe2xldCBhPW5baV07ZS5vYmplY3QubGV2ZWxzLnB1c2goe29iamVjdDphLm9iamVjdC51dWlkLGRpc3RhbmNlOmEuZGlzdGFuY2UsaHlzdGVyZXNpczphLmh5c3RlcmVzaXN9KX1yZXR1cm4gZX19LGlkPW5ldyBSLHNkPW5ldyB0ZSxyZD1uZXcgdGUscHY9bmV3IFIsYWQ9bmV3IEx0LHVhPW5ldyBSLERsPW5ldyBFZSxvZD1uZXcgTHQsTmw9bmV3IG5pLGphPWNsYXNzIGV4dGVuZHMgZGV7Y29uc3RydWN0b3IodCxlKXtzdXBlcih0LGUpLHRoaXMuaXNTa2lubmVkTWVzaD0hMCx0aGlzLnR5cGU9IlNraW5uZWRNZXNoIix0aGlzLmJpbmRNb2RlPWpsLHRoaXMuYmluZE1hdHJpeD1uZXcgTHQsdGhpcy5iaW5kTWF0cml4SW52ZXJzZT1uZXcgTHQsdGhpcy5ib3VuZGluZ0JveD1udWxsLHRoaXMuYm91bmRpbmdTcGhlcmU9bnVsbH1jb21wdXRlQm91bmRpbmdCb3goKXtsZXQgdD10aGlzLmdlb21ldHJ5O3RoaXMuYm91bmRpbmdCb3g9PT1udWxsJiYodGhpcy5ib3VuZGluZ0JveD1uZXcgd2UpLHRoaXMuYm91bmRpbmdCb3gubWFrZUVtcHR5KCk7bGV0IGU9dC5nZXRBdHRyaWJ1dGUoInBvc2l0aW9uIik7Zm9yKGxldCBuPTA7bjxlLmNvdW50O24rKyl0aGlzLmdldFZlcnRleFBvc2l0aW9uKG4sdWEpLHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludCh1YSl9Y29tcHV0ZUJvdW5kaW5nU3BoZXJlKCl7bGV0IHQ9dGhpcy5nZW9tZXRyeTt0aGlzLmJvdW5kaW5nU3BoZXJlPT09bnVsbCYmKHRoaXMuYm91bmRpbmdTcGhlcmU9bmV3IEVlKSx0aGlzLmJvdW5kaW5nU3BoZXJlLm1ha2VFbXB0eSgpO2xldCBlPXQuZ2V0QXR0cmlidXRlKCJwb3NpdGlvbiIpO2ZvcihsZXQgbj0wO248ZS5jb3VudDtuKyspdGhpcy5nZXRWZXJ0ZXhQb3NpdGlvbihuLHVhKSx0aGlzLmJvdW5kaW5nU3BoZXJlLmV4cGFuZEJ5UG9pbnQodWEpfWNvcHkodCxlKXtyZXR1cm4gc3VwZXIuY29weSh0LGUpLHRoaXMuYmluZE1vZGU9dC5iaW5kTW9kZSx0aGlzLmJpbmRNYXRyaXguY29weSh0LmJpbmRNYXRyaXgpLHRoaXMuYmluZE1hdHJpeEludmVyc2UuY29weSh0LmJpbmRNYXRyaXhJbnZlcnNlKSx0aGlzLnNrZWxldG9uPXQuc2tlbGV0b24sdC5ib3VuZGluZ0JveCE9PW51bGwmJih0aGlzLmJvdW5kaW5nQm94PXQuYm91bmRpbmdCb3guY2xvbmUoKSksdC5ib3VuZGluZ1NwaGVyZSE9PW51bGwmJih0aGlzLmJvdW5kaW5nU3BoZXJlPXQuYm91bmRpbmdTcGhlcmUuY2xvbmUoKSksdGhpc31yYXljYXN0KHQsZSl7bGV0IG49dGhpcy5tYXRlcmlhbCxpPXRoaXMubWF0cml4V29ybGQ7biE9PXZvaWQgMCYmKHRoaXMuYm91bmRpbmdTcGhlcmU9PT1udWxsJiZ0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpLERsLmNvcHkodGhpcy5ib3VuZGluZ1NwaGVyZSksRGwuYXBwbHlNYXRyaXg0KGkpLHQucmF5LmludGVyc2VjdHNTcGhlcmUoRGwpIT09ITEmJihvZC5jb3B5KGkpLmludmVydCgpLE5sLmNvcHkodC5yYXkpLmFwcGx5TWF0cml4NChvZCksISh0aGlzLmJvdW5kaW5nQm94IT09bnVsbCYmTmwuaW50ZXJzZWN0c0JveCh0aGlzLmJvdW5kaW5nQm94KT09PSExKSYmdGhpcy5fY29tcHV0ZUludGVyc2VjdGlvbnModCxlLE5sKSkpfWdldFZlcnRleFBvc2l0aW9uKHQsZSl7cmV0dXJuIHN1cGVyLmdldFZlcnRleFBvc2l0aW9uKHQsZSksdGhpcy5hcHBseUJvbmVUcmFuc2Zvcm0odCxlKSxlfWJpbmQodCxlKXt0aGlzLnNrZWxldG9uPXQsZT09PXZvaWQgMCYmKHRoaXMudXBkYXRlTWF0cml4V29ybGQoITApLHRoaXMuc2tlbGV0b24uY2FsY3VsYXRlSW52ZXJzZXMoKSxlPXRoaXMubWF0cml4V29ybGQpLHRoaXMuYmluZE1hdHJpeC5jb3B5KGUpLHRoaXMuYmluZE1hdHJpeEludmVyc2UuY29weShlKS5pbnZlcnQoKX1wb3NlKCl7dGhpcy5za2VsZXRvbi5wb3NlKCl9bm9ybWFsaXplU2tpbldlaWdodHMoKXtsZXQgdD1uZXcgdGUsZT10aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMuc2tpbldlaWdodDtmb3IobGV0IG49MCxpPWUuY291bnQ7bjxpO24rKyl7dC5mcm9tQnVmZmVyQXR0cmlidXRlKGUsbik7bGV0IHI9MS90Lm1hbmhhdHRhbkxlbmd0aCgpO3IhPT0xLzA/dC5tdWx0aXBseVNjYWxhcihyKTp0LnNldCgxLDAsMCwwKSxlLnNldFhZWlcobix0LngsdC55LHQueix0LncpfX11cGRhdGVNYXRyaXhXb3JsZCh0KXtzdXBlci51cGRhdGVNYXRyaXhXb3JsZCh0KSx0aGlzLmJpbmRNb2RlPT09amw/dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5jb3B5KHRoaXMubWF0cml4V29ybGQpLmludmVydCgpOnRoaXMuYmluZE1vZGU9PT1UZj90aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmNvcHkodGhpcy5iaW5kTWF0cml4KS5pbnZlcnQoKTpjb25zb2xlLndhcm4oIlRIUkVFLlNraW5uZWRNZXNoOiBVbnJlY29nbml6ZWQgYmluZE1vZGU6ICIrdGhpcy5iaW5kTW9kZSl9YXBwbHlCb25lVHJhbnNmb3JtKHQsZSl7bGV0IG49dGhpcy5za2VsZXRvbixpPXRoaXMuZ2VvbWV0cnk7c2QuZnJvbUJ1ZmZlckF0dHJpYnV0ZShpLmF0dHJpYnV0ZXMuc2tpbkluZGV4LHQpLHJkLmZyb21CdWZmZXJBdHRyaWJ1dGUoaS5hdHRyaWJ1dGVzLnNraW5XZWlnaHQsdCksaWQuY29weShlKS5hcHBseU1hdHJpeDQodGhpcy5iaW5kTWF0cml4KSxlLnNldCgwLDAsMCk7Zm9yKGxldCByPTA7cjw0O3IrKyl7bGV0IGE9cmQuZ2V0Q29tcG9uZW50KHIpO2lmKGEhPT0wKXtsZXQgbz1zZC5nZXRDb21wb25lbnQocik7YWQubXVsdGlwbHlNYXRyaWNlcyhuLmJvbmVzW29dLm1hdHJpeFdvcmxkLG4uYm9uZUludmVyc2VzW29dKSxlLmFkZFNjYWxlZFZlY3Rvcihwdi5jb3B5KGlkKS5hcHBseU1hdHJpeDQoYWQpLGEpfX1yZXR1cm4gZS5hcHBseU1hdHJpeDQodGhpcy5iaW5kTWF0cml4SW52ZXJzZSl9fSxncj1jbGFzcyBleHRlbmRzIEp0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLmlzQm9uZT0hMCx0aGlzLnR5cGU9IkJvbmUifX0sT249Y2xhc3MgZXh0ZW5kcyBfZXtjb25zdHJ1Y3Rvcih0PW51bGwsZT0xLG49MSxpLHIsYSxvLGwsYz1tZSxoPW1lLHUsZCl7c3VwZXIobnVsbCxhLG8sbCxjLGgsaSxyLHUsZCksdGhpcy5pc0RhdGFUZXh0dXJlPSEwLHRoaXMuaW1hZ2U9e2RhdGE6dCx3aWR0aDplLGhlaWdodDpufSx0aGlzLmdlbmVyYXRlTWlwbWFwcz0hMSx0aGlzLmZsaXBZPSExLHRoaXMudW5wYWNrQWxpZ25tZW50PTF9fSxsZD1uZXcgTHQsbXY9bmV3IEx0LHRvPWNsYXNzIHN7Y29uc3RydWN0b3IodD1bXSxlPVtdKXt0aGlzLnV1aWQ9WWUoKSx0aGlzLmJvbmVzPXQuc2xpY2UoMCksdGhpcy5ib25lSW52ZXJzZXM9ZSx0aGlzLmJvbmVNYXRyaWNlcz1udWxsLHRoaXMuYm9uZVRleHR1cmU9bnVsbCx0aGlzLmluaXQoKX1pbml0KCl7bGV0IHQ9dGhpcy5ib25lcyxlPXRoaXMuYm9uZUludmVyc2VzO2lmKHRoaXMuYm9uZU1hdHJpY2VzPW5ldyBGbG9hdDMyQXJyYXkodC5sZW5ndGgqMTYpLGUubGVuZ3RoPT09MCl0aGlzLmNhbGN1bGF0ZUludmVyc2VzKCk7ZWxzZSBpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXtjb25zb2xlLndhcm4oIlRIUkVFLlNrZWxldG9uOiBOdW1iZXIgb2YgaW52ZXJzZSBib25lIG1hdHJpY2VzIGRvZXMgbm90IG1hdGNoIGFtb3VudCBvZiBib25lcy4iKSx0aGlzLmJvbmVJbnZlcnNlcz1bXTtmb3IobGV0IG49MCxpPXRoaXMuYm9uZXMubGVuZ3RoO248aTtuKyspdGhpcy5ib25lSW52ZXJzZXMucHVzaChuZXcgTHQpfX1jYWxjdWxhdGVJbnZlcnNlcygpe3RoaXMuYm9uZUludmVyc2VzLmxlbmd0aD0wO2ZvcihsZXQgdD0wLGU9dGhpcy5ib25lcy5sZW5ndGg7dDxlO3QrKyl7bGV0IG49bmV3IEx0O3RoaXMuYm9uZXNbdF0mJm4uY29weSh0aGlzLmJvbmVzW3RdLm1hdHJpeFdvcmxkKS5pbnZlcnQoKSx0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKG4pfX1wb3NlKCl7Zm9yKGxldCB0PTAsZT10aGlzLmJvbmVzLmxlbmd0aDt0PGU7dCsrKXtsZXQgbj10aGlzLmJvbmVzW3RdO24mJm4ubWF0cml4V29ybGQuY29weSh0aGlzLmJvbmVJbnZlcnNlc1t0XSkuaW52ZXJ0KCl9Zm9yKGxldCB0PTAsZT10aGlzLmJvbmVzLmxlbmd0aDt0PGU7dCsrKXtsZXQgbj10aGlzLmJvbmVzW3RdO24mJihuLnBhcmVudCYmbi5wYXJlbnQuaXNCb25lPyhuLm1hdHJpeC5jb3B5KG4ucGFyZW50Lm1hdHJpeFdvcmxkKS5pbnZlcnQoKSxuLm1hdHJpeC5tdWx0aXBseShuLm1hdHJpeFdvcmxkKSk6bi5tYXRyaXguY29weShuLm1hdHJpeFdvcmxkKSxuLm1hdHJpeC5kZWNvbXBvc2Uobi5wb3NpdGlvbixuLnF1YXRlcm5pb24sbi5zY2FsZSkpfX11cGRhdGUoKXtsZXQgdD10aGlzLmJvbmVzLGU9dGhpcy5ib25lSW52ZXJzZXMsbj10aGlzLmJvbmVNYXRyaWNlcyxpPXRoaXMuYm9uZVRleHR1cmU7Zm9yKGxldCByPTAsYT10Lmxlbmd0aDtyPGE7cisrKXtsZXQgbz10W3JdP3Rbcl0ubWF0cml4V29ybGQ6bXY7bGQubXVsdGlwbHlNYXRyaWNlcyhvLGVbcl0pLGxkLnRvQXJyYXkobixyKjE2KX1pIT09bnVsbCYmKGkubmVlZHNVcGRhdGU9ITApfWNsb25lKCl7cmV0dXJuIG5ldyBzKHRoaXMuYm9uZXMsdGhpcy5ib25lSW52ZXJzZXMpfWNvbXB1dGVCb25lVGV4dHVyZSgpe2xldCB0PU1hdGguc3FydCh0aGlzLmJvbmVzLmxlbmd0aCo0KTt0PU1hdGguY2VpbCh0LzQpKjQsdD1NYXRoLm1heCh0LDQpO2xldCBlPW5ldyBGbG9hdDMyQXJyYXkodCp0KjQpO2Uuc2V0KHRoaXMuYm9uZU1hdHJpY2VzKTtsZXQgbj1uZXcgT24oZSx0LHQsSGUsZW4pO3JldHVybiBuLm5lZWRzVXBkYXRlPSEwLHRoaXMuYm9uZU1hdHJpY2VzPWUsdGhpcy5ib25lVGV4dHVyZT1uLHRoaXN9Z2V0Qm9uZUJ5TmFtZSh0KXtmb3IobGV0IGU9MCxuPXRoaXMuYm9uZXMubGVuZ3RoO2U8bjtlKyspe2xldCBpPXRoaXMuYm9uZXNbZV07aWYoaS5uYW1lPT09dClyZXR1cm4gaX19ZGlzcG9zZSgpe3RoaXMuYm9uZVRleHR1cmUhPT1udWxsJiYodGhpcy5ib25lVGV4dHVyZS5kaXNwb3NlKCksdGhpcy5ib25lVGV4dHVyZT1udWxsKX1mcm9tSlNPTih0LGUpe3RoaXMudXVpZD10LnV1aWQ7Zm9yKGxldCBuPTAsaT10LmJvbmVzLmxlbmd0aDtuPGk7bisrKXtsZXQgcj10LmJvbmVzW25dLGE9ZVtyXTthPT09dm9pZCAwJiYoY29uc29sZS53YXJuKCJUSFJFRS5Ta2VsZXRvbjogTm8gYm9uZSBmb3VuZCB3aXRoIFVVSUQ6IixyKSxhPW5ldyBnciksdGhpcy5ib25lcy5wdXNoKGEpLHRoaXMuYm9uZUludmVyc2VzLnB1c2gobmV3IEx0KCkuZnJvbUFycmF5KHQuYm9uZUludmVyc2VzW25dKSl9cmV0dXJuIHRoaXMuaW5pdCgpLHRoaXN9dG9KU09OKCl7bGV0IHQ9e21ldGFkYXRhOnt2ZXJzaW9uOjQuNix0eXBlOiJTa2VsZXRvbiIsZ2VuZXJhdG9yOiJTa2VsZXRvbi50b0pTT04ifSxib25lczpbXSxib25lSW52ZXJzZXM6W119O3QudXVpZD10aGlzLnV1aWQ7bGV0IGU9dGhpcy5ib25lcyxuPXRoaXMuYm9uZUludmVyc2VzO2ZvcihsZXQgaT0wLHI9ZS5sZW5ndGg7aTxyO2krKyl7bGV0IGE9ZVtpXTt0LmJvbmVzLnB1c2goYS51dWlkKTtsZXQgbz1uW2ldO3QuYm9uZUludmVyc2VzLnB1c2goby50b0FycmF5KCkpfXJldHVybiB0fX0saWk9Y2xhc3MgZXh0ZW5kcyBadHtjb25zdHJ1Y3Rvcih0LGUsbixpPTEpe3N1cGVyKHQsZSxuKSx0aGlzLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlPSEwLHRoaXMubWVzaFBlckF0dHJpYnV0ZT1pfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5tZXNoUGVyQXR0cmlidXRlPXQubWVzaFBlckF0dHJpYnV0ZSx0aGlzfXRvSlNPTigpe2xldCB0PXN1cGVyLnRvSlNPTigpO3JldHVybiB0Lm1lc2hQZXJBdHRyaWJ1dGU9dGhpcy5tZXNoUGVyQXR0cmlidXRlLHQuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU9ITAsdH19LGFzPW5ldyBMdCxjZD1uZXcgTHQsZGE9W10saGQ9bmV3IHdlLGd2PW5ldyBMdCxPcz1uZXcgZGUsRnM9bmV3IEVlLGVvPWNsYXNzIGV4dGVuZHMgZGV7Y29uc3RydWN0b3IodCxlLG4pe3N1cGVyKHQsZSksdGhpcy5pc0luc3RhbmNlZE1lc2g9ITAsdGhpcy5pbnN0YW5jZU1hdHJpeD1uZXcgaWkobmV3IEZsb2F0MzJBcnJheShuKjE2KSwxNiksdGhpcy5pbnN0YW5jZUNvbG9yPW51bGwsdGhpcy5jb3VudD1uLHRoaXMuYm91bmRpbmdCb3g9bnVsbCx0aGlzLmJvdW5kaW5nU3BoZXJlPW51bGw7Zm9yKGxldCBpPTA7aTxuO2krKyl0aGlzLnNldE1hdHJpeEF0KGksZ3YpfWNvbXB1dGVCb3VuZGluZ0JveCgpe2xldCB0PXRoaXMuZ2VvbWV0cnksZT10aGlzLmNvdW50O3RoaXMuYm91bmRpbmdCb3g9PT1udWxsJiYodGhpcy5ib3VuZGluZ0JveD1uZXcgd2UpLHQuYm91bmRpbmdCb3g9PT1udWxsJiZ0LmNvbXB1dGVCb3VuZGluZ0JveCgpLHRoaXMuYm91bmRpbmdCb3gubWFrZUVtcHR5KCk7Zm9yKGxldCBuPTA7bjxlO24rKyl0aGlzLmdldE1hdHJpeEF0KG4sYXMpLGhkLmNvcHkodC5ib3VuZGluZ0JveCkuYXBwbHlNYXRyaXg0KGFzKSx0aGlzLmJvdW5kaW5nQm94LnVuaW9uKGhkKX1jb21wdXRlQm91bmRpbmdTcGhlcmUoKXtsZXQgdD10aGlzLmdlb21ldHJ5LGU9dGhpcy5jb3VudDt0aGlzLmJvdW5kaW5nU3BoZXJlPT09bnVsbCYmKHRoaXMuYm91bmRpbmdTcGhlcmU9bmV3IEVlKSx0LmJvdW5kaW5nU3BoZXJlPT09bnVsbCYmdC5jb21wdXRlQm91bmRpbmdTcGhlcmUoKSx0aGlzLmJvdW5kaW5nU3BoZXJlLm1ha2VFbXB0eSgpO2ZvcihsZXQgbj0wO248ZTtuKyspdGhpcy5nZXRNYXRyaXhBdChuLGFzKSxGcy5jb3B5KHQuYm91bmRpbmdTcGhlcmUpLmFwcGx5TWF0cml4NChhcyksdGhpcy5ib3VuZGluZ1NwaGVyZS51bmlvbihGcyl9Y29weSh0LGUpe3JldHVybiBzdXBlci5jb3B5KHQsZSksdGhpcy5pbnN0YW5jZU1hdHJpeC5jb3B5KHQuaW5zdGFuY2VNYXRyaXgpLHQuaW5zdGFuY2VDb2xvciE9PW51bGwmJih0aGlzLmluc3RhbmNlQ29sb3I9dC5pbnN0YW5jZUNvbG9yLmNsb25lKCkpLHRoaXMuY291bnQ9dC5jb3VudCx0LmJvdW5kaW5nQm94IT09bnVsbCYmKHRoaXMuYm91bmRpbmdCb3g9dC5ib3VuZGluZ0JveC5jbG9uZSgpKSx0LmJvdW5kaW5nU3BoZXJlIT09bnVsbCYmKHRoaXMuYm91bmRpbmdTcGhlcmU9dC5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpKSx0aGlzfWdldENvbG9yQXQodCxlKXtlLmZyb21BcnJheSh0aGlzLmluc3RhbmNlQ29sb3IuYXJyYXksdCozKX1nZXRNYXRyaXhBdCh0LGUpe2UuZnJvbUFycmF5KHRoaXMuaW5zdGFuY2VNYXRyaXguYXJyYXksdCoxNil9cmF5Y2FzdCh0LGUpe2xldCBuPXRoaXMubWF0cml4V29ybGQsaT10aGlzLmNvdW50O2lmKE9zLmdlb21ldHJ5PXRoaXMuZ2VvbWV0cnksT3MubWF0ZXJpYWw9dGhpcy5tYXRlcmlhbCxPcy5tYXRlcmlhbCE9PXZvaWQgMCYmKHRoaXMuYm91bmRpbmdTcGhlcmU9PT1udWxsJiZ0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpLEZzLmNvcHkodGhpcy5ib3VuZGluZ1NwaGVyZSksRnMuYXBwbHlNYXRyaXg0KG4pLHQucmF5LmludGVyc2VjdHNTcGhlcmUoRnMpIT09ITEpKWZvcihsZXQgcj0wO3I8aTtyKyspe3RoaXMuZ2V0TWF0cml4QXQocixhcyksY2QubXVsdGlwbHlNYXRyaWNlcyhuLGFzKSxPcy5tYXRyaXhXb3JsZD1jZCxPcy5yYXljYXN0KHQsZGEpO2ZvcihsZXQgYT0wLG89ZGEubGVuZ3RoO2E8bzthKyspe2xldCBsPWRhW2FdO2wuaW5zdGFuY2VJZD1yLGwub2JqZWN0PXRoaXMsZS5wdXNoKGwpfWRhLmxlbmd0aD0wfX1zZXRDb2xvckF0KHQsZSl7dGhpcy5pbnN0YW5jZUNvbG9yPT09bnVsbCYmKHRoaXMuaW5zdGFuY2VDb2xvcj1uZXcgaWkobmV3IEZsb2F0MzJBcnJheSh0aGlzLmluc3RhbmNlTWF0cml4LmNvdW50KjMpLDMpKSxlLnRvQXJyYXkodGhpcy5pbnN0YW5jZUNvbG9yLmFycmF5LHQqMyl9c2V0TWF0cml4QXQodCxlKXtlLnRvQXJyYXkodGhpcy5pbnN0YW5jZU1hdHJpeC5hcnJheSx0KjE2KX11cGRhdGVNb3JwaFRhcmdldHMoKXt9ZGlzcG9zZSgpe3RoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToiZGlzcG9zZSJ9KX19O2Z1bmN0aW9uIF92KHMsdCl7cmV0dXJuIHMuei10Lnp9ZnVuY3Rpb24geHYocyx0KXtyZXR1cm4gdC56LXMuen12YXIgcWM9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmluZGV4PTAsdGhpcy5wb29sPVtdLHRoaXMubGlzdD1bXX1wdXNoKHQsZSl7bGV0IG49dGhpcy5wb29sLGk9dGhpcy5saXN0O3RoaXMuaW5kZXg+PW4ubGVuZ3RoJiZuLnB1c2goe3N0YXJ0Oi0xLGNvdW50Oi0xLHo6LTF9KTtsZXQgcj1uW3RoaXMuaW5kZXhdO2kucHVzaChyKSx0aGlzLmluZGV4Kyssci5zdGFydD10LnN0YXJ0LHIuY291bnQ9dC5jb3VudCxyLno9ZX1yZXNldCgpe3RoaXMubGlzdC5sZW5ndGg9MCx0aGlzLmluZGV4PTB9fSxvcz0iYmF0Y2hJZCIsWm49bmV3IEx0LHVkPW5ldyBMdCx2dj1uZXcgTHQsZGQ9bmV3IEx0LE9sPW5ldyBJaSxmYT1uZXcgd2UsZmk9bmV3IEVlLEJzPW5ldyBSLEZsPW5ldyBxYyxJZT1uZXcgZGUscGE9W107ZnVuY3Rpb24geXYocyx0LGU9MCl7bGV0IG49dC5pdGVtU2l6ZTtpZihzLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGV8fHMuYXJyYXkuY29uc3RydWN0b3IhPT10LmFycmF5LmNvbnN0cnVjdG9yKXtsZXQgaT1zLmNvdW50O2ZvcihsZXQgcj0wO3I8aTtyKyspZm9yKGxldCBhPTA7YTxuO2ErKyl0LnNldENvbXBvbmVudChyK2UsYSxzLmdldENvbXBvbmVudChyLGEpKX1lbHNlIHQuYXJyYXkuc2V0KHMuYXJyYXksZSpuKTt0Lm5lZWRzVXBkYXRlPSEwfXZhciBubz1jbGFzcyBleHRlbmRzIGRle2dldCBtYXhHZW9tZXRyeUNvdW50KCl7cmV0dXJuIHRoaXMuX21heEdlb21ldHJ5Q291bnR9Y29uc3RydWN0b3IodCxlLG49ZSoyLGkpe3N1cGVyKG5ldyBIdCxpKSx0aGlzLmlzQmF0Y2hlZE1lc2g9ITAsdGhpcy5wZXJPYmplY3RGcnVzdHVtQ3VsbGVkPSEwLHRoaXMuc29ydE9iamVjdHM9ITAsdGhpcy5ib3VuZGluZ0JveD1udWxsLHRoaXMuYm91bmRpbmdTcGhlcmU9bnVsbCx0aGlzLmN1c3RvbVNvcnQ9bnVsbCx0aGlzLl9kcmF3UmFuZ2VzPVtdLHRoaXMuX3Jlc2VydmVkUmFuZ2VzPVtdLHRoaXMuX3Zpc2liaWxpdHk9W10sdGhpcy5fYWN0aXZlPVtdLHRoaXMuX2JvdW5kcz1bXSx0aGlzLl9tYXhHZW9tZXRyeUNvdW50PXQsdGhpcy5fbWF4VmVydGV4Q291bnQ9ZSx0aGlzLl9tYXhJbmRleENvdW50PW4sdGhpcy5fZ2VvbWV0cnlJbml0aWFsaXplZD0hMSx0aGlzLl9nZW9tZXRyeUNvdW50PTAsdGhpcy5fbXVsdGlEcmF3Q291bnRzPW5ldyBJbnQzMkFycmF5KHQpLHRoaXMuX211bHRpRHJhd1N0YXJ0cz1uZXcgSW50MzJBcnJheSh0KSx0aGlzLl9tdWx0aURyYXdDb3VudD0wLHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2VkPSEwLHRoaXMuX21hdHJpY2VzVGV4dHVyZT1udWxsLHRoaXMuX2luaXRNYXRyaWNlc1RleHR1cmUoKX1faW5pdE1hdHJpY2VzVGV4dHVyZSgpe2xldCB0PU1hdGguc3FydCh0aGlzLl9tYXhHZW9tZXRyeUNvdW50KjQpO3Q9TWF0aC5jZWlsKHQvNCkqNCx0PU1hdGgubWF4KHQsNCk7bGV0IGU9bmV3IEZsb2F0MzJBcnJheSh0KnQqNCksbj1uZXcgT24oZSx0LHQsSGUsZW4pO3RoaXMuX21hdHJpY2VzVGV4dHVyZT1ufV9pbml0aWFsaXplR2VvbWV0cnkodCl7bGV0IGU9dGhpcy5nZW9tZXRyeSxuPXRoaXMuX21heFZlcnRleENvdW50LGk9dGhpcy5fbWF4R2VvbWV0cnlDb3VudCxyPXRoaXMuX21heEluZGV4Q291bnQ7aWYodGhpcy5fZ2VvbWV0cnlJbml0aWFsaXplZD09PSExKXtmb3IobGV0IG8gaW4gdC5hdHRyaWJ1dGVzKXtsZXQgbD10LmdldEF0dHJpYnV0ZShvKSx7YXJyYXk6YyxpdGVtU2l6ZTpoLG5vcm1hbGl6ZWQ6dX09bCxkPW5ldyBjLmNvbnN0cnVjdG9yKG4qaCksZj1uZXcgbC5jb25zdHJ1Y3RvcihkLGgsdSk7Zi5zZXRVc2FnZShsLnVzYWdlKSxlLnNldEF0dHJpYnV0ZShvLGYpfWlmKHQuZ2V0SW5kZXgoKSE9PW51bGwpe2xldCBvPW4+NjU1MzY/bmV3IFVpbnQzMkFycmF5KHIpOm5ldyBVaW50MTZBcnJheShyKTtlLnNldEluZGV4KG5ldyBadChvLDEpKX1sZXQgYT1pPjY1NTM2P25ldyBVaW50MzJBcnJheShuKTpuZXcgVWludDE2QXJyYXkobik7ZS5zZXRBdHRyaWJ1dGUob3MsbmV3IFp0KGEsMSkpLHRoaXMuX2dlb21ldHJ5SW5pdGlhbGl6ZWQ9ITB9fV92YWxpZGF0ZUdlb21ldHJ5KHQpe2lmKHQuZ2V0QXR0cmlidXRlKG9zKSl0aHJvdyBuZXcgRXJyb3IoYEJhdGNoZWRNZXNoOiBHZW9tZXRyeSBjYW5ub3QgdXNlIGF0dHJpYnV0ZSAiJHtvc30iYCk7bGV0IGU9dGhpcy5nZW9tZXRyeTtpZighIXQuZ2V0SW5kZXgoKSE9ISFlLmdldEluZGV4KCkpdGhyb3cgbmV3IEVycm9yKCdCYXRjaGVkTWVzaDogQWxsIGdlb21ldHJpZXMgbXVzdCBjb25zaXN0ZW50bHkgaGF2ZSAiaW5kZXgiLicpO2ZvcihsZXQgbiBpbiBlLmF0dHJpYnV0ZXMpe2lmKG49PT1vcyljb250aW51ZTtpZighdC5oYXNBdHRyaWJ1dGUobikpdGhyb3cgbmV3IEVycm9yKGBCYXRjaGVkTWVzaDogQWRkZWQgZ2VvbWV0cnkgbWlzc2luZyAiJHtufSIuIEFsbCBnZW9tZXRyaWVzIG11c3QgaGF2ZSBjb25zaXN0ZW50IGF0dHJpYnV0ZXMuYCk7bGV0IGk9dC5nZXRBdHRyaWJ1dGUobikscj1lLmdldEF0dHJpYnV0ZShuKTtpZihpLml0ZW1TaXplIT09ci5pdGVtU2l6ZXx8aS5ub3JtYWxpemVkIT09ci5ub3JtYWxpemVkKXRocm93IG5ldyBFcnJvcigiQmF0Y2hlZE1lc2g6IEFsbCBhdHRyaWJ1dGVzIG11c3QgaGF2ZSBhIGNvbnNpc3RlbnQgaXRlbVNpemUgYW5kIG5vcm1hbGl6ZWQgdmFsdWUuIil9fXNldEN1c3RvbVNvcnQodCl7cmV0dXJuIHRoaXMuY3VzdG9tU29ydD10LHRoaXN9Y29tcHV0ZUJvdW5kaW5nQm94KCl7dGhpcy5ib3VuZGluZ0JveD09PW51bGwmJih0aGlzLmJvdW5kaW5nQm94PW5ldyB3ZSk7bGV0IHQ9dGhpcy5fZ2VvbWV0cnlDb3VudCxlPXRoaXMuYm91bmRpbmdCb3gsbj10aGlzLl9hY3RpdmU7ZS5tYWtlRW1wdHkoKTtmb3IobGV0IGk9MDtpPHQ7aSsrKW5baV0hPT0hMSYmKHRoaXMuZ2V0TWF0cml4QXQoaSxabiksdGhpcy5nZXRCb3VuZGluZ0JveEF0KGksZmEpLmFwcGx5TWF0cml4NChabiksZS51bmlvbihmYSkpfWNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpe3RoaXMuYm91bmRpbmdTcGhlcmU9PT1udWxsJiYodGhpcy5ib3VuZGluZ1NwaGVyZT1uZXcgRWUpO2xldCB0PXRoaXMuX2dlb21ldHJ5Q291bnQsZT10aGlzLmJvdW5kaW5nU3BoZXJlLG49dGhpcy5fYWN0aXZlO2UubWFrZUVtcHR5KCk7Zm9yKGxldCBpPTA7aTx0O2krKyluW2ldIT09ITEmJih0aGlzLmdldE1hdHJpeEF0KGksWm4pLHRoaXMuZ2V0Qm91bmRpbmdTcGhlcmVBdChpLGZpKS5hcHBseU1hdHJpeDQoWm4pLGUudW5pb24oZmkpKX1hZGRHZW9tZXRyeSh0LGU9LTEsbj0tMSl7aWYodGhpcy5faW5pdGlhbGl6ZUdlb21ldHJ5KHQpLHRoaXMuX3ZhbGlkYXRlR2VvbWV0cnkodCksdGhpcy5fZ2VvbWV0cnlDb3VudD49dGhpcy5fbWF4R2VvbWV0cnlDb3VudCl0aHJvdyBuZXcgRXJyb3IoIkJhdGNoZWRNZXNoOiBNYXhpbXVtIGdlb21ldHJ5IGNvdW50IHJlYWNoZWQuIik7bGV0IGk9e3ZlcnRleFN0YXJ0Oi0xLHZlcnRleENvdW50Oi0xLGluZGV4U3RhcnQ6LTEsaW5kZXhDb3VudDotMX0scj1udWxsLGE9dGhpcy5fcmVzZXJ2ZWRSYW5nZXMsbz10aGlzLl9kcmF3UmFuZ2VzLGw9dGhpcy5fYm91bmRzO3RoaXMuX2dlb21ldHJ5Q291bnQhPT0wJiYocj1hW2EubGVuZ3RoLTFdKSxlPT09LTE/aS52ZXJ0ZXhDb3VudD10LmdldEF0dHJpYnV0ZSgicG9zaXRpb24iKS5jb3VudDppLnZlcnRleENvdW50PWUscj09PW51bGw/aS52ZXJ0ZXhTdGFydD0wOmkudmVydGV4U3RhcnQ9ci52ZXJ0ZXhTdGFydCtyLnZlcnRleENvdW50O2xldCBjPXQuZ2V0SW5kZXgoKSxoPWMhPT1udWxsO2lmKGgmJihuPT09LTE/aS5pbmRleENvdW50PWMuY291bnQ6aS5pbmRleENvdW50PW4scj09PW51bGw/aS5pbmRleFN0YXJ0PTA6aS5pbmRleFN0YXJ0PXIuaW5kZXhTdGFydCtyLmluZGV4Q291bnQpLGkuaW5kZXhTdGFydCE9PS0xJiZpLmluZGV4U3RhcnQraS5pbmRleENvdW50PnRoaXMuX21heEluZGV4Q291bnR8fGkudmVydGV4U3RhcnQraS52ZXJ0ZXhDb3VudD50aGlzLl9tYXhWZXJ0ZXhDb3VudCl0aHJvdyBuZXcgRXJyb3IoIkJhdGNoZWRNZXNoOiBSZXNlcnZlZCBzcGFjZSByZXF1ZXN0IGV4Y2VlZHMgdGhlIG1heGltdW0gYnVmZmVyIHNpemUuIik7bGV0IHU9dGhpcy5fdmlzaWJpbGl0eSxkPXRoaXMuX2FjdGl2ZSxmPXRoaXMuX21hdHJpY2VzVGV4dHVyZSxtPXRoaXMuX21hdHJpY2VzVGV4dHVyZS5pbWFnZS5kYXRhO3UucHVzaCghMCksZC5wdXNoKCEwKTtsZXQgXz10aGlzLl9nZW9tZXRyeUNvdW50O3RoaXMuX2dlb21ldHJ5Q291bnQrKyx2di50b0FycmF5KG0sXyoxNiksZi5uZWVkc1VwZGF0ZT0hMCxhLnB1c2goaSksby5wdXNoKHtzdGFydDpoP2kuaW5kZXhTdGFydDppLnZlcnRleFN0YXJ0LGNvdW50Oi0xfSksbC5wdXNoKHtib3hJbml0aWFsaXplZDohMSxib3g6bmV3IHdlLHNwaGVyZUluaXRpYWxpemVkOiExLHNwaGVyZTpuZXcgRWV9KTtsZXQgZz10aGlzLmdlb21ldHJ5LmdldEF0dHJpYnV0ZShvcyk7Zm9yKGxldCBwPTA7cDxpLnZlcnRleENvdW50O3ArKylnLnNldFgoaS52ZXJ0ZXhTdGFydCtwLF8pO3JldHVybiBnLm5lZWRzVXBkYXRlPSEwLHRoaXMuc2V0R2VvbWV0cnlBdChfLHQpLF99c2V0R2VvbWV0cnlBdCh0LGUpe2lmKHQ+PXRoaXMuX2dlb21ldHJ5Q291bnQpdGhyb3cgbmV3IEVycm9yKCJCYXRjaGVkTWVzaDogTWF4aW11bSBnZW9tZXRyeSBjb3VudCByZWFjaGVkLiIpO3RoaXMuX3ZhbGlkYXRlR2VvbWV0cnkoZSk7bGV0IG49dGhpcy5nZW9tZXRyeSxpPW4uZ2V0SW5kZXgoKSE9PW51bGwscj1uLmdldEluZGV4KCksYT1lLmdldEluZGV4KCksbz10aGlzLl9yZXNlcnZlZFJhbmdlc1t0XTtpZihpJiZhLmNvdW50Pm8uaW5kZXhDb3VudHx8ZS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50Pm8udmVydGV4Q291bnQpdGhyb3cgbmV3IEVycm9yKCJCYXRjaGVkTWVzaDogUmVzZXJ2ZWQgc3BhY2Ugbm90IGxhcmdlIGVub3VnaCBmb3IgcHJvdmlkZWQgZ2VvbWV0cnkuIik7bGV0IGw9by52ZXJ0ZXhTdGFydCxjPW8udmVydGV4Q291bnQ7Zm9yKGxldCBmIGluIG4uYXR0cmlidXRlcyl7aWYoZj09PW9zKWNvbnRpbnVlO2xldCBtPWUuZ2V0QXR0cmlidXRlKGYpLF89bi5nZXRBdHRyaWJ1dGUoZik7eXYobSxfLGwpO2xldCBnPW0uaXRlbVNpemU7Zm9yKGxldCBwPW0uY291bnQsdj1jO3A8djtwKyspe2xldCB4PWwrcDtmb3IobGV0IE09MDtNPGc7TSsrKV8uc2V0Q29tcG9uZW50KHgsTSwwKX1fLm5lZWRzVXBkYXRlPSEwfWlmKGkpe2xldCBmPW8uaW5kZXhTdGFydDtmb3IobGV0IG09MDttPGEuY291bnQ7bSsrKXIuc2V0WChmK20sbCthLmdldFgobSkpO2ZvcihsZXQgbT1hLmNvdW50LF89by5pbmRleENvdW50O208XzttKyspci5zZXRYKGYrbSxsKTtyLm5lZWRzVXBkYXRlPSEwfWxldCBoPXRoaXMuX2JvdW5kc1t0XTtlLmJvdW5kaW5nQm94IT09bnVsbD8oaC5ib3guY29weShlLmJvdW5kaW5nQm94KSxoLmJveEluaXRpYWxpemVkPSEwKTpoLmJveEluaXRpYWxpemVkPSExLGUuYm91bmRpbmdTcGhlcmUhPT1udWxsPyhoLnNwaGVyZS5jb3B5KGUuYm91bmRpbmdTcGhlcmUpLGguc3BoZXJlSW5pdGlhbGl6ZWQ9ITApOmguc3BoZXJlSW5pdGlhbGl6ZWQ9ITE7bGV0IHU9dGhpcy5fZHJhd1Jhbmdlc1t0XSxkPWUuZ2V0QXR0cmlidXRlKCJwb3NpdGlvbiIpO3JldHVybiB1LmNvdW50PWk/YS5jb3VudDpkLmNvdW50LHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2VkPSEwLHR9ZGVsZXRlR2VvbWV0cnkodCl7bGV0IGU9dGhpcy5fYWN0aXZlO3JldHVybiB0Pj1lLmxlbmd0aHx8ZVt0XT09PSExP3RoaXM6KGVbdF09ITEsdGhpcy5fdmlzaWJpbGl0eUNoYW5nZWQ9ITAsdGhpcyl9Z2V0Qm91bmRpbmdCb3hBdCh0LGUpe2lmKHRoaXMuX2FjdGl2ZVt0XT09PSExKXJldHVybiBudWxsO2xldCBpPXRoaXMuX2JvdW5kc1t0XSxyPWkuYm94LGE9dGhpcy5nZW9tZXRyeTtpZihpLmJveEluaXRpYWxpemVkPT09ITEpe3IubWFrZUVtcHR5KCk7bGV0IG89YS5pbmRleCxsPWEuYXR0cmlidXRlcy5wb3NpdGlvbixjPXRoaXMuX2RyYXdSYW5nZXNbdF07Zm9yKGxldCBoPWMuc3RhcnQsdT1jLnN0YXJ0K2MuY291bnQ7aDx1O2grKyl7bGV0IGQ9aDtvJiYoZD1vLmdldFgoZCkpLHIuZXhwYW5kQnlQb2ludChCcy5mcm9tQnVmZmVyQXR0cmlidXRlKGwsZCkpfWkuYm94SW5pdGlhbGl6ZWQ9ITB9cmV0dXJuIGUuY29weShyKSxlfWdldEJvdW5kaW5nU3BoZXJlQXQodCxlKXtpZih0aGlzLl9hY3RpdmVbdF09PT0hMSlyZXR1cm4gbnVsbDtsZXQgaT10aGlzLl9ib3VuZHNbdF0scj1pLnNwaGVyZSxhPXRoaXMuZ2VvbWV0cnk7aWYoaS5zcGhlcmVJbml0aWFsaXplZD09PSExKXtyLm1ha2VFbXB0eSgpLHRoaXMuZ2V0Qm91bmRpbmdCb3hBdCh0LGZhKSxmYS5nZXRDZW50ZXIoci5jZW50ZXIpO2xldCBvPWEuaW5kZXgsbD1hLmF0dHJpYnV0ZXMucG9zaXRpb24sYz10aGlzLl9kcmF3UmFuZ2VzW3RdLGg9MDtmb3IobGV0IHU9Yy5zdGFydCxkPWMuc3RhcnQrYy5jb3VudDt1PGQ7dSsrKXtsZXQgZj11O28mJihmPW8uZ2V0WChmKSksQnMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShsLGYpLGg9TWF0aC5tYXgoaCxyLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZChCcykpfXIucmFkaXVzPU1hdGguc3FydChoKSxpLnNwaGVyZUluaXRpYWxpemVkPSEwfXJldHVybiBlLmNvcHkociksZX1zZXRNYXRyaXhBdCh0LGUpe2xldCBuPXRoaXMuX2FjdGl2ZSxpPXRoaXMuX21hdHJpY2VzVGV4dHVyZSxyPXRoaXMuX21hdHJpY2VzVGV4dHVyZS5pbWFnZS5kYXRhLGE9dGhpcy5fZ2VvbWV0cnlDb3VudDtyZXR1cm4gdD49YXx8blt0XT09PSExP3RoaXM6KGUudG9BcnJheShyLHQqMTYpLGkubmVlZHNVcGRhdGU9ITAsdGhpcyl9Z2V0TWF0cml4QXQodCxlKXtsZXQgbj10aGlzLl9hY3RpdmUsaT10aGlzLl9tYXRyaWNlc1RleHR1cmUuaW1hZ2UuZGF0YSxyPXRoaXMuX2dlb21ldHJ5Q291bnQ7cmV0dXJuIHQ+PXJ8fG5bdF09PT0hMT9udWxsOmUuZnJvbUFycmF5KGksdCoxNil9c2V0VmlzaWJsZUF0KHQsZSl7bGV0IG49dGhpcy5fdmlzaWJpbGl0eSxpPXRoaXMuX2FjdGl2ZSxyPXRoaXMuX2dlb21ldHJ5Q291bnQ7cmV0dXJuIHQ+PXJ8fGlbdF09PT0hMXx8blt0XT09PWU/dGhpczooblt0XT1lLHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2VkPSEwLHRoaXMpfWdldFZpc2libGVBdCh0KXtsZXQgZT10aGlzLl92aXNpYmlsaXR5LG49dGhpcy5fYWN0aXZlLGk9dGhpcy5fZ2VvbWV0cnlDb3VudDtyZXR1cm4gdD49aXx8blt0XT09PSExPyExOmVbdF19cmF5Y2FzdCh0LGUpe2xldCBuPXRoaXMuX3Zpc2liaWxpdHksaT10aGlzLl9hY3RpdmUscj10aGlzLl9kcmF3UmFuZ2VzLGE9dGhpcy5fZ2VvbWV0cnlDb3VudCxvPXRoaXMubWF0cml4V29ybGQsbD10aGlzLmdlb21ldHJ5O0llLm1hdGVyaWFsPXRoaXMubWF0ZXJpYWwsSWUuZ2VvbWV0cnkuaW5kZXg9bC5pbmRleCxJZS5nZW9tZXRyeS5hdHRyaWJ1dGVzPWwuYXR0cmlidXRlcyxJZS5nZW9tZXRyeS5ib3VuZGluZ0JveD09PW51bGwmJihJZS5nZW9tZXRyeS5ib3VuZGluZ0JveD1uZXcgd2UpLEllLmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlPT09bnVsbCYmKEllLmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlPW5ldyBFZSk7Zm9yKGxldCBjPTA7YzxhO2MrKyl7aWYoIW5bY118fCFpW2NdKWNvbnRpbnVlO2xldCBoPXJbY107SWUuZ2VvbWV0cnkuc2V0RHJhd1JhbmdlKGguc3RhcnQsaC5jb3VudCksdGhpcy5nZXRNYXRyaXhBdChjLEllLm1hdHJpeFdvcmxkKS5wcmVtdWx0aXBseShvKSx0aGlzLmdldEJvdW5kaW5nQm94QXQoYyxJZS5nZW9tZXRyeS5ib3VuZGluZ0JveCksdGhpcy5nZXRCb3VuZGluZ1NwaGVyZUF0KGMsSWUuZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUpLEllLnJheWNhc3QodCxwYSk7Zm9yKGxldCB1PTAsZD1wYS5sZW5ndGg7dTxkO3UrKyl7bGV0IGY9cGFbdV07Zi5vYmplY3Q9dGhpcyxmLmJhdGNoSWQ9YyxlLnB1c2goZil9cGEubGVuZ3RoPTB9SWUubWF0ZXJpYWw9bnVsbCxJZS5nZW9tZXRyeS5pbmRleD1udWxsLEllLmdlb21ldHJ5LmF0dHJpYnV0ZXM9e30sSWUuZ2VvbWV0cnkuc2V0RHJhd1JhbmdlKDAsMS8wKX1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMuZ2VvbWV0cnk9dC5nZW9tZXRyeS5jbG9uZSgpLHRoaXMucGVyT2JqZWN0RnJ1c3R1bUN1bGxlZD10LnBlck9iamVjdEZydXN0dW1DdWxsZWQsdGhpcy5zb3J0T2JqZWN0cz10LnNvcnRPYmplY3RzLHRoaXMuYm91bmRpbmdCb3g9dC5ib3VuZGluZ0JveCE9PW51bGw/dC5ib3VuZGluZ0JveC5jbG9uZSgpOm51bGwsdGhpcy5ib3VuZGluZ1NwaGVyZT10LmJvdW5kaW5nU3BoZXJlIT09bnVsbD90LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk6bnVsbCx0aGlzLl9kcmF3UmFuZ2VzPXQuX2RyYXdSYW5nZXMubWFwKGU9Pih7Li4uZX0pKSx0aGlzLl9yZXNlcnZlZFJhbmdlcz10Ll9yZXNlcnZlZFJhbmdlcy5tYXAoZT0+KHsuLi5lfSkpLHRoaXMuX3Zpc2liaWxpdHk9dC5fdmlzaWJpbGl0eS5zbGljZSgpLHRoaXMuX2FjdGl2ZT10Ll9hY3RpdmUuc2xpY2UoKSx0aGlzLl9ib3VuZHM9dC5fYm91bmRzLm1hcChlPT4oe2JveEluaXRpYWxpemVkOmUuYm94SW5pdGlhbGl6ZWQsYm94OmUuYm94LmNsb25lKCksc3BoZXJlSW5pdGlhbGl6ZWQ6ZS5zcGhlcmVJbml0aWFsaXplZCxzcGhlcmU6ZS5zcGhlcmUuY2xvbmUoKX0pKSx0aGlzLl9tYXhHZW9tZXRyeUNvdW50PXQuX21heEdlb21ldHJ5Q291bnQsdGhpcy5fbWF4VmVydGV4Q291bnQ9dC5fbWF4VmVydGV4Q291bnQsdGhpcy5fbWF4SW5kZXhDb3VudD10Ll9tYXhJbmRleENvdW50LHRoaXMuX2dlb21ldHJ5SW5pdGlhbGl6ZWQ9dC5fZ2VvbWV0cnlJbml0aWFsaXplZCx0aGlzLl9nZW9tZXRyeUNvdW50PXQuX2dlb21ldHJ5Q291bnQsdGhpcy5fbXVsdGlEcmF3Q291bnRzPXQuX211bHRpRHJhd0NvdW50cy5zbGljZSgpLHRoaXMuX211bHRpRHJhd1N0YXJ0cz10Ll9tdWx0aURyYXdTdGFydHMuc2xpY2UoKSx0aGlzLl9tYXRyaWNlc1RleHR1cmU9dC5fbWF0cmljZXNUZXh0dXJlLmNsb25lKCksdGhpcy5fbWF0cmljZXNUZXh0dXJlLmltYWdlLmRhdGE9dGhpcy5fbWF0cmljZXNUZXh0dXJlLmltYWdlLnNsaWNlKCksdGhpc31kaXNwb3NlKCl7cmV0dXJuIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpLHRoaXMuX21hdHJpY2VzVGV4dHVyZS5kaXNwb3NlKCksdGhpcy5fbWF0cmljZXNUZXh0dXJlPW51bGwsdGhpc31vbkJlZm9yZVJlbmRlcih0LGUsbixpLHIpe2lmKCF0aGlzLl92aXNpYmlsaXR5Q2hhbmdlZCYmIXRoaXMucGVyT2JqZWN0RnJ1c3R1bUN1bGxlZCYmIXRoaXMuc29ydE9iamVjdHMpcmV0dXJuO2xldCBhPWkuZ2V0SW5kZXgoKSxvPWE9PT1udWxsPzE6YS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCxsPXRoaXMuX2FjdGl2ZSxjPXRoaXMuX3Zpc2liaWxpdHksaD10aGlzLl9tdWx0aURyYXdTdGFydHMsdT10aGlzLl9tdWx0aURyYXdDb3VudHMsZD10aGlzLl9kcmF3UmFuZ2VzLGY9dGhpcy5wZXJPYmplY3RGcnVzdHVtQ3VsbGVkO2YmJihkZC5tdWx0aXBseU1hdHJpY2VzKG4ucHJvamVjdGlvbk1hdHJpeCxuLm1hdHJpeFdvcmxkSW52ZXJzZSkubXVsdGlwbHkodGhpcy5tYXRyaXhXb3JsZCksT2wuc2V0RnJvbVByb2plY3Rpb25NYXRyaXgoZGQsdC5jb29yZGluYXRlU3lzdGVtKSk7bGV0IG09MDtpZih0aGlzLnNvcnRPYmplY3RzKXt1ZC5jb3B5KHRoaXMubWF0cml4V29ybGQpLmludmVydCgpLEJzLnNldEZyb21NYXRyaXhQb3NpdGlvbihuLm1hdHJpeFdvcmxkKS5hcHBseU1hdHJpeDQodWQpO2ZvcihsZXQgcD0wLHY9Yy5sZW5ndGg7cDx2O3ArKylpZihjW3BdJiZsW3BdKXt0aGlzLmdldE1hdHJpeEF0KHAsWm4pLHRoaXMuZ2V0Qm91bmRpbmdTcGhlcmVBdChwLGZpKS5hcHBseU1hdHJpeDQoWm4pO2xldCB4PSExO2lmKGYmJih4PSFPbC5pbnRlcnNlY3RzU3BoZXJlKGZpKSksIXgpe2xldCBNPUJzLmRpc3RhbmNlVG8oZmkuY2VudGVyKTtGbC5wdXNoKGRbcF0sTSl9fWxldCBfPUZsLmxpc3QsZz10aGlzLmN1c3RvbVNvcnQ7Zz09PW51bGw/Xy5zb3J0KHIudHJhbnNwYXJlbnQ/eHY6X3YpOmcuY2FsbCh0aGlzLF8sbik7Zm9yKGxldCBwPTAsdj1fLmxlbmd0aDtwPHY7cCsrKXtsZXQgeD1fW3BdO2hbbV09eC5zdGFydCpvLHVbbV09eC5jb3VudCxtKyt9RmwucmVzZXQoKX1lbHNlIGZvcihsZXQgXz0wLGc9Yy5sZW5ndGg7XzxnO18rKylpZihjW19dJiZsW19dKXtsZXQgcD0hMTtpZihmJiYodGhpcy5nZXRNYXRyaXhBdChfLFpuKSx0aGlzLmdldEJvdW5kaW5nU3BoZXJlQXQoXyxmaSkuYXBwbHlNYXRyaXg0KFpuKSxwPSFPbC5pbnRlcnNlY3RzU3BoZXJlKGZpKSksIXApe2xldCB2PWRbX107aFttXT12LnN0YXJ0Km8sdVttXT12LmNvdW50LG0rK319dGhpcy5fbXVsdGlEcmF3Q291bnQ9bSx0aGlzLl92aXNpYmlsaXR5Q2hhbmdlZD0hMX1vbkJlZm9yZVNoYWRvdyh0LGUsbixpLHIsYSl7dGhpcy5vbkJlZm9yZVJlbmRlcih0LG51bGwsaSxyLGEpfX0sUmU9Y2xhc3MgZXh0ZW5kcyBBZXtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuaXNMaW5lQmFzaWNNYXRlcmlhbD0hMCx0aGlzLnR5cGU9IkxpbmVCYXNpY01hdGVyaWFsIix0aGlzLmNvbG9yPW5ldyB1dCgxNjc3NzIxNSksdGhpcy5tYXA9bnVsbCx0aGlzLmxpbmV3aWR0aD0xLHRoaXMubGluZWNhcD0icm91bmQiLHRoaXMubGluZWpvaW49InJvdW5kIix0aGlzLmZvZz0hMCx0aGlzLnNldFZhbHVlcyh0KX1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMuY29sb3IuY29weSh0LmNvbG9yKSx0aGlzLm1hcD10Lm1hcCx0aGlzLmxpbmV3aWR0aD10LmxpbmV3aWR0aCx0aGlzLmxpbmVjYXA9dC5saW5lY2FwLHRoaXMubGluZWpvaW49dC5saW5lam9pbix0aGlzLmZvZz10LmZvZyx0aGlzfX0sZmQ9bmV3IFIscGQ9bmV3IFIsbWQ9bmV3IEx0LEJsPW5ldyBuaSxtYT1uZXcgRWUsdm49Y2xhc3MgZXh0ZW5kcyBKdHtjb25zdHJ1Y3Rvcih0PW5ldyBIdCxlPW5ldyBSZSl7c3VwZXIoKSx0aGlzLmlzTGluZT0hMCx0aGlzLnR5cGU9IkxpbmUiLHRoaXMuZ2VvbWV0cnk9dCx0aGlzLm1hdGVyaWFsPWUsdGhpcy51cGRhdGVNb3JwaFRhcmdldHMoKX1jb3B5KHQsZSl7cmV0dXJuIHN1cGVyLmNvcHkodCxlKSx0aGlzLm1hdGVyaWFsPUFycmF5LmlzQXJyYXkodC5tYXRlcmlhbCk/dC5tYXRlcmlhbC5zbGljZSgpOnQubWF0ZXJpYWwsdGhpcy5nZW9tZXRyeT10Lmdlb21ldHJ5LHRoaXN9Y29tcHV0ZUxpbmVEaXN0YW5jZXMoKXtsZXQgdD10aGlzLmdlb21ldHJ5O2lmKHQuaW5kZXg9PT1udWxsKXtsZXQgZT10LmF0dHJpYnV0ZXMucG9zaXRpb24sbj1bMF07Zm9yKGxldCBpPTEscj1lLmNvdW50O2k8cjtpKyspZmQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLGktMSkscGQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLGkpLG5baV09bltpLTFdLG5baV0rPWZkLmRpc3RhbmNlVG8ocGQpO3Quc2V0QXR0cmlidXRlKCJsaW5lRGlzdGFuY2UiLG5ldyBndChuLDEpKX1lbHNlIGNvbnNvbGUud2FybigiVEhSRUUuTGluZS5jb21wdXRlTGluZURpc3RhbmNlcygpOiBDb21wdXRhdGlvbiBvbmx5IHBvc3NpYmxlIHdpdGggbm9uLWluZGV4ZWQgQnVmZmVyR2VvbWV0cnkuIik7cmV0dXJuIHRoaXN9cmF5Y2FzdCh0LGUpe2xldCBuPXRoaXMuZ2VvbWV0cnksaT10aGlzLm1hdHJpeFdvcmxkLHI9dC5wYXJhbXMuTGluZS50aHJlc2hvbGQsYT1uLmRyYXdSYW5nZTtpZihuLmJvdW5kaW5nU3BoZXJlPT09bnVsbCYmbi5jb21wdXRlQm91bmRpbmdTcGhlcmUoKSxtYS5jb3B5KG4uYm91bmRpbmdTcGhlcmUpLG1hLmFwcGx5TWF0cml4NChpKSxtYS5yYWRpdXMrPXIsdC5yYXkuaW50ZXJzZWN0c1NwaGVyZShtYSk9PT0hMSlyZXR1cm47bWQuY29weShpKS5pbnZlcnQoKSxCbC5jb3B5KHQucmF5KS5hcHBseU1hdHJpeDQobWQpO2xldCBvPXIvKCh0aGlzLnNjYWxlLngrdGhpcy5zY2FsZS55K3RoaXMuc2NhbGUueikvMyksbD1vKm8sYz1uZXcgUixoPW5ldyBSLHU9bmV3IFIsZD1uZXcgUixmPXRoaXMuaXNMaW5lU2VnbWVudHM/MjoxLG09bi5pbmRleCxnPW4uYXR0cmlidXRlcy5wb3NpdGlvbjtpZihtIT09bnVsbCl7bGV0IHA9TWF0aC5tYXgoMCxhLnN0YXJ0KSx2PU1hdGgubWluKG0uY291bnQsYS5zdGFydCthLmNvdW50KTtmb3IobGV0IHg9cCxNPXYtMTt4PE07eCs9Zil7bGV0IEM9bS5nZXRYKHgpLEE9bS5nZXRYKHgrMSk7aWYoYy5mcm9tQnVmZmVyQXR0cmlidXRlKGcsQyksaC5mcm9tQnVmZmVyQXR0cmlidXRlKGcsQSksQmwuZGlzdGFuY2VTcVRvU2VnbWVudChjLGgsZCx1KT5sKWNvbnRpbnVlO2QuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpO2xldCBVPXQucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKGQpO1U8dC5uZWFyfHxVPnQuZmFyfHxlLnB1c2goe2Rpc3RhbmNlOlUscG9pbnQ6dS5jbG9uZSgpLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKSxpbmRleDp4LGZhY2U6bnVsbCxmYWNlSW5kZXg6bnVsbCxvYmplY3Q6dGhpc30pfX1lbHNle2xldCBwPU1hdGgubWF4KDAsYS5zdGFydCksdj1NYXRoLm1pbihnLmNvdW50LGEuc3RhcnQrYS5jb3VudCk7Zm9yKGxldCB4PXAsTT12LTE7eDxNO3grPWYpe2lmKGMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShnLHgpLGguZnJvbUJ1ZmZlckF0dHJpYnV0ZShnLHgrMSksQmwuZGlzdGFuY2VTcVRvU2VnbWVudChjLGgsZCx1KT5sKWNvbnRpbnVlO2QuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpO2xldCBBPXQucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKGQpO0E8dC5uZWFyfHxBPnQuZmFyfHxlLnB1c2goe2Rpc3RhbmNlOkEscG9pbnQ6dS5jbG9uZSgpLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKSxpbmRleDp4LGZhY2U6bnVsbCxmYWNlSW5kZXg6bnVsbCxvYmplY3Q6dGhpc30pfX19dXBkYXRlTW9ycGhUYXJnZXRzKCl7bGV0IGU9dGhpcy5nZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMsbj1PYmplY3Qua2V5cyhlKTtpZihuLmxlbmd0aD4wKXtsZXQgaT1lW25bMF1dO2lmKGkhPT12b2lkIDApe3RoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzPVtdLHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5PXt9O2ZvcihsZXQgcj0wLGE9aS5sZW5ndGg7cjxhO3IrKyl7bGV0IG89aVtyXS5uYW1lfHxTdHJpbmcocik7dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCgwKSx0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVtvXT1yfX19fX0sZ2Q9bmV3IFIsX2Q9bmV3IFIsbm49Y2xhc3MgZXh0ZW5kcyB2bntjb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKHQsZSksdGhpcy5pc0xpbmVTZWdtZW50cz0hMCx0aGlzLnR5cGU9IkxpbmVTZWdtZW50cyJ9Y29tcHV0ZUxpbmVEaXN0YW5jZXMoKXtsZXQgdD10aGlzLmdlb21ldHJ5O2lmKHQuaW5kZXg9PT1udWxsKXtsZXQgZT10LmF0dHJpYnV0ZXMucG9zaXRpb24sbj1bXTtmb3IobGV0IGk9MCxyPWUuY291bnQ7aTxyO2krPTIpZ2QuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLGkpLF9kLmZyb21CdWZmZXJBdHRyaWJ1dGUoZSxpKzEpLG5baV09aT09PTA/MDpuW2ktMV0sbltpKzFdPW5baV0rZ2QuZGlzdGFuY2VUbyhfZCk7dC5zZXRBdHRyaWJ1dGUoImxpbmVEaXN0YW5jZSIsbmV3IGd0KG4sMSkpfWVsc2UgY29uc29sZS53YXJuKCJUSFJFRS5MaW5lU2VnbWVudHMuY29tcHV0ZUxpbmVEaXN0YW5jZXMoKTogQ29tcHV0YXRpb24gb25seSBwb3NzaWJsZSB3aXRoIG5vbi1pbmRleGVkIEJ1ZmZlckdlb21ldHJ5LiIpO3JldHVybiB0aGlzfX0saW89Y2xhc3MgZXh0ZW5kcyB2bntjb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKHQsZSksdGhpcy5pc0xpbmVMb29wPSEwLHRoaXMudHlwZT0iTGluZUxvb3AifX0sX3I9Y2xhc3MgZXh0ZW5kcyBBZXtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuaXNQb2ludHNNYXRlcmlhbD0hMCx0aGlzLnR5cGU9IlBvaW50c01hdGVyaWFsIix0aGlzLmNvbG9yPW5ldyB1dCgxNjc3NzIxNSksdGhpcy5tYXA9bnVsbCx0aGlzLmFscGhhTWFwPW51bGwsdGhpcy5zaXplPTEsdGhpcy5zaXplQXR0ZW51YXRpb249ITAsdGhpcy5mb2c9ITAsdGhpcy5zZXRWYWx1ZXModCl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLmNvbG9yLmNvcHkodC5jb2xvciksdGhpcy5tYXA9dC5tYXAsdGhpcy5hbHBoYU1hcD10LmFscGhhTWFwLHRoaXMuc2l6ZT10LnNpemUsdGhpcy5zaXplQXR0ZW51YXRpb249dC5zaXplQXR0ZW51YXRpb24sdGhpcy5mb2c9dC5mb2csdGhpc319LHhkPW5ldyBMdCxZYz1uZXcgbmksZ2E9bmV3IEVlLF9hPW5ldyBSLHNvPWNsYXNzIGV4dGVuZHMgSnR7Y29uc3RydWN0b3IodD1uZXcgSHQsZT1uZXcgX3Ipe3N1cGVyKCksdGhpcy5pc1BvaW50cz0hMCx0aGlzLnR5cGU9IlBvaW50cyIsdGhpcy5nZW9tZXRyeT10LHRoaXMubWF0ZXJpYWw9ZSx0aGlzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpfWNvcHkodCxlKXtyZXR1cm4gc3VwZXIuY29weSh0LGUpLHRoaXMubWF0ZXJpYWw9QXJyYXkuaXNBcnJheSh0Lm1hdGVyaWFsKT90Lm1hdGVyaWFsLnNsaWNlKCk6dC5tYXRlcmlhbCx0aGlzLmdlb21ldHJ5PXQuZ2VvbWV0cnksdGhpc31yYXljYXN0KHQsZSl7bGV0IG49dGhpcy5nZW9tZXRyeSxpPXRoaXMubWF0cml4V29ybGQscj10LnBhcmFtcy5Qb2ludHMudGhyZXNob2xkLGE9bi5kcmF3UmFuZ2U7aWYobi5ib3VuZGluZ1NwaGVyZT09PW51bGwmJm4uY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCksZ2EuY29weShuLmJvdW5kaW5nU3BoZXJlKSxnYS5hcHBseU1hdHJpeDQoaSksZ2EucmFkaXVzKz1yLHQucmF5LmludGVyc2VjdHNTcGhlcmUoZ2EpPT09ITEpcmV0dXJuO3hkLmNvcHkoaSkuaW52ZXJ0KCksWWMuY29weSh0LnJheSkuYXBwbHlNYXRyaXg0KHhkKTtsZXQgbz1yLygodGhpcy5zY2FsZS54K3RoaXMuc2NhbGUueSt0aGlzLnNjYWxlLnopLzMpLGw9bypvLGM9bi5pbmRleCx1PW4uYXR0cmlidXRlcy5wb3NpdGlvbjtpZihjIT09bnVsbCl7bGV0IGQ9TWF0aC5tYXgoMCxhLnN0YXJ0KSxmPU1hdGgubWluKGMuY291bnQsYS5zdGFydCthLmNvdW50KTtmb3IobGV0IG09ZCxfPWY7bTxfO20rKyl7bGV0IGc9Yy5nZXRYKG0pO19hLmZyb21CdWZmZXJBdHRyaWJ1dGUodSxnKSx2ZChfYSxnLGwsaSx0LGUsdGhpcyl9fWVsc2V7bGV0IGQ9TWF0aC5tYXgoMCxhLnN0YXJ0KSxmPU1hdGgubWluKHUuY291bnQsYS5zdGFydCthLmNvdW50KTtmb3IobGV0IG09ZCxfPWY7bTxfO20rKylfYS5mcm9tQnVmZmVyQXR0cmlidXRlKHUsbSksdmQoX2EsbSxsLGksdCxlLHRoaXMpfX11cGRhdGVNb3JwaFRhcmdldHMoKXtsZXQgZT10aGlzLmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyxuPU9iamVjdC5rZXlzKGUpO2lmKG4ubGVuZ3RoPjApe2xldCBpPWVbblswXV07aWYoaSE9PXZvaWQgMCl7dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXM9W10sdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnk9e307Zm9yKGxldCByPTAsYT1pLmxlbmd0aDtyPGE7cisrKXtsZXQgbz1pW3JdLm5hbWV8fFN0cmluZyhyKTt0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5wdXNoKDApLHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5W29dPXJ9fX19fTtmdW5jdGlvbiB2ZChzLHQsZSxuLGkscixhKXtsZXQgbz1ZYy5kaXN0YW5jZVNxVG9Qb2ludChzKTtpZihvPGUpe2xldCBsPW5ldyBSO1ljLmNsb3Nlc3RQb2ludFRvUG9pbnQocyxsKSxsLmFwcGx5TWF0cml4NChuKTtsZXQgYz1pLnJheS5vcmlnaW4uZGlzdGFuY2VUbyhsKTtpZihjPGkubmVhcnx8Yz5pLmZhcilyZXR1cm47ci5wdXNoKHtkaXN0YW5jZTpjLGRpc3RhbmNlVG9SYXk6TWF0aC5zcXJ0KG8pLHBvaW50OmwsaW5kZXg6dCxmYWNlOm51bGwsb2JqZWN0OmF9KX19dmFyIFpjPWNsYXNzIGV4dGVuZHMgX2V7Y29uc3RydWN0b3IodCxlLG4saSxyLGEsbyxsLGMpe3N1cGVyKHQsZSxuLGkscixhLG8sbCxjKSx0aGlzLmlzVmlkZW9UZXh0dXJlPSEwLHRoaXMubWluRmlsdGVyPWEhPT12b2lkIDA/YTpvZSx0aGlzLm1hZ0ZpbHRlcj1yIT09dm9pZCAwP3I6b2UsdGhpcy5nZW5lcmF0ZU1pcG1hcHM9ITE7bGV0IGg9dGhpcztmdW5jdGlvbiB1KCl7aC5uZWVkc1VwZGF0ZT0hMCx0LnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2sodSl9InJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2siaW4gdCYmdC5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKHUpfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuaW1hZ2UpLmNvcHkodGhpcyl9dXBkYXRlKCl7bGV0IHQ9dGhpcy5pbWFnZTsicmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjayJpbiB0PT09ITEmJnQucmVhZHlTdGF0ZT49dC5IQVZFX0NVUlJFTlRfREFUQSYmKHRoaXMubmVlZHNVcGRhdGU9ITApfX0sSmM9Y2xhc3MgZXh0ZW5kcyBfZXtjb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKHt3aWR0aDp0LGhlaWdodDplfSksdGhpcy5pc0ZyYW1lYnVmZmVyVGV4dHVyZT0hMCx0aGlzLm1hZ0ZpbHRlcj1tZSx0aGlzLm1pbkZpbHRlcj1tZSx0aGlzLmdlbmVyYXRlTWlwbWFwcz0hMSx0aGlzLm5lZWRzVXBkYXRlPSEwfX0sYnM9Y2xhc3MgZXh0ZW5kcyBfZXtjb25zdHJ1Y3Rvcih0LGUsbixpLHIsYSxvLGwsYyxoLHUsZCl7c3VwZXIobnVsbCxhLG8sbCxjLGgsaSxyLHUsZCksdGhpcy5pc0NvbXByZXNzZWRUZXh0dXJlPSEwLHRoaXMuaW1hZ2U9e3dpZHRoOmUsaGVpZ2h0Om59LHRoaXMubWlwbWFwcz10LHRoaXMuZmxpcFk9ITEsdGhpcy5nZW5lcmF0ZU1pcG1hcHM9ITF9fSwkYz1jbGFzcyBleHRlbmRzIGJze2NvbnN0cnVjdG9yKHQsZSxuLGkscixhKXtzdXBlcih0LGUsbixyLGEpLHRoaXMuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlPSEwLHRoaXMuaW1hZ2UuZGVwdGg9aSx0aGlzLndyYXBSPVVlfX0sS2M9Y2xhc3MgZXh0ZW5kcyBic3tjb25zdHJ1Y3Rvcih0LGUsbil7c3VwZXIodm9pZCAwLHRbMF0ud2lkdGgsdFswXS5oZWlnaHQsZSxuLHpuKSx0aGlzLmlzQ29tcHJlc3NlZEN1YmVUZXh0dXJlPSEwLHRoaXMuaXNDdWJlVGV4dHVyZT0hMCx0aGlzLmltYWdlPXR9fSxRYz1jbGFzcyBleHRlbmRzIF9le2NvbnN0cnVjdG9yKHQsZSxuLGkscixhLG8sbCxjKXtzdXBlcih0LGUsbixpLHIsYSxvLGwsYyksdGhpcy5pc0NhbnZhc1RleHR1cmU9ITAsdGhpcy5uZWVkc1VwZGF0ZT0hMH19LCRlPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy50eXBlPSJDdXJ2ZSIsdGhpcy5hcmNMZW5ndGhEaXZpc2lvbnM9MjAwfWdldFBvaW50KCl7cmV0dXJuIGNvbnNvbGUud2FybigiVEhSRUUuQ3VydmU6IC5nZXRQb2ludCgpIG5vdCBpbXBsZW1lbnRlZC4iKSxudWxsfWdldFBvaW50QXQodCxlKXtsZXQgbj10aGlzLmdldFV0b1RtYXBwaW5nKHQpO3JldHVybiB0aGlzLmdldFBvaW50KG4sZSl9Z2V0UG9pbnRzKHQ9NSl7bGV0IGU9W107Zm9yKGxldCBuPTA7bjw9dDtuKyspZS5wdXNoKHRoaXMuZ2V0UG9pbnQobi90KSk7cmV0dXJuIGV9Z2V0U3BhY2VkUG9pbnRzKHQ9NSl7bGV0IGU9W107Zm9yKGxldCBuPTA7bjw9dDtuKyspZS5wdXNoKHRoaXMuZ2V0UG9pbnRBdChuL3QpKTtyZXR1cm4gZX1nZXRMZW5ndGgoKXtsZXQgdD10aGlzLmdldExlbmd0aHMoKTtyZXR1cm4gdFt0Lmxlbmd0aC0xXX1nZXRMZW5ndGhzKHQ9dGhpcy5hcmNMZW5ndGhEaXZpc2lvbnMpe2lmKHRoaXMuY2FjaGVBcmNMZW5ndGhzJiZ0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGg9PT10KzEmJiF0aGlzLm5lZWRzVXBkYXRlKXJldHVybiB0aGlzLmNhY2hlQXJjTGVuZ3Roczt0aGlzLm5lZWRzVXBkYXRlPSExO2xldCBlPVtdLG4saT10aGlzLmdldFBvaW50KDApLHI9MDtlLnB1c2goMCk7Zm9yKGxldCBhPTE7YTw9dDthKyspbj10aGlzLmdldFBvaW50KGEvdCkscis9bi5kaXN0YW5jZVRvKGkpLGUucHVzaChyKSxpPW47cmV0dXJuIHRoaXMuY2FjaGVBcmNMZW5ndGhzPWUsZX11cGRhdGVBcmNMZW5ndGhzKCl7dGhpcy5uZWVkc1VwZGF0ZT0hMCx0aGlzLmdldExlbmd0aHMoKX1nZXRVdG9UbWFwcGluZyh0LGUpe2xldCBuPXRoaXMuZ2V0TGVuZ3RocygpLGk9MCxyPW4ubGVuZ3RoLGE7ZT9hPWU6YT10Km5bci0xXTtsZXQgbz0wLGw9ci0xLGM7Zm9yKDtvPD1sOylpZihpPU1hdGguZmxvb3IobysobC1vKS8yKSxjPW5baV0tYSxjPDApbz1pKzE7ZWxzZSBpZihjPjApbD1pLTE7ZWxzZXtsPWk7YnJlYWt9aWYoaT1sLG5baV09PT1hKXJldHVybiBpLyhyLTEpO2xldCBoPW5baV0sZD1uW2krMV0taCxmPShhLWgpL2Q7cmV0dXJuKGkrZikvKHItMSl9Z2V0VGFuZ2VudCh0LGUpe2xldCBpPXQtMWUtNCxyPXQrMWUtNDtpPDAmJihpPTApLHI+MSYmKHI9MSk7bGV0IGE9dGhpcy5nZXRQb2ludChpKSxvPXRoaXMuZ2V0UG9pbnQociksbD1lfHwoYS5pc1ZlY3RvcjI/bmV3IFo6bmV3IFIpO3JldHVybiBsLmNvcHkobykuc3ViKGEpLm5vcm1hbGl6ZSgpLGx9Z2V0VGFuZ2VudEF0KHQsZSl7bGV0IG49dGhpcy5nZXRVdG9UbWFwcGluZyh0KTtyZXR1cm4gdGhpcy5nZXRUYW5nZW50KG4sZSl9Y29tcHV0ZUZyZW5ldEZyYW1lcyh0LGUpe2xldCBuPW5ldyBSLGk9W10scj1bXSxhPVtdLG89bmV3IFIsbD1uZXcgTHQ7Zm9yKGxldCBmPTA7Zjw9dDtmKyspe2xldCBtPWYvdDtpW2ZdPXRoaXMuZ2V0VGFuZ2VudEF0KG0sbmV3IFIpfXJbMF09bmV3IFIsYVswXT1uZXcgUjtsZXQgYz1OdW1iZXIuTUFYX1ZBTFVFLGg9TWF0aC5hYnMoaVswXS54KSx1PU1hdGguYWJzKGlbMF0ueSksZD1NYXRoLmFicyhpWzBdLnopO2g8PWMmJihjPWgsbi5zZXQoMSwwLDApKSx1PD1jJiYoYz11LG4uc2V0KDAsMSwwKSksZDw9YyYmbi5zZXQoMCwwLDEpLG8uY3Jvc3NWZWN0b3JzKGlbMF0sbikubm9ybWFsaXplKCksclswXS5jcm9zc1ZlY3RvcnMoaVswXSxvKSxhWzBdLmNyb3NzVmVjdG9ycyhpWzBdLHJbMF0pO2ZvcihsZXQgZj0xO2Y8PXQ7ZisrKXtpZihyW2ZdPXJbZi0xXS5jbG9uZSgpLGFbZl09YVtmLTFdLmNsb25lKCksby5jcm9zc1ZlY3RvcnMoaVtmLTFdLGlbZl0pLG8ubGVuZ3RoKCk+TnVtYmVyLkVQU0lMT04pe28ubm9ybWFsaXplKCk7bGV0IG09TWF0aC5hY29zKHVlKGlbZi0xXS5kb3QoaVtmXSksLTEsMSkpO3JbZl0uYXBwbHlNYXRyaXg0KGwubWFrZVJvdGF0aW9uQXhpcyhvLG0pKX1hW2ZdLmNyb3NzVmVjdG9ycyhpW2ZdLHJbZl0pfWlmKGU9PT0hMCl7bGV0IGY9TWF0aC5hY29zKHVlKHJbMF0uZG90KHJbdF0pLC0xLDEpKTtmLz10LGlbMF0uZG90KG8uY3Jvc3NWZWN0b3JzKHJbMF0sclt0XSkpPjAmJihmPS1mKTtmb3IobGV0IG09MTttPD10O20rKylyW21dLmFwcGx5TWF0cml4NChsLm1ha2VSb3RhdGlvbkF4aXMoaVttXSxmKm0pKSxhW21dLmNyb3NzVmVjdG9ycyhpW21dLHJbbV0pfXJldHVybnt0YW5nZW50czppLG5vcm1hbHM6cixiaW5vcm1hbHM6YX19Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpfWNvcHkodCl7cmV0dXJuIHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zPXQuYXJjTGVuZ3RoRGl2aXNpb25zLHRoaXN9dG9KU09OKCl7bGV0IHQ9e21ldGFkYXRhOnt2ZXJzaW9uOjQuNix0eXBlOiJDdXJ2ZSIsZ2VuZXJhdG9yOiJDdXJ2ZS50b0pTT04ifX07cmV0dXJuIHQuYXJjTGVuZ3RoRGl2aXNpb25zPXRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zLHQudHlwZT10aGlzLnR5cGUsdH1mcm9tSlNPTih0KXtyZXR1cm4gdGhpcy5hcmNMZW5ndGhEaXZpc2lvbnM9dC5hcmNMZW5ndGhEaXZpc2lvbnMsdGhpc319LEVzPWNsYXNzIGV4dGVuZHMgJGV7Y29uc3RydWN0b3IodD0wLGU9MCxuPTEsaT0xLHI9MCxhPU1hdGguUEkqMixvPSExLGw9MCl7c3VwZXIoKSx0aGlzLmlzRWxsaXBzZUN1cnZlPSEwLHRoaXMudHlwZT0iRWxsaXBzZUN1cnZlIix0aGlzLmFYPXQsdGhpcy5hWT1lLHRoaXMueFJhZGl1cz1uLHRoaXMueVJhZGl1cz1pLHRoaXMuYVN0YXJ0QW5nbGU9cix0aGlzLmFFbmRBbmdsZT1hLHRoaXMuYUNsb2Nrd2lzZT1vLHRoaXMuYVJvdGF0aW9uPWx9Z2V0UG9pbnQodCxlKXtsZXQgbj1lfHxuZXcgWixpPU1hdGguUEkqMixyPXRoaXMuYUVuZEFuZ2xlLXRoaXMuYVN0YXJ0QW5nbGUsYT1NYXRoLmFicyhyKTxOdW1iZXIuRVBTSUxPTjtmb3IoO3I8MDspcis9aTtmb3IoO3I+aTspci09aTtyPE51bWJlci5FUFNJTE9OJiYoYT9yPTA6cj1pKSx0aGlzLmFDbG9ja3dpc2U9PT0hMCYmIWEmJihyPT09aT9yPS1pOnI9ci1pKTtsZXQgbz10aGlzLmFTdGFydEFuZ2xlK3QqcixsPXRoaXMuYVgrdGhpcy54UmFkaXVzKk1hdGguY29zKG8pLGM9dGhpcy5hWSt0aGlzLnlSYWRpdXMqTWF0aC5zaW4obyk7aWYodGhpcy5hUm90YXRpb24hPT0wKXtsZXQgaD1NYXRoLmNvcyh0aGlzLmFSb3RhdGlvbiksdT1NYXRoLnNpbih0aGlzLmFSb3RhdGlvbiksZD1sLXRoaXMuYVgsZj1jLXRoaXMuYVk7bD1kKmgtZip1K3RoaXMuYVgsYz1kKnUrZipoK3RoaXMuYVl9cmV0dXJuIG4uc2V0KGwsYyl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLmFYPXQuYVgsdGhpcy5hWT10LmFZLHRoaXMueFJhZGl1cz10LnhSYWRpdXMsdGhpcy55UmFkaXVzPXQueVJhZGl1cyx0aGlzLmFTdGFydEFuZ2xlPXQuYVN0YXJ0QW5nbGUsdGhpcy5hRW5kQW5nbGU9dC5hRW5kQW5nbGUsdGhpcy5hQ2xvY2t3aXNlPXQuYUNsb2Nrd2lzZSx0aGlzLmFSb3RhdGlvbj10LmFSb3RhdGlvbix0aGlzfXRvSlNPTigpe2xldCB0PXN1cGVyLnRvSlNPTigpO3JldHVybiB0LmFYPXRoaXMuYVgsdC5hWT10aGlzLmFZLHQueFJhZGl1cz10aGlzLnhSYWRpdXMsdC55UmFkaXVzPXRoaXMueVJhZGl1cyx0LmFTdGFydEFuZ2xlPXRoaXMuYVN0YXJ0QW5nbGUsdC5hRW5kQW5nbGU9dGhpcy5hRW5kQW5nbGUsdC5hQ2xvY2t3aXNlPXRoaXMuYUNsb2Nrd2lzZSx0LmFSb3RhdGlvbj10aGlzLmFSb3RhdGlvbix0fWZyb21KU09OKHQpe3JldHVybiBzdXBlci5mcm9tSlNPTih0KSx0aGlzLmFYPXQuYVgsdGhpcy5hWT10LmFZLHRoaXMueFJhZGl1cz10LnhSYWRpdXMsdGhpcy55UmFkaXVzPXQueVJhZGl1cyx0aGlzLmFTdGFydEFuZ2xlPXQuYVN0YXJ0QW5nbGUsdGhpcy5hRW5kQW5nbGU9dC5hRW5kQW5nbGUsdGhpcy5hQ2xvY2t3aXNlPXQuYUNsb2Nrd2lzZSx0aGlzLmFSb3RhdGlvbj10LmFSb3RhdGlvbix0aGlzfX0scm89Y2xhc3MgZXh0ZW5kcyBFc3tjb25zdHJ1Y3Rvcih0LGUsbixpLHIsYSl7c3VwZXIodCxlLG4sbixpLHIsYSksdGhpcy5pc0FyY0N1cnZlPSEwLHRoaXMudHlwZT0iQXJjQ3VydmUifX07ZnVuY3Rpb24gc3UoKXtsZXQgcz0wLHQ9MCxlPTAsbj0wO2Z1bmN0aW9uIGkocixhLG8sbCl7cz1yLHQ9byxlPS0zKnIrMyphLTIqby1sLG49MipyLTIqYStvK2x9cmV0dXJue2luaXRDYXRtdWxsUm9tOmZ1bmN0aW9uKHIsYSxvLGwsYyl7aShhLG8sYyooby1yKSxjKihsLWEpKX0saW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tOmZ1bmN0aW9uKHIsYSxvLGwsYyxoLHUpe2xldCBkPShhLXIpL2MtKG8tcikvKGMraCkrKG8tYSkvaCxmPShvLWEpL2gtKGwtYSkvKGgrdSkrKGwtbykvdTtkKj1oLGYqPWgsaShhLG8sZCxmKX0sY2FsYzpmdW5jdGlvbihyKXtsZXQgYT1yKnIsbz1hKnI7cmV0dXJuIHMrdCpyK2UqYStuKm99fX12YXIgeGE9bmV3IFIsemw9bmV3IHN1LFZsPW5ldyBzdSxrbD1uZXcgc3UsYW89Y2xhc3MgZXh0ZW5kcyAkZXtjb25zdHJ1Y3Rvcih0PVtdLGU9ITEsbj0iY2VudHJpcGV0YWwiLGk9LjUpe3N1cGVyKCksdGhpcy5pc0NhdG11bGxSb21DdXJ2ZTM9ITAsdGhpcy50eXBlPSJDYXRtdWxsUm9tQ3VydmUzIix0aGlzLnBvaW50cz10LHRoaXMuY2xvc2VkPWUsdGhpcy5jdXJ2ZVR5cGU9bix0aGlzLnRlbnNpb249aX1nZXRQb2ludCh0LGU9bmV3IFIpe2xldCBuPWUsaT10aGlzLnBvaW50cyxyPWkubGVuZ3RoLGE9KHItKHRoaXMuY2xvc2VkPzA6MSkpKnQsbz1NYXRoLmZsb29yKGEpLGw9YS1vO3RoaXMuY2xvc2VkP28rPW8+MD8wOihNYXRoLmZsb29yKE1hdGguYWJzKG8pL3IpKzEpKnI6bD09PTAmJm89PT1yLTEmJihvPXItMixsPTEpO2xldCBjLGg7dGhpcy5jbG9zZWR8fG8+MD9jPWlbKG8tMSklcl06KHhhLnN1YlZlY3RvcnMoaVswXSxpWzFdKS5hZGQoaVswXSksYz14YSk7bGV0IHU9aVtvJXJdLGQ9aVsobysxKSVyXTtpZih0aGlzLmNsb3NlZHx8bysyPHI/aD1pWyhvKzIpJXJdOih4YS5zdWJWZWN0b3JzKGlbci0xXSxpW3ItMl0pLmFkZChpW3ItMV0pLGg9eGEpLHRoaXMuY3VydmVUeXBlPT09ImNlbnRyaXBldGFsInx8dGhpcy5jdXJ2ZVR5cGU9PT0iY2hvcmRhbCIpe2xldCBmPXRoaXMuY3VydmVUeXBlPT09ImNob3JkYWwiPy41Oi4yNSxtPU1hdGgucG93KGMuZGlzdGFuY2VUb1NxdWFyZWQodSksZiksXz1NYXRoLnBvdyh1LmRpc3RhbmNlVG9TcXVhcmVkKGQpLGYpLGc9TWF0aC5wb3coZC5kaXN0YW5jZVRvU3F1YXJlZChoKSxmKTtfPDFlLTQmJihfPTEpLG08MWUtNCYmKG09XyksZzwxZS00JiYoZz1fKSx6bC5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oYy54LHUueCxkLngsaC54LG0sXyxnKSxWbC5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oYy55LHUueSxkLnksaC55LG0sXyxnKSxrbC5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oYy56LHUueixkLnosaC56LG0sXyxnKX1lbHNlIHRoaXMuY3VydmVUeXBlPT09ImNhdG11bGxyb20iJiYoemwuaW5pdENhdG11bGxSb20oYy54LHUueCxkLngsaC54LHRoaXMudGVuc2lvbiksVmwuaW5pdENhdG11bGxSb20oYy55LHUueSxkLnksaC55LHRoaXMudGVuc2lvbiksa2wuaW5pdENhdG11bGxSb20oYy56LHUueixkLnosaC56LHRoaXMudGVuc2lvbikpO3JldHVybiBuLnNldCh6bC5jYWxjKGwpLFZsLmNhbGMobCksa2wuY2FsYyhsKSksbn1jb3B5KHQpe3N1cGVyLmNvcHkodCksdGhpcy5wb2ludHM9W107Zm9yKGxldCBlPTAsbj10LnBvaW50cy5sZW5ndGg7ZTxuO2UrKyl7bGV0IGk9dC5wb2ludHNbZV07dGhpcy5wb2ludHMucHVzaChpLmNsb25lKCkpfXJldHVybiB0aGlzLmNsb3NlZD10LmNsb3NlZCx0aGlzLmN1cnZlVHlwZT10LmN1cnZlVHlwZSx0aGlzLnRlbnNpb249dC50ZW5zaW9uLHRoaXN9dG9KU09OKCl7bGV0IHQ9c3VwZXIudG9KU09OKCk7dC5wb2ludHM9W107Zm9yKGxldCBlPTAsbj10aGlzLnBvaW50cy5sZW5ndGg7ZTxuO2UrKyl7bGV0IGk9dGhpcy5wb2ludHNbZV07dC5wb2ludHMucHVzaChpLnRvQXJyYXkoKSl9cmV0dXJuIHQuY2xvc2VkPXRoaXMuY2xvc2VkLHQuY3VydmVUeXBlPXRoaXMuY3VydmVUeXBlLHQudGVuc2lvbj10aGlzLnRlbnNpb24sdH1mcm9tSlNPTih0KXtzdXBlci5mcm9tSlNPTih0KSx0aGlzLnBvaW50cz1bXTtmb3IobGV0IGU9MCxuPXQucG9pbnRzLmxlbmd0aDtlPG47ZSsrKXtsZXQgaT10LnBvaW50c1tlXTt0aGlzLnBvaW50cy5wdXNoKG5ldyBSKCkuZnJvbUFycmF5KGkpKX1yZXR1cm4gdGhpcy5jbG9zZWQ9dC5jbG9zZWQsdGhpcy5jdXJ2ZVR5cGU9dC5jdXJ2ZVR5cGUsdGhpcy50ZW5zaW9uPXQudGVuc2lvbix0aGlzfX07ZnVuY3Rpb24geWQocyx0LGUsbixpKXtsZXQgcj0obi10KSouNSxhPShpLWUpKi41LG89cypzLGw9cypvO3JldHVybigyKmUtMipuK3IrYSkqbCsoLTMqZSszKm4tMipyLWEpKm8rcipzK2V9ZnVuY3Rpb24gTXYocyx0KXtsZXQgZT0xLXM7cmV0dXJuIGUqZSp0fWZ1bmN0aW9uIFN2KHMsdCl7cmV0dXJuIDIqKDEtcykqcyp0fWZ1bmN0aW9uIGJ2KHMsdCl7cmV0dXJuIHMqcyp0fWZ1bmN0aW9uIFdzKHMsdCxlLG4pe3JldHVybiBNdihzLHQpK1N2KHMsZSkrYnYocyxuKX1mdW5jdGlvbiBFdihzLHQpe2xldCBlPTEtcztyZXR1cm4gZSplKmUqdH1mdW5jdGlvbiBBdihzLHQpe2xldCBlPTEtcztyZXR1cm4gMyplKmUqcyp0fWZ1bmN0aW9uIFR2KHMsdCl7cmV0dXJuIDMqKDEtcykqcypzKnR9ZnVuY3Rpb24gd3Yocyx0KXtyZXR1cm4gcypzKnMqdH1mdW5jdGlvbiBYcyhzLHQsZSxuLGkpe3JldHVybiBFdihzLHQpK0F2KHMsZSkrVHYocyxuKSt3dihzLGkpfXZhciB4cj1jbGFzcyBleHRlbmRzICRle2NvbnN0cnVjdG9yKHQ9bmV3IFosZT1uZXcgWixuPW5ldyBaLGk9bmV3IFope3N1cGVyKCksdGhpcy5pc0N1YmljQmV6aWVyQ3VydmU9ITAsdGhpcy50eXBlPSJDdWJpY0JlemllckN1cnZlIix0aGlzLnYwPXQsdGhpcy52MT1lLHRoaXMudjI9bix0aGlzLnYzPWl9Z2V0UG9pbnQodCxlPW5ldyBaKXtsZXQgbj1lLGk9dGhpcy52MCxyPXRoaXMudjEsYT10aGlzLnYyLG89dGhpcy52MztyZXR1cm4gbi5zZXQoWHModCxpLngsci54LGEueCxvLngpLFhzKHQsaS55LHIueSxhLnksby55KSksbn1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMudjAuY29weSh0LnYwKSx0aGlzLnYxLmNvcHkodC52MSksdGhpcy52Mi5jb3B5KHQudjIpLHRoaXMudjMuY29weSh0LnYzKSx0aGlzfXRvSlNPTigpe2xldCB0PXN1cGVyLnRvSlNPTigpO3JldHVybiB0LnYwPXRoaXMudjAudG9BcnJheSgpLHQudjE9dGhpcy52MS50b0FycmF5KCksdC52Mj10aGlzLnYyLnRvQXJyYXkoKSx0LnYzPXRoaXMudjMudG9BcnJheSgpLHR9ZnJvbUpTT04odCl7cmV0dXJuIHN1cGVyLmZyb21KU09OKHQpLHRoaXMudjAuZnJvbUFycmF5KHQudjApLHRoaXMudjEuZnJvbUFycmF5KHQudjEpLHRoaXMudjIuZnJvbUFycmF5KHQudjIpLHRoaXMudjMuZnJvbUFycmF5KHQudjMpLHRoaXN9fSxvbz1jbGFzcyBleHRlbmRzICRle2NvbnN0cnVjdG9yKHQ9bmV3IFIsZT1uZXcgUixuPW5ldyBSLGk9bmV3IFIpe3N1cGVyKCksdGhpcy5pc0N1YmljQmV6aWVyQ3VydmUzPSEwLHRoaXMudHlwZT0iQ3ViaWNCZXppZXJDdXJ2ZTMiLHRoaXMudjA9dCx0aGlzLnYxPWUsdGhpcy52Mj1uLHRoaXMudjM9aX1nZXRQb2ludCh0LGU9bmV3IFIpe2xldCBuPWUsaT10aGlzLnYwLHI9dGhpcy52MSxhPXRoaXMudjIsbz10aGlzLnYzO3JldHVybiBuLnNldChYcyh0LGkueCxyLngsYS54LG8ueCksWHModCxpLnksci55LGEueSxvLnkpLFhzKHQsaS56LHIueixhLnosby56KSksbn1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMudjAuY29weSh0LnYwKSx0aGlzLnYxLmNvcHkodC52MSksdGhpcy52Mi5jb3B5KHQudjIpLHRoaXMudjMuY29weSh0LnYzKSx0aGlzfXRvSlNPTigpe2xldCB0PXN1cGVyLnRvSlNPTigpO3JldHVybiB0LnYwPXRoaXMudjAudG9BcnJheSgpLHQudjE9dGhpcy52MS50b0FycmF5KCksdC52Mj10aGlzLnYyLnRvQXJyYXkoKSx0LnYzPXRoaXMudjMudG9BcnJheSgpLHR9ZnJvbUpTT04odCl7cmV0dXJuIHN1cGVyLmZyb21KU09OKHQpLHRoaXMudjAuZnJvbUFycmF5KHQudjApLHRoaXMudjEuZnJvbUFycmF5KHQudjEpLHRoaXMudjIuZnJvbUFycmF5KHQudjIpLHRoaXMudjMuZnJvbUFycmF5KHQudjMpLHRoaXN9fSx2cj1jbGFzcyBleHRlbmRzICRle2NvbnN0cnVjdG9yKHQ9bmV3IFosZT1uZXcgWil7c3VwZXIoKSx0aGlzLmlzTGluZUN1cnZlPSEwLHRoaXMudHlwZT0iTGluZUN1cnZlIix0aGlzLnYxPXQsdGhpcy52Mj1lfWdldFBvaW50KHQsZT1uZXcgWil7bGV0IG49ZTtyZXR1cm4gdD09PTE/bi5jb3B5KHRoaXMudjIpOihuLmNvcHkodGhpcy52Mikuc3ViKHRoaXMudjEpLG4ubXVsdGlwbHlTY2FsYXIodCkuYWRkKHRoaXMudjEpKSxufWdldFBvaW50QXQodCxlKXtyZXR1cm4gdGhpcy5nZXRQb2ludCh0LGUpfWdldFRhbmdlbnQodCxlPW5ldyBaKXtyZXR1cm4gZS5zdWJWZWN0b3JzKHRoaXMudjIsdGhpcy52MSkubm9ybWFsaXplKCl9Z2V0VGFuZ2VudEF0KHQsZSl7cmV0dXJuIHRoaXMuZ2V0VGFuZ2VudCh0LGUpfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy52MS5jb3B5KHQudjEpLHRoaXMudjIuY29weSh0LnYyKSx0aGlzfXRvSlNPTigpe2xldCB0PXN1cGVyLnRvSlNPTigpO3JldHVybiB0LnYxPXRoaXMudjEudG9BcnJheSgpLHQudjI9dGhpcy52Mi50b0FycmF5KCksdH1mcm9tSlNPTih0KXtyZXR1cm4gc3VwZXIuZnJvbUpTT04odCksdGhpcy52MS5mcm9tQXJyYXkodC52MSksdGhpcy52Mi5mcm9tQXJyYXkodC52MiksdGhpc319LGxvPWNsYXNzIGV4dGVuZHMgJGV7Y29uc3RydWN0b3IodD1uZXcgUixlPW5ldyBSKXtzdXBlcigpLHRoaXMuaXNMaW5lQ3VydmUzPSEwLHRoaXMudHlwZT0iTGluZUN1cnZlMyIsdGhpcy52MT10LHRoaXMudjI9ZX1nZXRQb2ludCh0LGU9bmV3IFIpe2xldCBuPWU7cmV0dXJuIHQ9PT0xP24uY29weSh0aGlzLnYyKToobi5jb3B5KHRoaXMudjIpLnN1Yih0aGlzLnYxKSxuLm11bHRpcGx5U2NhbGFyKHQpLmFkZCh0aGlzLnYxKSksbn1nZXRQb2ludEF0KHQsZSl7cmV0dXJuIHRoaXMuZ2V0UG9pbnQodCxlKX1nZXRUYW5nZW50KHQsZT1uZXcgUil7cmV0dXJuIGUuc3ViVmVjdG9ycyh0aGlzLnYyLHRoaXMudjEpLm5vcm1hbGl6ZSgpfWdldFRhbmdlbnRBdCh0LGUpe3JldHVybiB0aGlzLmdldFRhbmdlbnQodCxlKX1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMudjEuY29weSh0LnYxKSx0aGlzLnYyLmNvcHkodC52MiksdGhpc310b0pTT04oKXtsZXQgdD1zdXBlci50b0pTT04oKTtyZXR1cm4gdC52MT10aGlzLnYxLnRvQXJyYXkoKSx0LnYyPXRoaXMudjIudG9BcnJheSgpLHR9ZnJvbUpTT04odCl7cmV0dXJuIHN1cGVyLmZyb21KU09OKHQpLHRoaXMudjEuZnJvbUFycmF5KHQudjEpLHRoaXMudjIuZnJvbUFycmF5KHQudjIpLHRoaXN9fSx5cj1jbGFzcyBleHRlbmRzICRle2NvbnN0cnVjdG9yKHQ9bmV3IFosZT1uZXcgWixuPW5ldyBaKXtzdXBlcigpLHRoaXMuaXNRdWFkcmF0aWNCZXppZXJDdXJ2ZT0hMCx0aGlzLnR5cGU9IlF1YWRyYXRpY0JlemllckN1cnZlIix0aGlzLnYwPXQsdGhpcy52MT1lLHRoaXMudjI9bn1nZXRQb2ludCh0LGU9bmV3IFope2xldCBuPWUsaT10aGlzLnYwLHI9dGhpcy52MSxhPXRoaXMudjI7cmV0dXJuIG4uc2V0KFdzKHQsaS54LHIueCxhLngpLFdzKHQsaS55LHIueSxhLnkpKSxufWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy52MC5jb3B5KHQudjApLHRoaXMudjEuY29weSh0LnYxKSx0aGlzLnYyLmNvcHkodC52MiksdGhpc310b0pTT04oKXtsZXQgdD1zdXBlci50b0pTT04oKTtyZXR1cm4gdC52MD10aGlzLnYwLnRvQXJyYXkoKSx0LnYxPXRoaXMudjEudG9BcnJheSgpLHQudjI9dGhpcy52Mi50b0FycmF5KCksdH1mcm9tSlNPTih0KXtyZXR1cm4gc3VwZXIuZnJvbUpTT04odCksdGhpcy52MC5mcm9tQXJyYXkodC52MCksdGhpcy52MS5mcm9tQXJyYXkodC52MSksdGhpcy52Mi5mcm9tQXJyYXkodC52MiksdGhpc319LE1yPWNsYXNzIGV4dGVuZHMgJGV7Y29uc3RydWN0b3IodD1uZXcgUixlPW5ldyBSLG49bmV3IFIpe3N1cGVyKCksdGhpcy5pc1F1YWRyYXRpY0JlemllckN1cnZlMz0hMCx0aGlzLnR5cGU9IlF1YWRyYXRpY0JlemllckN1cnZlMyIsdGhpcy52MD10LHRoaXMudjE9ZSx0aGlzLnYyPW59Z2V0UG9pbnQodCxlPW5ldyBSKXtsZXQgbj1lLGk9dGhpcy52MCxyPXRoaXMudjEsYT10aGlzLnYyO3JldHVybiBuLnNldChXcyh0LGkueCxyLngsYS54KSxXcyh0LGkueSxyLnksYS55KSxXcyh0LGkueixyLnosYS56KSksbn1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMudjAuY29weSh0LnYwKSx0aGlzLnYxLmNvcHkodC52MSksdGhpcy52Mi5jb3B5KHQudjIpLHRoaXN9dG9KU09OKCl7bGV0IHQ9c3VwZXIudG9KU09OKCk7cmV0dXJuIHQudjA9dGhpcy52MC50b0FycmF5KCksdC52MT10aGlzLnYxLnRvQXJyYXkoKSx0LnYyPXRoaXMudjIudG9BcnJheSgpLHR9ZnJvbUpTT04odCl7cmV0dXJuIHN1cGVyLmZyb21KU09OKHQpLHRoaXMudjAuZnJvbUFycmF5KHQudjApLHRoaXMudjEuZnJvbUFycmF5KHQudjEpLHRoaXMudjIuZnJvbUFycmF5KHQudjIpLHRoaXN9fSxTcj1jbGFzcyBleHRlbmRzICRle2NvbnN0cnVjdG9yKHQ9W10pe3N1cGVyKCksdGhpcy5pc1NwbGluZUN1cnZlPSEwLHRoaXMudHlwZT0iU3BsaW5lQ3VydmUiLHRoaXMucG9pbnRzPXR9Z2V0UG9pbnQodCxlPW5ldyBaKXtsZXQgbj1lLGk9dGhpcy5wb2ludHMscj0oaS5sZW5ndGgtMSkqdCxhPU1hdGguZmxvb3Iociksbz1yLWEsbD1pW2E9PT0wP2E6YS0xXSxjPWlbYV0saD1pW2E+aS5sZW5ndGgtMj9pLmxlbmd0aC0xOmErMV0sdT1pW2E+aS5sZW5ndGgtMz9pLmxlbmd0aC0xOmErMl07cmV0dXJuIG4uc2V0KHlkKG8sbC54LGMueCxoLngsdS54KSx5ZChvLGwueSxjLnksaC55LHUueSkpLG59Y29weSh0KXtzdXBlci5jb3B5KHQpLHRoaXMucG9pbnRzPVtdO2ZvcihsZXQgZT0wLG49dC5wb2ludHMubGVuZ3RoO2U8bjtlKyspe2xldCBpPXQucG9pbnRzW2VdO3RoaXMucG9pbnRzLnB1c2goaS5jbG9uZSgpKX1yZXR1cm4gdGhpc310b0pTT04oKXtsZXQgdD1zdXBlci50b0pTT04oKTt0LnBvaW50cz1bXTtmb3IobGV0IGU9MCxuPXRoaXMucG9pbnRzLmxlbmd0aDtlPG47ZSsrKXtsZXQgaT10aGlzLnBvaW50c1tlXTt0LnBvaW50cy5wdXNoKGkudG9BcnJheSgpKX1yZXR1cm4gdH1mcm9tSlNPTih0KXtzdXBlci5mcm9tSlNPTih0KSx0aGlzLnBvaW50cz1bXTtmb3IobGV0IGU9MCxuPXQucG9pbnRzLmxlbmd0aDtlPG47ZSsrKXtsZXQgaT10LnBvaW50c1tlXTt0aGlzLnBvaW50cy5wdXNoKG5ldyBaKCkuZnJvbUFycmF5KGkpKX1yZXR1cm4gdGhpc319LGNvPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEFyY0N1cnZlOnJvLENhdG11bGxSb21DdXJ2ZTM6YW8sQ3ViaWNCZXppZXJDdXJ2ZTp4cixDdWJpY0JlemllckN1cnZlMzpvbyxFbGxpcHNlQ3VydmU6RXMsTGluZUN1cnZlOnZyLExpbmVDdXJ2ZTM6bG8sUXVhZHJhdGljQmV6aWVyQ3VydmU6eXIsUXVhZHJhdGljQmV6aWVyQ3VydmUzOk1yLFNwbGluZUN1cnZlOlNyfSksaG89Y2xhc3MgZXh0ZW5kcyAkZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy50eXBlPSJDdXJ2ZVBhdGgiLHRoaXMuY3VydmVzPVtdLHRoaXMuYXV0b0Nsb3NlPSExfWFkZCh0KXt0aGlzLmN1cnZlcy5wdXNoKHQpfWNsb3NlUGF0aCgpe2xldCB0PXRoaXMuY3VydmVzWzBdLmdldFBvaW50KDApLGU9dGhpcy5jdXJ2ZXNbdGhpcy5jdXJ2ZXMubGVuZ3RoLTFdLmdldFBvaW50KDEpO2lmKCF0LmVxdWFscyhlKSl7bGV0IG49dC5pc1ZlY3RvcjI9PT0hMD8iTGluZUN1cnZlIjoiTGluZUN1cnZlMyI7dGhpcy5jdXJ2ZXMucHVzaChuZXcgY29bbl0oZSx0KSl9cmV0dXJuIHRoaXN9Z2V0UG9pbnQodCxlKXtsZXQgbj10KnRoaXMuZ2V0TGVuZ3RoKCksaT10aGlzLmdldEN1cnZlTGVuZ3RocygpLHI9MDtmb3IoO3I8aS5sZW5ndGg7KXtpZihpW3JdPj1uKXtsZXQgYT1pW3JdLW4sbz10aGlzLmN1cnZlc1tyXSxsPW8uZ2V0TGVuZ3RoKCksYz1sPT09MD8wOjEtYS9sO3JldHVybiBvLmdldFBvaW50QXQoYyxlKX1yKyt9cmV0dXJuIG51bGx9Z2V0TGVuZ3RoKCl7bGV0IHQ9dGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtyZXR1cm4gdFt0Lmxlbmd0aC0xXX11cGRhdGVBcmNMZW5ndGhzKCl7dGhpcy5uZWVkc1VwZGF0ZT0hMCx0aGlzLmNhY2hlTGVuZ3Rocz1udWxsLHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCl9Z2V0Q3VydmVMZW5ndGhzKCl7aWYodGhpcy5jYWNoZUxlbmd0aHMmJnRoaXMuY2FjaGVMZW5ndGhzLmxlbmd0aD09PXRoaXMuY3VydmVzLmxlbmd0aClyZXR1cm4gdGhpcy5jYWNoZUxlbmd0aHM7bGV0IHQ9W10sZT0wO2ZvcihsZXQgbj0wLGk9dGhpcy5jdXJ2ZXMubGVuZ3RoO248aTtuKyspZSs9dGhpcy5jdXJ2ZXNbbl0uZ2V0TGVuZ3RoKCksdC5wdXNoKGUpO3JldHVybiB0aGlzLmNhY2hlTGVuZ3Rocz10LHR9Z2V0U3BhY2VkUG9pbnRzKHQ9NDApe2xldCBlPVtdO2ZvcihsZXQgbj0wO248PXQ7bisrKWUucHVzaCh0aGlzLmdldFBvaW50KG4vdCkpO3JldHVybiB0aGlzLmF1dG9DbG9zZSYmZS5wdXNoKGVbMF0pLGV9Z2V0UG9pbnRzKHQ9MTIpe2xldCBlPVtdLG47Zm9yKGxldCBpPTAscj10aGlzLmN1cnZlcztpPHIubGVuZ3RoO2krKyl7bGV0IGE9cltpXSxvPWEuaXNFbGxpcHNlQ3VydmU/dCoyOmEuaXNMaW5lQ3VydmV8fGEuaXNMaW5lQ3VydmUzPzE6YS5pc1NwbGluZUN1cnZlP3QqYS5wb2ludHMubGVuZ3RoOnQsbD1hLmdldFBvaW50cyhvKTtmb3IobGV0IGM9MDtjPGwubGVuZ3RoO2MrKyl7bGV0IGg9bFtjXTtuJiZuLmVxdWFscyhoKXx8KGUucHVzaChoKSxuPWgpfX1yZXR1cm4gdGhpcy5hdXRvQ2xvc2UmJmUubGVuZ3RoPjEmJiFlW2UubGVuZ3RoLTFdLmVxdWFscyhlWzBdKSYmZS5wdXNoKGVbMF0pLGV9Y29weSh0KXtzdXBlci5jb3B5KHQpLHRoaXMuY3VydmVzPVtdO2ZvcihsZXQgZT0wLG49dC5jdXJ2ZXMubGVuZ3RoO2U8bjtlKyspe2xldCBpPXQuY3VydmVzW2VdO3RoaXMuY3VydmVzLnB1c2goaS5jbG9uZSgpKX1yZXR1cm4gdGhpcy5hdXRvQ2xvc2U9dC5hdXRvQ2xvc2UsdGhpc310b0pTT04oKXtsZXQgdD1zdXBlci50b0pTT04oKTt0LmF1dG9DbG9zZT10aGlzLmF1dG9DbG9zZSx0LmN1cnZlcz1bXTtmb3IobGV0IGU9MCxuPXRoaXMuY3VydmVzLmxlbmd0aDtlPG47ZSsrKXtsZXQgaT10aGlzLmN1cnZlc1tlXTt0LmN1cnZlcy5wdXNoKGkudG9KU09OKCkpfXJldHVybiB0fWZyb21KU09OKHQpe3N1cGVyLmZyb21KU09OKHQpLHRoaXMuYXV0b0Nsb3NlPXQuYXV0b0Nsb3NlLHRoaXMuY3VydmVzPVtdO2ZvcihsZXQgZT0wLG49dC5jdXJ2ZXMubGVuZ3RoO2U8bjtlKyspe2xldCBpPXQuY3VydmVzW2VdO3RoaXMuY3VydmVzLnB1c2gobmV3IGNvW2kudHlwZV0oKS5mcm9tSlNPTihpKSl9cmV0dXJuIHRoaXN9fSxEaT1jbGFzcyBleHRlbmRzIGhve2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy50eXBlPSJQYXRoIix0aGlzLmN1cnJlbnRQb2ludD1uZXcgWix0JiZ0aGlzLnNldEZyb21Qb2ludHModCl9c2V0RnJvbVBvaW50cyh0KXt0aGlzLm1vdmVUbyh0WzBdLngsdFswXS55KTtmb3IobGV0IGU9MSxuPXQubGVuZ3RoO2U8bjtlKyspdGhpcy5saW5lVG8odFtlXS54LHRbZV0ueSk7cmV0dXJuIHRoaXN9bW92ZVRvKHQsZSl7cmV0dXJuIHRoaXMuY3VycmVudFBvaW50LnNldCh0LGUpLHRoaXN9bGluZVRvKHQsZSl7bGV0IG49bmV3IHZyKHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksbmV3IFoodCxlKSk7cmV0dXJuIHRoaXMuY3VydmVzLnB1c2gobiksdGhpcy5jdXJyZW50UG9pbnQuc2V0KHQsZSksdGhpc31xdWFkcmF0aWNDdXJ2ZVRvKHQsZSxuLGkpe2xldCByPW5ldyB5cih0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpLG5ldyBaKHQsZSksbmV3IFoobixpKSk7cmV0dXJuIHRoaXMuY3VydmVzLnB1c2gociksdGhpcy5jdXJyZW50UG9pbnQuc2V0KG4saSksdGhpc31iZXppZXJDdXJ2ZVRvKHQsZSxuLGkscixhKXtsZXQgbz1uZXcgeHIodGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSxuZXcgWih0LGUpLG5ldyBaKG4saSksbmV3IFoocixhKSk7cmV0dXJuIHRoaXMuY3VydmVzLnB1c2gobyksdGhpcy5jdXJyZW50UG9pbnQuc2V0KHIsYSksdGhpc31zcGxpbmVUaHJ1KHQpe2xldCBlPVt0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpXS5jb25jYXQodCksbj1uZXcgU3IoZSk7cmV0dXJuIHRoaXMuY3VydmVzLnB1c2gobiksdGhpcy5jdXJyZW50UG9pbnQuY29weSh0W3QubGVuZ3RoLTFdKSx0aGlzfWFyYyh0LGUsbixpLHIsYSl7bGV0IG89dGhpcy5jdXJyZW50UG9pbnQueCxsPXRoaXMuY3VycmVudFBvaW50Lnk7cmV0dXJuIHRoaXMuYWJzYXJjKHQrbyxlK2wsbixpLHIsYSksdGhpc31hYnNhcmModCxlLG4saSxyLGEpe3JldHVybiB0aGlzLmFic2VsbGlwc2UodCxlLG4sbixpLHIsYSksdGhpc31lbGxpcHNlKHQsZSxuLGkscixhLG8sbCl7bGV0IGM9dGhpcy5jdXJyZW50UG9pbnQueCxoPXRoaXMuY3VycmVudFBvaW50Lnk7cmV0dXJuIHRoaXMuYWJzZWxsaXBzZSh0K2MsZStoLG4saSxyLGEsbyxsKSx0aGlzfWFic2VsbGlwc2UodCxlLG4saSxyLGEsbyxsKXtsZXQgYz1uZXcgRXModCxlLG4saSxyLGEsbyxsKTtpZih0aGlzLmN1cnZlcy5sZW5ndGg+MCl7bGV0IHU9Yy5nZXRQb2ludCgwKTt1LmVxdWFscyh0aGlzLmN1cnJlbnRQb2ludCl8fHRoaXMubGluZVRvKHUueCx1LnkpfXRoaXMuY3VydmVzLnB1c2goYyk7bGV0IGg9Yy5nZXRQb2ludCgxKTtyZXR1cm4gdGhpcy5jdXJyZW50UG9pbnQuY29weShoKSx0aGlzfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5jdXJyZW50UG9pbnQuY29weSh0LmN1cnJlbnRQb2ludCksdGhpc310b0pTT04oKXtsZXQgdD1zdXBlci50b0pTT04oKTtyZXR1cm4gdC5jdXJyZW50UG9pbnQ9dGhpcy5jdXJyZW50UG9pbnQudG9BcnJheSgpLHR9ZnJvbUpTT04odCl7cmV0dXJuIHN1cGVyLmZyb21KU09OKHQpLHRoaXMuY3VycmVudFBvaW50LmZyb21BcnJheSh0LmN1cnJlbnRQb2ludCksdGhpc319LGJyPWNsYXNzIHMgZXh0ZW5kcyBIdHtjb25zdHJ1Y3Rvcih0PVtuZXcgWigwLC0uNSksbmV3IFooLjUsMCksbmV3IFooMCwuNSldLGU9MTIsbj0wLGk9TWF0aC5QSSoyKXtzdXBlcigpLHRoaXMudHlwZT0iTGF0aGVHZW9tZXRyeSIsdGhpcy5wYXJhbWV0ZXJzPXtwb2ludHM6dCxzZWdtZW50czplLHBoaVN0YXJ0Om4scGhpTGVuZ3RoOml9LGU9TWF0aC5mbG9vcihlKSxpPXVlKGksMCxNYXRoLlBJKjIpO2xldCByPVtdLGE9W10sbz1bXSxsPVtdLGM9W10saD0xL2UsdT1uZXcgUixkPW5ldyBaLGY9bmV3IFIsbT1uZXcgUixfPW5ldyBSLGc9MCxwPTA7Zm9yKGxldCB2PTA7djw9dC5sZW5ndGgtMTt2Kyspc3dpdGNoKHYpe2Nhc2UgMDpnPXRbdisxXS54LXRbdl0ueCxwPXRbdisxXS55LXRbdl0ueSxmLng9cCoxLGYueT0tZyxmLno9cCowLF8uY29weShmKSxmLm5vcm1hbGl6ZSgpLGwucHVzaChmLngsZi55LGYueik7YnJlYWs7Y2FzZSB0Lmxlbmd0aC0xOmwucHVzaChfLngsXy55LF8ueik7YnJlYWs7ZGVmYXVsdDpnPXRbdisxXS54LXRbdl0ueCxwPXRbdisxXS55LXRbdl0ueSxmLng9cCoxLGYueT0tZyxmLno9cCowLG0uY29weShmKSxmLngrPV8ueCxmLnkrPV8ueSxmLnorPV8ueixmLm5vcm1hbGl6ZSgpLGwucHVzaChmLngsZi55LGYueiksXy5jb3B5KG0pfWZvcihsZXQgdj0wO3Y8PWU7disrKXtsZXQgeD1uK3YqaCppLE09TWF0aC5zaW4oeCksQz1NYXRoLmNvcyh4KTtmb3IobGV0IEE9MDtBPD10Lmxlbmd0aC0xO0ErKyl7dS54PXRbQV0ueCpNLHUueT10W0FdLnksdS56PXRbQV0ueCpDLGEucHVzaCh1LngsdS55LHUueiksZC54PXYvZSxkLnk9QS8odC5sZW5ndGgtMSksby5wdXNoKGQueCxkLnkpO2xldCBUPWxbMypBKzBdKk0sVT1sWzMqQSsxXSxrPWxbMypBKzBdKkM7Yy5wdXNoKFQsVSxrKX19Zm9yKGxldCB2PTA7djxlO3YrKylmb3IobGV0IHg9MDt4PHQubGVuZ3RoLTE7eCsrKXtsZXQgTT14K3YqdC5sZW5ndGgsQz1NLEE9TSt0Lmxlbmd0aCxUPU0rdC5sZW5ndGgrMSxVPU0rMTtyLnB1c2goQyxBLFUpLHIucHVzaChULFUsQSl9dGhpcy5zZXRJbmRleChyKSx0aGlzLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBndChhLDMpKSx0aGlzLnNldEF0dHJpYnV0ZSgidXYiLG5ldyBndChvLDIpKSx0aGlzLnNldEF0dHJpYnV0ZSgibm9ybWFsIixuZXcgZ3QoYywzKSl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLnBhcmFtZXRlcnM9T2JqZWN0LmFzc2lnbih7fSx0LnBhcmFtZXRlcnMpLHRoaXN9c3RhdGljIGZyb21KU09OKHQpe3JldHVybiBuZXcgcyh0LnBvaW50cyx0LnNlZ21lbnRzLHQucGhpU3RhcnQsdC5waGlMZW5ndGgpfX0sdW89Y2xhc3MgcyBleHRlbmRzIGJye2NvbnN0cnVjdG9yKHQ9MSxlPTEsbj00LGk9OCl7bGV0IHI9bmV3IERpO3IuYWJzYXJjKDAsLWUvMix0LE1hdGguUEkqMS41LDApLHIuYWJzYXJjKDAsZS8yLHQsMCxNYXRoLlBJKi41KSxzdXBlcihyLmdldFBvaW50cyhuKSxpKSx0aGlzLnR5cGU9IkNhcHN1bGVHZW9tZXRyeSIsdGhpcy5wYXJhbWV0ZXJzPXtyYWRpdXM6dCxsZW5ndGg6ZSxjYXBTZWdtZW50czpuLHJhZGlhbFNlZ21lbnRzOml9fXN0YXRpYyBmcm9tSlNPTih0KXtyZXR1cm4gbmV3IHModC5yYWRpdXMsdC5sZW5ndGgsdC5jYXBTZWdtZW50cyx0LnJhZGlhbFNlZ21lbnRzKX19LGZvPWNsYXNzIHMgZXh0ZW5kcyBIdHtjb25zdHJ1Y3Rvcih0PTEsZT0zMixuPTAsaT1NYXRoLlBJKjIpe3N1cGVyKCksdGhpcy50eXBlPSJDaXJjbGVHZW9tZXRyeSIsdGhpcy5wYXJhbWV0ZXJzPXtyYWRpdXM6dCxzZWdtZW50czplLHRoZXRhU3RhcnQ6bix0aGV0YUxlbmd0aDppfSxlPU1hdGgubWF4KDMsZSk7bGV0IHI9W10sYT1bXSxvPVtdLGw9W10sYz1uZXcgUixoPW5ldyBaO2EucHVzaCgwLDAsMCksby5wdXNoKDAsMCwxKSxsLnB1c2goLjUsLjUpO2ZvcihsZXQgdT0wLGQ9Mzt1PD1lO3UrKyxkKz0zKXtsZXQgZj1uK3UvZSppO2MueD10Kk1hdGguY29zKGYpLGMueT10Kk1hdGguc2luKGYpLGEucHVzaChjLngsYy55LGMueiksby5wdXNoKDAsMCwxKSxoLng9KGFbZF0vdCsxKS8yLGgueT0oYVtkKzFdL3QrMSkvMixsLnB1c2goaC54LGgueSl9Zm9yKGxldCB1PTE7dTw9ZTt1Kyspci5wdXNoKHUsdSsxLDApO3RoaXMuc2V0SW5kZXgociksdGhpcy5zZXRBdHRyaWJ1dGUoInBvc2l0aW9uIixuZXcgZ3QoYSwzKSksdGhpcy5zZXRBdHRyaWJ1dGUoIm5vcm1hbCIsbmV3IGd0KG8sMykpLHRoaXMuc2V0QXR0cmlidXRlKCJ1diIsbmV3IGd0KGwsMikpfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5wYXJhbWV0ZXJzPU9iamVjdC5hc3NpZ24oe30sdC5wYXJhbWV0ZXJzKSx0aGlzfXN0YXRpYyBmcm9tSlNPTih0KXtyZXR1cm4gbmV3IHModC5yYWRpdXMsdC5zZWdtZW50cyx0LnRoZXRhU3RhcnQsdC50aGV0YUxlbmd0aCl9fSxBcz1jbGFzcyBzIGV4dGVuZHMgSHR7Y29uc3RydWN0b3IodD0xLGU9MSxuPTEsaT0zMixyPTEsYT0hMSxvPTAsbD1NYXRoLlBJKjIpe3N1cGVyKCksdGhpcy50eXBlPSJDeWxpbmRlckdlb21ldHJ5Iix0aGlzLnBhcmFtZXRlcnM9e3JhZGl1c1RvcDp0LHJhZGl1c0JvdHRvbTplLGhlaWdodDpuLHJhZGlhbFNlZ21lbnRzOmksaGVpZ2h0U2VnbWVudHM6cixvcGVuRW5kZWQ6YSx0aGV0YVN0YXJ0Om8sdGhldGFMZW5ndGg6bH07bGV0IGM9dGhpcztpPU1hdGguZmxvb3IoaSkscj1NYXRoLmZsb29yKHIpO2xldCBoPVtdLHU9W10sZD1bXSxmPVtdLG09MCxfPVtdLGc9bi8yLHA9MDt2KCksYT09PSExJiYodD4wJiZ4KCEwKSxlPjAmJngoITEpKSx0aGlzLnNldEluZGV4KGgpLHRoaXMuc2V0QXR0cmlidXRlKCJwb3NpdGlvbiIsbmV3IGd0KHUsMykpLHRoaXMuc2V0QXR0cmlidXRlKCJub3JtYWwiLG5ldyBndChkLDMpKSx0aGlzLnNldEF0dHJpYnV0ZSgidXYiLG5ldyBndChmLDIpKTtmdW5jdGlvbiB2KCl7bGV0IE09bmV3IFIsQz1uZXcgUixBPTAsVD0oZS10KS9uO2ZvcihsZXQgVT0wO1U8PXI7VSsrKXtsZXQgaz1bXSx5PVUvcix3PXkqKGUtdCkrdDtmb3IobGV0IEc9MDtHPD1pO0crKyl7bGV0IEo9Ry9pLEk9SipsK28sej1NYXRoLnNpbihJKSxGPU1hdGguY29zKEkpO0MueD13KnosQy55PS15Km4rZyxDLno9dypGLHUucHVzaChDLngsQy55LEMueiksTS5zZXQoeixULEYpLm5vcm1hbGl6ZSgpLGQucHVzaChNLngsTS55LE0ueiksZi5wdXNoKEosMS15KSxrLnB1c2gobSsrKX1fLnB1c2goayl9Zm9yKGxldCBVPTA7VTxpO1UrKylmb3IobGV0IGs9MDtrPHI7aysrKXtsZXQgeT1fW2tdW1VdLHc9X1trKzFdW1VdLEc9X1trKzFdW1UrMV0sSj1fW2tdW1UrMV07aC5wdXNoKHksdyxKKSxoLnB1c2godyxHLEopLEErPTZ9Yy5hZGRHcm91cChwLEEsMCkscCs9QX1mdW5jdGlvbiB4KE0pe2xldCBDPW0sQT1uZXcgWixUPW5ldyBSLFU9MCxrPU09PT0hMD90OmUseT1NPT09ITA/MTotMTtmb3IobGV0IEc9MTtHPD1pO0crKyl1LnB1c2goMCxnKnksMCksZC5wdXNoKDAseSwwKSxmLnB1c2goLjUsLjUpLG0rKztsZXQgdz1tO2ZvcihsZXQgRz0wO0c8PWk7RysrKXtsZXQgST1HL2kqbCtvLHo9TWF0aC5jb3MoSSksRj1NYXRoLnNpbihJKTtULng9aypGLFQueT1nKnksVC56PWsqeix1LnB1c2goVC54LFQueSxULnopLGQucHVzaCgwLHksMCksQS54PXoqLjUrLjUsQS55PUYqLjUqeSsuNSxmLnB1c2goQS54LEEueSksbSsrfWZvcihsZXQgRz0wO0c8aTtHKyspe2xldCBKPUMrRyxJPXcrRztNPT09ITA/aC5wdXNoKEksSSsxLEopOmgucHVzaChJKzEsSSxKKSxVKz0zfWMuYWRkR3JvdXAocCxVLE09PT0hMD8xOjIpLHArPVV9fWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5wYXJhbWV0ZXJzPU9iamVjdC5hc3NpZ24oe30sdC5wYXJhbWV0ZXJzKSx0aGlzfXN0YXRpYyBmcm9tSlNPTih0KXtyZXR1cm4gbmV3IHModC5yYWRpdXNUb3AsdC5yYWRpdXNCb3R0b20sdC5oZWlnaHQsdC5yYWRpYWxTZWdtZW50cyx0LmhlaWdodFNlZ21lbnRzLHQub3BlbkVuZGVkLHQudGhldGFTdGFydCx0LnRoZXRhTGVuZ3RoKX19LHBvPWNsYXNzIHMgZXh0ZW5kcyBBc3tjb25zdHJ1Y3Rvcih0PTEsZT0xLG49MzIsaT0xLHI9ITEsYT0wLG89TWF0aC5QSSoyKXtzdXBlcigwLHQsZSxuLGkscixhLG8pLHRoaXMudHlwZT0iQ29uZUdlb21ldHJ5Iix0aGlzLnBhcmFtZXRlcnM9e3JhZGl1czp0LGhlaWdodDplLHJhZGlhbFNlZ21lbnRzOm4saGVpZ2h0U2VnbWVudHM6aSxvcGVuRW5kZWQ6cix0aGV0YVN0YXJ0OmEsdGhldGFMZW5ndGg6b319c3RhdGljIGZyb21KU09OKHQpe3JldHVybiBuZXcgcyh0LnJhZGl1cyx0LmhlaWdodCx0LnJhZGlhbFNlZ21lbnRzLHQuaGVpZ2h0U2VnbWVudHMsdC5vcGVuRW5kZWQsdC50aGV0YVN0YXJ0LHQudGhldGFMZW5ndGgpfX0sc2k9Y2xhc3MgcyBleHRlbmRzIEh0e2NvbnN0cnVjdG9yKHQ9W10sZT1bXSxuPTEsaT0wKXtzdXBlcigpLHRoaXMudHlwZT0iUG9seWhlZHJvbkdlb21ldHJ5Iix0aGlzLnBhcmFtZXRlcnM9e3ZlcnRpY2VzOnQsaW5kaWNlczplLHJhZGl1czpuLGRldGFpbDppfTtsZXQgcj1bXSxhPVtdO28oaSksYyhuKSxoKCksdGhpcy5zZXRBdHRyaWJ1dGUoInBvc2l0aW9uIixuZXcgZ3QociwzKSksdGhpcy5zZXRBdHRyaWJ1dGUoIm5vcm1hbCIsbmV3IGd0KHIuc2xpY2UoKSwzKSksdGhpcy5zZXRBdHRyaWJ1dGUoInV2IixuZXcgZ3QoYSwyKSksaT09PTA/dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpOnRoaXMubm9ybWFsaXplTm9ybWFscygpO2Z1bmN0aW9uIG8odil7bGV0IHg9bmV3IFIsTT1uZXcgUixDPW5ldyBSO2ZvcihsZXQgQT0wO0E8ZS5sZW5ndGg7QSs9MylmKGVbQSswXSx4KSxmKGVbQSsxXSxNKSxmKGVbQSsyXSxDKSxsKHgsTSxDLHYpfWZ1bmN0aW9uIGwodix4LE0sQyl7bGV0IEE9QysxLFQ9W107Zm9yKGxldCBVPTA7VTw9QTtVKyspe1RbVV09W107bGV0IGs9di5jbG9uZSgpLmxlcnAoTSxVL0EpLHk9eC5jbG9uZSgpLmxlcnAoTSxVL0EpLHc9QS1VO2ZvcihsZXQgRz0wO0c8PXc7RysrKUc9PT0wJiZVPT09QT9UW1VdW0ddPWs6VFtVXVtHXT1rLmNsb25lKCkubGVycCh5LEcvdyl9Zm9yKGxldCBVPTA7VTxBO1UrKylmb3IobGV0IGs9MDtrPDIqKEEtVSktMTtrKyspe2xldCB5PU1hdGguZmxvb3Ioay8yKTtrJTI9PT0wPyhkKFRbVV1beSsxXSksZChUW1UrMV1beV0pLGQoVFtVXVt5XSkpOihkKFRbVV1beSsxXSksZChUW1UrMV1beSsxXSksZChUW1UrMV1beV0pKX19ZnVuY3Rpb24gYyh2KXtsZXQgeD1uZXcgUjtmb3IobGV0IE09MDtNPHIubGVuZ3RoO00rPTMpeC54PXJbTSswXSx4Lnk9cltNKzFdLHguej1yW00rMl0seC5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcih2KSxyW00rMF09eC54LHJbTSsxXT14LnkscltNKzJdPXguen1mdW5jdGlvbiBoKCl7bGV0IHY9bmV3IFI7Zm9yKGxldCB4PTA7eDxyLmxlbmd0aDt4Kz0zKXt2Lng9clt4KzBdLHYueT1yW3grMV0sdi56PXJbeCsyXTtsZXQgTT1nKHYpLzIvTWF0aC5QSSsuNSxDPXAodikvTWF0aC5QSSsuNTthLnB1c2goTSwxLUMpfW0oKSx1KCl9ZnVuY3Rpb24gdSgpe2ZvcihsZXQgdj0wO3Y8YS5sZW5ndGg7dis9Nil7bGV0IHg9YVt2KzBdLE09YVt2KzJdLEM9YVt2KzRdLEE9TWF0aC5tYXgoeCxNLEMpLFQ9TWF0aC5taW4oeCxNLEMpO0E+LjkmJlQ8LjEmJih4PC4yJiYoYVt2KzBdKz0xKSxNPC4yJiYoYVt2KzJdKz0xKSxDPC4yJiYoYVt2KzRdKz0xKSl9fWZ1bmN0aW9uIGQodil7ci5wdXNoKHYueCx2Lnksdi56KX1mdW5jdGlvbiBmKHYseCl7bGV0IE09diozO3gueD10W00rMF0seC55PXRbTSsxXSx4Lno9dFtNKzJdfWZ1bmN0aW9uIG0oKXtsZXQgdj1uZXcgUix4PW5ldyBSLE09bmV3IFIsQz1uZXcgUixBPW5ldyBaLFQ9bmV3IFosVT1uZXcgWjtmb3IobGV0IGs9MCx5PTA7azxyLmxlbmd0aDtrKz05LHkrPTYpe3Yuc2V0KHJbayswXSxyW2srMV0scltrKzJdKSx4LnNldChyW2srM10scltrKzRdLHJbays1XSksTS5zZXQocltrKzZdLHJbays3XSxyW2srOF0pLEEuc2V0KGFbeSswXSxhW3krMV0pLFQuc2V0KGFbeSsyXSxhW3krM10pLFUuc2V0KGFbeSs0XSxhW3krNV0pLEMuY29weSh2KS5hZGQoeCkuYWRkKE0pLmRpdmlkZVNjYWxhcigzKTtsZXQgdz1nKEMpO18oQSx5KzAsdix3KSxfKFQseSsyLHgsdyksXyhVLHkrNCxNLHcpfX1mdW5jdGlvbiBfKHYseCxNLEMpe0M8MCYmdi54PT09MSYmKGFbeF09di54LTEpLE0ueD09PTAmJk0uej09PTAmJihhW3hdPUMvMi9NYXRoLlBJKy41KX1mdW5jdGlvbiBnKHYpe3JldHVybiBNYXRoLmF0YW4yKHYueiwtdi54KX1mdW5jdGlvbiBwKHYpe3JldHVybiBNYXRoLmF0YW4yKC12LnksTWF0aC5zcXJ0KHYueCp2Lngrdi56KnYueikpfX1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMucGFyYW1ldGVycz1PYmplY3QuYXNzaWduKHt9LHQucGFyYW1ldGVycyksdGhpc31zdGF0aWMgZnJvbUpTT04odCl7cmV0dXJuIG5ldyBzKHQudmVydGljZXMsdC5pbmRpY2VzLHQucmFkaXVzLHQuZGV0YWlscyl9fSxtbz1jbGFzcyBzIGV4dGVuZHMgc2l7Y29uc3RydWN0b3IodD0xLGU9MCl7bGV0IG49KDErTWF0aC5zcXJ0KDUpKS8yLGk9MS9uLHI9Wy0xLC0xLC0xLC0xLC0xLDEsLTEsMSwtMSwtMSwxLDEsMSwtMSwtMSwxLC0xLDEsMSwxLC0xLDEsMSwxLDAsLWksLW4sMCwtaSxuLDAsaSwtbiwwLGksbiwtaSwtbiwwLC1pLG4sMCxpLC1uLDAsaSxuLDAsLW4sMCwtaSxuLDAsLWksLW4sMCxpLG4sMCxpXSxhPVszLDExLDcsMyw3LDE1LDMsMTUsMTMsNywxOSwxNyw3LDE3LDYsNyw2LDE1LDE3LDQsOCwxNyw4LDEwLDE3LDEwLDYsOCwwLDE2LDgsMTYsMiw4LDIsMTAsMCwxMiwxLDAsMSwxOCwwLDE4LDE2LDYsMTAsMiw2LDIsMTMsNiwxMywxNSwyLDE2LDE4LDIsMTgsMywyLDMsMTMsMTgsMSw5LDE4LDksMTEsMTgsMTEsMyw0LDE0LDEyLDQsMTIsMCw0LDAsOCwxMSw5LDUsMTEsNSwxOSwxMSwxOSw3LDE5LDUsMTQsMTksMTQsNCwxOSw0LDE3LDEsMTIsMTQsMSwxNCw1LDEsNSw5XTtzdXBlcihyLGEsdCxlKSx0aGlzLnR5cGU9IkRvZGVjYWhlZHJvbkdlb21ldHJ5Iix0aGlzLnBhcmFtZXRlcnM9e3JhZGl1czp0LGRldGFpbDplfX1zdGF0aWMgZnJvbUpTT04odCl7cmV0dXJuIG5ldyBzKHQucmFkaXVzLHQuZGV0YWlsKX19LHZhPW5ldyBSLHlhPW5ldyBSLEhsPW5ldyBSLE1hPW5ldyBMbixnbz1jbGFzcyBleHRlbmRzIEh0e2NvbnN0cnVjdG9yKHQ9bnVsbCxlPTEpe2lmKHN1cGVyKCksdGhpcy50eXBlPSJFZGdlc0dlb21ldHJ5Iix0aGlzLnBhcmFtZXRlcnM9e2dlb21ldHJ5OnQsdGhyZXNob2xkQW5nbGU6ZX0sdCE9PW51bGwpe2xldCBpPU1hdGgucG93KDEwLDQpLHI9TWF0aC5jb3Mod2kqZSksYT10LmdldEluZGV4KCksbz10LmdldEF0dHJpYnV0ZSgicG9zaXRpb24iKSxsPWE/YS5jb3VudDpvLmNvdW50LGM9WzAsMCwwXSxoPVsiYSIsImIiLCJjIl0sdT1uZXcgQXJyYXkoMyksZD17fSxmPVtdO2ZvcihsZXQgbT0wO208bDttKz0zKXthPyhjWzBdPWEuZ2V0WChtKSxjWzFdPWEuZ2V0WChtKzEpLGNbMl09YS5nZXRYKG0rMikpOihjWzBdPW0sY1sxXT1tKzEsY1syXT1tKzIpO2xldHthOl8sYjpnLGM6cH09TWE7aWYoXy5mcm9tQnVmZmVyQXR0cmlidXRlKG8sY1swXSksZy5mcm9tQnVmZmVyQXR0cmlidXRlKG8sY1sxXSkscC5mcm9tQnVmZmVyQXR0cmlidXRlKG8sY1syXSksTWEuZ2V0Tm9ybWFsKEhsKSx1WzBdPWAke01hdGgucm91bmQoXy54KmkpfSwke01hdGgucm91bmQoXy55KmkpfSwke01hdGgucm91bmQoXy56KmkpfWAsdVsxXT1gJHtNYXRoLnJvdW5kKGcueCppKX0sJHtNYXRoLnJvdW5kKGcueSppKX0sJHtNYXRoLnJvdW5kKGcueippKX1gLHVbMl09YCR7TWF0aC5yb3VuZChwLngqaSl9LCR7TWF0aC5yb3VuZChwLnkqaSl9LCR7TWF0aC5yb3VuZChwLnoqaSl9YCwhKHVbMF09PT11WzFdfHx1WzFdPT09dVsyXXx8dVsyXT09PXVbMF0pKWZvcihsZXQgdj0wO3Y8Mzt2Kyspe2xldCB4PSh2KzEpJTMsTT11W3ZdLEM9dVt4XSxBPU1hW2hbdl1dLFQ9TWFbaFt4XV0sVT1gJHtNfV8ke0N9YCxrPWAke0N9XyR7TX1gO2sgaW4gZCYmZFtrXT8oSGwuZG90KGRba10ubm9ybWFsKTw9ciYmKGYucHVzaChBLngsQS55LEEueiksZi5wdXNoKFQueCxULnksVC56KSksZFtrXT1udWxsKTpVIGluIGR8fChkW1VdPXtpbmRleDA6Y1t2XSxpbmRleDE6Y1t4XSxub3JtYWw6SGwuY2xvbmUoKX0pfX1mb3IobGV0IG0gaW4gZClpZihkW21dKXtsZXR7aW5kZXgwOl8saW5kZXgxOmd9PWRbbV07dmEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShvLF8pLHlhLmZyb21CdWZmZXJBdHRyaWJ1dGUobyxnKSxmLnB1c2godmEueCx2YS55LHZhLnopLGYucHVzaCh5YS54LHlhLnkseWEueil9dGhpcy5zZXRBdHRyaWJ1dGUoInBvc2l0aW9uIixuZXcgZ3QoZiwzKSl9fWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5wYXJhbWV0ZXJzPU9iamVjdC5hc3NpZ24oe30sdC5wYXJhbWV0ZXJzKSx0aGlzfX0sRm49Y2xhc3MgZXh0ZW5kcyBEaXtjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSx0aGlzLnV1aWQ9WWUoKSx0aGlzLnR5cGU9IlNoYXBlIix0aGlzLmhvbGVzPVtdfWdldFBvaW50c0hvbGVzKHQpe2xldCBlPVtdO2ZvcihsZXQgbj0wLGk9dGhpcy5ob2xlcy5sZW5ndGg7bjxpO24rKyllW25dPXRoaXMuaG9sZXNbbl0uZ2V0UG9pbnRzKHQpO3JldHVybiBlfWV4dHJhY3RQb2ludHModCl7cmV0dXJue3NoYXBlOnRoaXMuZ2V0UG9pbnRzKHQpLGhvbGVzOnRoaXMuZ2V0UG9pbnRzSG9sZXModCl9fWNvcHkodCl7c3VwZXIuY29weSh0KSx0aGlzLmhvbGVzPVtdO2ZvcihsZXQgZT0wLG49dC5ob2xlcy5sZW5ndGg7ZTxuO2UrKyl7bGV0IGk9dC5ob2xlc1tlXTt0aGlzLmhvbGVzLnB1c2goaS5jbG9uZSgpKX1yZXR1cm4gdGhpc310b0pTT04oKXtsZXQgdD1zdXBlci50b0pTT04oKTt0LnV1aWQ9dGhpcy51dWlkLHQuaG9sZXM9W107Zm9yKGxldCBlPTAsbj10aGlzLmhvbGVzLmxlbmd0aDtlPG47ZSsrKXtsZXQgaT10aGlzLmhvbGVzW2VdO3QuaG9sZXMucHVzaChpLnRvSlNPTigpKX1yZXR1cm4gdH1mcm9tSlNPTih0KXtzdXBlci5mcm9tSlNPTih0KSx0aGlzLnV1aWQ9dC51dWlkLHRoaXMuaG9sZXM9W107Zm9yKGxldCBlPTAsbj10LmhvbGVzLmxlbmd0aDtlPG47ZSsrKXtsZXQgaT10LmhvbGVzW2VdO3RoaXMuaG9sZXMucHVzaChuZXcgRGkoKS5mcm9tSlNPTihpKSl9cmV0dXJuIHRoaXN9fSxSdj17dHJpYW5ndWxhdGU6ZnVuY3Rpb24ocyx0LGU9Mil7bGV0IG49dCYmdC5sZW5ndGgsaT1uP3RbMF0qZTpzLmxlbmd0aCxyPW9wKHMsMCxpLGUsITApLGE9W107aWYoIXJ8fHIubmV4dD09PXIucHJldilyZXR1cm4gYTtsZXQgbyxsLGMsaCx1LGQsZjtpZihuJiYocj1VdihzLHQscixlKSkscy5sZW5ndGg+ODAqZSl7bz1jPXNbMF0sbD1oPXNbMV07Zm9yKGxldCBtPWU7bTxpO20rPWUpdT1zW21dLGQ9c1ttKzFdLHU8byYmKG89dSksZDxsJiYobD1kKSx1PmMmJihjPXUpLGQ+aCYmKGg9ZCk7Zj1NYXRoLm1heChjLW8saC1sKSxmPWYhPT0wPzMyNzY3L2Y6MH1yZXR1cm4gRXIocixhLGUsbyxsLGYsMCksYX19O2Z1bmN0aW9uIG9wKHMsdCxlLG4saSl7bGV0IHIsYTtpZihpPT09V3Yocyx0LGUsbik+MClmb3Iocj10O3I8ZTtyKz1uKWE9TWQocixzW3JdLHNbcisxXSxhKTtlbHNlIGZvcihyPWUtbjtyPj10O3ItPW4pYT1NZChyLHNbcl0sc1tyKzFdLGEpO3JldHVybiBhJiZybChhLGEubmV4dCkmJihUcihhKSxhPWEubmV4dCksYX1mdW5jdGlvbiBOaShzLHQpe2lmKCFzKXJldHVybiBzO3R8fCh0PXMpO2xldCBlPXMsbjtkbyBpZihuPSExLCFlLnN0ZWluZXImJihybChlLGUubmV4dCl8fGxlKGUucHJldixlLGUubmV4dCk9PT0wKSl7aWYoVHIoZSksZT10PWUucHJldixlPT09ZS5uZXh0KWJyZWFrO249ITB9ZWxzZSBlPWUubmV4dDt3aGlsZShufHxlIT09dCk7cmV0dXJuIHR9ZnVuY3Rpb24gRXIocyx0LGUsbixpLHIsYSl7aWYoIXMpcmV0dXJuOyFhJiZyJiZCdihzLG4saSxyKTtsZXQgbz1zLGwsYztmb3IoO3MucHJldiE9PXMubmV4dDspe2lmKGw9cy5wcmV2LGM9cy5uZXh0LHI/UHYocyxuLGkscik6Q3Yocykpe3QucHVzaChsLmkvZXwwKSx0LnB1c2gocy5pL2V8MCksdC5wdXNoKGMuaS9lfDApLFRyKHMpLHM9Yy5uZXh0LG89Yy5uZXh0O2NvbnRpbnVlfWlmKHM9YyxzPT09byl7YT9hPT09MT8ocz1MdihOaShzKSx0LGUpLEVyKHMsdCxlLG4saSxyLDIpKTphPT09MiYmSXYocyx0LGUsbixpLHIpOkVyKE5pKHMpLHQsZSxuLGksciwxKTticmVha319fWZ1bmN0aW9uIEN2KHMpe2xldCB0PXMucHJldixlPXMsbj1zLm5leHQ7aWYobGUodCxlLG4pPj0wKXJldHVybiExO2xldCBpPXQueCxyPWUueCxhPW4ueCxvPXQueSxsPWUueSxjPW4ueSxoPWk8cj9pPGE/aTphOnI8YT9yOmEsdT1vPGw/bzxjP286YzpsPGM/bDpjLGQ9aT5yP2k+YT9pOmE6cj5hP3I6YSxmPW8+bD9vPmM/bzpjOmw+Yz9sOmMsbT1uLm5leHQ7Zm9yKDttIT09dDspe2lmKG0ueD49aCYmbS54PD1kJiZtLnk+PXUmJm0ueTw9ZiYmdXMoaSxvLHIsbCxhLGMsbS54LG0ueSkmJmxlKG0ucHJldixtLG0ubmV4dCk+PTApcmV0dXJuITE7bT1tLm5leHR9cmV0dXJuITB9ZnVuY3Rpb24gUHYocyx0LGUsbil7bGV0IGk9cy5wcmV2LHI9cyxhPXMubmV4dDtpZihsZShpLHIsYSk+PTApcmV0dXJuITE7bGV0IG89aS54LGw9ci54LGM9YS54LGg9aS55LHU9ci55LGQ9YS55LGY9bzxsP288Yz9vOmM6bDxjP2w6YyxtPWg8dT9oPGQ/aDpkOnU8ZD91OmQsXz1vPmw/bz5jP286YzpsPmM/bDpjLGc9aD51P2g+ZD9oOmQ6dT5kP3U6ZCxwPWpjKGYsbSx0LGUsbiksdj1qYyhfLGcsdCxlLG4pLHg9cy5wcmV2WixNPXMubmV4dFo7Zm9yKDt4JiZ4Lno+PXAmJk0mJk0uejw9djspe2lmKHgueD49ZiYmeC54PD1fJiZ4Lnk+PW0mJngueTw9ZyYmeCE9PWkmJnghPT1hJiZ1cyhvLGgsbCx1LGMsZCx4LngseC55KSYmbGUoeC5wcmV2LHgseC5uZXh0KT49MHx8KHg9eC5wcmV2WixNLng+PWYmJk0ueDw9XyYmTS55Pj1tJiZNLnk8PWcmJk0hPT1pJiZNIT09YSYmdXMobyxoLGwsdSxjLGQsTS54LE0ueSkmJmxlKE0ucHJldixNLE0ubmV4dCk+PTApKXJldHVybiExO009TS5uZXh0Wn1mb3IoO3gmJnguej49cDspe2lmKHgueD49ZiYmeC54PD1fJiZ4Lnk+PW0mJngueTw9ZyYmeCE9PWkmJnghPT1hJiZ1cyhvLGgsbCx1LGMsZCx4LngseC55KSYmbGUoeC5wcmV2LHgseC5uZXh0KT49MClyZXR1cm4hMTt4PXgucHJldlp9Zm9yKDtNJiZNLno8PXY7KXtpZihNLng+PWYmJk0ueDw9XyYmTS55Pj1tJiZNLnk8PWcmJk0hPT1pJiZNIT09YSYmdXMobyxoLGwsdSxjLGQsTS54LE0ueSkmJmxlKE0ucHJldixNLE0ubmV4dCk+PTApcmV0dXJuITE7TT1NLm5leHRafXJldHVybiEwfWZ1bmN0aW9uIEx2KHMsdCxlKXtsZXQgbj1zO2Rve2xldCBpPW4ucHJldixyPW4ubmV4dC5uZXh0OyFybChpLHIpJiZscChpLG4sbi5uZXh0LHIpJiZBcihpLHIpJiZBcihyLGkpJiYodC5wdXNoKGkuaS9lfDApLHQucHVzaChuLmkvZXwwKSx0LnB1c2goci5pL2V8MCksVHIobiksVHIobi5uZXh0KSxuPXM9ciksbj1uLm5leHR9d2hpbGUobiE9PXMpO3JldHVybiBOaShuKX1mdW5jdGlvbiBJdihzLHQsZSxuLGkscil7bGV0IGE9cztkb3tsZXQgbz1hLm5leHQubmV4dDtmb3IoO28hPT1hLnByZXY7KXtpZihhLmkhPT1vLmkmJmt2KGEsbykpe2xldCBsPWNwKGEsbyk7YT1OaShhLGEubmV4dCksbD1OaShsLGwubmV4dCksRXIoYSx0LGUsbixpLHIsMCksRXIobCx0LGUsbixpLHIsMCk7cmV0dXJufW89by5uZXh0fWE9YS5uZXh0fXdoaWxlKGEhPT1zKX1mdW5jdGlvbiBVdihzLHQsZSxuKXtsZXQgaT1bXSxyLGEsbyxsLGM7Zm9yKHI9MCxhPXQubGVuZ3RoO3I8YTtyKyspbz10W3JdKm4sbD1yPGEtMT90W3IrMV0qbjpzLmxlbmd0aCxjPW9wKHMsbyxsLG4sITEpLGM9PT1jLm5leHQmJihjLnN0ZWluZXI9ITApLGkucHVzaChWdihjKSk7Zm9yKGkuc29ydChEdikscj0wO3I8aS5sZW5ndGg7cisrKWU9TnYoaVtyXSxlKTtyZXR1cm4gZX1mdW5jdGlvbiBEdihzLHQpe3JldHVybiBzLngtdC54fWZ1bmN0aW9uIE52KHMsdCl7bGV0IGU9T3Yocyx0KTtpZighZSlyZXR1cm4gdDtsZXQgbj1jcChlLHMpO3JldHVybiBOaShuLG4ubmV4dCksTmkoZSxlLm5leHQpfWZ1bmN0aW9uIE92KHMsdCl7bGV0IGU9dCxuPS0xLzAsaSxyPXMueCxhPXMueTtkb3tpZihhPD1lLnkmJmE+PWUubmV4dC55JiZlLm5leHQueSE9PWUueSl7bGV0IGQ9ZS54KyhhLWUueSkqKGUubmV4dC54LWUueCkvKGUubmV4dC55LWUueSk7aWYoZDw9ciYmZD5uJiYobj1kLGk9ZS54PGUubmV4dC54P2U6ZS5uZXh0LGQ9PT1yKSlyZXR1cm4gaX1lPWUubmV4dH13aGlsZShlIT09dCk7aWYoIWkpcmV0dXJuIG51bGw7bGV0IG89aSxsPWkueCxjPWkueSxoPTEvMCx1O2U9aTtkbyByPj1lLngmJmUueD49bCYmciE9PWUueCYmdXMoYTxjP3I6bixhLGwsYyxhPGM/bjpyLGEsZS54LGUueSkmJih1PU1hdGguYWJzKGEtZS55KS8oci1lLngpLEFyKGUscykmJih1PGh8fHU9PT1oJiYoZS54PmkueHx8ZS54PT09aS54JiZGdihpLGUpKSkmJihpPWUsaD11KSksZT1lLm5leHQ7d2hpbGUoZSE9PW8pO3JldHVybiBpfWZ1bmN0aW9uIEZ2KHMsdCl7cmV0dXJuIGxlKHMucHJldixzLHQucHJldik8MCYmbGUodC5uZXh0LHMscy5uZXh0KTwwfWZ1bmN0aW9uIEJ2KHMsdCxlLG4pe2xldCBpPXM7ZG8gaS56PT09MCYmKGkuej1qYyhpLngsaS55LHQsZSxuKSksaS5wcmV2Wj1pLnByZXYsaS5uZXh0Wj1pLm5leHQsaT1pLm5leHQ7d2hpbGUoaSE9PXMpO2kucHJldloubmV4dFo9bnVsbCxpLnByZXZaPW51bGwsenYoaSl9ZnVuY3Rpb24genYocyl7bGV0IHQsZSxuLGkscixhLG8sbCxjPTE7ZG97Zm9yKGU9cyxzPW51bGwscj1udWxsLGE9MDtlOyl7Zm9yKGErKyxuPWUsbz0wLHQ9MDt0PGMmJihvKyssbj1uLm5leHRaLCEhbik7dCsrKTtmb3IobD1jO28+MHx8bD4wJiZuOylvIT09MCYmKGw9PT0wfHwhbnx8ZS56PD1uLnopPyhpPWUsZT1lLm5leHRaLG8tLSk6KGk9bixuPW4ubmV4dFosbC0tKSxyP3IubmV4dFo9aTpzPWksaS5wcmV2Wj1yLHI9aTtlPW59ci5uZXh0Wj1udWxsLGMqPTJ9d2hpbGUoYT4xKTtyZXR1cm4gc31mdW5jdGlvbiBqYyhzLHQsZSxuLGkpe3JldHVybiBzPShzLWUpKml8MCx0PSh0LW4pKml8MCxzPShzfHM8PDgpJjE2NzExOTM1LHM9KHN8czw8NCkmMjUyNjQ1MTM1LHM9KHN8czw8MikmODU4OTkzNDU5LHM9KHN8czw8MSkmMTQzMTY1NTc2NSx0PSh0fHQ8PDgpJjE2NzExOTM1LHQ9KHR8dDw8NCkmMjUyNjQ1MTM1LHQ9KHR8dDw8MikmODU4OTkzNDU5LHQ9KHR8dDw8MSkmMTQzMTY1NTc2NSxzfHQ8PDF9ZnVuY3Rpb24gVnYocyl7bGV0IHQ9cyxlPXM7ZG8odC54PGUueHx8dC54PT09ZS54JiZ0Lnk8ZS55KSYmKGU9dCksdD10Lm5leHQ7d2hpbGUodCE9PXMpO3JldHVybiBlfWZ1bmN0aW9uIHVzKHMsdCxlLG4saSxyLGEsbyl7cmV0dXJuKGktYSkqKHQtbyk+PShzLWEpKihyLW8pJiYocy1hKSoobi1vKT49KGUtYSkqKHQtbykmJihlLWEpKihyLW8pPj0oaS1hKSoobi1vKX1mdW5jdGlvbiBrdihzLHQpe3JldHVybiBzLm5leHQuaSE9PXQuaSYmcy5wcmV2LmkhPT10LmkmJiFIdihzLHQpJiYoQXIocyx0KSYmQXIodCxzKSYmR3Yocyx0KSYmKGxlKHMucHJldixzLHQucHJldil8fGxlKHMsdC5wcmV2LHQpKXx8cmwocyx0KSYmbGUocy5wcmV2LHMscy5uZXh0KT4wJiZsZSh0LnByZXYsdCx0Lm5leHQpPjApfWZ1bmN0aW9uIGxlKHMsdCxlKXtyZXR1cm4odC55LXMueSkqKGUueC10LngpLSh0Lngtcy54KSooZS55LXQueSl9ZnVuY3Rpb24gcmwocyx0KXtyZXR1cm4gcy54PT09dC54JiZzLnk9PT10Lnl9ZnVuY3Rpb24gbHAocyx0LGUsbil7bGV0IGk9YmEobGUocyx0LGUpKSxyPWJhKGxlKHMsdCxuKSksYT1iYShsZShlLG4scykpLG89YmEobGUoZSxuLHQpKTtyZXR1cm4hIShpIT09ciYmYSE9PW98fGk9PT0wJiZTYShzLGUsdCl8fHI9PT0wJiZTYShzLG4sdCl8fGE9PT0wJiZTYShlLHMsbil8fG89PT0wJiZTYShlLHQsbikpfWZ1bmN0aW9uIFNhKHMsdCxlKXtyZXR1cm4gdC54PD1NYXRoLm1heChzLngsZS54KSYmdC54Pj1NYXRoLm1pbihzLngsZS54KSYmdC55PD1NYXRoLm1heChzLnksZS55KSYmdC55Pj1NYXRoLm1pbihzLnksZS55KX1mdW5jdGlvbiBiYShzKXtyZXR1cm4gcz4wPzE6czwwPy0xOjB9ZnVuY3Rpb24gSHYocyx0KXtsZXQgZT1zO2Rve2lmKGUuaSE9PXMuaSYmZS5uZXh0LmkhPT1zLmkmJmUuaSE9PXQuaSYmZS5uZXh0LmkhPT10LmkmJmxwKGUsZS5uZXh0LHMsdCkpcmV0dXJuITA7ZT1lLm5leHR9d2hpbGUoZSE9PXMpO3JldHVybiExfWZ1bmN0aW9uIEFyKHMsdCl7cmV0dXJuIGxlKHMucHJldixzLHMubmV4dCk8MD9sZShzLHQscy5uZXh0KT49MCYmbGUocyxzLnByZXYsdCk+PTA6bGUocyx0LHMucHJldik8MHx8bGUocyxzLm5leHQsdCk8MH1mdW5jdGlvbiBHdihzLHQpe2xldCBlPXMsbj0hMSxpPShzLngrdC54KS8yLHI9KHMueSt0LnkpLzI7ZG8gZS55PnIhPWUubmV4dC55PnImJmUubmV4dC55IT09ZS55JiZpPChlLm5leHQueC1lLngpKihyLWUueSkvKGUubmV4dC55LWUueSkrZS54JiYobj0hbiksZT1lLm5leHQ7d2hpbGUoZSE9PXMpO3JldHVybiBufWZ1bmN0aW9uIGNwKHMsdCl7bGV0IGU9bmV3IHRoKHMuaSxzLngscy55KSxuPW5ldyB0aCh0LmksdC54LHQueSksaT1zLm5leHQscj10LnByZXY7cmV0dXJuIHMubmV4dD10LHQucHJldj1zLGUubmV4dD1pLGkucHJldj1lLG4ubmV4dD1lLGUucHJldj1uLHIubmV4dD1uLG4ucHJldj1yLG59ZnVuY3Rpb24gTWQocyx0LGUsbil7bGV0IGk9bmV3IHRoKHMsdCxlKTtyZXR1cm4gbj8oaS5uZXh0PW4ubmV4dCxpLnByZXY9bixuLm5leHQucHJldj1pLG4ubmV4dD1pKTooaS5wcmV2PWksaS5uZXh0PWkpLGl9ZnVuY3Rpb24gVHIocyl7cy5uZXh0LnByZXY9cy5wcmV2LHMucHJldi5uZXh0PXMubmV4dCxzLnByZXZaJiYocy5wcmV2Wi5uZXh0Wj1zLm5leHRaKSxzLm5leHRaJiYocy5uZXh0Wi5wcmV2Wj1zLnByZXZaKX1mdW5jdGlvbiB0aChzLHQsZSl7dGhpcy5pPXMsdGhpcy54PXQsdGhpcy55PWUsdGhpcy5wcmV2PW51bGwsdGhpcy5uZXh0PW51bGwsdGhpcy56PTAsdGhpcy5wcmV2Wj1udWxsLHRoaXMubmV4dFo9bnVsbCx0aGlzLnN0ZWluZXI9ITF9ZnVuY3Rpb24gV3Yocyx0LGUsbil7bGV0IGk9MDtmb3IobGV0IHI9dCxhPWUtbjtyPGU7cis9bilpKz0oc1thXS1zW3JdKSooc1tyKzFdK3NbYSsxXSksYT1yO3JldHVybiBpfXZhciBnbj1jbGFzcyBze3N0YXRpYyBhcmVhKHQpe2xldCBlPXQubGVuZ3RoLG49MDtmb3IobGV0IGk9ZS0xLHI9MDtyPGU7aT1yKyspbis9dFtpXS54KnRbcl0ueS10W3JdLngqdFtpXS55O3JldHVybiBuKi41fXN0YXRpYyBpc0Nsb2NrV2lzZSh0KXtyZXR1cm4gcy5hcmVhKHQpPDB9c3RhdGljIHRyaWFuZ3VsYXRlU2hhcGUodCxlKXtsZXQgbj1bXSxpPVtdLHI9W107U2QodCksYmQobix0KTtsZXQgYT10Lmxlbmd0aDtlLmZvckVhY2goU2QpO2ZvcihsZXQgbD0wO2w8ZS5sZW5ndGg7bCsrKWkucHVzaChhKSxhKz1lW2xdLmxlbmd0aCxiZChuLGVbbF0pO2xldCBvPVJ2LnRyaWFuZ3VsYXRlKG4saSk7Zm9yKGxldCBsPTA7bDxvLmxlbmd0aDtsKz0zKXIucHVzaChvLnNsaWNlKGwsbCszKSk7cmV0dXJuIHJ9fTtmdW5jdGlvbiBTZChzKXtsZXQgdD1zLmxlbmd0aDt0PjImJnNbdC0xXS5lcXVhbHMoc1swXSkmJnMucG9wKCl9ZnVuY3Rpb24gYmQocyx0KXtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylzLnB1c2godFtlXS54KSxzLnB1c2godFtlXS55KX12YXIgX289Y2xhc3MgcyBleHRlbmRzIEh0e2NvbnN0cnVjdG9yKHQ9bmV3IEZuKFtuZXcgWiguNSwuNSksbmV3IFooLS41LC41KSxuZXcgWigtLjUsLS41KSxuZXcgWiguNSwtLjUpXSksZT17fSl7c3VwZXIoKSx0aGlzLnR5cGU9IkV4dHJ1ZGVHZW9tZXRyeSIsdGhpcy5wYXJhbWV0ZXJzPXtzaGFwZXM6dCxvcHRpb25zOmV9LHQ9QXJyYXkuaXNBcnJheSh0KT90Olt0XTtsZXQgbj10aGlzLGk9W10scj1bXTtmb3IobGV0IG89MCxsPXQubGVuZ3RoO288bDtvKyspe2xldCBjPXRbb107YShjKX10aGlzLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBndChpLDMpKSx0aGlzLnNldEF0dHJpYnV0ZSgidXYiLG5ldyBndChyLDIpKSx0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7ZnVuY3Rpb24gYShvKXtsZXQgbD1bXSxjPWUuY3VydmVTZWdtZW50cyE9PXZvaWQgMD9lLmN1cnZlU2VnbWVudHM6MTIsaD1lLnN0ZXBzIT09dm9pZCAwP2Uuc3RlcHM6MSx1PWUuZGVwdGghPT12b2lkIDA/ZS5kZXB0aDoxLGQ9ZS5iZXZlbEVuYWJsZWQhPT12b2lkIDA/ZS5iZXZlbEVuYWJsZWQ6ITAsZj1lLmJldmVsVGhpY2tuZXNzIT09dm9pZCAwP2UuYmV2ZWxUaGlja25lc3M6LjIsbT1lLmJldmVsU2l6ZSE9PXZvaWQgMD9lLmJldmVsU2l6ZTpmLS4xLF89ZS5iZXZlbE9mZnNldCE9PXZvaWQgMD9lLmJldmVsT2Zmc2V0OjAsZz1lLmJldmVsU2VnbWVudHMhPT12b2lkIDA/ZS5iZXZlbFNlZ21lbnRzOjMscD1lLmV4dHJ1ZGVQYXRoLHY9ZS5VVkdlbmVyYXRvciE9PXZvaWQgMD9lLlVWR2VuZXJhdG9yOlh2LHgsTT0hMSxDLEEsVCxVO3AmJih4PXAuZ2V0U3BhY2VkUG9pbnRzKGgpLE09ITAsZD0hMSxDPXAuY29tcHV0ZUZyZW5ldEZyYW1lcyhoLCExKSxBPW5ldyBSLFQ9bmV3IFIsVT1uZXcgUiksZHx8KGc9MCxmPTAsbT0wLF89MCk7bGV0IGs9by5leHRyYWN0UG9pbnRzKGMpLHk9ay5zaGFwZSx3PWsuaG9sZXM7aWYoIWduLmlzQ2xvY2tXaXNlKHkpKXt5PXkucmV2ZXJzZSgpO2ZvcihsZXQgTD0wLG90PXcubGVuZ3RoO0w8b3Q7TCsrKXtsZXQgWD13W0xdO2duLmlzQ2xvY2tXaXNlKFgpJiYod1tMXT1YLnJldmVyc2UoKSl9fWxldCBKPWduLnRyaWFuZ3VsYXRlU2hhcGUoeSx3KSxJPXk7Zm9yKGxldCBMPTAsb3Q9dy5sZW5ndGg7TDxvdDtMKyspe2xldCBYPXdbTF07eT15LmNvbmNhdChYKX1mdW5jdGlvbiB6KEwsb3QsWCl7cmV0dXJuIG90fHxjb25zb2xlLmVycm9yKCJUSFJFRS5FeHRydWRlR2VvbWV0cnk6IHZlYyBkb2VzIG5vdCBleGlzdCIpLEwuY2xvbmUoKS5hZGRTY2FsZWRWZWN0b3Iob3QsWCl9bGV0IEY9eS5sZW5ndGgsJD1KLmxlbmd0aDtmdW5jdGlvbiBxKEwsb3QsWCl7bGV0IHN0LFksYnQsaHQ9TC54LW90LngsYj1MLnktb3QueSxTPVgueC1MLngsTj1YLnktTC55LG50PWh0Kmh0K2IqYixqPWh0Kk4tYipTO2lmKE1hdGguYWJzKGopPk51bWJlci5FUFNJTE9OKXtsZXQgSz1NYXRoLnNxcnQobnQpLHh0PU1hdGguc3FydChTKlMrTipOKSxjdD1vdC54LWIvSyxtdD1vdC55K2h0L0ssUnQ9WC54LU4veHQsRnQ9WC55K1MveHQsdHQ9KChSdC1jdCkqTi0oRnQtbXQpKlMpLyhodCpOLWIqUyk7c3Q9Y3QraHQqdHQtTC54LFk9bXQrYip0dC1MLnk7bGV0IFl0PXN0KnN0K1kqWTtpZihZdDw9MilyZXR1cm4gbmV3IFooc3QsWSk7YnQ9TWF0aC5zcXJ0KFl0LzIpfWVsc2V7bGV0IEs9ITE7aHQ+TnVtYmVyLkVQU0lMT04/Uz5OdW1iZXIuRVBTSUxPTiYmKEs9ITApOmh0PC1OdW1iZXIuRVBTSUxPTj9TPC1OdW1iZXIuRVBTSUxPTiYmKEs9ITApOk1hdGguc2lnbihiKT09PU1hdGguc2lnbihOKSYmKEs9ITApLEs/KHN0PS1iLFk9aHQsYnQ9TWF0aC5zcXJ0KG50KSk6KHN0PWh0LFk9YixidD1NYXRoLnNxcnQobnQvMikpfXJldHVybiBuZXcgWihzdC9idCxZL2J0KX1sZXQgVz1bXTtmb3IobGV0IEw9MCxvdD1JLmxlbmd0aCxYPW90LTEsc3Q9TCsxO0w8b3Q7TCsrLFgrKyxzdCsrKVg9PT1vdCYmKFg9MCksc3Q9PT1vdCYmKHN0PTApLFdbTF09cShJW0xdLElbWF0sSVtzdF0pO2xldCBldD1bXSxRLGZ0PVcuY29uY2F0KCk7Zm9yKGxldCBMPTAsb3Q9dy5sZW5ndGg7TDxvdDtMKyspe2xldCBYPXdbTF07UT1bXTtmb3IobGV0IHN0PTAsWT1YLmxlbmd0aCxidD1ZLTEsaHQ9c3QrMTtzdDxZO3N0KyssYnQrKyxodCsrKWJ0PT09WSYmKGJ0PTApLGh0PT09WSYmKGh0PTApLFFbc3RdPXEoWFtzdF0sWFtidF0sWFtodF0pO2V0LnB1c2goUSksZnQ9ZnQuY29uY2F0KFEpfWZvcihsZXQgTD0wO0w8ZztMKyspe2xldCBvdD1ML2csWD1mKk1hdGguY29zKG90Kk1hdGguUEkvMiksc3Q9bSpNYXRoLnNpbihvdCpNYXRoLlBJLzIpK187Zm9yKGxldCBZPTAsYnQ9SS5sZW5ndGg7WTxidDtZKyspe2xldCBodD16KElbWV0sV1tZXSxzdCk7dnQoaHQueCxodC55LC1YKX1mb3IobGV0IFk9MCxidD13Lmxlbmd0aDtZPGJ0O1krKyl7bGV0IGh0PXdbWV07UT1ldFtZXTtmb3IobGV0IGI9MCxTPWh0Lmxlbmd0aDtiPFM7YisrKXtsZXQgTj16KGh0W2JdLFFbYl0sc3QpO3Z0KE4ueCxOLnksLVgpfX19bGV0IFB0PW0rXztmb3IobGV0IEw9MDtMPEY7TCsrKXtsZXQgb3Q9ZD96KHlbTF0sZnRbTF0sUHQpOnlbTF07TT8oVC5jb3B5KEMubm9ybWFsc1swXSkubXVsdGlwbHlTY2FsYXIob3QueCksQS5jb3B5KEMuYmlub3JtYWxzWzBdKS5tdWx0aXBseVNjYWxhcihvdC55KSxVLmNvcHkoeFswXSkuYWRkKFQpLmFkZChBKSx2dChVLngsVS55LFUueikpOnZ0KG90Lngsb3QueSwwKX1mb3IobGV0IEw9MTtMPD1oO0wrKylmb3IobGV0IG90PTA7b3Q8RjtvdCsrKXtsZXQgWD1kP3ooeVtvdF0sZnRbb3RdLFB0KTp5W290XTtNPyhULmNvcHkoQy5ub3JtYWxzW0xdKS5tdWx0aXBseVNjYWxhcihYLngpLEEuY29weShDLmJpbm9ybWFsc1tMXSkubXVsdGlwbHlTY2FsYXIoWC55KSxVLmNvcHkoeFtMXSkuYWRkKFQpLmFkZChBKSx2dChVLngsVS55LFUueikpOnZ0KFgueCxYLnksdS9oKkwpfWZvcihsZXQgTD1nLTE7TD49MDtMLS0pe2xldCBvdD1ML2csWD1mKk1hdGguY29zKG90Kk1hdGguUEkvMiksc3Q9bSpNYXRoLnNpbihvdCpNYXRoLlBJLzIpK187Zm9yKGxldCBZPTAsYnQ9SS5sZW5ndGg7WTxidDtZKyspe2xldCBodD16KElbWV0sV1tZXSxzdCk7dnQoaHQueCxodC55LHUrWCl9Zm9yKGxldCBZPTAsYnQ9dy5sZW5ndGg7WTxidDtZKyspe2xldCBodD13W1ldO1E9ZXRbWV07Zm9yKGxldCBiPTAsUz1odC5sZW5ndGg7YjxTO2IrKyl7bGV0IE49eihodFtiXSxRW2JdLHN0KTtNP3Z0KE4ueCxOLnkreFtoLTFdLnkseFtoLTFdLngrWCk6dnQoTi54LE4ueSx1K1gpfX19SCgpLGl0KCk7ZnVuY3Rpb24gSCgpe2xldCBMPWkubGVuZ3RoLzM7aWYoZCl7bGV0IG90PTAsWD1GKm90O2ZvcihsZXQgc3Q9MDtzdDwkO3N0Kyspe2xldCBZPUpbc3RdO0V0KFlbMl0rWCxZWzFdK1gsWVswXStYKX1vdD1oK2cqMixYPUYqb3Q7Zm9yKGxldCBzdD0wO3N0PCQ7c3QrKyl7bGV0IFk9SltzdF07RXQoWVswXStYLFlbMV0rWCxZWzJdK1gpfX1lbHNle2ZvcihsZXQgb3Q9MDtvdDwkO290Kyspe2xldCBYPUpbb3RdO0V0KFhbMl0sWFsxXSxYWzBdKX1mb3IobGV0IG90PTA7b3Q8JDtvdCsrKXtsZXQgWD1KW290XTtFdChYWzBdK0YqaCxYWzFdK0YqaCxYWzJdK0YqaCl9fW4uYWRkR3JvdXAoTCxpLmxlbmd0aC8zLUwsMCl9ZnVuY3Rpb24gaXQoKXtsZXQgTD1pLmxlbmd0aC8zLG90PTA7cHQoSSxvdCksb3QrPUkubGVuZ3RoO2ZvcihsZXQgWD0wLHN0PXcubGVuZ3RoO1g8c3Q7WCsrKXtsZXQgWT13W1hdO3B0KFksb3QpLG90Kz1ZLmxlbmd0aH1uLmFkZEdyb3VwKEwsaS5sZW5ndGgvMy1MLDEpfWZ1bmN0aW9uIHB0KEwsb3Qpe2xldCBYPUwubGVuZ3RoO2Zvcig7LS1YPj0wOyl7bGV0IHN0PVgsWT1YLTE7WTwwJiYoWT1MLmxlbmd0aC0xKTtmb3IobGV0IGJ0PTAsaHQ9aCtnKjI7YnQ8aHQ7YnQrKyl7bGV0IGI9RipidCxTPUYqKGJ0KzEpLE49b3Qrc3QrYixudD1vdCtZK2Isaj1vdCtZK1MsSz1vdCtzdCtTO3l0KE4sbnQsaixLKX19fWZ1bmN0aW9uIHZ0KEwsb3QsWCl7bC5wdXNoKEwpLGwucHVzaChvdCksbC5wdXNoKFgpfWZ1bmN0aW9uIEV0KEwsb3QsWCl7T3QoTCksT3Qob3QpLE90KFgpO2xldCBzdD1pLmxlbmd0aC8zLFk9di5nZW5lcmF0ZVRvcFVWKG4saSxzdC0zLHN0LTIsc3QtMSk7QXQoWVswXSksQXQoWVsxXSksQXQoWVsyXSl9ZnVuY3Rpb24geXQoTCxvdCxYLHN0KXtPdChMKSxPdChvdCksT3Qoc3QpLE90KG90KSxPdChYKSxPdChzdCk7bGV0IFk9aS5sZW5ndGgvMyxidD12LmdlbmVyYXRlU2lkZVdhbGxVVihuLGksWS02LFktMyxZLTIsWS0xKTtBdChidFswXSksQXQoYnRbMV0pLEF0KGJ0WzNdKSxBdChidFsxXSksQXQoYnRbMl0pLEF0KGJ0WzNdKX1mdW5jdGlvbiBPdChMKXtpLnB1c2gobFtMKjMrMF0pLGkucHVzaChsW0wqMysxXSksaS5wdXNoKGxbTCozKzJdKX1mdW5jdGlvbiBBdChMKXtyLnB1c2goTC54KSxyLnB1c2goTC55KX19fWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5wYXJhbWV0ZXJzPU9iamVjdC5hc3NpZ24oe30sdC5wYXJhbWV0ZXJzKSx0aGlzfXRvSlNPTigpe2xldCB0PXN1cGVyLnRvSlNPTigpLGU9dGhpcy5wYXJhbWV0ZXJzLnNoYXBlcyxuPXRoaXMucGFyYW1ldGVycy5vcHRpb25zO3JldHVybiBxdihlLG4sdCl9c3RhdGljIGZyb21KU09OKHQsZSl7bGV0IG49W107Zm9yKGxldCByPTAsYT10LnNoYXBlcy5sZW5ndGg7cjxhO3IrKyl7bGV0IG89ZVt0LnNoYXBlc1tyXV07bi5wdXNoKG8pfWxldCBpPXQub3B0aW9ucy5leHRydWRlUGF0aDtyZXR1cm4gaSE9PXZvaWQgMCYmKHQub3B0aW9ucy5leHRydWRlUGF0aD1uZXcgY29baS50eXBlXSgpLmZyb21KU09OKGkpKSxuZXcgcyhuLHQub3B0aW9ucyl9fSxYdj17Z2VuZXJhdGVUb3BVVjpmdW5jdGlvbihzLHQsZSxuLGkpe2xldCByPXRbZSozXSxhPXRbZSozKzFdLG89dFtuKjNdLGw9dFtuKjMrMV0sYz10W2kqM10saD10W2kqMysxXTtyZXR1cm5bbmV3IFoocixhKSxuZXcgWihvLGwpLG5ldyBaKGMsaCldfSxnZW5lcmF0ZVNpZGVXYWxsVVY6ZnVuY3Rpb24ocyx0LGUsbixpLHIpe2xldCBhPXRbZSozXSxvPXRbZSozKzFdLGw9dFtlKjMrMl0sYz10W24qM10saD10W24qMysxXSx1PXRbbiozKzJdLGQ9dFtpKjNdLGY9dFtpKjMrMV0sbT10W2kqMysyXSxfPXRbciozXSxnPXRbciozKzFdLHA9dFtyKjMrMl07cmV0dXJuIE1hdGguYWJzKG8taCk8TWF0aC5hYnMoYS1jKT9bbmV3IFooYSwxLWwpLG5ldyBaKGMsMS11KSxuZXcgWihkLDEtbSksbmV3IFooXywxLXApXTpbbmV3IFoobywxLWwpLG5ldyBaKGgsMS11KSxuZXcgWihmLDEtbSksbmV3IFooZywxLXApXX19O2Z1bmN0aW9uIHF2KHMsdCxlKXtpZihlLnNoYXBlcz1bXSxBcnJheS5pc0FycmF5KHMpKWZvcihsZXQgbj0wLGk9cy5sZW5ndGg7bjxpO24rKyl7bGV0IHI9c1tuXTtlLnNoYXBlcy5wdXNoKHIudXVpZCl9ZWxzZSBlLnNoYXBlcy5wdXNoKHMudXVpZCk7cmV0dXJuIGUub3B0aW9ucz1PYmplY3QuYXNzaWduKHt9LHQpLHQuZXh0cnVkZVBhdGghPT12b2lkIDAmJihlLm9wdGlvbnMuZXh0cnVkZVBhdGg9dC5leHRydWRlUGF0aC50b0pTT04oKSksZX12YXIgeG89Y2xhc3MgcyBleHRlbmRzIHNpe2NvbnN0cnVjdG9yKHQ9MSxlPTApe2xldCBuPSgxK01hdGguc3FydCg1KSkvMixpPVstMSxuLDAsMSxuLDAsLTEsLW4sMCwxLC1uLDAsMCwtMSxuLDAsMSxuLDAsLTEsLW4sMCwxLC1uLG4sMCwtMSxuLDAsMSwtbiwwLC0xLC1uLDAsMV0scj1bMCwxMSw1LDAsNSwxLDAsMSw3LDAsNywxMCwwLDEwLDExLDEsNSw5LDUsMTEsNCwxMSwxMCwyLDEwLDcsNiw3LDEsOCwzLDksNCwzLDQsMiwzLDIsNiwzLDYsOCwzLDgsOSw0LDksNSwyLDQsMTEsNiwyLDEwLDgsNiw3LDksOCwxXTtzdXBlcihpLHIsdCxlKSx0aGlzLnR5cGU9Ikljb3NhaGVkcm9uR2VvbWV0cnkiLHRoaXMucGFyYW1ldGVycz17cmFkaXVzOnQsZGV0YWlsOmV9fXN0YXRpYyBmcm9tSlNPTih0KXtyZXR1cm4gbmV3IHModC5yYWRpdXMsdC5kZXRhaWwpfX0sd3I9Y2xhc3MgcyBleHRlbmRzIHNpe2NvbnN0cnVjdG9yKHQ9MSxlPTApe2xldCBuPVsxLDAsMCwtMSwwLDAsMCwxLDAsMCwtMSwwLDAsMCwxLDAsMCwtMV0saT1bMCwyLDQsMCw0LDMsMCwzLDUsMCw1LDIsMSwyLDUsMSw1LDMsMSwzLDQsMSw0LDJdO3N1cGVyKG4saSx0LGUpLHRoaXMudHlwZT0iT2N0YWhlZHJvbkdlb21ldHJ5Iix0aGlzLnBhcmFtZXRlcnM9e3JhZGl1czp0LGRldGFpbDplfX1zdGF0aWMgZnJvbUpTT04odCl7cmV0dXJuIG5ldyBzKHQucmFkaXVzLHQuZGV0YWlsKX19LHZvPWNsYXNzIHMgZXh0ZW5kcyBIdHtjb25zdHJ1Y3Rvcih0PS41LGU9MSxuPTMyLGk9MSxyPTAsYT1NYXRoLlBJKjIpe3N1cGVyKCksdGhpcy50eXBlPSJSaW5nR2VvbWV0cnkiLHRoaXMucGFyYW1ldGVycz17aW5uZXJSYWRpdXM6dCxvdXRlclJhZGl1czplLHRoZXRhU2VnbWVudHM6bixwaGlTZWdtZW50czppLHRoZXRhU3RhcnQ6cix0aGV0YUxlbmd0aDphfSxuPU1hdGgubWF4KDMsbiksaT1NYXRoLm1heCgxLGkpO2xldCBvPVtdLGw9W10sYz1bXSxoPVtdLHU9dCxkPShlLXQpL2ksZj1uZXcgUixtPW5ldyBaO2ZvcihsZXQgXz0wO188PWk7XysrKXtmb3IobGV0IGc9MDtnPD1uO2crKyl7bGV0IHA9citnL24qYTtmLng9dSpNYXRoLmNvcyhwKSxmLnk9dSpNYXRoLnNpbihwKSxsLnB1c2goZi54LGYueSxmLnopLGMucHVzaCgwLDAsMSksbS54PShmLngvZSsxKS8yLG0ueT0oZi55L2UrMSkvMixoLnB1c2gobS54LG0ueSl9dSs9ZH1mb3IobGV0IF89MDtfPGk7XysrKXtsZXQgZz1fKihuKzEpO2ZvcihsZXQgcD0wO3A8bjtwKyspe2xldCB2PXArZyx4PXYsTT12K24rMSxDPXYrbisyLEE9disxO28ucHVzaCh4LE0sQSksby5wdXNoKE0sQyxBKX19dGhpcy5zZXRJbmRleChvKSx0aGlzLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBndChsLDMpKSx0aGlzLnNldEF0dHJpYnV0ZSgibm9ybWFsIixuZXcgZ3QoYywzKSksdGhpcy5zZXRBdHRyaWJ1dGUoInV2IixuZXcgZ3QoaCwyKSl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLnBhcmFtZXRlcnM9T2JqZWN0LmFzc2lnbih7fSx0LnBhcmFtZXRlcnMpLHRoaXN9c3RhdGljIGZyb21KU09OKHQpe3JldHVybiBuZXcgcyh0LmlubmVyUmFkaXVzLHQub3V0ZXJSYWRpdXMsdC50aGV0YVNlZ21lbnRzLHQucGhpU2VnbWVudHMsdC50aGV0YVN0YXJ0LHQudGhldGFMZW5ndGgpfX0seW89Y2xhc3MgcyBleHRlbmRzIEh0e2NvbnN0cnVjdG9yKHQ9bmV3IEZuKFtuZXcgWigwLC41KSxuZXcgWigtLjUsLS41KSxuZXcgWiguNSwtLjUpXSksZT0xMil7c3VwZXIoKSx0aGlzLnR5cGU9IlNoYXBlR2VvbWV0cnkiLHRoaXMucGFyYW1ldGVycz17c2hhcGVzOnQsY3VydmVTZWdtZW50czplfTtsZXQgbj1bXSxpPVtdLHI9W10sYT1bXSxvPTAsbD0wO2lmKEFycmF5LmlzQXJyYXkodCk9PT0hMSljKHQpO2Vsc2UgZm9yKGxldCBoPTA7aDx0Lmxlbmd0aDtoKyspYyh0W2hdKSx0aGlzLmFkZEdyb3VwKG8sbCxoKSxvKz1sLGw9MDt0aGlzLnNldEluZGV4KG4pLHRoaXMuc2V0QXR0cmlidXRlKCJwb3NpdGlvbiIsbmV3IGd0KGksMykpLHRoaXMuc2V0QXR0cmlidXRlKCJub3JtYWwiLG5ldyBndChyLDMpKSx0aGlzLnNldEF0dHJpYnV0ZSgidXYiLG5ldyBndChhLDIpKTtmdW5jdGlvbiBjKGgpe2xldCB1PWkubGVuZ3RoLzMsZD1oLmV4dHJhY3RQb2ludHMoZSksZj1kLnNoYXBlLG09ZC5ob2xlcztnbi5pc0Nsb2NrV2lzZShmKT09PSExJiYoZj1mLnJldmVyc2UoKSk7Zm9yKGxldCBnPTAscD1tLmxlbmd0aDtnPHA7ZysrKXtsZXQgdj1tW2ddO2duLmlzQ2xvY2tXaXNlKHYpPT09ITAmJihtW2ddPXYucmV2ZXJzZSgpKX1sZXQgXz1nbi50cmlhbmd1bGF0ZVNoYXBlKGYsbSk7Zm9yKGxldCBnPTAscD1tLmxlbmd0aDtnPHA7ZysrKXtsZXQgdj1tW2ddO2Y9Zi5jb25jYXQodil9Zm9yKGxldCBnPTAscD1mLmxlbmd0aDtnPHA7ZysrKXtsZXQgdj1mW2ddO2kucHVzaCh2Lngsdi55LDApLHIucHVzaCgwLDAsMSksYS5wdXNoKHYueCx2LnkpfWZvcihsZXQgZz0wLHA9Xy5sZW5ndGg7ZzxwO2crKyl7bGV0IHY9X1tnXSx4PXZbMF0rdSxNPXZbMV0rdSxDPXZbMl0rdTtuLnB1c2goeCxNLEMpLGwrPTN9fX1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMucGFyYW1ldGVycz1PYmplY3QuYXNzaWduKHt9LHQucGFyYW1ldGVycyksdGhpc310b0pTT04oKXtsZXQgdD1zdXBlci50b0pTT04oKSxlPXRoaXMucGFyYW1ldGVycy5zaGFwZXM7cmV0dXJuIFl2KGUsdCl9c3RhdGljIGZyb21KU09OKHQsZSl7bGV0IG49W107Zm9yKGxldCBpPTAscj10LnNoYXBlcy5sZW5ndGg7aTxyO2krKyl7bGV0IGE9ZVt0LnNoYXBlc1tpXV07bi5wdXNoKGEpfXJldHVybiBuZXcgcyhuLHQuY3VydmVTZWdtZW50cyl9fTtmdW5jdGlvbiBZdihzLHQpe2lmKHQuc2hhcGVzPVtdLEFycmF5LmlzQXJyYXkocykpZm9yKGxldCBlPTAsbj1zLmxlbmd0aDtlPG47ZSsrKXtsZXQgaT1zW2VdO3Quc2hhcGVzLnB1c2goaS51dWlkKX1lbHNlIHQuc2hhcGVzLnB1c2gocy51dWlkKTtyZXR1cm4gdH12YXIgUnI9Y2xhc3MgcyBleHRlbmRzIEh0e2NvbnN0cnVjdG9yKHQ9MSxlPTMyLG49MTYsaT0wLHI9TWF0aC5QSSoyLGE9MCxvPU1hdGguUEkpe3N1cGVyKCksdGhpcy50eXBlPSJTcGhlcmVHZW9tZXRyeSIsdGhpcy5wYXJhbWV0ZXJzPXtyYWRpdXM6dCx3aWR0aFNlZ21lbnRzOmUsaGVpZ2h0U2VnbWVudHM6bixwaGlTdGFydDppLHBoaUxlbmd0aDpyLHRoZXRhU3RhcnQ6YSx0aGV0YUxlbmd0aDpvfSxlPU1hdGgubWF4KDMsTWF0aC5mbG9vcihlKSksbj1NYXRoLm1heCgyLE1hdGguZmxvb3IobikpO2xldCBsPU1hdGgubWluKGErbyxNYXRoLlBJKSxjPTAsaD1bXSx1PW5ldyBSLGQ9bmV3IFIsZj1bXSxtPVtdLF89W10sZz1bXTtmb3IobGV0IHA9MDtwPD1uO3ArKyl7bGV0IHY9W10seD1wL24sTT0wO3A9PT0wJiZhPT09MD9NPS41L2U6cD09PW4mJmw9PT1NYXRoLlBJJiYoTT0tLjUvZSk7Zm9yKGxldCBDPTA7Qzw9ZTtDKyspe2xldCBBPUMvZTt1Lng9LXQqTWF0aC5jb3MoaStBKnIpKk1hdGguc2luKGEreCpvKSx1Lnk9dCpNYXRoLmNvcyhhK3gqbyksdS56PXQqTWF0aC5zaW4oaStBKnIpKk1hdGguc2luKGEreCpvKSxtLnB1c2godS54LHUueSx1LnopLGQuY29weSh1KS5ub3JtYWxpemUoKSxfLnB1c2goZC54LGQueSxkLnopLGcucHVzaChBK00sMS14KSx2LnB1c2goYysrKX1oLnB1c2godil9Zm9yKGxldCBwPTA7cDxuO3ArKylmb3IobGV0IHY9MDt2PGU7disrKXtsZXQgeD1oW3BdW3YrMV0sTT1oW3BdW3ZdLEM9aFtwKzFdW3ZdLEE9aFtwKzFdW3YrMV07KHAhPT0wfHxhPjApJiZmLnB1c2goeCxNLEEpLChwIT09bi0xfHxsPE1hdGguUEkpJiZmLnB1c2goTSxDLEEpfXRoaXMuc2V0SW5kZXgoZiksdGhpcy5zZXRBdHRyaWJ1dGUoInBvc2l0aW9uIixuZXcgZ3QobSwzKSksdGhpcy5zZXRBdHRyaWJ1dGUoIm5vcm1hbCIsbmV3IGd0KF8sMykpLHRoaXMuc2V0QXR0cmlidXRlKCJ1diIsbmV3IGd0KGcsMikpfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5wYXJhbWV0ZXJzPU9iamVjdC5hc3NpZ24oe30sdC5wYXJhbWV0ZXJzKSx0aGlzfXN0YXRpYyBmcm9tSlNPTih0KXtyZXR1cm4gbmV3IHModC5yYWRpdXMsdC53aWR0aFNlZ21lbnRzLHQuaGVpZ2h0U2VnbWVudHMsdC5waGlTdGFydCx0LnBoaUxlbmd0aCx0LnRoZXRhU3RhcnQsdC50aGV0YUxlbmd0aCl9fSxNbz1jbGFzcyBzIGV4dGVuZHMgc2l7Y29uc3RydWN0b3IodD0xLGU9MCl7bGV0IG49WzEsMSwxLC0xLC0xLDEsLTEsMSwtMSwxLC0xLC0xXSxpPVsyLDEsMCwwLDMsMiwxLDMsMCwyLDMsMV07c3VwZXIobixpLHQsZSksdGhpcy50eXBlPSJUZXRyYWhlZHJvbkdlb21ldHJ5Iix0aGlzLnBhcmFtZXRlcnM9e3JhZGl1czp0LGRldGFpbDplfX1zdGF0aWMgZnJvbUpTT04odCl7cmV0dXJuIG5ldyBzKHQucmFkaXVzLHQuZGV0YWlsKX19LFNvPWNsYXNzIHMgZXh0ZW5kcyBIdHtjb25zdHJ1Y3Rvcih0PTEsZT0uNCxuPTEyLGk9NDgscj1NYXRoLlBJKjIpe3N1cGVyKCksdGhpcy50eXBlPSJUb3J1c0dlb21ldHJ5Iix0aGlzLnBhcmFtZXRlcnM9e3JhZGl1czp0LHR1YmU6ZSxyYWRpYWxTZWdtZW50czpuLHR1YnVsYXJTZWdtZW50czppLGFyYzpyfSxuPU1hdGguZmxvb3IobiksaT1NYXRoLmZsb29yKGkpO2xldCBhPVtdLG89W10sbD1bXSxjPVtdLGg9bmV3IFIsdT1uZXcgUixkPW5ldyBSO2ZvcihsZXQgZj0wO2Y8PW47ZisrKWZvcihsZXQgbT0wO208PWk7bSsrKXtsZXQgXz1tL2kqcixnPWYvbipNYXRoLlBJKjI7dS54PSh0K2UqTWF0aC5jb3MoZykpKk1hdGguY29zKF8pLHUueT0odCtlKk1hdGguY29zKGcpKSpNYXRoLnNpbihfKSx1Lno9ZSpNYXRoLnNpbihnKSxvLnB1c2godS54LHUueSx1LnopLGgueD10Kk1hdGguY29zKF8pLGgueT10Kk1hdGguc2luKF8pLGQuc3ViVmVjdG9ycyh1LGgpLm5vcm1hbGl6ZSgpLGwucHVzaChkLngsZC55LGQueiksYy5wdXNoKG0vaSksYy5wdXNoKGYvbil9Zm9yKGxldCBmPTE7Zjw9bjtmKyspZm9yKGxldCBtPTE7bTw9aTttKyspe2xldCBfPShpKzEpKmYrbS0xLGc9KGkrMSkqKGYtMSkrbS0xLHA9KGkrMSkqKGYtMSkrbSx2PShpKzEpKmYrbTthLnB1c2goXyxnLHYpLGEucHVzaChnLHAsdil9dGhpcy5zZXRJbmRleChhKSx0aGlzLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBndChvLDMpKSx0aGlzLnNldEF0dHJpYnV0ZSgibm9ybWFsIixuZXcgZ3QobCwzKSksdGhpcy5zZXRBdHRyaWJ1dGUoInV2IixuZXcgZ3QoYywyKSl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLnBhcmFtZXRlcnM9T2JqZWN0LmFzc2lnbih7fSx0LnBhcmFtZXRlcnMpLHRoaXN9c3RhdGljIGZyb21KU09OKHQpe3JldHVybiBuZXcgcyh0LnJhZGl1cyx0LnR1YmUsdC5yYWRpYWxTZWdtZW50cyx0LnR1YnVsYXJTZWdtZW50cyx0LmFyYyl9fSxibz1jbGFzcyBzIGV4dGVuZHMgSHR7Y29uc3RydWN0b3IodD0xLGU9LjQsbj02NCxpPTgscj0yLGE9Myl7c3VwZXIoKSx0aGlzLnR5cGU9IlRvcnVzS25vdEdlb21ldHJ5Iix0aGlzLnBhcmFtZXRlcnM9e3JhZGl1czp0LHR1YmU6ZSx0dWJ1bGFyU2VnbWVudHM6bixyYWRpYWxTZWdtZW50czppLHA6cixxOmF9LG49TWF0aC5mbG9vcihuKSxpPU1hdGguZmxvb3IoaSk7bGV0IG89W10sbD1bXSxjPVtdLGg9W10sdT1uZXcgUixkPW5ldyBSLGY9bmV3IFIsbT1uZXcgUixfPW5ldyBSLGc9bmV3IFIscD1uZXcgUjtmb3IobGV0IHg9MDt4PD1uOysreCl7bGV0IE09eC9uKnIqTWF0aC5QSSoyO3YoTSxyLGEsdCxmKSx2KE0rLjAxLHIsYSx0LG0pLGcuc3ViVmVjdG9ycyhtLGYpLHAuYWRkVmVjdG9ycyhtLGYpLF8uY3Jvc3NWZWN0b3JzKGcscCkscC5jcm9zc1ZlY3RvcnMoXyxnKSxfLm5vcm1hbGl6ZSgpLHAubm9ybWFsaXplKCk7Zm9yKGxldCBDPTA7Qzw9aTsrK0Mpe2xldCBBPUMvaSpNYXRoLlBJKjIsVD0tZSpNYXRoLmNvcyhBKSxVPWUqTWF0aC5zaW4oQSk7dS54PWYueCsoVCpwLngrVSpfLngpLHUueT1mLnkrKFQqcC55K1UqXy55KSx1Lno9Zi56KyhUKnAueitVKl8ueiksbC5wdXNoKHUueCx1LnksdS56KSxkLnN1YlZlY3RvcnModSxmKS5ub3JtYWxpemUoKSxjLnB1c2goZC54LGQueSxkLnopLGgucHVzaCh4L24pLGgucHVzaChDL2kpfX1mb3IobGV0IHg9MTt4PD1uO3grKylmb3IobGV0IE09MTtNPD1pO00rKyl7bGV0IEM9KGkrMSkqKHgtMSkrKE0tMSksQT0oaSsxKSp4KyhNLTEpLFQ9KGkrMSkqeCtNLFU9KGkrMSkqKHgtMSkrTTtvLnB1c2goQyxBLFUpLG8ucHVzaChBLFQsVSl9dGhpcy5zZXRJbmRleChvKSx0aGlzLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBndChsLDMpKSx0aGlzLnNldEF0dHJpYnV0ZSgibm9ybWFsIixuZXcgZ3QoYywzKSksdGhpcy5zZXRBdHRyaWJ1dGUoInV2IixuZXcgZ3QoaCwyKSk7ZnVuY3Rpb24gdih4LE0sQyxBLFQpe2xldCBVPU1hdGguY29zKHgpLGs9TWF0aC5zaW4oeCkseT1DL00qeCx3PU1hdGguY29zKHkpO1QueD1BKigyK3cpKi41KlUsVC55PUEqKDIrdykqayouNSxULno9QSpNYXRoLnNpbih5KSouNX19Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLnBhcmFtZXRlcnM9T2JqZWN0LmFzc2lnbih7fSx0LnBhcmFtZXRlcnMpLHRoaXN9c3RhdGljIGZyb21KU09OKHQpe3JldHVybiBuZXcgcyh0LnJhZGl1cyx0LnR1YmUsdC50dWJ1bGFyU2VnbWVudHMsdC5yYWRpYWxTZWdtZW50cyx0LnAsdC5xKX19LEVvPWNsYXNzIHMgZXh0ZW5kcyBIdHtjb25zdHJ1Y3Rvcih0PW5ldyBNcihuZXcgUigtMSwtMSwwKSxuZXcgUigtMSwxLDApLG5ldyBSKDEsMSwwKSksZT02NCxuPTEsaT04LHI9ITEpe3N1cGVyKCksdGhpcy50eXBlPSJUdWJlR2VvbWV0cnkiLHRoaXMucGFyYW1ldGVycz17cGF0aDp0LHR1YnVsYXJTZWdtZW50czplLHJhZGl1czpuLHJhZGlhbFNlZ21lbnRzOmksY2xvc2VkOnJ9O2xldCBhPXQuY29tcHV0ZUZyZW5ldEZyYW1lcyhlLHIpO3RoaXMudGFuZ2VudHM9YS50YW5nZW50cyx0aGlzLm5vcm1hbHM9YS5ub3JtYWxzLHRoaXMuYmlub3JtYWxzPWEuYmlub3JtYWxzO2xldCBvPW5ldyBSLGw9bmV3IFIsYz1uZXcgWixoPW5ldyBSLHU9W10sZD1bXSxmPVtdLG09W107XygpLHRoaXMuc2V0SW5kZXgobSksdGhpcy5zZXRBdHRyaWJ1dGUoInBvc2l0aW9uIixuZXcgZ3QodSwzKSksdGhpcy5zZXRBdHRyaWJ1dGUoIm5vcm1hbCIsbmV3IGd0KGQsMykpLHRoaXMuc2V0QXR0cmlidXRlKCJ1diIsbmV3IGd0KGYsMikpO2Z1bmN0aW9uIF8oKXtmb3IobGV0IHg9MDt4PGU7eCsrKWcoeCk7ZyhyPT09ITE/ZTowKSx2KCkscCgpfWZ1bmN0aW9uIGcoeCl7aD10LmdldFBvaW50QXQoeC9lLGgpO2xldCBNPWEubm9ybWFsc1t4XSxDPWEuYmlub3JtYWxzW3hdO2ZvcihsZXQgQT0wO0E8PWk7QSsrKXtsZXQgVD1BL2kqTWF0aC5QSSoyLFU9TWF0aC5zaW4oVCksaz0tTWF0aC5jb3MoVCk7bC54PWsqTS54K1UqQy54LGwueT1rKk0ueStVKkMueSxsLno9aypNLnorVSpDLnosbC5ub3JtYWxpemUoKSxkLnB1c2gobC54LGwueSxsLnopLG8ueD1oLngrbipsLngsby55PWgueStuKmwueSxvLno9aC56K24qbC56LHUucHVzaChvLngsby55LG8ueil9fWZ1bmN0aW9uIHAoKXtmb3IobGV0IHg9MTt4PD1lO3grKylmb3IobGV0IE09MTtNPD1pO00rKyl7bGV0IEM9KGkrMSkqKHgtMSkrKE0tMSksQT0oaSsxKSp4KyhNLTEpLFQ9KGkrMSkqeCtNLFU9KGkrMSkqKHgtMSkrTTttLnB1c2goQyxBLFUpLG0ucHVzaChBLFQsVSl9fWZ1bmN0aW9uIHYoKXtmb3IobGV0IHg9MDt4PD1lO3grKylmb3IobGV0IE09MDtNPD1pO00rKyljLng9eC9lLGMueT1NL2ksZi5wdXNoKGMueCxjLnkpfX1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMucGFyYW1ldGVycz1PYmplY3QuYXNzaWduKHt9LHQucGFyYW1ldGVycyksdGhpc310b0pTT04oKXtsZXQgdD1zdXBlci50b0pTT04oKTtyZXR1cm4gdC5wYXRoPXRoaXMucGFyYW1ldGVycy5wYXRoLnRvSlNPTigpLHR9c3RhdGljIGZyb21KU09OKHQpe3JldHVybiBuZXcgcyhuZXcgY29bdC5wYXRoLnR5cGVdKCkuZnJvbUpTT04odC5wYXRoKSx0LnR1YnVsYXJTZWdtZW50cyx0LnJhZGl1cyx0LnJhZGlhbFNlZ21lbnRzLHQuY2xvc2VkKX19LEFvPWNsYXNzIGV4dGVuZHMgSHR7Y29uc3RydWN0b3IodD1udWxsKXtpZihzdXBlcigpLHRoaXMudHlwZT0iV2lyZWZyYW1lR2VvbWV0cnkiLHRoaXMucGFyYW1ldGVycz17Z2VvbWV0cnk6dH0sdCE9PW51bGwpe2xldCBlPVtdLG49bmV3IFNldCxpPW5ldyBSLHI9bmV3IFI7aWYodC5pbmRleCE9PW51bGwpe2xldCBhPXQuYXR0cmlidXRlcy5wb3NpdGlvbixvPXQuaW5kZXgsbD10Lmdyb3VwcztsLmxlbmd0aD09PTAmJihsPVt7c3RhcnQ6MCxjb3VudDpvLmNvdW50LG1hdGVyaWFsSW5kZXg6MH1dKTtmb3IobGV0IGM9MCxoPWwubGVuZ3RoO2M8aDsrK2Mpe2xldCB1PWxbY10sZD11LnN0YXJ0LGY9dS5jb3VudDtmb3IobGV0IG09ZCxfPWQrZjttPF87bSs9Mylmb3IobGV0IGc9MDtnPDM7ZysrKXtsZXQgcD1vLmdldFgobStnKSx2PW8uZ2V0WChtKyhnKzEpJTMpO2kuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhLHApLHIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhLHYpLEVkKGkscixuKT09PSEwJiYoZS5wdXNoKGkueCxpLnksaS56KSxlLnB1c2goci54LHIueSxyLnopKX19fWVsc2V7bGV0IGE9dC5hdHRyaWJ1dGVzLnBvc2l0aW9uO2ZvcihsZXQgbz0wLGw9YS5jb3VudC8zO288bDtvKyspZm9yKGxldCBjPTA7YzwzO2MrKyl7bGV0IGg9MypvK2MsdT0zKm8rKGMrMSklMztpLmZyb21CdWZmZXJBdHRyaWJ1dGUoYSxoKSxyLmZyb21CdWZmZXJBdHRyaWJ1dGUoYSx1KSxFZChpLHIsbik9PT0hMCYmKGUucHVzaChpLngsaS55LGkueiksZS5wdXNoKHIueCxyLnksci56KSl9fXRoaXMuc2V0QXR0cmlidXRlKCJwb3NpdGlvbiIsbmV3IGd0KGUsMykpfX1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMucGFyYW1ldGVycz1PYmplY3QuYXNzaWduKHt9LHQucGFyYW1ldGVycyksdGhpc319O2Z1bmN0aW9uIEVkKHMsdCxlKXtsZXQgbj1gJHtzLnh9LCR7cy55fSwke3Muen0tJHt0Lnh9LCR7dC55fSwke3Quen1gLGk9YCR7dC54fSwke3QueX0sJHt0Lnp9LSR7cy54fSwke3MueX0sJHtzLnp9YDtyZXR1cm4gZS5oYXMobik9PT0hMHx8ZS5oYXMoaSk9PT0hMD8hMTooZS5hZGQobiksZS5hZGQoaSksITApfXZhciBBZD1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxCb3hHZW9tZXRyeTpQaSxDYXBzdWxlR2VvbWV0cnk6dW8sQ2lyY2xlR2VvbWV0cnk6Zm8sQ29uZUdlb21ldHJ5OnBvLEN5bGluZGVyR2VvbWV0cnk6QXMsRG9kZWNhaGVkcm9uR2VvbWV0cnk6bW8sRWRnZXNHZW9tZXRyeTpnbyxFeHRydWRlR2VvbWV0cnk6X28sSWNvc2FoZWRyb25HZW9tZXRyeTp4byxMYXRoZUdlb21ldHJ5OmJyLE9jdGFoZWRyb25HZW9tZXRyeTp3cixQbGFuZUdlb21ldHJ5OnlzLFBvbHloZWRyb25HZW9tZXRyeTpzaSxSaW5nR2VvbWV0cnk6dm8sU2hhcGVHZW9tZXRyeTp5byxTcGhlcmVHZW9tZXRyeTpScixUZXRyYWhlZHJvbkdlb21ldHJ5Ok1vLFRvcnVzR2VvbWV0cnk6U28sVG9ydXNLbm90R2VvbWV0cnk6Ym8sVHViZUdlb21ldHJ5OkVvLFdpcmVmcmFtZUdlb21ldHJ5OkFvfSksVG89Y2xhc3MgZXh0ZW5kcyBBZXtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuaXNTaGFkb3dNYXRlcmlhbD0hMCx0aGlzLnR5cGU9IlNoYWRvd01hdGVyaWFsIix0aGlzLmNvbG9yPW5ldyB1dCgwKSx0aGlzLnRyYW5zcGFyZW50PSEwLHRoaXMuZm9nPSEwLHRoaXMuc2V0VmFsdWVzKHQpfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5jb2xvci5jb3B5KHQuY29sb3IpLHRoaXMuZm9nPXQuZm9nLHRoaXN9fSx3bz1jbGFzcyBleHRlbmRzIEple2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMuaXNSYXdTaGFkZXJNYXRlcmlhbD0hMCx0aGlzLnR5cGU9IlJhd1NoYWRlck1hdGVyaWFsIn19LENyPWNsYXNzIGV4dGVuZHMgQWV7Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWw9ITAsdGhpcy5kZWZpbmVzPXtTVEFOREFSRDoiIn0sdGhpcy50eXBlPSJNZXNoU3RhbmRhcmRNYXRlcmlhbCIsdGhpcy5jb2xvcj1uZXcgdXQoMTY3NzcyMTUpLHRoaXMucm91Z2huZXNzPTEsdGhpcy5tZXRhbG5lc3M9MCx0aGlzLm1hcD1udWxsLHRoaXMubGlnaHRNYXA9bnVsbCx0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5PTEsdGhpcy5hb01hcD1udWxsLHRoaXMuYW9NYXBJbnRlbnNpdHk9MSx0aGlzLmVtaXNzaXZlPW5ldyB1dCgwKSx0aGlzLmVtaXNzaXZlSW50ZW5zaXR5PTEsdGhpcy5lbWlzc2l2ZU1hcD1udWxsLHRoaXMuYnVtcE1hcD1udWxsLHRoaXMuYnVtcFNjYWxlPTEsdGhpcy5ub3JtYWxNYXA9bnVsbCx0aGlzLm5vcm1hbE1hcFR5cGU9YWksdGhpcy5ub3JtYWxTY2FsZT1uZXcgWigxLDEpLHRoaXMuZGlzcGxhY2VtZW50TWFwPW51bGwsdGhpcy5kaXNwbGFjZW1lbnRTY2FsZT0xLHRoaXMuZGlzcGxhY2VtZW50Qmlhcz0wLHRoaXMucm91Z2huZXNzTWFwPW51bGwsdGhpcy5tZXRhbG5lc3NNYXA9bnVsbCx0aGlzLmFscGhhTWFwPW51bGwsdGhpcy5lbnZNYXA9bnVsbCx0aGlzLmVudk1hcEludGVuc2l0eT0xLHRoaXMud2lyZWZyYW1lPSExLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPTEsdGhpcy53aXJlZnJhbWVMaW5lY2FwPSJyb3VuZCIsdGhpcy53aXJlZnJhbWVMaW5lam9pbj0icm91bmQiLHRoaXMuZmxhdFNoYWRpbmc9ITEsdGhpcy5mb2c9ITAsdGhpcy5zZXRWYWx1ZXModCl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLmRlZmluZXM9e1NUQU5EQVJEOiIifSx0aGlzLmNvbG9yLmNvcHkodC5jb2xvciksdGhpcy5yb3VnaG5lc3M9dC5yb3VnaG5lc3MsdGhpcy5tZXRhbG5lc3M9dC5tZXRhbG5lc3MsdGhpcy5tYXA9dC5tYXAsdGhpcy5saWdodE1hcD10LmxpZ2h0TWFwLHRoaXMubGlnaHRNYXBJbnRlbnNpdHk9dC5saWdodE1hcEludGVuc2l0eSx0aGlzLmFvTWFwPXQuYW9NYXAsdGhpcy5hb01hcEludGVuc2l0eT10LmFvTWFwSW50ZW5zaXR5LHRoaXMuZW1pc3NpdmUuY29weSh0LmVtaXNzaXZlKSx0aGlzLmVtaXNzaXZlTWFwPXQuZW1pc3NpdmVNYXAsdGhpcy5lbWlzc2l2ZUludGVuc2l0eT10LmVtaXNzaXZlSW50ZW5zaXR5LHRoaXMuYnVtcE1hcD10LmJ1bXBNYXAsdGhpcy5idW1wU2NhbGU9dC5idW1wU2NhbGUsdGhpcy5ub3JtYWxNYXA9dC5ub3JtYWxNYXAsdGhpcy5ub3JtYWxNYXBUeXBlPXQubm9ybWFsTWFwVHlwZSx0aGlzLm5vcm1hbFNjYWxlLmNvcHkodC5ub3JtYWxTY2FsZSksdGhpcy5kaXNwbGFjZW1lbnRNYXA9dC5kaXNwbGFjZW1lbnRNYXAsdGhpcy5kaXNwbGFjZW1lbnRTY2FsZT10LmRpc3BsYWNlbWVudFNjYWxlLHRoaXMuZGlzcGxhY2VtZW50Qmlhcz10LmRpc3BsYWNlbWVudEJpYXMsdGhpcy5yb3VnaG5lc3NNYXA9dC5yb3VnaG5lc3NNYXAsdGhpcy5tZXRhbG5lc3NNYXA9dC5tZXRhbG5lc3NNYXAsdGhpcy5hbHBoYU1hcD10LmFscGhhTWFwLHRoaXMuZW52TWFwPXQuZW52TWFwLHRoaXMuZW52TWFwSW50ZW5zaXR5PXQuZW52TWFwSW50ZW5zaXR5LHRoaXMud2lyZWZyYW1lPXQud2lyZWZyYW1lLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPXQud2lyZWZyYW1lTGluZXdpZHRoLHRoaXMud2lyZWZyYW1lTGluZWNhcD10LndpcmVmcmFtZUxpbmVjYXAsdGhpcy53aXJlZnJhbWVMaW5lam9pbj10LndpcmVmcmFtZUxpbmVqb2luLHRoaXMuZmxhdFNoYWRpbmc9dC5mbGF0U2hhZGluZyx0aGlzLmZvZz10LmZvZyx0aGlzfX0sUm89Y2xhc3MgZXh0ZW5kcyBDcntjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuaXNNZXNoUGh5c2ljYWxNYXRlcmlhbD0hMCx0aGlzLmRlZmluZXM9e1NUQU5EQVJEOiIiLFBIWVNJQ0FMOiIifSx0aGlzLnR5cGU9Ik1lc2hQaHlzaWNhbE1hdGVyaWFsIix0aGlzLmFuaXNvdHJvcHlSb3RhdGlvbj0wLHRoaXMuYW5pc290cm9weU1hcD1udWxsLHRoaXMuY2xlYXJjb2F0TWFwPW51bGwsdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3M9MCx0aGlzLmNsZWFyY29hdFJvdWdobmVzc01hcD1udWxsLHRoaXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGU9bmV3IFooMSwxKSx0aGlzLmNsZWFyY29hdE5vcm1hbE1hcD1udWxsLHRoaXMuaW9yPTEuNSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicmVmbGVjdGl2aXR5Iix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHVlKDIuNSoodGhpcy5pb3ItMSkvKHRoaXMuaW9yKzEpLDAsMSl9LHNldDpmdW5jdGlvbihlKXt0aGlzLmlvcj0oMSsuNCplKS8oMS0uNCplKX19KSx0aGlzLmlyaWRlc2NlbmNlTWFwPW51bGwsdGhpcy5pcmlkZXNjZW5jZUlPUj0xLjMsdGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlPVsxMDAsNDAwXSx0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwPW51bGwsdGhpcy5zaGVlbkNvbG9yPW5ldyB1dCgwKSx0aGlzLnNoZWVuQ29sb3JNYXA9bnVsbCx0aGlzLnNoZWVuUm91Z2huZXNzPTEsdGhpcy5zaGVlblJvdWdobmVzc01hcD1udWxsLHRoaXMudHJhbnNtaXNzaW9uTWFwPW51bGwsdGhpcy50aGlja25lc3M9MCx0aGlzLnRoaWNrbmVzc01hcD1udWxsLHRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZT0xLzAsdGhpcy5hdHRlbnVhdGlvbkNvbG9yPW5ldyB1dCgxLDEsMSksdGhpcy5zcGVjdWxhckludGVuc2l0eT0xLHRoaXMuc3BlY3VsYXJJbnRlbnNpdHlNYXA9bnVsbCx0aGlzLnNwZWN1bGFyQ29sb3I9bmV3IHV0KDEsMSwxKSx0aGlzLnNwZWN1bGFyQ29sb3JNYXA9bnVsbCx0aGlzLl9hbmlzb3Ryb3B5PTAsdGhpcy5fY2xlYXJjb2F0PTAsdGhpcy5faXJpZGVzY2VuY2U9MCx0aGlzLl9zaGVlbj0wLHRoaXMuX3RyYW5zbWlzc2lvbj0wLHRoaXMuc2V0VmFsdWVzKHQpfWdldCBhbmlzb3Ryb3B5KCl7cmV0dXJuIHRoaXMuX2FuaXNvdHJvcHl9c2V0IGFuaXNvdHJvcHkodCl7dGhpcy5fYW5pc290cm9weT4wIT10PjAmJnRoaXMudmVyc2lvbisrLHRoaXMuX2FuaXNvdHJvcHk9dH1nZXQgY2xlYXJjb2F0KCl7cmV0dXJuIHRoaXMuX2NsZWFyY29hdH1zZXQgY2xlYXJjb2F0KHQpe3RoaXMuX2NsZWFyY29hdD4wIT10PjAmJnRoaXMudmVyc2lvbisrLHRoaXMuX2NsZWFyY29hdD10fWdldCBpcmlkZXNjZW5jZSgpe3JldHVybiB0aGlzLl9pcmlkZXNjZW5jZX1zZXQgaXJpZGVzY2VuY2UodCl7dGhpcy5faXJpZGVzY2VuY2U+MCE9dD4wJiZ0aGlzLnZlcnNpb24rKyx0aGlzLl9pcmlkZXNjZW5jZT10fWdldCBzaGVlbigpe3JldHVybiB0aGlzLl9zaGVlbn1zZXQgc2hlZW4odCl7dGhpcy5fc2hlZW4+MCE9dD4wJiZ0aGlzLnZlcnNpb24rKyx0aGlzLl9zaGVlbj10fWdldCB0cmFuc21pc3Npb24oKXtyZXR1cm4gdGhpcy5fdHJhbnNtaXNzaW9ufXNldCB0cmFuc21pc3Npb24odCl7dGhpcy5fdHJhbnNtaXNzaW9uPjAhPXQ+MCYmdGhpcy52ZXJzaW9uKyssdGhpcy5fdHJhbnNtaXNzaW9uPXR9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLmRlZmluZXM9e1NUQU5EQVJEOiIiLFBIWVNJQ0FMOiIifSx0aGlzLmFuaXNvdHJvcHk9dC5hbmlzb3Ryb3B5LHRoaXMuYW5pc290cm9weVJvdGF0aW9uPXQuYW5pc290cm9weVJvdGF0aW9uLHRoaXMuYW5pc290cm9weU1hcD10LmFuaXNvdHJvcHlNYXAsdGhpcy5jbGVhcmNvYXQ9dC5jbGVhcmNvYXQsdGhpcy5jbGVhcmNvYXRNYXA9dC5jbGVhcmNvYXRNYXAsdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3M9dC5jbGVhcmNvYXRSb3VnaG5lc3MsdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXA9dC5jbGVhcmNvYXRSb3VnaG5lc3NNYXAsdGhpcy5jbGVhcmNvYXROb3JtYWxNYXA9dC5jbGVhcmNvYXROb3JtYWxNYXAsdGhpcy5jbGVhcmNvYXROb3JtYWxTY2FsZS5jb3B5KHQuY2xlYXJjb2F0Tm9ybWFsU2NhbGUpLHRoaXMuaW9yPXQuaW9yLHRoaXMuaXJpZGVzY2VuY2U9dC5pcmlkZXNjZW5jZSx0aGlzLmlyaWRlc2NlbmNlTWFwPXQuaXJpZGVzY2VuY2VNYXAsdGhpcy5pcmlkZXNjZW5jZUlPUj10LmlyaWRlc2NlbmNlSU9SLHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZT1bLi4udC5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlXSx0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwPXQuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAsdGhpcy5zaGVlbj10LnNoZWVuLHRoaXMuc2hlZW5Db2xvci5jb3B5KHQuc2hlZW5Db2xvciksdGhpcy5zaGVlbkNvbG9yTWFwPXQuc2hlZW5Db2xvck1hcCx0aGlzLnNoZWVuUm91Z2huZXNzPXQuc2hlZW5Sb3VnaG5lc3MsdGhpcy5zaGVlblJvdWdobmVzc01hcD10LnNoZWVuUm91Z2huZXNzTWFwLHRoaXMudHJhbnNtaXNzaW9uPXQudHJhbnNtaXNzaW9uLHRoaXMudHJhbnNtaXNzaW9uTWFwPXQudHJhbnNtaXNzaW9uTWFwLHRoaXMudGhpY2tuZXNzPXQudGhpY2tuZXNzLHRoaXMudGhpY2tuZXNzTWFwPXQudGhpY2tuZXNzTWFwLHRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZT10LmF0dGVudWF0aW9uRGlzdGFuY2UsdGhpcy5hdHRlbnVhdGlvbkNvbG9yLmNvcHkodC5hdHRlbnVhdGlvbkNvbG9yKSx0aGlzLnNwZWN1bGFySW50ZW5zaXR5PXQuc3BlY3VsYXJJbnRlbnNpdHksdGhpcy5zcGVjdWxhckludGVuc2l0eU1hcD10LnNwZWN1bGFySW50ZW5zaXR5TWFwLHRoaXMuc3BlY3VsYXJDb2xvci5jb3B5KHQuc3BlY3VsYXJDb2xvciksdGhpcy5zcGVjdWxhckNvbG9yTWFwPXQuc3BlY3VsYXJDb2xvck1hcCx0aGlzfX0sQ289Y2xhc3MgZXh0ZW5kcyBBZXtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuaXNNZXNoUGhvbmdNYXRlcmlhbD0hMCx0aGlzLnR5cGU9Ik1lc2hQaG9uZ01hdGVyaWFsIix0aGlzLmNvbG9yPW5ldyB1dCgxNjc3NzIxNSksdGhpcy5zcGVjdWxhcj1uZXcgdXQoMTExODQ4MSksdGhpcy5zaGluaW5lc3M9MzAsdGhpcy5tYXA9bnVsbCx0aGlzLmxpZ2h0TWFwPW51bGwsdGhpcy5saWdodE1hcEludGVuc2l0eT0xLHRoaXMuYW9NYXA9bnVsbCx0aGlzLmFvTWFwSW50ZW5zaXR5PTEsdGhpcy5lbWlzc2l2ZT1uZXcgdXQoMCksdGhpcy5lbWlzc2l2ZUludGVuc2l0eT0xLHRoaXMuZW1pc3NpdmVNYXA9bnVsbCx0aGlzLmJ1bXBNYXA9bnVsbCx0aGlzLmJ1bXBTY2FsZT0xLHRoaXMubm9ybWFsTWFwPW51bGwsdGhpcy5ub3JtYWxNYXBUeXBlPWFpLHRoaXMubm9ybWFsU2NhbGU9bmV3IFooMSwxKSx0aGlzLmRpc3BsYWNlbWVudE1hcD1udWxsLHRoaXMuZGlzcGxhY2VtZW50U2NhbGU9MSx0aGlzLmRpc3BsYWNlbWVudEJpYXM9MCx0aGlzLnNwZWN1bGFyTWFwPW51bGwsdGhpcy5hbHBoYU1hcD1udWxsLHRoaXMuZW52TWFwPW51bGwsdGhpcy5jb21iaW5lPU9yLHRoaXMucmVmbGVjdGl2aXR5PTEsdGhpcy5yZWZyYWN0aW9uUmF0aW89Ljk4LHRoaXMud2lyZWZyYW1lPSExLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPTEsdGhpcy53aXJlZnJhbWVMaW5lY2FwPSJyb3VuZCIsdGhpcy53aXJlZnJhbWVMaW5lam9pbj0icm91bmQiLHRoaXMuZmxhdFNoYWRpbmc9ITEsdGhpcy5mb2c9ITAsdGhpcy5zZXRWYWx1ZXModCl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLmNvbG9yLmNvcHkodC5jb2xvciksdGhpcy5zcGVjdWxhci5jb3B5KHQuc3BlY3VsYXIpLHRoaXMuc2hpbmluZXNzPXQuc2hpbmluZXNzLHRoaXMubWFwPXQubWFwLHRoaXMubGlnaHRNYXA9dC5saWdodE1hcCx0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5PXQubGlnaHRNYXBJbnRlbnNpdHksdGhpcy5hb01hcD10LmFvTWFwLHRoaXMuYW9NYXBJbnRlbnNpdHk9dC5hb01hcEludGVuc2l0eSx0aGlzLmVtaXNzaXZlLmNvcHkodC5lbWlzc2l2ZSksdGhpcy5lbWlzc2l2ZU1hcD10LmVtaXNzaXZlTWFwLHRoaXMuZW1pc3NpdmVJbnRlbnNpdHk9dC5lbWlzc2l2ZUludGVuc2l0eSx0aGlzLmJ1bXBNYXA9dC5idW1wTWFwLHRoaXMuYnVtcFNjYWxlPXQuYnVtcFNjYWxlLHRoaXMubm9ybWFsTWFwPXQubm9ybWFsTWFwLHRoaXMubm9ybWFsTWFwVHlwZT10Lm5vcm1hbE1hcFR5cGUsdGhpcy5ub3JtYWxTY2FsZS5jb3B5KHQubm9ybWFsU2NhbGUpLHRoaXMuZGlzcGxhY2VtZW50TWFwPXQuZGlzcGxhY2VtZW50TWFwLHRoaXMuZGlzcGxhY2VtZW50U2NhbGU9dC5kaXNwbGFjZW1lbnRTY2FsZSx0aGlzLmRpc3BsYWNlbWVudEJpYXM9dC5kaXNwbGFjZW1lbnRCaWFzLHRoaXMuc3BlY3VsYXJNYXA9dC5zcGVjdWxhck1hcCx0aGlzLmFscGhhTWFwPXQuYWxwaGFNYXAsdGhpcy5lbnZNYXA9dC5lbnZNYXAsdGhpcy5jb21iaW5lPXQuY29tYmluZSx0aGlzLnJlZmxlY3Rpdml0eT10LnJlZmxlY3Rpdml0eSx0aGlzLnJlZnJhY3Rpb25SYXRpbz10LnJlZnJhY3Rpb25SYXRpbyx0aGlzLndpcmVmcmFtZT10LndpcmVmcmFtZSx0aGlzLndpcmVmcmFtZUxpbmV3aWR0aD10LndpcmVmcmFtZUxpbmV3aWR0aCx0aGlzLndpcmVmcmFtZUxpbmVjYXA9dC53aXJlZnJhbWVMaW5lY2FwLHRoaXMud2lyZWZyYW1lTGluZWpvaW49dC53aXJlZnJhbWVMaW5lam9pbix0aGlzLmZsYXRTaGFkaW5nPXQuZmxhdFNoYWRpbmcsdGhpcy5mb2c9dC5mb2csdGhpc319LFBvPWNsYXNzIGV4dGVuZHMgQWV7Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLmlzTWVzaFRvb25NYXRlcmlhbD0hMCx0aGlzLmRlZmluZXM9e1RPT046IiJ9LHRoaXMudHlwZT0iTWVzaFRvb25NYXRlcmlhbCIsdGhpcy5jb2xvcj1uZXcgdXQoMTY3NzcyMTUpLHRoaXMubWFwPW51bGwsdGhpcy5ncmFkaWVudE1hcD1udWxsLHRoaXMubGlnaHRNYXA9bnVsbCx0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5PTEsdGhpcy5hb01hcD1udWxsLHRoaXMuYW9NYXBJbnRlbnNpdHk9MSx0aGlzLmVtaXNzaXZlPW5ldyB1dCgwKSx0aGlzLmVtaXNzaXZlSW50ZW5zaXR5PTEsdGhpcy5lbWlzc2l2ZU1hcD1udWxsLHRoaXMuYnVtcE1hcD1udWxsLHRoaXMuYnVtcFNjYWxlPTEsdGhpcy5ub3JtYWxNYXA9bnVsbCx0aGlzLm5vcm1hbE1hcFR5cGU9YWksdGhpcy5ub3JtYWxTY2FsZT1uZXcgWigxLDEpLHRoaXMuZGlzcGxhY2VtZW50TWFwPW51bGwsdGhpcy5kaXNwbGFjZW1lbnRTY2FsZT0xLHRoaXMuZGlzcGxhY2VtZW50Qmlhcz0wLHRoaXMuYWxwaGFNYXA9bnVsbCx0aGlzLndpcmVmcmFtZT0hMSx0aGlzLndpcmVmcmFtZUxpbmV3aWR0aD0xLHRoaXMud2lyZWZyYW1lTGluZWNhcD0icm91bmQiLHRoaXMud2lyZWZyYW1lTGluZWpvaW49InJvdW5kIix0aGlzLmZvZz0hMCx0aGlzLnNldFZhbHVlcyh0KX1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMuY29sb3IuY29weSh0LmNvbG9yKSx0aGlzLm1hcD10Lm1hcCx0aGlzLmdyYWRpZW50TWFwPXQuZ3JhZGllbnRNYXAsdGhpcy5saWdodE1hcD10LmxpZ2h0TWFwLHRoaXMubGlnaHRNYXBJbnRlbnNpdHk9dC5saWdodE1hcEludGVuc2l0eSx0aGlzLmFvTWFwPXQuYW9NYXAsdGhpcy5hb01hcEludGVuc2l0eT10LmFvTWFwSW50ZW5zaXR5LHRoaXMuZW1pc3NpdmUuY29weSh0LmVtaXNzaXZlKSx0aGlzLmVtaXNzaXZlTWFwPXQuZW1pc3NpdmVNYXAsdGhpcy5lbWlzc2l2ZUludGVuc2l0eT10LmVtaXNzaXZlSW50ZW5zaXR5LHRoaXMuYnVtcE1hcD10LmJ1bXBNYXAsdGhpcy5idW1wU2NhbGU9dC5idW1wU2NhbGUsdGhpcy5ub3JtYWxNYXA9dC5ub3JtYWxNYXAsdGhpcy5ub3JtYWxNYXBUeXBlPXQubm9ybWFsTWFwVHlwZSx0aGlzLm5vcm1hbFNjYWxlLmNvcHkodC5ub3JtYWxTY2FsZSksdGhpcy5kaXNwbGFjZW1lbnRNYXA9dC5kaXNwbGFjZW1lbnRNYXAsdGhpcy5kaXNwbGFjZW1lbnRTY2FsZT10LmRpc3BsYWNlbWVudFNjYWxlLHRoaXMuZGlzcGxhY2VtZW50Qmlhcz10LmRpc3BsYWNlbWVudEJpYXMsdGhpcy5hbHBoYU1hcD10LmFscGhhTWFwLHRoaXMud2lyZWZyYW1lPXQud2lyZWZyYW1lLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPXQud2lyZWZyYW1lTGluZXdpZHRoLHRoaXMud2lyZWZyYW1lTGluZWNhcD10LndpcmVmcmFtZUxpbmVjYXAsdGhpcy53aXJlZnJhbWVMaW5lam9pbj10LndpcmVmcmFtZUxpbmVqb2luLHRoaXMuZm9nPXQuZm9nLHRoaXN9fSxMbz1jbGFzcyBleHRlbmRzIEFle2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5pc01lc2hOb3JtYWxNYXRlcmlhbD0hMCx0aGlzLnR5cGU9Ik1lc2hOb3JtYWxNYXRlcmlhbCIsdGhpcy5idW1wTWFwPW51bGwsdGhpcy5idW1wU2NhbGU9MSx0aGlzLm5vcm1hbE1hcD1udWxsLHRoaXMubm9ybWFsTWFwVHlwZT1haSx0aGlzLm5vcm1hbFNjYWxlPW5ldyBaKDEsMSksdGhpcy5kaXNwbGFjZW1lbnRNYXA9bnVsbCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPTEsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPTAsdGhpcy53aXJlZnJhbWU9ITEsdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg9MSx0aGlzLmZsYXRTaGFkaW5nPSExLHRoaXMuc2V0VmFsdWVzKHQpfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5idW1wTWFwPXQuYnVtcE1hcCx0aGlzLmJ1bXBTY2FsZT10LmJ1bXBTY2FsZSx0aGlzLm5vcm1hbE1hcD10Lm5vcm1hbE1hcCx0aGlzLm5vcm1hbE1hcFR5cGU9dC5ub3JtYWxNYXBUeXBlLHRoaXMubm9ybWFsU2NhbGUuY29weSh0Lm5vcm1hbFNjYWxlKSx0aGlzLmRpc3BsYWNlbWVudE1hcD10LmRpc3BsYWNlbWVudE1hcCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPXQuZGlzcGxhY2VtZW50U2NhbGUsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPXQuZGlzcGxhY2VtZW50Qmlhcyx0aGlzLndpcmVmcmFtZT10LndpcmVmcmFtZSx0aGlzLndpcmVmcmFtZUxpbmV3aWR0aD10LndpcmVmcmFtZUxpbmV3aWR0aCx0aGlzLmZsYXRTaGFkaW5nPXQuZmxhdFNoYWRpbmcsdGhpc319LElvPWNsYXNzIGV4dGVuZHMgQWV7Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLmlzTWVzaExhbWJlcnRNYXRlcmlhbD0hMCx0aGlzLnR5cGU9Ik1lc2hMYW1iZXJ0TWF0ZXJpYWwiLHRoaXMuY29sb3I9bmV3IHV0KDE2Nzc3MjE1KSx0aGlzLm1hcD1udWxsLHRoaXMubGlnaHRNYXA9bnVsbCx0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5PTEsdGhpcy5hb01hcD1udWxsLHRoaXMuYW9NYXBJbnRlbnNpdHk9MSx0aGlzLmVtaXNzaXZlPW5ldyB1dCgwKSx0aGlzLmVtaXNzaXZlSW50ZW5zaXR5PTEsdGhpcy5lbWlzc2l2ZU1hcD1udWxsLHRoaXMuYnVtcE1hcD1udWxsLHRoaXMuYnVtcFNjYWxlPTEsdGhpcy5ub3JtYWxNYXA9bnVsbCx0aGlzLm5vcm1hbE1hcFR5cGU9YWksdGhpcy5ub3JtYWxTY2FsZT1uZXcgWigxLDEpLHRoaXMuZGlzcGxhY2VtZW50TWFwPW51bGwsdGhpcy5kaXNwbGFjZW1lbnRTY2FsZT0xLHRoaXMuZGlzcGxhY2VtZW50Qmlhcz0wLHRoaXMuc3BlY3VsYXJNYXA9bnVsbCx0aGlzLmFscGhhTWFwPW51bGwsdGhpcy5lbnZNYXA9bnVsbCx0aGlzLmNvbWJpbmU9T3IsdGhpcy5yZWZsZWN0aXZpdHk9MSx0aGlzLnJlZnJhY3Rpb25SYXRpbz0uOTgsdGhpcy53aXJlZnJhbWU9ITEsdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg9MSx0aGlzLndpcmVmcmFtZUxpbmVjYXA9InJvdW5kIix0aGlzLndpcmVmcmFtZUxpbmVqb2luPSJyb3VuZCIsdGhpcy5mbGF0U2hhZGluZz0hMSx0aGlzLmZvZz0hMCx0aGlzLnNldFZhbHVlcyh0KX1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMuY29sb3IuY29weSh0LmNvbG9yKSx0aGlzLm1hcD10Lm1hcCx0aGlzLmxpZ2h0TWFwPXQubGlnaHRNYXAsdGhpcy5saWdodE1hcEludGVuc2l0eT10LmxpZ2h0TWFwSW50ZW5zaXR5LHRoaXMuYW9NYXA9dC5hb01hcCx0aGlzLmFvTWFwSW50ZW5zaXR5PXQuYW9NYXBJbnRlbnNpdHksdGhpcy5lbWlzc2l2ZS5jb3B5KHQuZW1pc3NpdmUpLHRoaXMuZW1pc3NpdmVNYXA9dC5lbWlzc2l2ZU1hcCx0aGlzLmVtaXNzaXZlSW50ZW5zaXR5PXQuZW1pc3NpdmVJbnRlbnNpdHksdGhpcy5idW1wTWFwPXQuYnVtcE1hcCx0aGlzLmJ1bXBTY2FsZT10LmJ1bXBTY2FsZSx0aGlzLm5vcm1hbE1hcD10Lm5vcm1hbE1hcCx0aGlzLm5vcm1hbE1hcFR5cGU9dC5ub3JtYWxNYXBUeXBlLHRoaXMubm9ybWFsU2NhbGUuY29weSh0Lm5vcm1hbFNjYWxlKSx0aGlzLmRpc3BsYWNlbWVudE1hcD10LmRpc3BsYWNlbWVudE1hcCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPXQuZGlzcGxhY2VtZW50U2NhbGUsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPXQuZGlzcGxhY2VtZW50Qmlhcyx0aGlzLnNwZWN1bGFyTWFwPXQuc3BlY3VsYXJNYXAsdGhpcy5hbHBoYU1hcD10LmFscGhhTWFwLHRoaXMuZW52TWFwPXQuZW52TWFwLHRoaXMuY29tYmluZT10LmNvbWJpbmUsdGhpcy5yZWZsZWN0aXZpdHk9dC5yZWZsZWN0aXZpdHksdGhpcy5yZWZyYWN0aW9uUmF0aW89dC5yZWZyYWN0aW9uUmF0aW8sdGhpcy53aXJlZnJhbWU9dC53aXJlZnJhbWUsdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg9dC53aXJlZnJhbWVMaW5ld2lkdGgsdGhpcy53aXJlZnJhbWVMaW5lY2FwPXQud2lyZWZyYW1lTGluZWNhcCx0aGlzLndpcmVmcmFtZUxpbmVqb2luPXQud2lyZWZyYW1lTGluZWpvaW4sdGhpcy5mbGF0U2hhZGluZz10LmZsYXRTaGFkaW5nLHRoaXMuZm9nPXQuZm9nLHRoaXN9fSxVbz1jbGFzcyBleHRlbmRzIEFle2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5pc01lc2hNYXRjYXBNYXRlcmlhbD0hMCx0aGlzLmRlZmluZXM9e01BVENBUDoiIn0sdGhpcy50eXBlPSJNZXNoTWF0Y2FwTWF0ZXJpYWwiLHRoaXMuY29sb3I9bmV3IHV0KDE2Nzc3MjE1KSx0aGlzLm1hdGNhcD1udWxsLHRoaXMubWFwPW51bGwsdGhpcy5idW1wTWFwPW51bGwsdGhpcy5idW1wU2NhbGU9MSx0aGlzLm5vcm1hbE1hcD1udWxsLHRoaXMubm9ybWFsTWFwVHlwZT1haSx0aGlzLm5vcm1hbFNjYWxlPW5ldyBaKDEsMSksdGhpcy5kaXNwbGFjZW1lbnRNYXA9bnVsbCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPTEsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPTAsdGhpcy5hbHBoYU1hcD1udWxsLHRoaXMuZmxhdFNoYWRpbmc9ITEsdGhpcy5mb2c9ITAsdGhpcy5zZXRWYWx1ZXModCl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLmRlZmluZXM9e01BVENBUDoiIn0sdGhpcy5jb2xvci5jb3B5KHQuY29sb3IpLHRoaXMubWF0Y2FwPXQubWF0Y2FwLHRoaXMubWFwPXQubWFwLHRoaXMuYnVtcE1hcD10LmJ1bXBNYXAsdGhpcy5idW1wU2NhbGU9dC5idW1wU2NhbGUsdGhpcy5ub3JtYWxNYXA9dC5ub3JtYWxNYXAsdGhpcy5ub3JtYWxNYXBUeXBlPXQubm9ybWFsTWFwVHlwZSx0aGlzLm5vcm1hbFNjYWxlLmNvcHkodC5ub3JtYWxTY2FsZSksdGhpcy5kaXNwbGFjZW1lbnRNYXA9dC5kaXNwbGFjZW1lbnRNYXAsdGhpcy5kaXNwbGFjZW1lbnRTY2FsZT10LmRpc3BsYWNlbWVudFNjYWxlLHRoaXMuZGlzcGxhY2VtZW50Qmlhcz10LmRpc3BsYWNlbWVudEJpYXMsdGhpcy5hbHBoYU1hcD10LmFscGhhTWFwLHRoaXMuZmxhdFNoYWRpbmc9dC5mbGF0U2hhZGluZyx0aGlzLmZvZz10LmZvZyx0aGlzfX0sRG89Y2xhc3MgZXh0ZW5kcyBSZXtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuaXNMaW5lRGFzaGVkTWF0ZXJpYWw9ITAsdGhpcy50eXBlPSJMaW5lRGFzaGVkTWF0ZXJpYWwiLHRoaXMuc2NhbGU9MSx0aGlzLmRhc2hTaXplPTMsdGhpcy5nYXBTaXplPTEsdGhpcy5zZXRWYWx1ZXModCl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLnNjYWxlPXQuc2NhbGUsdGhpcy5kYXNoU2l6ZT10LmRhc2hTaXplLHRoaXMuZ2FwU2l6ZT10LmdhcFNpemUsdGhpc319O2Z1bmN0aW9uIEFpKHMsdCxlKXtyZXR1cm4hc3x8IWUmJnMuY29uc3RydWN0b3I9PT10P3M6dHlwZW9mIHQuQllURVNfUEVSX0VMRU1FTlQ9PSJudW1iZXIiP25ldyB0KHMpOkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHMpfWZ1bmN0aW9uIGhwKHMpe3JldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcocykmJiEocyBpbnN0YW5jZW9mIERhdGFWaWV3KX1mdW5jdGlvbiB1cChzKXtmdW5jdGlvbiB0KGkscil7cmV0dXJuIHNbaV0tc1tyXX1sZXQgZT1zLmxlbmd0aCxuPW5ldyBBcnJheShlKTtmb3IobGV0IGk9MDtpIT09ZTsrK2kpbltpXT1pO3JldHVybiBuLnNvcnQodCksbn1mdW5jdGlvbiBlaChzLHQsZSl7bGV0IG49cy5sZW5ndGgsaT1uZXcgcy5jb25zdHJ1Y3RvcihuKTtmb3IobGV0IHI9MCxhPTA7YSE9PW47KytyKXtsZXQgbz1lW3JdKnQ7Zm9yKGxldCBsPTA7bCE9PXQ7KytsKWlbYSsrXT1zW28rbF19cmV0dXJuIGl9ZnVuY3Rpb24gcnUocyx0LGUsbil7bGV0IGk9MSxyPXNbMF07Zm9yKDtyIT09dm9pZCAwJiZyW25dPT09dm9pZCAwOylyPXNbaSsrXTtpZihyPT09dm9pZCAwKXJldHVybjtsZXQgYT1yW25dO2lmKGEhPT12b2lkIDApaWYoQXJyYXkuaXNBcnJheShhKSlkbyBhPXJbbl0sYSE9PXZvaWQgMCYmKHQucHVzaChyLnRpbWUpLGUucHVzaC5hcHBseShlLGEpKSxyPXNbaSsrXTt3aGlsZShyIT09dm9pZCAwKTtlbHNlIGlmKGEudG9BcnJheSE9PXZvaWQgMClkbyBhPXJbbl0sYSE9PXZvaWQgMCYmKHQucHVzaChyLnRpbWUpLGEudG9BcnJheShlLGUubGVuZ3RoKSkscj1zW2krK107d2hpbGUociE9PXZvaWQgMCk7ZWxzZSBkbyBhPXJbbl0sYSE9PXZvaWQgMCYmKHQucHVzaChyLnRpbWUpLGUucHVzaChhKSkscj1zW2krK107d2hpbGUociE9PXZvaWQgMCl9ZnVuY3Rpb24gWnYocyx0LGUsbixpPTMwKXtsZXQgcj1zLmNsb25lKCk7ci5uYW1lPXQ7bGV0IGE9W107Zm9yKGxldCBsPTA7bDxyLnRyYWNrcy5sZW5ndGg7KytsKXtsZXQgYz1yLnRyYWNrc1tsXSxoPWMuZ2V0VmFsdWVTaXplKCksdT1bXSxkPVtdO2ZvcihsZXQgZj0wO2Y8Yy50aW1lcy5sZW5ndGg7KytmKXtsZXQgbT1jLnRpbWVzW2ZdKmk7aWYoIShtPGV8fG0+PW4pKXt1LnB1c2goYy50aW1lc1tmXSk7Zm9yKGxldCBfPTA7XzxoOysrXylkLnB1c2goYy52YWx1ZXNbZipoK19dKX19dS5sZW5ndGghPT0wJiYoYy50aW1lcz1BaSh1LGMudGltZXMuY29uc3RydWN0b3IpLGMudmFsdWVzPUFpKGQsYy52YWx1ZXMuY29uc3RydWN0b3IpLGEucHVzaChjKSl9ci50cmFja3M9YTtsZXQgbz0xLzA7Zm9yKGxldCBsPTA7bDxyLnRyYWNrcy5sZW5ndGg7KytsKW8+ci50cmFja3NbbF0udGltZXNbMF0mJihvPXIudHJhY2tzW2xdLnRpbWVzWzBdKTtmb3IobGV0IGw9MDtsPHIudHJhY2tzLmxlbmd0aDsrK2wpci50cmFja3NbbF0uc2hpZnQoLTEqbyk7cmV0dXJuIHIucmVzZXREdXJhdGlvbigpLHJ9ZnVuY3Rpb24gSnYocyx0PTAsZT1zLG49MzApe248PTAmJihuPTMwKTtsZXQgaT1lLnRyYWNrcy5sZW5ndGgscj10L247Zm9yKGxldCBhPTA7YTxpOysrYSl7bGV0IG89ZS50cmFja3NbYV0sbD1vLlZhbHVlVHlwZU5hbWU7aWYobD09PSJib29sInx8bD09PSJzdHJpbmciKWNvbnRpbnVlO2xldCBjPXMudHJhY2tzLmZpbmQoZnVuY3Rpb24ocCl7cmV0dXJuIHAubmFtZT09PW8ubmFtZSYmcC5WYWx1ZVR5cGVOYW1lPT09bH0pO2lmKGM9PT12b2lkIDApY29udGludWU7bGV0IGg9MCx1PW8uZ2V0VmFsdWVTaXplKCk7by5jcmVhdGVJbnRlcnBvbGFudC5pc0ludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSYmKGg9dS8zKTtsZXQgZD0wLGY9Yy5nZXRWYWx1ZVNpemUoKTtjLmNyZWF0ZUludGVycG9sYW50LmlzSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lJiYoZD1mLzMpO2xldCBtPW8udGltZXMubGVuZ3RoLTEsXztpZihyPD1vLnRpbWVzWzBdKXtsZXQgcD1oLHY9dS1oO189by52YWx1ZXMuc2xpY2UocCx2KX1lbHNlIGlmKHI+PW8udGltZXNbbV0pe2xldCBwPW0qdStoLHY9cCt1LWg7Xz1vLnZhbHVlcy5zbGljZShwLHYpfWVsc2V7bGV0IHA9by5jcmVhdGVJbnRlcnBvbGFudCgpLHY9aCx4PXUtaDtwLmV2YWx1YXRlKHIpLF89cC5yZXN1bHRCdWZmZXIuc2xpY2Uodix4KX1sPT09InF1YXRlcm5pb24iJiZuZXcgRGUoKS5mcm9tQXJyYXkoXykubm9ybWFsaXplKCkuY29uanVnYXRlKCkudG9BcnJheShfKTtsZXQgZz1jLnRpbWVzLmxlbmd0aDtmb3IobGV0IHA9MDtwPGc7KytwKXtsZXQgdj1wKmYrZDtpZihsPT09InF1YXRlcm5pb24iKURlLm11bHRpcGx5UXVhdGVybmlvbnNGbGF0KGMudmFsdWVzLHYsXywwLGMudmFsdWVzLHYpO2Vsc2V7bGV0IHg9Zi1kKjI7Zm9yKGxldCBNPTA7TTx4OysrTSljLnZhbHVlc1t2K01dLT1fW01dfX19cmV0dXJuIHMuYmxlbmRNb2RlPWpoLHN9dmFyICR2PXtjb252ZXJ0QXJyYXk6QWksaXNUeXBlZEFycmF5OmhwLGdldEtleWZyYW1lT3JkZXI6dXAsc29ydGVkQXJyYXk6ZWgsZmxhdHRlbkpTT046cnUsc3ViY2xpcDpadixtYWtlQ2xpcEFkZGl0aXZlOkp2fSxPaT1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUsbixpKXt0aGlzLnBhcmFtZXRlclBvc2l0aW9ucz10LHRoaXMuX2NhY2hlZEluZGV4PTAsdGhpcy5yZXN1bHRCdWZmZXI9aSE9PXZvaWQgMD9pOm5ldyBlLmNvbnN0cnVjdG9yKG4pLHRoaXMuc2FtcGxlVmFsdWVzPWUsdGhpcy52YWx1ZVNpemU9bix0aGlzLnNldHRpbmdzPW51bGwsdGhpcy5EZWZhdWx0U2V0dGluZ3NfPXt9fWV2YWx1YXRlKHQpe2xldCBlPXRoaXMucGFyYW1ldGVyUG9zaXRpb25zLG49dGhpcy5fY2FjaGVkSW5kZXgsaT1lW25dLHI9ZVtuLTFdO3Q6e2U6e2xldCBhO246e2k6aWYoISh0PGkpKXtmb3IobGV0IG89bisyOzspe2lmKGk9PT12b2lkIDApe2lmKHQ8cilicmVhayBpO3JldHVybiBuPWUubGVuZ3RoLHRoaXMuX2NhY2hlZEluZGV4PW4sdGhpcy5jb3B5U2FtcGxlVmFsdWVfKG4tMSl9aWYobj09PW8pYnJlYWs7aWYocj1pLGk9ZVsrK25dLHQ8aSlicmVhayBlfWE9ZS5sZW5ndGg7YnJlYWsgbn1pZighKHQ+PXIpKXtsZXQgbz1lWzFdO3Q8byYmKG49MixyPW8pO2ZvcihsZXQgbD1uLTI7Oyl7aWYocj09PXZvaWQgMClyZXR1cm4gdGhpcy5fY2FjaGVkSW5kZXg9MCx0aGlzLmNvcHlTYW1wbGVWYWx1ZV8oMCk7aWYobj09PWwpYnJlYWs7aWYoaT1yLHI9ZVstLW4tMV0sdD49cilicmVhayBlfWE9bixuPTA7YnJlYWsgbn1icmVhayB0fWZvcig7bjxhOyl7bGV0IG89bithPj4+MTt0PGVbb10/YT1vOm49bysxfWlmKGk9ZVtuXSxyPWVbbi0xXSxyPT09dm9pZCAwKXJldHVybiB0aGlzLl9jYWNoZWRJbmRleD0wLHRoaXMuY29weVNhbXBsZVZhbHVlXygwKTtpZihpPT09dm9pZCAwKXJldHVybiBuPWUubGVuZ3RoLHRoaXMuX2NhY2hlZEluZGV4PW4sdGhpcy5jb3B5U2FtcGxlVmFsdWVfKG4tMSl9dGhpcy5fY2FjaGVkSW5kZXg9bix0aGlzLmludGVydmFsQ2hhbmdlZF8obixyLGkpfXJldHVybiB0aGlzLmludGVycG9sYXRlXyhuLHIsdCxpKX1nZXRTZXR0aW5nc18oKXtyZXR1cm4gdGhpcy5zZXR0aW5nc3x8dGhpcy5EZWZhdWx0U2V0dGluZ3NffWNvcHlTYW1wbGVWYWx1ZV8odCl7bGV0IGU9dGhpcy5yZXN1bHRCdWZmZXIsbj10aGlzLnNhbXBsZVZhbHVlcyxpPXRoaXMudmFsdWVTaXplLHI9dCppO2ZvcihsZXQgYT0wO2EhPT1pOysrYSllW2FdPW5bcithXTtyZXR1cm4gZX1pbnRlcnBvbGF0ZV8oKXt0aHJvdyBuZXcgRXJyb3IoImNhbGwgdG8gYWJzdHJhY3QgbWV0aG9kIil9aW50ZXJ2YWxDaGFuZ2VkXygpe319LE5vPWNsYXNzIGV4dGVuZHMgT2l7Y29uc3RydWN0b3IodCxlLG4saSl7c3VwZXIodCxlLG4saSksdGhpcy5fd2VpZ2h0UHJldj0tMCx0aGlzLl9vZmZzZXRQcmV2PS0wLHRoaXMuX3dlaWdodE5leHQ9LTAsdGhpcy5fb2Zmc2V0TmV4dD0tMCx0aGlzLkRlZmF1bHRTZXR0aW5nc189e2VuZGluZ1N0YXJ0OmJpLGVuZGluZ0VuZDpiaX19aW50ZXJ2YWxDaGFuZ2VkXyh0LGUsbil7bGV0IGk9dGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnMscj10LTIsYT10KzEsbz1pW3JdLGw9aVthXTtpZihvPT09dm9pZCAwKXN3aXRjaCh0aGlzLmdldFNldHRpbmdzXygpLmVuZGluZ1N0YXJ0KXtjYXNlIEVpOnI9dCxvPTIqZS1uO2JyZWFrO2Nhc2UganM6cj1pLmxlbmd0aC0yLG89ZStpW3JdLWlbcisxXTticmVhaztkZWZhdWx0OnI9dCxvPW59aWYobD09PXZvaWQgMClzd2l0Y2godGhpcy5nZXRTZXR0aW5nc18oKS5lbmRpbmdFbmQpe2Nhc2UgRWk6YT10LGw9MipuLWU7YnJlYWs7Y2FzZSBqczphPTEsbD1uK2lbMV0taVswXTticmVhaztkZWZhdWx0OmE9dC0xLGw9ZX1sZXQgYz0obi1lKSouNSxoPXRoaXMudmFsdWVTaXplO3RoaXMuX3dlaWdodFByZXY9Yy8oZS1vKSx0aGlzLl93ZWlnaHROZXh0PWMvKGwtbiksdGhpcy5fb2Zmc2V0UHJldj1yKmgsdGhpcy5fb2Zmc2V0TmV4dD1hKmh9aW50ZXJwb2xhdGVfKHQsZSxuLGkpe2xldCByPXRoaXMucmVzdWx0QnVmZmVyLGE9dGhpcy5zYW1wbGVWYWx1ZXMsbz10aGlzLnZhbHVlU2l6ZSxsPXQqbyxjPWwtbyxoPXRoaXMuX29mZnNldFByZXYsdT10aGlzLl9vZmZzZXROZXh0LGQ9dGhpcy5fd2VpZ2h0UHJldixmPXRoaXMuX3dlaWdodE5leHQsbT0obi1lKS8oaS1lKSxfPW0qbSxnPV8qbSxwPS1kKmcrMipkKl8tZCptLHY9KDErZCkqZysoLTEuNS0yKmQpKl8rKC0uNStkKSptKzEseD0oLTEtZikqZysoMS41K2YpKl8rLjUqbSxNPWYqZy1mKl87Zm9yKGxldCBDPTA7QyE9PW87KytDKXJbQ109cCphW2grQ10rdiphW2MrQ10reCphW2wrQ10rTSphW3UrQ107cmV0dXJuIHJ9fSxQcj1jbGFzcyBleHRlbmRzIE9pe2NvbnN0cnVjdG9yKHQsZSxuLGkpe3N1cGVyKHQsZSxuLGkpfWludGVycG9sYXRlXyh0LGUsbixpKXtsZXQgcj10aGlzLnJlc3VsdEJ1ZmZlcixhPXRoaXMuc2FtcGxlVmFsdWVzLG89dGhpcy52YWx1ZVNpemUsbD10Km8sYz1sLW8saD0obi1lKS8oaS1lKSx1PTEtaDtmb3IobGV0IGQ9MDtkIT09bzsrK2QpcltkXT1hW2MrZF0qdSthW2wrZF0qaDtyZXR1cm4gcn19LE9vPWNsYXNzIGV4dGVuZHMgT2l7Y29uc3RydWN0b3IodCxlLG4saSl7c3VwZXIodCxlLG4saSl9aW50ZXJwb2xhdGVfKHQpe3JldHVybiB0aGlzLmNvcHlTYW1wbGVWYWx1ZV8odC0xKX19LEtlPWNsYXNze2NvbnN0cnVjdG9yKHQsZSxuLGkpe2lmKHQ9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKCJUSFJFRS5LZXlmcmFtZVRyYWNrOiB0cmFjayBuYW1lIGlzIHVuZGVmaW5lZCIpO2lmKGU9PT12b2lkIDB8fGUubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLktleWZyYW1lVHJhY2s6IG5vIGtleWZyYW1lcyBpbiB0cmFjayBuYW1lZCAiK3QpO3RoaXMubmFtZT10LHRoaXMudGltZXM9QWkoZSx0aGlzLlRpbWVCdWZmZXJUeXBlKSx0aGlzLnZhbHVlcz1BaShuLHRoaXMuVmFsdWVCdWZmZXJUeXBlKSx0aGlzLnNldEludGVycG9sYXRpb24oaXx8dGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbil9c3RhdGljIHRvSlNPTih0KXtsZXQgZT10LmNvbnN0cnVjdG9yLG47aWYoZS50b0pTT04hPT10aGlzLnRvSlNPTiluPWUudG9KU09OKHQpO2Vsc2V7bj17bmFtZTp0Lm5hbWUsdGltZXM6QWkodC50aW1lcyxBcnJheSksdmFsdWVzOkFpKHQudmFsdWVzLEFycmF5KX07bGV0IGk9dC5nZXRJbnRlcnBvbGF0aW9uKCk7aSE9PXQuRGVmYXVsdEludGVycG9sYXRpb24mJihuLmludGVycG9sYXRpb249aSl9cmV0dXJuIG4udHlwZT10LlZhbHVlVHlwZU5hbWUsbn1JbnRlcnBvbGFudEZhY3RvcnlNZXRob2REaXNjcmV0ZSh0KXtyZXR1cm4gbmV3IE9vKHRoaXMudGltZXMsdGhpcy52YWx1ZXMsdGhpcy5nZXRWYWx1ZVNpemUoKSx0KX1JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXIodCl7cmV0dXJuIG5ldyBQcih0aGlzLnRpbWVzLHRoaXMudmFsdWVzLHRoaXMuZ2V0VmFsdWVTaXplKCksdCl9SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoKHQpe3JldHVybiBuZXcgTm8odGhpcy50aW1lcyx0aGlzLnZhbHVlcyx0aGlzLmdldFZhbHVlU2l6ZSgpLHQpfXNldEludGVycG9sYXRpb24odCl7bGV0IGU7c3dpdGNoKHQpe2Nhc2UgS3M6ZT10aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlO2JyZWFrO2Nhc2UgUXM6ZT10aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjticmVhaztjYXNlIE9hOmU9dGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg7YnJlYWt9aWYoZT09PXZvaWQgMCl7bGV0IG49InVuc3VwcG9ydGVkIGludGVycG9sYXRpb24gZm9yICIrdGhpcy5WYWx1ZVR5cGVOYW1lKyIga2V5ZnJhbWUgdHJhY2sgbmFtZWQgIit0aGlzLm5hbWU7aWYodGhpcy5jcmVhdGVJbnRlcnBvbGFudD09PXZvaWQgMClpZih0IT09dGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbil0aGlzLnNldEludGVycG9sYXRpb24odGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbik7ZWxzZSB0aHJvdyBuZXcgRXJyb3Iobik7cmV0dXJuIGNvbnNvbGUud2FybigiVEhSRUUuS2V5ZnJhbWVUcmFjazoiLG4pLHRoaXN9cmV0dXJuIHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQ9ZSx0aGlzfWdldEludGVycG9sYXRpb24oKXtzd2l0Y2godGhpcy5jcmVhdGVJbnRlcnBvbGFudCl7Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlOnJldHVybiBLcztjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyOnJldHVybiBRcztjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOnJldHVybiBPYX19Z2V0VmFsdWVTaXplKCl7cmV0dXJuIHRoaXMudmFsdWVzLmxlbmd0aC90aGlzLnRpbWVzLmxlbmd0aH1zaGlmdCh0KXtpZih0IT09MCl7bGV0IGU9dGhpcy50aW1lcztmb3IobGV0IG49MCxpPWUubGVuZ3RoO24hPT1pOysrbillW25dKz10fXJldHVybiB0aGlzfXNjYWxlKHQpe2lmKHQhPT0xKXtsZXQgZT10aGlzLnRpbWVzO2ZvcihsZXQgbj0wLGk9ZS5sZW5ndGg7biE9PWk7KytuKWVbbl0qPXR9cmV0dXJuIHRoaXN9dHJpbSh0LGUpe2xldCBuPXRoaXMudGltZXMsaT1uLmxlbmd0aCxyPTAsYT1pLTE7Zm9yKDtyIT09aSYmbltyXTx0OykrK3I7Zm9yKDthIT09LTEmJm5bYV0+ZTspLS1hO2lmKCsrYSxyIT09MHx8YSE9PWkpe3I+PWEmJihhPU1hdGgubWF4KGEsMSkscj1hLTEpO2xldCBvPXRoaXMuZ2V0VmFsdWVTaXplKCk7dGhpcy50aW1lcz1uLnNsaWNlKHIsYSksdGhpcy52YWx1ZXM9dGhpcy52YWx1ZXMuc2xpY2UocipvLGEqbyl9cmV0dXJuIHRoaXN9dmFsaWRhdGUoKXtsZXQgdD0hMCxlPXRoaXMuZ2V0VmFsdWVTaXplKCk7ZS1NYXRoLmZsb29yKGUpIT09MCYmKGNvbnNvbGUuZXJyb3IoIlRIUkVFLktleWZyYW1lVHJhY2s6IEludmFsaWQgdmFsdWUgc2l6ZSBpbiB0cmFjay4iLHRoaXMpLHQ9ITEpO2xldCBuPXRoaXMudGltZXMsaT10aGlzLnZhbHVlcyxyPW4ubGVuZ3RoO3I9PT0wJiYoY29uc29sZS5lcnJvcigiVEhSRUUuS2V5ZnJhbWVUcmFjazogVHJhY2sgaXMgZW1wdHkuIix0aGlzKSx0PSExKTtsZXQgYT1udWxsO2ZvcihsZXQgbz0wO28hPT1yO28rKyl7bGV0IGw9bltvXTtpZih0eXBlb2YgbD09Im51bWJlciImJmlzTmFOKGwpKXtjb25zb2xlLmVycm9yKCJUSFJFRS5LZXlmcmFtZVRyYWNrOiBUaW1lIGlzIG5vdCBhIHZhbGlkIG51bWJlci4iLHRoaXMsbyxsKSx0PSExO2JyZWFrfWlmKGEhPT1udWxsJiZhPmwpe2NvbnNvbGUuZXJyb3IoIlRIUkVFLktleWZyYW1lVHJhY2s6IE91dCBvZiBvcmRlciBrZXlzLiIsdGhpcyxvLGwsYSksdD0hMTticmVha31hPWx9aWYoaSE9PXZvaWQgMCYmaHAoaSkpZm9yKGxldCBvPTAsbD1pLmxlbmd0aDtvIT09bDsrK28pe2xldCBjPWlbb107aWYoaXNOYU4oYykpe2NvbnNvbGUuZXJyb3IoIlRIUkVFLktleWZyYW1lVHJhY2s6IFZhbHVlIGlzIG5vdCBhIHZhbGlkIG51bWJlci4iLHRoaXMsbyxjKSx0PSExO2JyZWFrfX1yZXR1cm4gdH1vcHRpbWl6ZSgpe2xldCB0PXRoaXMudGltZXMuc2xpY2UoKSxlPXRoaXMudmFsdWVzLnNsaWNlKCksbj10aGlzLmdldFZhbHVlU2l6ZSgpLGk9dGhpcy5nZXRJbnRlcnBvbGF0aW9uKCk9PT1PYSxyPXQubGVuZ3RoLTEsYT0xO2ZvcihsZXQgbz0xO288cjsrK28pe2xldCBsPSExLGM9dFtvXSxoPXRbbysxXTtpZihjIT09aCYmKG8hPT0xfHxjIT09dFswXSkpaWYoaSlsPSEwO2Vsc2V7bGV0IHU9bypuLGQ9dS1uLGY9dStuO2ZvcihsZXQgbT0wO20hPT1uOysrbSl7bGV0IF89ZVt1K21dO2lmKF8hPT1lW2QrbV18fF8hPT1lW2YrbV0pe2w9ITA7YnJlYWt9fX1pZihsKXtpZihvIT09YSl7dFthXT10W29dO2xldCB1PW8qbixkPWEqbjtmb3IobGV0IGY9MDtmIT09bjsrK2YpZVtkK2ZdPWVbdStmXX0rK2F9fWlmKHI+MCl7dFthXT10W3JdO2ZvcihsZXQgbz1yKm4sbD1hKm4sYz0wO2MhPT1uOysrYyllW2wrY109ZVtvK2NdOysrYX1yZXR1cm4gYSE9PXQubGVuZ3RoPyh0aGlzLnRpbWVzPXQuc2xpY2UoMCxhKSx0aGlzLnZhbHVlcz1lLnNsaWNlKDAsYSpuKSk6KHRoaXMudGltZXM9dCx0aGlzLnZhbHVlcz1lKSx0aGlzfWNsb25lKCl7bGV0IHQ9dGhpcy50aW1lcy5zbGljZSgpLGU9dGhpcy52YWx1ZXMuc2xpY2UoKSxuPXRoaXMuY29uc3RydWN0b3IsaT1uZXcgbih0aGlzLm5hbWUsdCxlKTtyZXR1cm4gaS5jcmVhdGVJbnRlcnBvbGFudD10aGlzLmNyZWF0ZUludGVycG9sYW50LGl9fTtLZS5wcm90b3R5cGUuVGltZUJ1ZmZlclR5cGU9RmxvYXQzMkFycmF5O0tlLnByb3RvdHlwZS5WYWx1ZUJ1ZmZlclR5cGU9RmxvYXQzMkFycmF5O0tlLnByb3RvdHlwZS5EZWZhdWx0SW50ZXJwb2xhdGlvbj1Rczt2YXIgVm49Y2xhc3MgZXh0ZW5kcyBLZXt9O1ZuLnByb3RvdHlwZS5WYWx1ZVR5cGVOYW1lPSJib29sIjtWbi5wcm90b3R5cGUuVmFsdWVCdWZmZXJUeXBlPUFycmF5O1ZuLnByb3RvdHlwZS5EZWZhdWx0SW50ZXJwb2xhdGlvbj1LcztWbi5wcm90b3R5cGUuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyPXZvaWQgMDtWbi5wcm90b3R5cGUuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoPXZvaWQgMDt2YXIgTHI9Y2xhc3MgZXh0ZW5kcyBLZXt9O0xyLnByb3RvdHlwZS5WYWx1ZVR5cGVOYW1lPSJjb2xvciI7dmFyIEZpPWNsYXNzIGV4dGVuZHMgS2V7fTtGaS5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZT0ibnVtYmVyIjt2YXIgRm89Y2xhc3MgZXh0ZW5kcyBPaXtjb25zdHJ1Y3Rvcih0LGUsbixpKXtzdXBlcih0LGUsbixpKX1pbnRlcnBvbGF0ZV8odCxlLG4saSl7bGV0IHI9dGhpcy5yZXN1bHRCdWZmZXIsYT10aGlzLnNhbXBsZVZhbHVlcyxvPXRoaXMudmFsdWVTaXplLGw9KG4tZSkvKGktZSksYz10Km87Zm9yKGxldCBoPWMrbztjIT09aDtjKz00KURlLnNsZXJwRmxhdChyLDAsYSxjLW8sYSxjLGwpO3JldHVybiByfX0scmk9Y2xhc3MgZXh0ZW5kcyBLZXtJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXIodCl7cmV0dXJuIG5ldyBGbyh0aGlzLnRpbWVzLHRoaXMudmFsdWVzLHRoaXMuZ2V0VmFsdWVTaXplKCksdCl9fTtyaS5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZT0icXVhdGVybmlvbiI7cmkucHJvdG90eXBlLkRlZmF1bHRJbnRlcnBvbGF0aW9uPVFzO3JpLnByb3RvdHlwZS5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg9dm9pZCAwO3ZhciBrbj1jbGFzcyBleHRlbmRzIEtle307a24ucHJvdG90eXBlLlZhbHVlVHlwZU5hbWU9InN0cmluZyI7a24ucHJvdG90eXBlLlZhbHVlQnVmZmVyVHlwZT1BcnJheTtrbi5wcm90b3R5cGUuRGVmYXVsdEludGVycG9sYXRpb249S3M7a24ucHJvdG90eXBlLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcj12b2lkIDA7a24ucHJvdG90eXBlLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aD12b2lkIDA7dmFyIEJpPWNsYXNzIGV4dGVuZHMgS2V7fTtCaS5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZT0idmVjdG9yIjt2YXIgemk9Y2xhc3N7Y29uc3RydWN0b3IodCxlPS0xLG4saT1ubCl7dGhpcy5uYW1lPXQsdGhpcy50cmFja3M9bix0aGlzLmR1cmF0aW9uPWUsdGhpcy5ibGVuZE1vZGU9aSx0aGlzLnV1aWQ9WWUoKSx0aGlzLmR1cmF0aW9uPDAmJnRoaXMucmVzZXREdXJhdGlvbigpfXN0YXRpYyBwYXJzZSh0KXtsZXQgZT1bXSxuPXQudHJhY2tzLGk9MS8odC5mcHN8fDEpO2ZvcihsZXQgYT0wLG89bi5sZW5ndGg7YSE9PW87KythKWUucHVzaChRdihuW2FdKS5zY2FsZShpKSk7bGV0IHI9bmV3IHRoaXModC5uYW1lLHQuZHVyYXRpb24sZSx0LmJsZW5kTW9kZSk7cmV0dXJuIHIudXVpZD10LnV1aWQscn1zdGF0aWMgdG9KU09OKHQpe2xldCBlPVtdLG49dC50cmFja3MsaT17bmFtZTp0Lm5hbWUsZHVyYXRpb246dC5kdXJhdGlvbix0cmFja3M6ZSx1dWlkOnQudXVpZCxibGVuZE1vZGU6dC5ibGVuZE1vZGV9O2ZvcihsZXQgcj0wLGE9bi5sZW5ndGg7ciE9PWE7KytyKWUucHVzaChLZS50b0pTT04obltyXSkpO3JldHVybiBpfXN0YXRpYyBDcmVhdGVGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZSh0LGUsbixpKXtsZXQgcj1lLmxlbmd0aCxhPVtdO2ZvcihsZXQgbz0wO288cjtvKyspe2xldCBsPVtdLGM9W107bC5wdXNoKChvK3ItMSklcixvLChvKzEpJXIpLGMucHVzaCgwLDEsMCk7bGV0IGg9dXAobCk7bD1laChsLDEsaCksYz1laChjLDEsaCksIWkmJmxbMF09PT0wJiYobC5wdXNoKHIpLGMucHVzaChjWzBdKSksYS5wdXNoKG5ldyBGaSgiLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1siK2Vbb10ubmFtZSsiXSIsbCxjKS5zY2FsZSgxL24pKX1yZXR1cm4gbmV3IHRoaXModCwtMSxhKX1zdGF0aWMgZmluZEJ5TmFtZSh0LGUpe2xldCBuPXQ7aWYoIUFycmF5LmlzQXJyYXkodCkpe2xldCBpPXQ7bj1pLmdlb21ldHJ5JiZpLmdlb21ldHJ5LmFuaW1hdGlvbnN8fGkuYW5pbWF0aW9uc31mb3IobGV0IGk9MDtpPG4ubGVuZ3RoO2krKylpZihuW2ldLm5hbWU9PT1lKXJldHVybiBuW2ldO3JldHVybiBudWxsfXN0YXRpYyBDcmVhdGVDbGlwc0Zyb21Nb3JwaFRhcmdldFNlcXVlbmNlcyh0LGUsbil7bGV0IGk9e30scj0vXihbXHctXSo/KShbXGRdKykkLztmb3IobGV0IG89MCxsPXQubGVuZ3RoO288bDtvKyspe2xldCBjPXRbb10saD1jLm5hbWUubWF0Y2gocik7aWYoaCYmaC5sZW5ndGg+MSl7bGV0IHU9aFsxXSxkPWlbdV07ZHx8KGlbdV09ZD1bXSksZC5wdXNoKGMpfX1sZXQgYT1bXTtmb3IobGV0IG8gaW4gaSlhLnB1c2godGhpcy5DcmVhdGVGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZShvLGlbb10sZSxuKSk7cmV0dXJuIGF9c3RhdGljIHBhcnNlQW5pbWF0aW9uKHQsZSl7aWYoIXQpcmV0dXJuIGNvbnNvbGUuZXJyb3IoIlRIUkVFLkFuaW1hdGlvbkNsaXA6IE5vIGFuaW1hdGlvbiBpbiBKU09OTG9hZGVyIGRhdGEuIiksbnVsbDtsZXQgbj1mdW5jdGlvbih1LGQsZixtLF8pe2lmKGYubGVuZ3RoIT09MCl7bGV0IGc9W10scD1bXTtydShmLGcscCxtKSxnLmxlbmd0aCE9PTAmJl8ucHVzaChuZXcgdShkLGcscCkpfX0saT1bXSxyPXQubmFtZXx8ImRlZmF1bHQiLGE9dC5mcHN8fDMwLG89dC5ibGVuZE1vZGUsbD10Lmxlbmd0aHx8LTEsYz10LmhpZXJhcmNoeXx8W107Zm9yKGxldCB1PTA7dTxjLmxlbmd0aDt1Kyspe2xldCBkPWNbdV0ua2V5cztpZighKCFkfHxkLmxlbmd0aD09PTApKWlmKGRbMF0ubW9ycGhUYXJnZXRzKXtsZXQgZj17fSxtO2ZvcihtPTA7bTxkLmxlbmd0aDttKyspaWYoZFttXS5tb3JwaFRhcmdldHMpZm9yKGxldCBfPTA7XzxkW21dLm1vcnBoVGFyZ2V0cy5sZW5ndGg7XysrKWZbZFttXS5tb3JwaFRhcmdldHNbX11dPS0xO2ZvcihsZXQgXyBpbiBmKXtsZXQgZz1bXSxwPVtdO2ZvcihsZXQgdj0wO3YhPT1kW21dLm1vcnBoVGFyZ2V0cy5sZW5ndGg7Kyt2KXtsZXQgeD1kW21dO2cucHVzaCh4LnRpbWUpLHAucHVzaCh4Lm1vcnBoVGFyZ2V0PT09Xz8xOjApfWkucHVzaChuZXcgRmkoIi5tb3JwaFRhcmdldEluZmx1ZW5jZVsiK18rIl0iLGcscCkpfWw9Zi5sZW5ndGgqYX1lbHNle2xldCBmPSIuYm9uZXNbIitlW3VdLm5hbWUrIl0iO24oQmksZisiLnBvc2l0aW9uIixkLCJwb3MiLGkpLG4ocmksZisiLnF1YXRlcm5pb24iLGQsInJvdCIsaSksbihCaSxmKyIuc2NhbGUiLGQsInNjbCIsaSl9fXJldHVybiBpLmxlbmd0aD09PTA/bnVsbDpuZXcgdGhpcyhyLGwsaSxvKX1yZXNldER1cmF0aW9uKCl7bGV0IHQ9dGhpcy50cmFja3MsZT0wO2ZvcihsZXQgbj0wLGk9dC5sZW5ndGg7biE9PWk7KytuKXtsZXQgcj10aGlzLnRyYWNrc1tuXTtlPU1hdGgubWF4KGUsci50aW1lc1tyLnRpbWVzLmxlbmd0aC0xXSl9cmV0dXJuIHRoaXMuZHVyYXRpb249ZSx0aGlzfXRyaW0oKXtmb3IobGV0IHQ9MDt0PHRoaXMudHJhY2tzLmxlbmd0aDt0KyspdGhpcy50cmFja3NbdF0udHJpbSgwLHRoaXMuZHVyYXRpb24pO3JldHVybiB0aGlzfXZhbGlkYXRlKCl7bGV0IHQ9ITA7Zm9yKGxldCBlPTA7ZTx0aGlzLnRyYWNrcy5sZW5ndGg7ZSsrKXQ9dCYmdGhpcy50cmFja3NbZV0udmFsaWRhdGUoKTtyZXR1cm4gdH1vcHRpbWl6ZSgpe2ZvcihsZXQgdD0wO3Q8dGhpcy50cmFja3MubGVuZ3RoO3QrKyl0aGlzLnRyYWNrc1t0XS5vcHRpbWl6ZSgpO3JldHVybiB0aGlzfWNsb25lKCl7bGV0IHQ9W107Zm9yKGxldCBlPTA7ZTx0aGlzLnRyYWNrcy5sZW5ndGg7ZSsrKXQucHVzaCh0aGlzLnRyYWNrc1tlXS5jbG9uZSgpKTtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5uYW1lLHRoaXMuZHVyYXRpb24sdCx0aGlzLmJsZW5kTW9kZSl9dG9KU09OKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9KU09OKHRoaXMpfX07ZnVuY3Rpb24gS3Yocyl7c3dpdGNoKHMudG9Mb3dlckNhc2UoKSl7Y2FzZSJzY2FsYXIiOmNhc2UiZG91YmxlIjpjYXNlImZsb2F0IjpjYXNlIm51bWJlciI6Y2FzZSJpbnRlZ2VyIjpyZXR1cm4gRmk7Y2FzZSJ2ZWN0b3IiOmNhc2UidmVjdG9yMiI6Y2FzZSJ2ZWN0b3IzIjpjYXNlInZlY3RvcjQiOnJldHVybiBCaTtjYXNlImNvbG9yIjpyZXR1cm4gTHI7Y2FzZSJxdWF0ZXJuaW9uIjpyZXR1cm4gcmk7Y2FzZSJib29sIjpjYXNlImJvb2xlYW4iOnJldHVybiBWbjtjYXNlInN0cmluZyI6cmV0dXJuIGtufXRocm93IG5ldyBFcnJvcigiVEhSRUUuS2V5ZnJhbWVUcmFjazogVW5zdXBwb3J0ZWQgdHlwZU5hbWU6ICIrcyl9ZnVuY3Rpb24gUXYocyl7aWYocy50eXBlPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcigiVEhSRUUuS2V5ZnJhbWVUcmFjazogdHJhY2sgdHlwZSB1bmRlZmluZWQsIGNhbiBub3QgcGFyc2UiKTtsZXQgdD1LdihzLnR5cGUpO2lmKHMudGltZXM9PT12b2lkIDApe2xldCBlPVtdLG49W107cnUocy5rZXlzLGUsbiwidmFsdWUiKSxzLnRpbWVzPWUscy52YWx1ZXM9bn1yZXR1cm4gdC5wYXJzZSE9PXZvaWQgMD90LnBhcnNlKHMpOm5ldyB0KHMubmFtZSxzLnRpbWVzLHMudmFsdWVzLHMuaW50ZXJwb2xhdGlvbil9dmFyIEluPXtlbmFibGVkOiExLGZpbGVzOnt9LGFkZDpmdW5jdGlvbihzLHQpe3RoaXMuZW5hYmxlZCE9PSExJiYodGhpcy5maWxlc1tzXT10KX0sZ2V0OmZ1bmN0aW9uKHMpe2lmKHRoaXMuZW5hYmxlZCE9PSExKXJldHVybiB0aGlzLmZpbGVzW3NdfSxyZW1vdmU6ZnVuY3Rpb24ocyl7ZGVsZXRlIHRoaXMuZmlsZXNbc119LGNsZWFyOmZ1bmN0aW9uKCl7dGhpcy5maWxlcz17fX19LElyPWNsYXNze2NvbnN0cnVjdG9yKHQsZSxuKXtsZXQgaT10aGlzLHI9ITEsYT0wLG89MCxsLGM9W107dGhpcy5vblN0YXJ0PXZvaWQgMCx0aGlzLm9uTG9hZD10LHRoaXMub25Qcm9ncmVzcz1lLHRoaXMub25FcnJvcj1uLHRoaXMuaXRlbVN0YXJ0PWZ1bmN0aW9uKGgpe28rKyxyPT09ITEmJmkub25TdGFydCE9PXZvaWQgMCYmaS5vblN0YXJ0KGgsYSxvKSxyPSEwfSx0aGlzLml0ZW1FbmQ9ZnVuY3Rpb24oaCl7YSsrLGkub25Qcm9ncmVzcyE9PXZvaWQgMCYmaS5vblByb2dyZXNzKGgsYSxvKSxhPT09byYmKHI9ITEsaS5vbkxvYWQhPT12b2lkIDAmJmkub25Mb2FkKCkpfSx0aGlzLml0ZW1FcnJvcj1mdW5jdGlvbihoKXtpLm9uRXJyb3IhPT12b2lkIDAmJmkub25FcnJvcihoKX0sdGhpcy5yZXNvbHZlVVJMPWZ1bmN0aW9uKGgpe3JldHVybiBsP2woaCk6aH0sdGhpcy5zZXRVUkxNb2RpZmllcj1mdW5jdGlvbihoKXtyZXR1cm4gbD1oLHRoaXN9LHRoaXMuYWRkSGFuZGxlcj1mdW5jdGlvbihoLHUpe3JldHVybiBjLnB1c2goaCx1KSx0aGlzfSx0aGlzLnJlbW92ZUhhbmRsZXI9ZnVuY3Rpb24oaCl7bGV0IHU9Yy5pbmRleE9mKGgpO3JldHVybiB1IT09LTEmJmMuc3BsaWNlKHUsMiksdGhpc30sdGhpcy5nZXRIYW5kbGVyPWZ1bmN0aW9uKGgpe2ZvcihsZXQgdT0wLGQ9Yy5sZW5ndGg7dTxkO3UrPTIpe2xldCBmPWNbdV0sbT1jW3UrMV07aWYoZi5nbG9iYWwmJihmLmxhc3RJbmRleD0wKSxmLnRlc3QoaCkpcmV0dXJuIG19cmV0dXJuIG51bGx9fX0sZHA9bmV3IElyLE5lPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMubWFuYWdlcj10IT09dm9pZCAwP3Q6ZHAsdGhpcy5jcm9zc09yaWdpbj0iYW5vbnltb3VzIix0aGlzLndpdGhDcmVkZW50aWFscz0hMSx0aGlzLnBhdGg9IiIsdGhpcy5yZXNvdXJjZVBhdGg9IiIsdGhpcy5yZXF1ZXN0SGVhZGVyPXt9fWxvYWQoKXt9bG9hZEFzeW5jKHQsZSl7bGV0IG49dGhpcztyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oaSxyKXtuLmxvYWQodCxpLGUscil9KX1wYXJzZSgpe31zZXRDcm9zc09yaWdpbih0KXtyZXR1cm4gdGhpcy5jcm9zc09yaWdpbj10LHRoaXN9c2V0V2l0aENyZWRlbnRpYWxzKHQpe3JldHVybiB0aGlzLndpdGhDcmVkZW50aWFscz10LHRoaXN9c2V0UGF0aCh0KXtyZXR1cm4gdGhpcy5wYXRoPXQsdGhpc31zZXRSZXNvdXJjZVBhdGgodCl7cmV0dXJuIHRoaXMucmVzb3VyY2VQYXRoPXQsdGhpc31zZXRSZXF1ZXN0SGVhZGVyKHQpe3JldHVybiB0aGlzLnJlcXVlc3RIZWFkZXI9dCx0aGlzfX07TmUuREVGQVVMVF9NQVRFUklBTF9OQU1FPSJfX0RFRkFVTFQiO3ZhciB3bj17fSxuaD1jbGFzcyBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQsZSl7c3VwZXIodCksdGhpcy5yZXNwb25zZT1lfX0sY249Y2xhc3MgZXh0ZW5kcyBOZXtjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1sb2FkKHQsZSxuLGkpe3Q9PT12b2lkIDAmJih0PSIiKSx0aGlzLnBhdGghPT12b2lkIDAmJih0PXRoaXMucGF0aCt0KSx0PXRoaXMubWFuYWdlci5yZXNvbHZlVVJMKHQpO2xldCByPUluLmdldCh0KTtpZihyIT09dm9pZCAwKXJldHVybiB0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KHQpLHNldFRpbWVvdXQoKCk9PntlJiZlKHIpLHRoaXMubWFuYWdlci5pdGVtRW5kKHQpfSwwKSxyO2lmKHduW3RdIT09dm9pZCAwKXt3blt0XS5wdXNoKHtvbkxvYWQ6ZSxvblByb2dyZXNzOm4sb25FcnJvcjppfSk7cmV0dXJufXduW3RdPVtdLHduW3RdLnB1c2goe29uTG9hZDplLG9uUHJvZ3Jlc3M6bixvbkVycm9yOml9KTtsZXQgYT1uZXcgUmVxdWVzdCh0LHtoZWFkZXJzOm5ldyBIZWFkZXJzKHRoaXMucmVxdWVzdEhlYWRlciksY3JlZGVudGlhbHM6dGhpcy53aXRoQ3JlZGVudGlhbHM/ImluY2x1ZGUiOiJzYW1lLW9yaWdpbiJ9KSxvPXRoaXMubWltZVR5cGUsbD10aGlzLnJlc3BvbnNlVHlwZTtmZXRjaChhKS50aGVuKGM9PntpZihjLnN0YXR1cz09PTIwMHx8Yy5zdGF0dXM9PT0wKXtpZihjLnN0YXR1cz09PTAmJmNvbnNvbGUud2FybigiVEhSRUUuRmlsZUxvYWRlcjogSFRUUCBTdGF0dXMgMCByZWNlaXZlZC4iKSx0eXBlb2YgUmVhZGFibGVTdHJlYW0+InUifHxjLmJvZHk9PT12b2lkIDB8fGMuYm9keS5nZXRSZWFkZXI9PT12b2lkIDApcmV0dXJuIGM7bGV0IGg9d25bdF0sdT1jLmJvZHkuZ2V0UmVhZGVyKCksZD1jLmhlYWRlcnMuZ2V0KCJDb250ZW50LUxlbmd0aCIpfHxjLmhlYWRlcnMuZ2V0KCJYLUZpbGUtU2l6ZSIpLGY9ZD9wYXJzZUludChkKTowLG09ZiE9PTAsXz0wLGc9bmV3IFJlYWRhYmxlU3RyZWFtKHtzdGFydChwKXt2KCk7ZnVuY3Rpb24gdigpe3UucmVhZCgpLnRoZW4oKHtkb25lOngsdmFsdWU6TX0pPT57aWYoeClwLmNsb3NlKCk7ZWxzZXtfKz1NLmJ5dGVMZW5ndGg7bGV0IEM9bmV3IFByb2dyZXNzRXZlbnQoInByb2dyZXNzIix7bGVuZ3RoQ29tcHV0YWJsZTptLGxvYWRlZDpfLHRvdGFsOmZ9KTtmb3IobGV0IEE9MCxUPWgubGVuZ3RoO0E8VDtBKyspe2xldCBVPWhbQV07VS5vblByb2dyZXNzJiZVLm9uUHJvZ3Jlc3MoQyl9cC5lbnF1ZXVlKE0pLHYoKX19KX19fSk7cmV0dXJuIG5ldyBSZXNwb25zZShnKX1lbHNlIHRocm93IG5ldyBuaChgZmV0Y2ggZm9yICIke2MudXJsfSIgcmVzcG9uZGVkIHdpdGggJHtjLnN0YXR1c306ICR7Yy5zdGF0dXNUZXh0fWAsYyl9KS50aGVuKGM9Pntzd2l0Y2gobCl7Y2FzZSJhcnJheWJ1ZmZlciI6cmV0dXJuIGMuYXJyYXlCdWZmZXIoKTtjYXNlImJsb2IiOnJldHVybiBjLmJsb2IoKTtjYXNlImRvY3VtZW50IjpyZXR1cm4gYy50ZXh0KCkudGhlbihoPT5uZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKGgsbykpO2Nhc2UianNvbiI6cmV0dXJuIGMuanNvbigpO2RlZmF1bHQ6aWYobz09PXZvaWQgMClyZXR1cm4gYy50ZXh0KCk7e2xldCB1PS9jaGFyc2V0PSI/KFteOyJcc10qKSI/L2kuZXhlYyhvKSxkPXUmJnVbMV0/dVsxXS50b0xvd2VyQ2FzZSgpOnZvaWQgMCxmPW5ldyBUZXh0RGVjb2RlcihkKTtyZXR1cm4gYy5hcnJheUJ1ZmZlcigpLnRoZW4obT0+Zi5kZWNvZGUobSkpfX19KS50aGVuKGM9PntJbi5hZGQodCxjKTtsZXQgaD13blt0XTtkZWxldGUgd25bdF07Zm9yKGxldCB1PTAsZD1oLmxlbmd0aDt1PGQ7dSsrKXtsZXQgZj1oW3VdO2Yub25Mb2FkJiZmLm9uTG9hZChjKX19KS5jYXRjaChjPT57bGV0IGg9d25bdF07aWYoaD09PXZvaWQgMCl0aHJvdyB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKHQpLGM7ZGVsZXRlIHduW3RdO2ZvcihsZXQgdT0wLGQ9aC5sZW5ndGg7dTxkO3UrKyl7bGV0IGY9aFt1XTtmLm9uRXJyb3ImJmYub25FcnJvcihjKX10aGlzLm1hbmFnZXIuaXRlbUVycm9yKHQpfSkuZmluYWxseSgoKT0+e3RoaXMubWFuYWdlci5pdGVtRW5kKHQpfSksdGhpcy5tYW5hZ2VyLml0ZW1TdGFydCh0KX1zZXRSZXNwb25zZVR5cGUodCl7cmV0dXJuIHRoaXMucmVzcG9uc2VUeXBlPXQsdGhpc31zZXRNaW1lVHlwZSh0KXtyZXR1cm4gdGhpcy5taW1lVHlwZT10LHRoaXN9fSxpaD1jbGFzcyBleHRlbmRzIE5le2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpfWxvYWQodCxlLG4saSl7bGV0IHI9dGhpcyxhPW5ldyBjbih0aGlzLm1hbmFnZXIpO2Euc2V0UGF0aCh0aGlzLnBhdGgpLGEuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpLGEuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKSxhLmxvYWQodCxmdW5jdGlvbihvKXt0cnl7ZShyLnBhcnNlKEpTT04ucGFyc2UobykpKX1jYXRjaChsKXtpP2kobCk6Y29uc29sZS5lcnJvcihsKSxyLm1hbmFnZXIuaXRlbUVycm9yKHQpfX0sbixpKX1wYXJzZSh0KXtsZXQgZT1bXTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyl7bGV0IGk9emkucGFyc2UodFtuXSk7ZS5wdXNoKGkpfXJldHVybiBlfX0sc2g9Y2xhc3MgZXh0ZW5kcyBOZXtjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1sb2FkKHQsZSxuLGkpe2xldCByPXRoaXMsYT1bXSxvPW5ldyBicyxsPW5ldyBjbih0aGlzLm1hbmFnZXIpO2wuc2V0UGF0aCh0aGlzLnBhdGgpLGwuc2V0UmVzcG9uc2VUeXBlKCJhcnJheWJ1ZmZlciIpLGwuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpLGwuc2V0V2l0aENyZWRlbnRpYWxzKHIud2l0aENyZWRlbnRpYWxzKTtsZXQgYz0wO2Z1bmN0aW9uIGgodSl7bC5sb2FkKHRbdV0sZnVuY3Rpb24oZCl7bGV0IGY9ci5wYXJzZShkLCEwKTthW3VdPXt3aWR0aDpmLndpZHRoLGhlaWdodDpmLmhlaWdodCxmb3JtYXQ6Zi5mb3JtYXQsbWlwbWFwczpmLm1pcG1hcHN9LGMrPTEsYz09PTYmJihmLm1pcG1hcENvdW50PT09MSYmKG8ubWluRmlsdGVyPW9lKSxvLmltYWdlPWEsby5mb3JtYXQ9Zi5mb3JtYXQsby5uZWVkc1VwZGF0ZT0hMCxlJiZlKG8pKX0sbixpKX1pZihBcnJheS5pc0FycmF5KHQpKWZvcihsZXQgdT0wLGQ9dC5sZW5ndGg7dTxkOysrdSloKHUpO2Vsc2UgbC5sb2FkKHQsZnVuY3Rpb24odSl7bGV0IGQ9ci5wYXJzZSh1LCEwKTtpZihkLmlzQ3ViZW1hcCl7bGV0IGY9ZC5taXBtYXBzLmxlbmd0aC9kLm1pcG1hcENvdW50O2ZvcihsZXQgbT0wO208ZjttKyspe2FbbV09e21pcG1hcHM6W119O2ZvcihsZXQgXz0wO188ZC5taXBtYXBDb3VudDtfKyspYVttXS5taXBtYXBzLnB1c2goZC5taXBtYXBzW20qZC5taXBtYXBDb3VudCtfXSksYVttXS5mb3JtYXQ9ZC5mb3JtYXQsYVttXS53aWR0aD1kLndpZHRoLGFbbV0uaGVpZ2h0PWQuaGVpZ2h0fW8uaW1hZ2U9YX1lbHNlIG8uaW1hZ2Uud2lkdGg9ZC53aWR0aCxvLmltYWdlLmhlaWdodD1kLmhlaWdodCxvLm1pcG1hcHM9ZC5taXBtYXBzO2QubWlwbWFwQ291bnQ9PT0xJiYoby5taW5GaWx0ZXI9b2UpLG8uZm9ybWF0PWQuZm9ybWF0LG8ubmVlZHNVcGRhdGU9ITAsZSYmZShvKX0sbixpKTtyZXR1cm4gb319LFZpPWNsYXNzIGV4dGVuZHMgTmV7Y29uc3RydWN0b3IodCl7c3VwZXIodCl9bG9hZCh0LGUsbixpKXt0aGlzLnBhdGghPT12b2lkIDAmJih0PXRoaXMucGF0aCt0KSx0PXRoaXMubWFuYWdlci5yZXNvbHZlVVJMKHQpO2xldCByPXRoaXMsYT1Jbi5nZXQodCk7aWYoYSE9PXZvaWQgMClyZXR1cm4gci5tYW5hZ2VyLml0ZW1TdGFydCh0KSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZSYmZShhKSxyLm1hbmFnZXIuaXRlbUVuZCh0KX0sMCksYTtsZXQgbz1ycigiaW1nIik7ZnVuY3Rpb24gbCgpe2goKSxJbi5hZGQodCx0aGlzKSxlJiZlKHRoaXMpLHIubWFuYWdlci5pdGVtRW5kKHQpfWZ1bmN0aW9uIGModSl7aCgpLGkmJmkodSksci5tYW5hZ2VyLml0ZW1FcnJvcih0KSxyLm1hbmFnZXIuaXRlbUVuZCh0KX1mdW5jdGlvbiBoKCl7by5yZW1vdmVFdmVudExpc3RlbmVyKCJsb2FkIixsLCExKSxvLnJlbW92ZUV2ZW50TGlzdGVuZXIoImVycm9yIixjLCExKX1yZXR1cm4gby5hZGRFdmVudExpc3RlbmVyKCJsb2FkIixsLCExKSxvLmFkZEV2ZW50TGlzdGVuZXIoImVycm9yIixjLCExKSx0LnNsaWNlKDAsNSkhPT0iZGF0YToiJiZ0aGlzLmNyb3NzT3JpZ2luIT09dm9pZCAwJiYoby5jcm9zc09yaWdpbj10aGlzLmNyb3NzT3JpZ2luKSxyLm1hbmFnZXIuaXRlbVN0YXJ0KHQpLG8uc3JjPXQsb319LHJoPWNsYXNzIGV4dGVuZHMgTmV7Y29uc3RydWN0b3IodCl7c3VwZXIodCl9bG9hZCh0LGUsbixpKXtsZXQgcj1uZXcgTGk7ci5jb2xvclNwYWNlPXhlO2xldCBhPW5ldyBWaSh0aGlzLm1hbmFnZXIpO2Euc2V0Q3Jvc3NPcmlnaW4odGhpcy5jcm9zc09yaWdpbiksYS5zZXRQYXRoKHRoaXMucGF0aCk7bGV0IG89MDtmdW5jdGlvbiBsKGMpe2EubG9hZCh0W2NdLGZ1bmN0aW9uKGgpe3IuaW1hZ2VzW2NdPWgsbysrLG89PT02JiYoci5uZWVkc1VwZGF0ZT0hMCxlJiZlKHIpKX0sdm9pZCAwLGkpfWZvcihsZXQgYz0wO2M8dC5sZW5ndGg7KytjKWwoYyk7cmV0dXJuIHJ9fSxhaD1jbGFzcyBleHRlbmRzIE5le2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpfWxvYWQodCxlLG4saSl7bGV0IHI9dGhpcyxhPW5ldyBPbixvPW5ldyBjbih0aGlzLm1hbmFnZXIpO3JldHVybiBvLnNldFJlc3BvbnNlVHlwZSgiYXJyYXlidWZmZXIiKSxvLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKSxvLnNldFBhdGgodGhpcy5wYXRoKSxvLnNldFdpdGhDcmVkZW50aWFscyhyLndpdGhDcmVkZW50aWFscyksby5sb2FkKHQsZnVuY3Rpb24obCl7bGV0IGM7dHJ5e2M9ci5wYXJzZShsKX1jYXRjaChoKXtpZihpIT09dm9pZCAwKWkoaCk7ZWxzZXtjb25zb2xlLmVycm9yKGgpO3JldHVybn19Yy5pbWFnZSE9PXZvaWQgMD9hLmltYWdlPWMuaW1hZ2U6Yy5kYXRhIT09dm9pZCAwJiYoYS5pbWFnZS53aWR0aD1jLndpZHRoLGEuaW1hZ2UuaGVpZ2h0PWMuaGVpZ2h0LGEuaW1hZ2UuZGF0YT1jLmRhdGEpLGEud3JhcFM9Yy53cmFwUyE9PXZvaWQgMD9jLndyYXBTOlVlLGEud3JhcFQ9Yy53cmFwVCE9PXZvaWQgMD9jLndyYXBUOlVlLGEubWFnRmlsdGVyPWMubWFnRmlsdGVyIT09dm9pZCAwP2MubWFnRmlsdGVyOm9lLGEubWluRmlsdGVyPWMubWluRmlsdGVyIT09dm9pZCAwP2MubWluRmlsdGVyOm9lLGEuYW5pc290cm9weT1jLmFuaXNvdHJvcHkhPT12b2lkIDA/Yy5hbmlzb3Ryb3B5OjEsYy5jb2xvclNwYWNlIT09dm9pZCAwP2EuY29sb3JTcGFjZT1jLmNvbG9yU3BhY2U6Yy5lbmNvZGluZyE9PXZvaWQgMCYmKGEuZW5jb2Rpbmc9Yy5lbmNvZGluZyksYy5mbGlwWSE9PXZvaWQgMCYmKGEuZmxpcFk9Yy5mbGlwWSksYy5mb3JtYXQhPT12b2lkIDAmJihhLmZvcm1hdD1jLmZvcm1hdCksYy50eXBlIT09dm9pZCAwJiYoYS50eXBlPWMudHlwZSksYy5taXBtYXBzIT09dm9pZCAwJiYoYS5taXBtYXBzPWMubWlwbWFwcyxhLm1pbkZpbHRlcj1wbiksYy5taXBtYXBDb3VudD09PTEmJihhLm1pbkZpbHRlcj1vZSksYy5nZW5lcmF0ZU1pcG1hcHMhPT12b2lkIDAmJihhLmdlbmVyYXRlTWlwbWFwcz1jLmdlbmVyYXRlTWlwbWFwcyksYS5uZWVkc1VwZGF0ZT0hMCxlJiZlKGEsYyl9LG4saSksYX19LG9oPWNsYXNzIGV4dGVuZHMgTmV7Y29uc3RydWN0b3IodCl7c3VwZXIodCl9bG9hZCh0LGUsbixpKXtsZXQgcj1uZXcgX2UsYT1uZXcgVmkodGhpcy5tYW5hZ2VyKTtyZXR1cm4gYS5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKSxhLnNldFBhdGgodGhpcy5wYXRoKSxhLmxvYWQodCxmdW5jdGlvbihvKXtyLmltYWdlPW8sci5uZWVkc1VwZGF0ZT0hMCxlIT09dm9pZCAwJiZlKHIpfSxuLGkpLHJ9fSx5bj1jbGFzcyBleHRlbmRzIEp0e2NvbnN0cnVjdG9yKHQsZT0xKXtzdXBlcigpLHRoaXMuaXNMaWdodD0hMCx0aGlzLnR5cGU9IkxpZ2h0Iix0aGlzLmNvbG9yPW5ldyB1dCh0KSx0aGlzLmludGVuc2l0eT1lfWRpc3Bvc2UoKXt9Y29weSh0LGUpe3JldHVybiBzdXBlci5jb3B5KHQsZSksdGhpcy5jb2xvci5jb3B5KHQuY29sb3IpLHRoaXMuaW50ZW5zaXR5PXQuaW50ZW5zaXR5LHRoaXN9dG9KU09OKHQpe2xldCBlPXN1cGVyLnRvSlNPTih0KTtyZXR1cm4gZS5vYmplY3QuY29sb3I9dGhpcy5jb2xvci5nZXRIZXgoKSxlLm9iamVjdC5pbnRlbnNpdHk9dGhpcy5pbnRlbnNpdHksdGhpcy5ncm91bmRDb2xvciE9PXZvaWQgMCYmKGUub2JqZWN0Lmdyb3VuZENvbG9yPXRoaXMuZ3JvdW5kQ29sb3IuZ2V0SGV4KCkpLHRoaXMuZGlzdGFuY2UhPT12b2lkIDAmJihlLm9iamVjdC5kaXN0YW5jZT10aGlzLmRpc3RhbmNlKSx0aGlzLmFuZ2xlIT09dm9pZCAwJiYoZS5vYmplY3QuYW5nbGU9dGhpcy5hbmdsZSksdGhpcy5kZWNheSE9PXZvaWQgMCYmKGUub2JqZWN0LmRlY2F5PXRoaXMuZGVjYXkpLHRoaXMucGVudW1icmEhPT12b2lkIDAmJihlLm9iamVjdC5wZW51bWJyYT10aGlzLnBlbnVtYnJhKSx0aGlzLnNoYWRvdyE9PXZvaWQgMCYmKGUub2JqZWN0LnNoYWRvdz10aGlzLnNoYWRvdy50b0pTT04oKSksZX19LEJvPWNsYXNzIGV4dGVuZHMgeW57Y29uc3RydWN0b3IodCxlLG4pe3N1cGVyKHQsbiksdGhpcy5pc0hlbWlzcGhlcmVMaWdodD0hMCx0aGlzLnR5cGU9IkhlbWlzcGhlcmVMaWdodCIsdGhpcy5wb3NpdGlvbi5jb3B5KEp0LkRFRkFVTFRfVVApLHRoaXMudXBkYXRlTWF0cml4KCksdGhpcy5ncm91bmRDb2xvcj1uZXcgdXQoZSl9Y29weSh0LGUpe3JldHVybiBzdXBlci5jb3B5KHQsZSksdGhpcy5ncm91bmRDb2xvci5jb3B5KHQuZ3JvdW5kQ29sb3IpLHRoaXN9fSxHbD1uZXcgTHQsVGQ9bmV3IFIsd2Q9bmV3IFIsVXI9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5jYW1lcmE9dCx0aGlzLmJpYXM9MCx0aGlzLm5vcm1hbEJpYXM9MCx0aGlzLnJhZGl1cz0xLHRoaXMuYmx1clNhbXBsZXM9OCx0aGlzLm1hcFNpemU9bmV3IFooNTEyLDUxMiksdGhpcy5tYXA9bnVsbCx0aGlzLm1hcFBhc3M9bnVsbCx0aGlzLm1hdHJpeD1uZXcgTHQsdGhpcy5hdXRvVXBkYXRlPSEwLHRoaXMubmVlZHNVcGRhdGU9ITEsdGhpcy5fZnJ1c3R1bT1uZXcgSWksdGhpcy5fZnJhbWVFeHRlbnRzPW5ldyBaKDEsMSksdGhpcy5fdmlld3BvcnRDb3VudD0xLHRoaXMuX3ZpZXdwb3J0cz1bbmV3IHRlKDAsMCwxLDEpXX1nZXRWaWV3cG9ydENvdW50KCl7cmV0dXJuIHRoaXMuX3ZpZXdwb3J0Q291bnR9Z2V0RnJ1c3R1bSgpe3JldHVybiB0aGlzLl9mcnVzdHVtfXVwZGF0ZU1hdHJpY2VzKHQpe2xldCBlPXRoaXMuY2FtZXJhLG49dGhpcy5tYXRyaXg7VGQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHQubWF0cml4V29ybGQpLGUucG9zaXRpb24uY29weShUZCksd2Quc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHQudGFyZ2V0Lm1hdHJpeFdvcmxkKSxlLmxvb2tBdCh3ZCksZS51cGRhdGVNYXRyaXhXb3JsZCgpLEdsLm11bHRpcGx5TWF0cmljZXMoZS5wcm9qZWN0aW9uTWF0cml4LGUubWF0cml4V29ybGRJbnZlcnNlKSx0aGlzLl9mcnVzdHVtLnNldEZyb21Qcm9qZWN0aW9uTWF0cml4KEdsKSxuLnNldCguNSwwLDAsLjUsMCwuNSwwLC41LDAsMCwuNSwuNSwwLDAsMCwxKSxuLm11bHRpcGx5KEdsKX1nZXRWaWV3cG9ydCh0KXtyZXR1cm4gdGhpcy5fdmlld3BvcnRzW3RdfWdldEZyYW1lRXh0ZW50cygpe3JldHVybiB0aGlzLl9mcmFtZUV4dGVudHN9ZGlzcG9zZSgpe3RoaXMubWFwJiZ0aGlzLm1hcC5kaXNwb3NlKCksdGhpcy5tYXBQYXNzJiZ0aGlzLm1hcFBhc3MuZGlzcG9zZSgpfWNvcHkodCl7cmV0dXJuIHRoaXMuY2FtZXJhPXQuY2FtZXJhLmNsb25lKCksdGhpcy5iaWFzPXQuYmlhcyx0aGlzLnJhZGl1cz10LnJhZGl1cyx0aGlzLm1hcFNpemUuY29weSh0Lm1hcFNpemUpLHRoaXN9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpfXRvSlNPTigpe2xldCB0PXt9O3JldHVybiB0aGlzLmJpYXMhPT0wJiYodC5iaWFzPXRoaXMuYmlhcyksdGhpcy5ub3JtYWxCaWFzIT09MCYmKHQubm9ybWFsQmlhcz10aGlzLm5vcm1hbEJpYXMpLHRoaXMucmFkaXVzIT09MSYmKHQucmFkaXVzPXRoaXMucmFkaXVzKSwodGhpcy5tYXBTaXplLnghPT01MTJ8fHRoaXMubWFwU2l6ZS55IT09NTEyKSYmKHQubWFwU2l6ZT10aGlzLm1hcFNpemUudG9BcnJheSgpKSx0LmNhbWVyYT10aGlzLmNhbWVyYS50b0pTT04oITEpLm9iamVjdCxkZWxldGUgdC5jYW1lcmEubWF0cml4LHR9fSxsaD1jbGFzcyBleHRlbmRzIFVye2NvbnN0cnVjdG9yKCl7c3VwZXIobmV3IHZlKDUwLDEsLjUsNTAwKSksdGhpcy5pc1Nwb3RMaWdodFNoYWRvdz0hMCx0aGlzLmZvY3VzPTF9dXBkYXRlTWF0cmljZXModCl7bGV0IGU9dGhpcy5jYW1lcmEsbj1tcyoyKnQuYW5nbGUqdGhpcy5mb2N1cyxpPXRoaXMubWFwU2l6ZS53aWR0aC90aGlzLm1hcFNpemUuaGVpZ2h0LHI9dC5kaXN0YW5jZXx8ZS5mYXI7KG4hPT1lLmZvdnx8aSE9PWUuYXNwZWN0fHxyIT09ZS5mYXIpJiYoZS5mb3Y9bixlLmFzcGVjdD1pLGUuZmFyPXIsZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCkpLHN1cGVyLnVwZGF0ZU1hdHJpY2VzKHQpfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5mb2N1cz10LmZvY3VzLHRoaXN9fSx6bz1jbGFzcyBleHRlbmRzIHlue2NvbnN0cnVjdG9yKHQsZSxuPTAsaT1NYXRoLlBJLzMscj0wLGE9Mil7c3VwZXIodCxlKSx0aGlzLmlzU3BvdExpZ2h0PSEwLHRoaXMudHlwZT0iU3BvdExpZ2h0Iix0aGlzLnBvc2l0aW9uLmNvcHkoSnQuREVGQVVMVF9VUCksdGhpcy51cGRhdGVNYXRyaXgoKSx0aGlzLnRhcmdldD1uZXcgSnQsdGhpcy5kaXN0YW5jZT1uLHRoaXMuYW5nbGU9aSx0aGlzLnBlbnVtYnJhPXIsdGhpcy5kZWNheT1hLHRoaXMubWFwPW51bGwsdGhpcy5zaGFkb3c9bmV3IGxofWdldCBwb3dlcigpe3JldHVybiB0aGlzLmludGVuc2l0eSpNYXRoLlBJfXNldCBwb3dlcih0KXt0aGlzLmludGVuc2l0eT10L01hdGguUEl9ZGlzcG9zZSgpe3RoaXMuc2hhZG93LmRpc3Bvc2UoKX1jb3B5KHQsZSl7cmV0dXJuIHN1cGVyLmNvcHkodCxlKSx0aGlzLmRpc3RhbmNlPXQuZGlzdGFuY2UsdGhpcy5hbmdsZT10LmFuZ2xlLHRoaXMucGVudW1icmE9dC5wZW51bWJyYSx0aGlzLmRlY2F5PXQuZGVjYXksdGhpcy50YXJnZXQ9dC50YXJnZXQuY2xvbmUoKSx0aGlzLnNoYWRvdz10LnNoYWRvdy5jbG9uZSgpLHRoaXN9fSxSZD1uZXcgTHQsenM9bmV3IFIsV2w9bmV3IFIsY2g9Y2xhc3MgZXh0ZW5kcyBVcntjb25zdHJ1Y3Rvcigpe3N1cGVyKG5ldyB2ZSg5MCwxLC41LDUwMCkpLHRoaXMuaXNQb2ludExpZ2h0U2hhZG93PSEwLHRoaXMuX2ZyYW1lRXh0ZW50cz1uZXcgWig0LDIpLHRoaXMuX3ZpZXdwb3J0Q291bnQ9Nix0aGlzLl92aWV3cG9ydHM9W25ldyB0ZSgyLDEsMSwxKSxuZXcgdGUoMCwxLDEsMSksbmV3IHRlKDMsMSwxLDEpLG5ldyB0ZSgxLDEsMSwxKSxuZXcgdGUoMywwLDEsMSksbmV3IHRlKDEsMCwxLDEpXSx0aGlzLl9jdWJlRGlyZWN0aW9ucz1bbmV3IFIoMSwwLDApLG5ldyBSKC0xLDAsMCksbmV3IFIoMCwwLDEpLG5ldyBSKDAsMCwtMSksbmV3IFIoMCwxLDApLG5ldyBSKDAsLTEsMCldLHRoaXMuX2N1YmVVcHM9W25ldyBSKDAsMSwwKSxuZXcgUigwLDEsMCksbmV3IFIoMCwxLDApLG5ldyBSKDAsMSwwKSxuZXcgUigwLDAsMSksbmV3IFIoMCwwLC0xKV19dXBkYXRlTWF0cmljZXModCxlPTApe2xldCBuPXRoaXMuY2FtZXJhLGk9dGhpcy5tYXRyaXgscj10LmRpc3RhbmNlfHxuLmZhcjtyIT09bi5mYXImJihuLmZhcj1yLG4udXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpKSx6cy5zZXRGcm9tTWF0cml4UG9zaXRpb24odC5tYXRyaXhXb3JsZCksbi5wb3NpdGlvbi5jb3B5KHpzKSxXbC5jb3B5KG4ucG9zaXRpb24pLFdsLmFkZCh0aGlzLl9jdWJlRGlyZWN0aW9uc1tlXSksbi51cC5jb3B5KHRoaXMuX2N1YmVVcHNbZV0pLG4ubG9va0F0KFdsKSxuLnVwZGF0ZU1hdHJpeFdvcmxkKCksaS5tYWtlVHJhbnNsYXRpb24oLXpzLngsLXpzLnksLXpzLnopLFJkLm11bHRpcGx5TWF0cmljZXMobi5wcm9qZWN0aW9uTWF0cml4LG4ubWF0cml4V29ybGRJbnZlcnNlKSx0aGlzLl9mcnVzdHVtLnNldEZyb21Qcm9qZWN0aW9uTWF0cml4KFJkKX19LFZvPWNsYXNzIGV4dGVuZHMgeW57Y29uc3RydWN0b3IodCxlLG49MCxpPTIpe3N1cGVyKHQsZSksdGhpcy5pc1BvaW50TGlnaHQ9ITAsdGhpcy50eXBlPSJQb2ludExpZ2h0Iix0aGlzLmRpc3RhbmNlPW4sdGhpcy5kZWNheT1pLHRoaXMuc2hhZG93PW5ldyBjaH1nZXQgcG93ZXIoKXtyZXR1cm4gdGhpcy5pbnRlbnNpdHkqNCpNYXRoLlBJfXNldCBwb3dlcih0KXt0aGlzLmludGVuc2l0eT10Lyg0Kk1hdGguUEkpfWRpc3Bvc2UoKXt0aGlzLnNoYWRvdy5kaXNwb3NlKCl9Y29weSh0LGUpe3JldHVybiBzdXBlci5jb3B5KHQsZSksdGhpcy5kaXN0YW5jZT10LmRpc3RhbmNlLHRoaXMuZGVjYXk9dC5kZWNheSx0aGlzLnNoYWRvdz10LnNoYWRvdy5jbG9uZSgpLHRoaXN9fSxoaD1jbGFzcyBleHRlbmRzIFVye2NvbnN0cnVjdG9yKCl7c3VwZXIobmV3IE1zKC01LDUsNSwtNSwuNSw1MDApKSx0aGlzLmlzRGlyZWN0aW9uYWxMaWdodFNoYWRvdz0hMH19LGtvPWNsYXNzIGV4dGVuZHMgeW57Y29uc3RydWN0b3IodCxlKXtzdXBlcih0LGUpLHRoaXMuaXNEaXJlY3Rpb25hbExpZ2h0PSEwLHRoaXMudHlwZT0iRGlyZWN0aW9uYWxMaWdodCIsdGhpcy5wb3NpdGlvbi5jb3B5KEp0LkRFRkFVTFRfVVApLHRoaXMudXBkYXRlTWF0cml4KCksdGhpcy50YXJnZXQ9bmV3IEp0LHRoaXMuc2hhZG93PW5ldyBoaH1kaXNwb3NlKCl7dGhpcy5zaGFkb3cuZGlzcG9zZSgpfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy50YXJnZXQ9dC50YXJnZXQuY2xvbmUoKSx0aGlzLnNoYWRvdz10LnNoYWRvdy5jbG9uZSgpLHRoaXN9fSxIbz1jbGFzcyBleHRlbmRzIHlue2NvbnN0cnVjdG9yKHQsZSl7c3VwZXIodCxlKSx0aGlzLmlzQW1iaWVudExpZ2h0PSEwLHRoaXMudHlwZT0iQW1iaWVudExpZ2h0In19LEdvPWNsYXNzIGV4dGVuZHMgeW57Y29uc3RydWN0b3IodCxlLG49MTAsaT0xMCl7c3VwZXIodCxlKSx0aGlzLmlzUmVjdEFyZWFMaWdodD0hMCx0aGlzLnR5cGU9IlJlY3RBcmVhTGlnaHQiLHRoaXMud2lkdGg9bix0aGlzLmhlaWdodD1pfWdldCBwb3dlcigpe3JldHVybiB0aGlzLmludGVuc2l0eSp0aGlzLndpZHRoKnRoaXMuaGVpZ2h0Kk1hdGguUEl9c2V0IHBvd2VyKHQpe3RoaXMuaW50ZW5zaXR5PXQvKHRoaXMud2lkdGgqdGhpcy5oZWlnaHQqTWF0aC5QSSl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLndpZHRoPXQud2lkdGgsdGhpcy5oZWlnaHQ9dC5oZWlnaHQsdGhpc310b0pTT04odCl7bGV0IGU9c3VwZXIudG9KU09OKHQpO3JldHVybiBlLm9iamVjdC53aWR0aD10aGlzLndpZHRoLGUub2JqZWN0LmhlaWdodD10aGlzLmhlaWdodCxlfX0sV289Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmlzU3BoZXJpY2FsSGFybW9uaWNzMz0hMCx0aGlzLmNvZWZmaWNpZW50cz1bXTtmb3IobGV0IHQ9MDt0PDk7dCsrKXRoaXMuY29lZmZpY2llbnRzLnB1c2gobmV3IFIpfXNldCh0KXtmb3IobGV0IGU9MDtlPDk7ZSsrKXRoaXMuY29lZmZpY2llbnRzW2VdLmNvcHkodFtlXSk7cmV0dXJuIHRoaXN9emVybygpe2ZvcihsZXQgdD0wO3Q8OTt0KyspdGhpcy5jb2VmZmljaWVudHNbdF0uc2V0KDAsMCwwKTtyZXR1cm4gdGhpc31nZXRBdCh0LGUpe2xldCBuPXQueCxpPXQueSxyPXQueixhPXRoaXMuY29lZmZpY2llbnRzO3JldHVybiBlLmNvcHkoYVswXSkubXVsdGlwbHlTY2FsYXIoLjI4MjA5NSksZS5hZGRTY2FsZWRWZWN0b3IoYVsxXSwuNDg4NjAzKmkpLGUuYWRkU2NhbGVkVmVjdG9yKGFbMl0sLjQ4ODYwMypyKSxlLmFkZFNjYWxlZFZlY3RvcihhWzNdLC40ODg2MDMqbiksZS5hZGRTY2FsZWRWZWN0b3IoYVs0XSwxLjA5MjU0OCoobippKSksZS5hZGRTY2FsZWRWZWN0b3IoYVs1XSwxLjA5MjU0OCooaSpyKSksZS5hZGRTY2FsZWRWZWN0b3IoYVs2XSwuMzE1MzkyKigzKnIqci0xKSksZS5hZGRTY2FsZWRWZWN0b3IoYVs3XSwxLjA5MjU0OCoobipyKSksZS5hZGRTY2FsZWRWZWN0b3IoYVs4XSwuNTQ2Mjc0KihuKm4taSppKSksZX1nZXRJcnJhZGlhbmNlQXQodCxlKXtsZXQgbj10LngsaT10Lnkscj10LnosYT10aGlzLmNvZWZmaWNpZW50cztyZXR1cm4gZS5jb3B5KGFbMF0pLm11bHRpcGx5U2NhbGFyKC44ODYyMjcpLGUuYWRkU2NhbGVkVmVjdG9yKGFbMV0sMiouNTExNjY0KmkpLGUuYWRkU2NhbGVkVmVjdG9yKGFbMl0sMiouNTExNjY0KnIpLGUuYWRkU2NhbGVkVmVjdG9yKGFbM10sMiouNTExNjY0Km4pLGUuYWRkU2NhbGVkVmVjdG9yKGFbNF0sMiouNDI5MDQzKm4qaSksZS5hZGRTY2FsZWRWZWN0b3IoYVs1XSwyKi40MjkwNDMqaSpyKSxlLmFkZFNjYWxlZFZlY3RvcihhWzZdLC43NDMxMjUqcipyLS4yNDc3MDgpLGUuYWRkU2NhbGVkVmVjdG9yKGFbN10sMiouNDI5MDQzKm4qciksZS5hZGRTY2FsZWRWZWN0b3IoYVs4XSwuNDI5MDQzKihuKm4taSppKSksZX1hZGQodCl7Zm9yKGxldCBlPTA7ZTw5O2UrKyl0aGlzLmNvZWZmaWNpZW50c1tlXS5hZGQodC5jb2VmZmljaWVudHNbZV0pO3JldHVybiB0aGlzfWFkZFNjYWxlZFNIKHQsZSl7Zm9yKGxldCBuPTA7bjw5O24rKyl0aGlzLmNvZWZmaWNpZW50c1tuXS5hZGRTY2FsZWRWZWN0b3IodC5jb2VmZmljaWVudHNbbl0sZSk7cmV0dXJuIHRoaXN9c2NhbGUodCl7Zm9yKGxldCBlPTA7ZTw5O2UrKyl0aGlzLmNvZWZmaWNpZW50c1tlXS5tdWx0aXBseVNjYWxhcih0KTtyZXR1cm4gdGhpc31sZXJwKHQsZSl7Zm9yKGxldCBuPTA7bjw5O24rKyl0aGlzLmNvZWZmaWNpZW50c1tuXS5sZXJwKHQuY29lZmZpY2llbnRzW25dLGUpO3JldHVybiB0aGlzfWVxdWFscyh0KXtmb3IobGV0IGU9MDtlPDk7ZSsrKWlmKCF0aGlzLmNvZWZmaWNpZW50c1tlXS5lcXVhbHModC5jb2VmZmljaWVudHNbZV0pKXJldHVybiExO3JldHVybiEwfWNvcHkodCl7cmV0dXJuIHRoaXMuc2V0KHQuY29lZmZpY2llbnRzKX1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyl9ZnJvbUFycmF5KHQsZT0wKXtsZXQgbj10aGlzLmNvZWZmaWNpZW50cztmb3IobGV0IGk9MDtpPDk7aSsrKW5baV0uZnJvbUFycmF5KHQsZStpKjMpO3JldHVybiB0aGlzfXRvQXJyYXkodD1bXSxlPTApe2xldCBuPXRoaXMuY29lZmZpY2llbnRzO2ZvcihsZXQgaT0wO2k8OTtpKyspbltpXS50b0FycmF5KHQsZStpKjMpO3JldHVybiB0fXN0YXRpYyBnZXRCYXNpc0F0KHQsZSl7bGV0IG49dC54LGk9dC55LHI9dC56O2VbMF09LjI4MjA5NSxlWzFdPS40ODg2MDMqaSxlWzJdPS40ODg2MDMqcixlWzNdPS40ODg2MDMqbixlWzRdPTEuMDkyNTQ4Km4qaSxlWzVdPTEuMDkyNTQ4KmkqcixlWzZdPS4zMTUzOTIqKDMqcipyLTEpLGVbN109MS4wOTI1NDgqbipyLGVbOF09LjU0NjI3NCoobipuLWkqaSl9fSxYbz1jbGFzcyBleHRlbmRzIHlue2NvbnN0cnVjdG9yKHQ9bmV3IFdvLGU9MSl7c3VwZXIodm9pZCAwLGUpLHRoaXMuaXNMaWdodFByb2JlPSEwLHRoaXMuc2g9dH1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMuc2guY29weSh0LnNoKSx0aGlzfWZyb21KU09OKHQpe3JldHVybiB0aGlzLmludGVuc2l0eT10LmludGVuc2l0eSx0aGlzLnNoLmZyb21BcnJheSh0LnNoKSx0aGlzfXRvSlNPTih0KXtsZXQgZT1zdXBlci50b0pTT04odCk7cmV0dXJuIGUub2JqZWN0LnNoPXRoaXMuc2gudG9BcnJheSgpLGV9fSxxbz1jbGFzcyBzIGV4dGVuZHMgTmV7Y29uc3RydWN0b3IodCl7c3VwZXIodCksdGhpcy50ZXh0dXJlcz17fX1sb2FkKHQsZSxuLGkpe2xldCByPXRoaXMsYT1uZXcgY24oci5tYW5hZ2VyKTthLnNldFBhdGgoci5wYXRoKSxhLnNldFJlcXVlc3RIZWFkZXIoci5yZXF1ZXN0SGVhZGVyKSxhLnNldFdpdGhDcmVkZW50aWFscyhyLndpdGhDcmVkZW50aWFscyksYS5sb2FkKHQsZnVuY3Rpb24obyl7dHJ5e2Uoci5wYXJzZShKU09OLnBhcnNlKG8pKSl9Y2F0Y2gobCl7aT9pKGwpOmNvbnNvbGUuZXJyb3IobCksci5tYW5hZ2VyLml0ZW1FcnJvcih0KX19LG4saSl9cGFyc2UodCl7bGV0IGU9dGhpcy50ZXh0dXJlcztmdW5jdGlvbiBuKHIpe3JldHVybiBlW3JdPT09dm9pZCAwJiZjb25zb2xlLndhcm4oIlRIUkVFLk1hdGVyaWFsTG9hZGVyOiBVbmRlZmluZWQgdGV4dHVyZSIsciksZVtyXX1sZXQgaT1zLmNyZWF0ZU1hdGVyaWFsRnJvbVR5cGUodC50eXBlKTtpZih0LnV1aWQhPT12b2lkIDAmJihpLnV1aWQ9dC51dWlkKSx0Lm5hbWUhPT12b2lkIDAmJihpLm5hbWU9dC5uYW1lKSx0LmNvbG9yIT09dm9pZCAwJiZpLmNvbG9yIT09dm9pZCAwJiZpLmNvbG9yLnNldEhleCh0LmNvbG9yKSx0LnJvdWdobmVzcyE9PXZvaWQgMCYmKGkucm91Z2huZXNzPXQucm91Z2huZXNzKSx0Lm1ldGFsbmVzcyE9PXZvaWQgMCYmKGkubWV0YWxuZXNzPXQubWV0YWxuZXNzKSx0LnNoZWVuIT09dm9pZCAwJiYoaS5zaGVlbj10LnNoZWVuKSx0LnNoZWVuQ29sb3IhPT12b2lkIDAmJihpLnNoZWVuQ29sb3I9bmV3IHV0KCkuc2V0SGV4KHQuc2hlZW5Db2xvcikpLHQuc2hlZW5Sb3VnaG5lc3MhPT12b2lkIDAmJihpLnNoZWVuUm91Z2huZXNzPXQuc2hlZW5Sb3VnaG5lc3MpLHQuZW1pc3NpdmUhPT12b2lkIDAmJmkuZW1pc3NpdmUhPT12b2lkIDAmJmkuZW1pc3NpdmUuc2V0SGV4KHQuZW1pc3NpdmUpLHQuc3BlY3VsYXIhPT12b2lkIDAmJmkuc3BlY3VsYXIhPT12b2lkIDAmJmkuc3BlY3VsYXIuc2V0SGV4KHQuc3BlY3VsYXIpLHQuc3BlY3VsYXJJbnRlbnNpdHkhPT12b2lkIDAmJihpLnNwZWN1bGFySW50ZW5zaXR5PXQuc3BlY3VsYXJJbnRlbnNpdHkpLHQuc3BlY3VsYXJDb2xvciE9PXZvaWQgMCYmaS5zcGVjdWxhckNvbG9yIT09dm9pZCAwJiZpLnNwZWN1bGFyQ29sb3Iuc2V0SGV4KHQuc3BlY3VsYXJDb2xvciksdC5zaGluaW5lc3MhPT12b2lkIDAmJihpLnNoaW5pbmVzcz10LnNoaW5pbmVzcyksdC5jbGVhcmNvYXQhPT12b2lkIDAmJihpLmNsZWFyY29hdD10LmNsZWFyY29hdCksdC5jbGVhcmNvYXRSb3VnaG5lc3MhPT12b2lkIDAmJihpLmNsZWFyY29hdFJvdWdobmVzcz10LmNsZWFyY29hdFJvdWdobmVzcyksdC5pcmlkZXNjZW5jZSE9PXZvaWQgMCYmKGkuaXJpZGVzY2VuY2U9dC5pcmlkZXNjZW5jZSksdC5pcmlkZXNjZW5jZUlPUiE9PXZvaWQgMCYmKGkuaXJpZGVzY2VuY2VJT1I9dC5pcmlkZXNjZW5jZUlPUiksdC5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlIT09dm9pZCAwJiYoaS5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlPXQuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSksdC50cmFuc21pc3Npb24hPT12b2lkIDAmJihpLnRyYW5zbWlzc2lvbj10LnRyYW5zbWlzc2lvbiksdC50aGlja25lc3MhPT12b2lkIDAmJihpLnRoaWNrbmVzcz10LnRoaWNrbmVzcyksdC5hdHRlbnVhdGlvbkRpc3RhbmNlIT09dm9pZCAwJiYoaS5hdHRlbnVhdGlvbkRpc3RhbmNlPXQuYXR0ZW51YXRpb25EaXN0YW5jZSksdC5hdHRlbnVhdGlvbkNvbG9yIT09dm9pZCAwJiZpLmF0dGVudWF0aW9uQ29sb3IhPT12b2lkIDAmJmkuYXR0ZW51YXRpb25Db2xvci5zZXRIZXgodC5hdHRlbnVhdGlvbkNvbG9yKSx0LmFuaXNvdHJvcHkhPT12b2lkIDAmJihpLmFuaXNvdHJvcHk9dC5hbmlzb3Ryb3B5KSx0LmFuaXNvdHJvcHlSb3RhdGlvbiE9PXZvaWQgMCYmKGkuYW5pc290cm9weVJvdGF0aW9uPXQuYW5pc290cm9weVJvdGF0aW9uKSx0LmZvZyE9PXZvaWQgMCYmKGkuZm9nPXQuZm9nKSx0LmZsYXRTaGFkaW5nIT09dm9pZCAwJiYoaS5mbGF0U2hhZGluZz10LmZsYXRTaGFkaW5nKSx0LmJsZW5kaW5nIT09dm9pZCAwJiYoaS5ibGVuZGluZz10LmJsZW5kaW5nKSx0LmNvbWJpbmUhPT12b2lkIDAmJihpLmNvbWJpbmU9dC5jb21iaW5lKSx0LnNpZGUhPT12b2lkIDAmJihpLnNpZGU9dC5zaWRlKSx0LnNoYWRvd1NpZGUhPT12b2lkIDAmJihpLnNoYWRvd1NpZGU9dC5zaGFkb3dTaWRlKSx0Lm9wYWNpdHkhPT12b2lkIDAmJihpLm9wYWNpdHk9dC5vcGFjaXR5KSx0LnRyYW5zcGFyZW50IT09dm9pZCAwJiYoaS50cmFuc3BhcmVudD10LnRyYW5zcGFyZW50KSx0LmFscGhhVGVzdCE9PXZvaWQgMCYmKGkuYWxwaGFUZXN0PXQuYWxwaGFUZXN0KSx0LmFscGhhSGFzaCE9PXZvaWQgMCYmKGkuYWxwaGFIYXNoPXQuYWxwaGFIYXNoKSx0LmRlcHRoRnVuYyE9PXZvaWQgMCYmKGkuZGVwdGhGdW5jPXQuZGVwdGhGdW5jKSx0LmRlcHRoVGVzdCE9PXZvaWQgMCYmKGkuZGVwdGhUZXN0PXQuZGVwdGhUZXN0KSx0LmRlcHRoV3JpdGUhPT12b2lkIDAmJihpLmRlcHRoV3JpdGU9dC5kZXB0aFdyaXRlKSx0LmNvbG9yV3JpdGUhPT12b2lkIDAmJihpLmNvbG9yV3JpdGU9dC5jb2xvcldyaXRlKSx0LmJsZW5kU3JjIT09dm9pZCAwJiYoaS5ibGVuZFNyYz10LmJsZW5kU3JjKSx0LmJsZW5kRHN0IT09dm9pZCAwJiYoaS5ibGVuZERzdD10LmJsZW5kRHN0KSx0LmJsZW5kRXF1YXRpb24hPT12b2lkIDAmJihpLmJsZW5kRXF1YXRpb249dC5ibGVuZEVxdWF0aW9uKSx0LmJsZW5kU3JjQWxwaGEhPT12b2lkIDAmJihpLmJsZW5kU3JjQWxwaGE9dC5ibGVuZFNyY0FscGhhKSx0LmJsZW5kRHN0QWxwaGEhPT12b2lkIDAmJihpLmJsZW5kRHN0QWxwaGE9dC5ibGVuZERzdEFscGhhKSx0LmJsZW5kRXF1YXRpb25BbHBoYSE9PXZvaWQgMCYmKGkuYmxlbmRFcXVhdGlvbkFscGhhPXQuYmxlbmRFcXVhdGlvbkFscGhhKSx0LmJsZW5kQ29sb3IhPT12b2lkIDAmJmkuYmxlbmRDb2xvciE9PXZvaWQgMCYmaS5ibGVuZENvbG9yLnNldEhleCh0LmJsZW5kQ29sb3IpLHQuYmxlbmRBbHBoYSE9PXZvaWQgMCYmKGkuYmxlbmRBbHBoYT10LmJsZW5kQWxwaGEpLHQuc3RlbmNpbFdyaXRlTWFzayE9PXZvaWQgMCYmKGkuc3RlbmNpbFdyaXRlTWFzaz10LnN0ZW5jaWxXcml0ZU1hc2spLHQuc3RlbmNpbEZ1bmMhPT12b2lkIDAmJihpLnN0ZW5jaWxGdW5jPXQuc3RlbmNpbEZ1bmMpLHQuc3RlbmNpbFJlZiE9PXZvaWQgMCYmKGkuc3RlbmNpbFJlZj10LnN0ZW5jaWxSZWYpLHQuc3RlbmNpbEZ1bmNNYXNrIT09dm9pZCAwJiYoaS5zdGVuY2lsRnVuY01hc2s9dC5zdGVuY2lsRnVuY01hc2spLHQuc3RlbmNpbEZhaWwhPT12b2lkIDAmJihpLnN0ZW5jaWxGYWlsPXQuc3RlbmNpbEZhaWwpLHQuc3RlbmNpbFpGYWlsIT09dm9pZCAwJiYoaS5zdGVuY2lsWkZhaWw9dC5zdGVuY2lsWkZhaWwpLHQuc3RlbmNpbFpQYXNzIT09dm9pZCAwJiYoaS5zdGVuY2lsWlBhc3M9dC5zdGVuY2lsWlBhc3MpLHQuc3RlbmNpbFdyaXRlIT09dm9pZCAwJiYoaS5zdGVuY2lsV3JpdGU9dC5zdGVuY2lsV3JpdGUpLHQud2lyZWZyYW1lIT09dm9pZCAwJiYoaS53aXJlZnJhbWU9dC53aXJlZnJhbWUpLHQud2lyZWZyYW1lTGluZXdpZHRoIT09dm9pZCAwJiYoaS53aXJlZnJhbWVMaW5ld2lkdGg9dC53aXJlZnJhbWVMaW5ld2lkdGgpLHQud2lyZWZyYW1lTGluZWNhcCE9PXZvaWQgMCYmKGkud2lyZWZyYW1lTGluZWNhcD10LndpcmVmcmFtZUxpbmVjYXApLHQud2lyZWZyYW1lTGluZWpvaW4hPT12b2lkIDAmJihpLndpcmVmcmFtZUxpbmVqb2luPXQud2lyZWZyYW1lTGluZWpvaW4pLHQucm90YXRpb24hPT12b2lkIDAmJihpLnJvdGF0aW9uPXQucm90YXRpb24pLHQubGluZXdpZHRoIT09dm9pZCAwJiYoaS5saW5ld2lkdGg9dC5saW5ld2lkdGgpLHQuZGFzaFNpemUhPT12b2lkIDAmJihpLmRhc2hTaXplPXQuZGFzaFNpemUpLHQuZ2FwU2l6ZSE9PXZvaWQgMCYmKGkuZ2FwU2l6ZT10LmdhcFNpemUpLHQuc2NhbGUhPT12b2lkIDAmJihpLnNjYWxlPXQuc2NhbGUpLHQucG9seWdvbk9mZnNldCE9PXZvaWQgMCYmKGkucG9seWdvbk9mZnNldD10LnBvbHlnb25PZmZzZXQpLHQucG9seWdvbk9mZnNldEZhY3RvciE9PXZvaWQgMCYmKGkucG9seWdvbk9mZnNldEZhY3Rvcj10LnBvbHlnb25PZmZzZXRGYWN0b3IpLHQucG9seWdvbk9mZnNldFVuaXRzIT09dm9pZCAwJiYoaS5wb2x5Z29uT2Zmc2V0VW5pdHM9dC5wb2x5Z29uT2Zmc2V0VW5pdHMpLHQuZGl0aGVyaW5nIT09dm9pZCAwJiYoaS5kaXRoZXJpbmc9dC5kaXRoZXJpbmcpLHQuYWxwaGFUb0NvdmVyYWdlIT09dm9pZCAwJiYoaS5hbHBoYVRvQ292ZXJhZ2U9dC5hbHBoYVRvQ292ZXJhZ2UpLHQucHJlbXVsdGlwbGllZEFscGhhIT09dm9pZCAwJiYoaS5wcmVtdWx0aXBsaWVkQWxwaGE9dC5wcmVtdWx0aXBsaWVkQWxwaGEpLHQuZm9yY2VTaW5nbGVQYXNzIT09dm9pZCAwJiYoaS5mb3JjZVNpbmdsZVBhc3M9dC5mb3JjZVNpbmdsZVBhc3MpLHQudmlzaWJsZSE9PXZvaWQgMCYmKGkudmlzaWJsZT10LnZpc2libGUpLHQudG9uZU1hcHBlZCE9PXZvaWQgMCYmKGkudG9uZU1hcHBlZD10LnRvbmVNYXBwZWQpLHQudXNlckRhdGEhPT12b2lkIDAmJihpLnVzZXJEYXRhPXQudXNlckRhdGEpLHQudmVydGV4Q29sb3JzIT09dm9pZCAwJiYodHlwZW9mIHQudmVydGV4Q29sb3JzPT0ibnVtYmVyIj9pLnZlcnRleENvbG9ycz10LnZlcnRleENvbG9ycz4wOmkudmVydGV4Q29sb3JzPXQudmVydGV4Q29sb3JzKSx0LnVuaWZvcm1zIT09dm9pZCAwKWZvcihsZXQgciBpbiB0LnVuaWZvcm1zKXtsZXQgYT10LnVuaWZvcm1zW3JdO3N3aXRjaChpLnVuaWZvcm1zW3JdPXt9LGEudHlwZSl7Y2FzZSJ0IjppLnVuaWZvcm1zW3JdLnZhbHVlPW4oYS52YWx1ZSk7YnJlYWs7Y2FzZSJjIjppLnVuaWZvcm1zW3JdLnZhbHVlPW5ldyB1dCgpLnNldEhleChhLnZhbHVlKTticmVhaztjYXNlInYyIjppLnVuaWZvcm1zW3JdLnZhbHVlPW5ldyBaKCkuZnJvbUFycmF5KGEudmFsdWUpO2JyZWFrO2Nhc2UidjMiOmkudW5pZm9ybXNbcl0udmFsdWU9bmV3IFIoKS5mcm9tQXJyYXkoYS52YWx1ZSk7YnJlYWs7Y2FzZSJ2NCI6aS51bmlmb3Jtc1tyXS52YWx1ZT1uZXcgdGUoKS5mcm9tQXJyYXkoYS52YWx1ZSk7YnJlYWs7Y2FzZSJtMyI6aS51bmlmb3Jtc1tyXS52YWx1ZT1uZXcga3QoKS5mcm9tQXJyYXkoYS52YWx1ZSk7YnJlYWs7Y2FzZSJtNCI6aS51bmlmb3Jtc1tyXS52YWx1ZT1uZXcgTHQoKS5mcm9tQXJyYXkoYS52YWx1ZSk7YnJlYWs7ZGVmYXVsdDppLnVuaWZvcm1zW3JdLnZhbHVlPWEudmFsdWV9fWlmKHQuZGVmaW5lcyE9PXZvaWQgMCYmKGkuZGVmaW5lcz10LmRlZmluZXMpLHQudmVydGV4U2hhZGVyIT09dm9pZCAwJiYoaS52ZXJ0ZXhTaGFkZXI9dC52ZXJ0ZXhTaGFkZXIpLHQuZnJhZ21lbnRTaGFkZXIhPT12b2lkIDAmJihpLmZyYWdtZW50U2hhZGVyPXQuZnJhZ21lbnRTaGFkZXIpLHQuZ2xzbFZlcnNpb24hPT12b2lkIDAmJihpLmdsc2xWZXJzaW9uPXQuZ2xzbFZlcnNpb24pLHQuZXh0ZW5zaW9ucyE9PXZvaWQgMClmb3IobGV0IHIgaW4gdC5leHRlbnNpb25zKWkuZXh0ZW5zaW9uc1tyXT10LmV4dGVuc2lvbnNbcl07aWYodC5saWdodHMhPT12b2lkIDAmJihpLmxpZ2h0cz10LmxpZ2h0cyksdC5jbGlwcGluZyE9PXZvaWQgMCYmKGkuY2xpcHBpbmc9dC5jbGlwcGluZyksdC5zaXplIT09dm9pZCAwJiYoaS5zaXplPXQuc2l6ZSksdC5zaXplQXR0ZW51YXRpb24hPT12b2lkIDAmJihpLnNpemVBdHRlbnVhdGlvbj10LnNpemVBdHRlbnVhdGlvbiksdC5tYXAhPT12b2lkIDAmJihpLm1hcD1uKHQubWFwKSksdC5tYXRjYXAhPT12b2lkIDAmJihpLm1hdGNhcD1uKHQubWF0Y2FwKSksdC5hbHBoYU1hcCE9PXZvaWQgMCYmKGkuYWxwaGFNYXA9bih0LmFscGhhTWFwKSksdC5idW1wTWFwIT09dm9pZCAwJiYoaS5idW1wTWFwPW4odC5idW1wTWFwKSksdC5idW1wU2NhbGUhPT12b2lkIDAmJihpLmJ1bXBTY2FsZT10LmJ1bXBTY2FsZSksdC5ub3JtYWxNYXAhPT12b2lkIDAmJihpLm5vcm1hbE1hcD1uKHQubm9ybWFsTWFwKSksdC5ub3JtYWxNYXBUeXBlIT09dm9pZCAwJiYoaS5ub3JtYWxNYXBUeXBlPXQubm9ybWFsTWFwVHlwZSksdC5ub3JtYWxTY2FsZSE9PXZvaWQgMCl7bGV0IHI9dC5ub3JtYWxTY2FsZTtBcnJheS5pc0FycmF5KHIpPT09ITEmJihyPVtyLHJdKSxpLm5vcm1hbFNjYWxlPW5ldyBaKCkuZnJvbUFycmF5KHIpfXJldHVybiB0LmRpc3BsYWNlbWVudE1hcCE9PXZvaWQgMCYmKGkuZGlzcGxhY2VtZW50TWFwPW4odC5kaXNwbGFjZW1lbnRNYXApKSx0LmRpc3BsYWNlbWVudFNjYWxlIT09dm9pZCAwJiYoaS5kaXNwbGFjZW1lbnRTY2FsZT10LmRpc3BsYWNlbWVudFNjYWxlKSx0LmRpc3BsYWNlbWVudEJpYXMhPT12b2lkIDAmJihpLmRpc3BsYWNlbWVudEJpYXM9dC5kaXNwbGFjZW1lbnRCaWFzKSx0LnJvdWdobmVzc01hcCE9PXZvaWQgMCYmKGkucm91Z2huZXNzTWFwPW4odC5yb3VnaG5lc3NNYXApKSx0Lm1ldGFsbmVzc01hcCE9PXZvaWQgMCYmKGkubWV0YWxuZXNzTWFwPW4odC5tZXRhbG5lc3NNYXApKSx0LmVtaXNzaXZlTWFwIT09dm9pZCAwJiYoaS5lbWlzc2l2ZU1hcD1uKHQuZW1pc3NpdmVNYXApKSx0LmVtaXNzaXZlSW50ZW5zaXR5IT09dm9pZCAwJiYoaS5lbWlzc2l2ZUludGVuc2l0eT10LmVtaXNzaXZlSW50ZW5zaXR5KSx0LnNwZWN1bGFyTWFwIT09dm9pZCAwJiYoaS5zcGVjdWxhck1hcD1uKHQuc3BlY3VsYXJNYXApKSx0LnNwZWN1bGFySW50ZW5zaXR5TWFwIT09dm9pZCAwJiYoaS5zcGVjdWxhckludGVuc2l0eU1hcD1uKHQuc3BlY3VsYXJJbnRlbnNpdHlNYXApKSx0LnNwZWN1bGFyQ29sb3JNYXAhPT12b2lkIDAmJihpLnNwZWN1bGFyQ29sb3JNYXA9bih0LnNwZWN1bGFyQ29sb3JNYXApKSx0LmVudk1hcCE9PXZvaWQgMCYmKGkuZW52TWFwPW4odC5lbnZNYXApKSx0LmVudk1hcEludGVuc2l0eSE9PXZvaWQgMCYmKGkuZW52TWFwSW50ZW5zaXR5PXQuZW52TWFwSW50ZW5zaXR5KSx0LnJlZmxlY3Rpdml0eSE9PXZvaWQgMCYmKGkucmVmbGVjdGl2aXR5PXQucmVmbGVjdGl2aXR5KSx0LnJlZnJhY3Rpb25SYXRpbyE9PXZvaWQgMCYmKGkucmVmcmFjdGlvblJhdGlvPXQucmVmcmFjdGlvblJhdGlvKSx0LmxpZ2h0TWFwIT09dm9pZCAwJiYoaS5saWdodE1hcD1uKHQubGlnaHRNYXApKSx0LmxpZ2h0TWFwSW50ZW5zaXR5IT09dm9pZCAwJiYoaS5saWdodE1hcEludGVuc2l0eT10LmxpZ2h0TWFwSW50ZW5zaXR5KSx0LmFvTWFwIT09dm9pZCAwJiYoaS5hb01hcD1uKHQuYW9NYXApKSx0LmFvTWFwSW50ZW5zaXR5IT09dm9pZCAwJiYoaS5hb01hcEludGVuc2l0eT10LmFvTWFwSW50ZW5zaXR5KSx0LmdyYWRpZW50TWFwIT09dm9pZCAwJiYoaS5ncmFkaWVudE1hcD1uKHQuZ3JhZGllbnRNYXApKSx0LmNsZWFyY29hdE1hcCE9PXZvaWQgMCYmKGkuY2xlYXJjb2F0TWFwPW4odC5jbGVhcmNvYXRNYXApKSx0LmNsZWFyY29hdFJvdWdobmVzc01hcCE9PXZvaWQgMCYmKGkuY2xlYXJjb2F0Um91Z2huZXNzTWFwPW4odC5jbGVhcmNvYXRSb3VnaG5lc3NNYXApKSx0LmNsZWFyY29hdE5vcm1hbE1hcCE9PXZvaWQgMCYmKGkuY2xlYXJjb2F0Tm9ybWFsTWFwPW4odC5jbGVhcmNvYXROb3JtYWxNYXApKSx0LmNsZWFyY29hdE5vcm1hbFNjYWxlIT09dm9pZCAwJiYoaS5jbGVhcmNvYXROb3JtYWxTY2FsZT1uZXcgWigpLmZyb21BcnJheSh0LmNsZWFyY29hdE5vcm1hbFNjYWxlKSksdC5pcmlkZXNjZW5jZU1hcCE9PXZvaWQgMCYmKGkuaXJpZGVzY2VuY2VNYXA9bih0LmlyaWRlc2NlbmNlTWFwKSksdC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCE9PXZvaWQgMCYmKGkuaXJpZGVzY2VuY2VUaGlja25lc3NNYXA9bih0LmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwKSksdC50cmFuc21pc3Npb25NYXAhPT12b2lkIDAmJihpLnRyYW5zbWlzc2lvbk1hcD1uKHQudHJhbnNtaXNzaW9uTWFwKSksdC50aGlja25lc3NNYXAhPT12b2lkIDAmJihpLnRoaWNrbmVzc01hcD1uKHQudGhpY2tuZXNzTWFwKSksdC5hbmlzb3Ryb3B5TWFwIT09dm9pZCAwJiYoaS5hbmlzb3Ryb3B5TWFwPW4odC5hbmlzb3Ryb3B5TWFwKSksdC5zaGVlbkNvbG9yTWFwIT09dm9pZCAwJiYoaS5zaGVlbkNvbG9yTWFwPW4odC5zaGVlbkNvbG9yTWFwKSksdC5zaGVlblJvdWdobmVzc01hcCE9PXZvaWQgMCYmKGkuc2hlZW5Sb3VnaG5lc3NNYXA9bih0LnNoZWVuUm91Z2huZXNzTWFwKSksaX1zZXRUZXh0dXJlcyh0KXtyZXR1cm4gdGhpcy50ZXh0dXJlcz10LHRoaXN9c3RhdGljIGNyZWF0ZU1hdGVyaWFsRnJvbVR5cGUodCl7bGV0IGU9e1NoYWRvd01hdGVyaWFsOlRvLFNwcml0ZU1hdGVyaWFsOm1yLFJhd1NoYWRlck1hdGVyaWFsOndvLFNoYWRlck1hdGVyaWFsOkplLFBvaW50c01hdGVyaWFsOl9yLE1lc2hQaHlzaWNhbE1hdGVyaWFsOlJvLE1lc2hTdGFuZGFyZE1hdGVyaWFsOkNyLE1lc2hQaG9uZ01hdGVyaWFsOkNvLE1lc2hUb29uTWF0ZXJpYWw6UG8sTWVzaE5vcm1hbE1hdGVyaWFsOkxvLE1lc2hMYW1iZXJ0TWF0ZXJpYWw6SW8sTWVzaERlcHRoTWF0ZXJpYWw6ZnIsTWVzaERpc3RhbmNlTWF0ZXJpYWw6cHIsTWVzaEJhc2ljTWF0ZXJpYWw6eG4sTWVzaE1hdGNhcE1hdGVyaWFsOlVvLExpbmVEYXNoZWRNYXRlcmlhbDpEbyxMaW5lQmFzaWNNYXRlcmlhbDpSZSxNYXRlcmlhbDpBZX07cmV0dXJuIG5ldyBlW3RdfX0sRHI9Y2xhc3N7c3RhdGljIGRlY29kZVRleHQodCl7aWYodHlwZW9mIFRleHREZWNvZGVyPCJ1IilyZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHQpO2xldCBlPSIiO2ZvcihsZXQgbj0wLGk9dC5sZW5ndGg7bjxpO24rKyllKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHRbbl0pO3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShlKSl9Y2F0Y2h7cmV0dXJuIGV9fXN0YXRpYyBleHRyYWN0VXJsQmFzZSh0KXtsZXQgZT10Lmxhc3RJbmRleE9mKCIvIik7cmV0dXJuIGU9PT0tMT8iLi8iOnQuc2xpY2UoMCxlKzEpfXN0YXRpYyByZXNvbHZlVVJMKHQsZSl7cmV0dXJuIHR5cGVvZiB0IT0ic3RyaW5nInx8dD09PSIiPyIiOigvXmh0dHBzPzpcL1wvL2kudGVzdChlKSYmL15cLy8udGVzdCh0KSYmKGU9ZS5yZXBsYWNlKC8oXmh0dHBzPzpcL1wvW15cL10rKS4qL2ksIiQxIikpLC9eKGh0dHBzPzopP1wvXC8vaS50ZXN0KHQpfHwvXmRhdGE6LiosLiokL2kudGVzdCh0KXx8L15ibG9iOi4qJC9pLnRlc3QodCk/dDplK3QpfX0sWW89Y2xhc3MgZXh0ZW5kcyBIdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5PSEwLHRoaXMudHlwZT0iSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkiLHRoaXMuaW5zdGFuY2VDb3VudD0xLzB9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLmluc3RhbmNlQ291bnQ9dC5pbnN0YW5jZUNvdW50LHRoaXN9dG9KU09OKCl7bGV0IHQ9c3VwZXIudG9KU09OKCk7cmV0dXJuIHQuaW5zdGFuY2VDb3VudD10aGlzLmluc3RhbmNlQ291bnQsdC5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5PSEwLHR9fSxabz1jbGFzcyBleHRlbmRzIE5le2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpfWxvYWQodCxlLG4saSl7bGV0IHI9dGhpcyxhPW5ldyBjbihyLm1hbmFnZXIpO2Euc2V0UGF0aChyLnBhdGgpLGEuc2V0UmVxdWVzdEhlYWRlcihyLnJlcXVlc3RIZWFkZXIpLGEuc2V0V2l0aENyZWRlbnRpYWxzKHIud2l0aENyZWRlbnRpYWxzKSxhLmxvYWQodCxmdW5jdGlvbihvKXt0cnl7ZShyLnBhcnNlKEpTT04ucGFyc2UobykpKX1jYXRjaChsKXtpP2kobCk6Y29uc29sZS5lcnJvcihsKSxyLm1hbmFnZXIuaXRlbUVycm9yKHQpfX0sbixpKX1wYXJzZSh0KXtsZXQgZT17fSxuPXt9O2Z1bmN0aW9uIGkoZixtKXtpZihlW21dIT09dm9pZCAwKXJldHVybiBlW21dO2xldCBnPWYuaW50ZXJsZWF2ZWRCdWZmZXJzW21dLHA9cihmLGcuYnVmZmVyKSx2PWxzKGcudHlwZSxwKSx4PW5ldyBTcyh2LGcuc3RyaWRlKTtyZXR1cm4geC51dWlkPWcudXVpZCxlW21dPXgseH1mdW5jdGlvbiByKGYsbSl7aWYoblttXSE9PXZvaWQgMClyZXR1cm4gblttXTtsZXQgZz1mLmFycmF5QnVmZmVyc1ttXSxwPW5ldyBVaW50MzJBcnJheShnKS5idWZmZXI7cmV0dXJuIG5bbV09cCxwfWxldCBhPXQuaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeT9uZXcgWW86bmV3IEh0LG89dC5kYXRhLmluZGV4O2lmKG8hPT12b2lkIDApe2xldCBmPWxzKG8udHlwZSxvLmFycmF5KTthLnNldEluZGV4KG5ldyBadChmLDEpKX1sZXQgbD10LmRhdGEuYXR0cmlidXRlcztmb3IobGV0IGYgaW4gbCl7bGV0IG09bFtmXSxfO2lmKG0uaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSl7bGV0IGc9aSh0LmRhdGEsbS5kYXRhKTtfPW5ldyBVaShnLG0uaXRlbVNpemUsbS5vZmZzZXQsbS5ub3JtYWxpemVkKX1lbHNle2xldCBnPWxzKG0udHlwZSxtLmFycmF5KSxwPW0uaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU/aWk6WnQ7Xz1uZXcgcChnLG0uaXRlbVNpemUsbS5ub3JtYWxpemVkKX1tLm5hbWUhPT12b2lkIDAmJihfLm5hbWU9bS5uYW1lKSxtLnVzYWdlIT09dm9pZCAwJiZfLnNldFVzYWdlKG0udXNhZ2UpLGEuc2V0QXR0cmlidXRlKGYsXyl9bGV0IGM9dC5kYXRhLm1vcnBoQXR0cmlidXRlcztpZihjKWZvcihsZXQgZiBpbiBjKXtsZXQgbT1jW2ZdLF89W107Zm9yKGxldCBnPTAscD1tLmxlbmd0aDtnPHA7ZysrKXtsZXQgdj1tW2ddLHg7aWYodi5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKXtsZXQgTT1pKHQuZGF0YSx2LmRhdGEpO3g9bmV3IFVpKE0sdi5pdGVtU2l6ZSx2Lm9mZnNldCx2Lm5vcm1hbGl6ZWQpfWVsc2V7bGV0IE09bHModi50eXBlLHYuYXJyYXkpO3g9bmV3IFp0KE0sdi5pdGVtU2l6ZSx2Lm5vcm1hbGl6ZWQpfXYubmFtZSE9PXZvaWQgMCYmKHgubmFtZT12Lm5hbWUpLF8ucHVzaCh4KX1hLm1vcnBoQXR0cmlidXRlc1tmXT1ffXQuZGF0YS5tb3JwaFRhcmdldHNSZWxhdGl2ZSYmKGEubW9ycGhUYXJnZXRzUmVsYXRpdmU9ITApO2xldCB1PXQuZGF0YS5ncm91cHN8fHQuZGF0YS5kcmF3Y2FsbHN8fHQuZGF0YS5vZmZzZXRzO2lmKHUhPT12b2lkIDApZm9yKGxldCBmPTAsbT11Lmxlbmd0aDtmIT09bTsrK2Ype2xldCBfPXVbZl07YS5hZGRHcm91cChfLnN0YXJ0LF8uY291bnQsXy5tYXRlcmlhbEluZGV4KX1sZXQgZD10LmRhdGEuYm91bmRpbmdTcGhlcmU7aWYoZCE9PXZvaWQgMCl7bGV0IGY9bmV3IFI7ZC5jZW50ZXIhPT12b2lkIDAmJmYuZnJvbUFycmF5KGQuY2VudGVyKSxhLmJvdW5kaW5nU3BoZXJlPW5ldyBFZShmLGQucmFkaXVzKX1yZXR1cm4gdC5uYW1lJiYoYS5uYW1lPXQubmFtZSksdC51c2VyRGF0YSYmKGEudXNlckRhdGE9dC51c2VyRGF0YSksYX19LHVoPWNsYXNzIGV4dGVuZHMgTmV7Y29uc3RydWN0b3IodCl7c3VwZXIodCl9bG9hZCh0LGUsbixpKXtsZXQgcj10aGlzLGE9dGhpcy5wYXRoPT09IiI/RHIuZXh0cmFjdFVybEJhc2UodCk6dGhpcy5wYXRoO3RoaXMucmVzb3VyY2VQYXRoPXRoaXMucmVzb3VyY2VQYXRofHxhO2xldCBvPW5ldyBjbih0aGlzLm1hbmFnZXIpO28uc2V0UGF0aCh0aGlzLnBhdGgpLG8uc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpLG8uc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKSxvLmxvYWQodCxmdW5jdGlvbihsKXtsZXQgYz1udWxsO3RyeXtjPUpTT04ucGFyc2UobCl9Y2F0Y2godSl7aSE9PXZvaWQgMCYmaSh1KSxjb25zb2xlLmVycm9yKCJUSFJFRTpPYmplY3RMb2FkZXI6IENhbid0IHBhcnNlICIrdCsiLiIsdS5tZXNzYWdlKTtyZXR1cm59bGV0IGg9Yy5tZXRhZGF0YTtpZihoPT09dm9pZCAwfHxoLnR5cGU9PT12b2lkIDB8fGgudHlwZS50b0xvd2VyQ2FzZSgpPT09Imdlb21ldHJ5Iil7aSE9PXZvaWQgMCYmaShuZXcgRXJyb3IoIlRIUkVFLk9iamVjdExvYWRlcjogQ2FuJ3QgbG9hZCAiK3QpKSxjb25zb2xlLmVycm9yKCJUSFJFRS5PYmplY3RMb2FkZXI6IENhbid0IGxvYWQgIit0KTtyZXR1cm59ci5wYXJzZShjLGUpfSxuLGkpfWFzeW5jIGxvYWRBc3luYyh0LGUpe2xldCBuPXRoaXMsaT10aGlzLnBhdGg9PT0iIj9Eci5leHRyYWN0VXJsQmFzZSh0KTp0aGlzLnBhdGg7dGhpcy5yZXNvdXJjZVBhdGg9dGhpcy5yZXNvdXJjZVBhdGh8fGk7bGV0IHI9bmV3IGNuKHRoaXMubWFuYWdlcik7ci5zZXRQYXRoKHRoaXMucGF0aCksci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlciksci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO2xldCBhPWF3YWl0IHIubG9hZEFzeW5jKHQsZSksbz1KU09OLnBhcnNlKGEpLGw9by5tZXRhZGF0YTtpZihsPT09dm9pZCAwfHxsLnR5cGU9PT12b2lkIDB8fGwudHlwZS50b0xvd2VyQ2FzZSgpPT09Imdlb21ldHJ5Iil0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLk9iamVjdExvYWRlcjogQ2FuJ3QgbG9hZCAiK3QpO3JldHVybiBhd2FpdCBuLnBhcnNlQXN5bmMobyl9cGFyc2UodCxlKXtsZXQgbj10aGlzLnBhcnNlQW5pbWF0aW9ucyh0LmFuaW1hdGlvbnMpLGk9dGhpcy5wYXJzZVNoYXBlcyh0LnNoYXBlcykscj10aGlzLnBhcnNlR2VvbWV0cmllcyh0Lmdlb21ldHJpZXMsaSksYT10aGlzLnBhcnNlSW1hZ2VzKHQuaW1hZ2VzLGZ1bmN0aW9uKCl7ZSE9PXZvaWQgMCYmZShjKX0pLG89dGhpcy5wYXJzZVRleHR1cmVzKHQudGV4dHVyZXMsYSksbD10aGlzLnBhcnNlTWF0ZXJpYWxzKHQubWF0ZXJpYWxzLG8pLGM9dGhpcy5wYXJzZU9iamVjdCh0Lm9iamVjdCxyLGwsbyxuKSxoPXRoaXMucGFyc2VTa2VsZXRvbnModC5za2VsZXRvbnMsYyk7aWYodGhpcy5iaW5kU2tlbGV0b25zKGMsaCksZSE9PXZvaWQgMCl7bGV0IHU9ITE7Zm9yKGxldCBkIGluIGEpaWYoYVtkXS5kYXRhIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCl7dT0hMDticmVha311PT09ITEmJmUoYyl9cmV0dXJuIGN9YXN5bmMgcGFyc2VBc3luYyh0KXtsZXQgZT10aGlzLnBhcnNlQW5pbWF0aW9ucyh0LmFuaW1hdGlvbnMpLG49dGhpcy5wYXJzZVNoYXBlcyh0LnNoYXBlcyksaT10aGlzLnBhcnNlR2VvbWV0cmllcyh0Lmdlb21ldHJpZXMsbikscj1hd2FpdCB0aGlzLnBhcnNlSW1hZ2VzQXN5bmModC5pbWFnZXMpLGE9dGhpcy5wYXJzZVRleHR1cmVzKHQudGV4dHVyZXMsciksbz10aGlzLnBhcnNlTWF0ZXJpYWxzKHQubWF0ZXJpYWxzLGEpLGw9dGhpcy5wYXJzZU9iamVjdCh0Lm9iamVjdCxpLG8sYSxlKSxjPXRoaXMucGFyc2VTa2VsZXRvbnModC5za2VsZXRvbnMsbCk7cmV0dXJuIHRoaXMuYmluZFNrZWxldG9ucyhsLGMpLGx9cGFyc2VTaGFwZXModCl7bGV0IGU9e307aWYodCE9PXZvaWQgMClmb3IobGV0IG49MCxpPXQubGVuZ3RoO248aTtuKyspe2xldCByPW5ldyBGbigpLmZyb21KU09OKHRbbl0pO2Vbci51dWlkXT1yfXJldHVybiBlfXBhcnNlU2tlbGV0b25zKHQsZSl7bGV0IG49e30saT17fTtpZihlLnRyYXZlcnNlKGZ1bmN0aW9uKHIpe3IuaXNCb25lJiYoaVtyLnV1aWRdPXIpfSksdCE9PXZvaWQgMClmb3IobGV0IHI9MCxhPXQubGVuZ3RoO3I8YTtyKyspe2xldCBvPW5ldyB0bygpLmZyb21KU09OKHRbcl0saSk7bltvLnV1aWRdPW99cmV0dXJuIG59cGFyc2VHZW9tZXRyaWVzKHQsZSl7bGV0IG49e307aWYodCE9PXZvaWQgMCl7bGV0IGk9bmV3IFpvO2ZvcihsZXQgcj0wLGE9dC5sZW5ndGg7cjxhO3IrKyl7bGV0IG8sbD10W3JdO3N3aXRjaChsLnR5cGUpe2Nhc2UiQnVmZmVyR2VvbWV0cnkiOmNhc2UiSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkiOm89aS5wYXJzZShsKTticmVhaztkZWZhdWx0OmwudHlwZSBpbiBBZD9vPUFkW2wudHlwZV0uZnJvbUpTT04obCxlKTpjb25zb2xlLndhcm4oYFRIUkVFLk9iamVjdExvYWRlcjogVW5zdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZSAiJHtsLnR5cGV9ImApfW8udXVpZD1sLnV1aWQsbC5uYW1lIT09dm9pZCAwJiYoby5uYW1lPWwubmFtZSksbC51c2VyRGF0YSE9PXZvaWQgMCYmKG8udXNlckRhdGE9bC51c2VyRGF0YSksbltsLnV1aWRdPW99fXJldHVybiBufXBhcnNlTWF0ZXJpYWxzKHQsZSl7bGV0IG49e30saT17fTtpZih0IT09dm9pZCAwKXtsZXQgcj1uZXcgcW87ci5zZXRUZXh0dXJlcyhlKTtmb3IobGV0IGE9MCxvPXQubGVuZ3RoO2E8bzthKyspe2xldCBsPXRbYV07bltsLnV1aWRdPT09dm9pZCAwJiYobltsLnV1aWRdPXIucGFyc2UobCkpLGlbbC51dWlkXT1uW2wudXVpZF19fXJldHVybiBpfXBhcnNlQW5pbWF0aW9ucyh0KXtsZXQgZT17fTtpZih0IT09dm9pZCAwKWZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKXtsZXQgaT10W25dLHI9emkucGFyc2UoaSk7ZVtyLnV1aWRdPXJ9cmV0dXJuIGV9cGFyc2VJbWFnZXModCxlKXtsZXQgbj10aGlzLGk9e30scjtmdW5jdGlvbiBhKGwpe3JldHVybiBuLm1hbmFnZXIuaXRlbVN0YXJ0KGwpLHIubG9hZChsLGZ1bmN0aW9uKCl7bi5tYW5hZ2VyLml0ZW1FbmQobCl9LHZvaWQgMCxmdW5jdGlvbigpe24ubWFuYWdlci5pdGVtRXJyb3IobCksbi5tYW5hZ2VyLml0ZW1FbmQobCl9KX1mdW5jdGlvbiBvKGwpe2lmKHR5cGVvZiBsPT0ic3RyaW5nIil7bGV0IGM9bCxoPS9eKFwvXC8pfChbYS16XSs6KFwvXC8pPykvaS50ZXN0KGMpP2M6bi5yZXNvdXJjZVBhdGgrYztyZXR1cm4gYShoKX1lbHNlIHJldHVybiBsLmRhdGE/e2RhdGE6bHMobC50eXBlLGwuZGF0YSksd2lkdGg6bC53aWR0aCxoZWlnaHQ6bC5oZWlnaHR9Om51bGx9aWYodCE9PXZvaWQgMCYmdC5sZW5ndGg+MCl7bGV0IGw9bmV3IElyKGUpO3I9bmV3IFZpKGwpLHIuc2V0Q3Jvc3NPcmlnaW4odGhpcy5jcm9zc09yaWdpbik7Zm9yKGxldCBjPTAsaD10Lmxlbmd0aDtjPGg7YysrKXtsZXQgdT10W2NdLGQ9dS51cmw7aWYoQXJyYXkuaXNBcnJheShkKSl7bGV0IGY9W107Zm9yKGxldCBtPTAsXz1kLmxlbmd0aDttPF87bSsrKXtsZXQgZz1kW21dLHA9byhnKTtwIT09bnVsbCYmKHAgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50P2YucHVzaChwKTpmLnB1c2gobmV3IE9uKHAuZGF0YSxwLndpZHRoLHAuaGVpZ2h0KSkpfWlbdS51dWlkXT1uZXcgUG4oZil9ZWxzZXtsZXQgZj1vKHUudXJsKTtpW3UudXVpZF09bmV3IFBuKGYpfX19cmV0dXJuIGl9YXN5bmMgcGFyc2VJbWFnZXNBc3luYyh0KXtsZXQgZT10aGlzLG49e30saTthc3luYyBmdW5jdGlvbiByKGEpe2lmKHR5cGVvZiBhPT0ic3RyaW5nIil7bGV0IG89YSxsPS9eKFwvXC8pfChbYS16XSs6KFwvXC8pPykvaS50ZXN0KG8pP286ZS5yZXNvdXJjZVBhdGgrbztyZXR1cm4gYXdhaXQgaS5sb2FkQXN5bmMobCl9ZWxzZSByZXR1cm4gYS5kYXRhP3tkYXRhOmxzKGEudHlwZSxhLmRhdGEpLHdpZHRoOmEud2lkdGgsaGVpZ2h0OmEuaGVpZ2h0fTpudWxsfWlmKHQhPT12b2lkIDAmJnQubGVuZ3RoPjApe2k9bmV3IFZpKHRoaXMubWFuYWdlciksaS5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKTtmb3IobGV0IGE9MCxvPXQubGVuZ3RoO2E8bzthKyspe2xldCBsPXRbYV0sYz1sLnVybDtpZihBcnJheS5pc0FycmF5KGMpKXtsZXQgaD1bXTtmb3IobGV0IHU9MCxkPWMubGVuZ3RoO3U8ZDt1Kyspe2xldCBmPWNbdV0sbT1hd2FpdCByKGYpO20hPT1udWxsJiYobSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQ/aC5wdXNoKG0pOmgucHVzaChuZXcgT24obS5kYXRhLG0ud2lkdGgsbS5oZWlnaHQpKSl9bltsLnV1aWRdPW5ldyBQbihoKX1lbHNle2xldCBoPWF3YWl0IHIobC51cmwpO25bbC51dWlkXT1uZXcgUG4oaCl9fX1yZXR1cm4gbn1wYXJzZVRleHR1cmVzKHQsZSl7ZnVuY3Rpb24gbihyLGEpe3JldHVybiB0eXBlb2Ygcj09Im51bWJlciI/cjooY29uc29sZS53YXJuKCJUSFJFRS5PYmplY3RMb2FkZXIucGFyc2VUZXh0dXJlOiBDb25zdGFudCBzaG91bGQgYmUgaW4gbnVtZXJpYyBmb3JtLiIsciksYVtyXSl9bGV0IGk9e307aWYodCE9PXZvaWQgMClmb3IobGV0IHI9MCxhPXQubGVuZ3RoO3I8YTtyKyspe2xldCBvPXRbcl07by5pbWFnZT09PXZvaWQgMCYmY29uc29sZS53YXJuKCdUSFJFRS5PYmplY3RMb2FkZXI6IE5vICJpbWFnZSIgc3BlY2lmaWVkIGZvcicsby51dWlkKSxlW28uaW1hZ2VdPT09dm9pZCAwJiZjb25zb2xlLndhcm4oIlRIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIGltYWdlIixvLmltYWdlKTtsZXQgbD1lW28uaW1hZ2VdLGM9bC5kYXRhLGg7QXJyYXkuaXNBcnJheShjKT8oaD1uZXcgTGksYy5sZW5ndGg9PT02JiYoaC5uZWVkc1VwZGF0ZT0hMCkpOihjJiZjLmRhdGE/aD1uZXcgT246aD1uZXcgX2UsYyYmKGgubmVlZHNVcGRhdGU9ITApKSxoLnNvdXJjZT1sLGgudXVpZD1vLnV1aWQsby5uYW1lIT09dm9pZCAwJiYoaC5uYW1lPW8ubmFtZSksby5tYXBwaW5nIT09dm9pZCAwJiYoaC5tYXBwaW5nPW4oby5tYXBwaW5nLGp2KSksby5jaGFubmVsIT09dm9pZCAwJiYoaC5jaGFubmVsPW8uY2hhbm5lbCksby5vZmZzZXQhPT12b2lkIDAmJmgub2Zmc2V0LmZyb21BcnJheShvLm9mZnNldCksby5yZXBlYXQhPT12b2lkIDAmJmgucmVwZWF0LmZyb21BcnJheShvLnJlcGVhdCksby5jZW50ZXIhPT12b2lkIDAmJmguY2VudGVyLmZyb21BcnJheShvLmNlbnRlciksby5yb3RhdGlvbiE9PXZvaWQgMCYmKGgucm90YXRpb249by5yb3RhdGlvbiksby53cmFwIT09dm9pZCAwJiYoaC53cmFwUz1uKG8ud3JhcFswXSxDZCksaC53cmFwVD1uKG8ud3JhcFsxXSxDZCkpLG8uZm9ybWF0IT09dm9pZCAwJiYoaC5mb3JtYXQ9by5mb3JtYXQpLG8uaW50ZXJuYWxGb3JtYXQhPT12b2lkIDAmJihoLmludGVybmFsRm9ybWF0PW8uaW50ZXJuYWxGb3JtYXQpLG8udHlwZSE9PXZvaWQgMCYmKGgudHlwZT1vLnR5cGUpLG8uY29sb3JTcGFjZSE9PXZvaWQgMCYmKGguY29sb3JTcGFjZT1vLmNvbG9yU3BhY2UpLG8uZW5jb2RpbmchPT12b2lkIDAmJihoLmVuY29kaW5nPW8uZW5jb2RpbmcpLG8ubWluRmlsdGVyIT09dm9pZCAwJiYoaC5taW5GaWx0ZXI9bihvLm1pbkZpbHRlcixQZCkpLG8ubWFnRmlsdGVyIT09dm9pZCAwJiYoaC5tYWdGaWx0ZXI9bihvLm1hZ0ZpbHRlcixQZCkpLG8uYW5pc290cm9weSE9PXZvaWQgMCYmKGguYW5pc290cm9weT1vLmFuaXNvdHJvcHkpLG8uZmxpcFkhPT12b2lkIDAmJihoLmZsaXBZPW8uZmxpcFkpLG8uZ2VuZXJhdGVNaXBtYXBzIT09dm9pZCAwJiYoaC5nZW5lcmF0ZU1pcG1hcHM9by5nZW5lcmF0ZU1pcG1hcHMpLG8ucHJlbXVsdGlwbHlBbHBoYSE9PXZvaWQgMCYmKGgucHJlbXVsdGlwbHlBbHBoYT1vLnByZW11bHRpcGx5QWxwaGEpLG8udW5wYWNrQWxpZ25tZW50IT09dm9pZCAwJiYoaC51bnBhY2tBbGlnbm1lbnQ9by51bnBhY2tBbGlnbm1lbnQpLG8uY29tcGFyZUZ1bmN0aW9uIT09dm9pZCAwJiYoaC5jb21wYXJlRnVuY3Rpb249by5jb21wYXJlRnVuY3Rpb24pLG8udXNlckRhdGEhPT12b2lkIDAmJihoLnVzZXJEYXRhPW8udXNlckRhdGEpLGlbby51dWlkXT1ofXJldHVybiBpfXBhcnNlT2JqZWN0KHQsZSxuLGkscil7bGV0IGE7ZnVuY3Rpb24gbyhkKXtyZXR1cm4gZVtkXT09PXZvaWQgMCYmY29uc29sZS53YXJuKCJUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBnZW9tZXRyeSIsZCksZVtkXX1mdW5jdGlvbiBsKGQpe2lmKGQhPT12b2lkIDApe2lmKEFycmF5LmlzQXJyYXkoZCkpe2xldCBmPVtdO2ZvcihsZXQgbT0wLF89ZC5sZW5ndGg7bTxfO20rKyl7bGV0IGc9ZFttXTtuW2ddPT09dm9pZCAwJiZjb25zb2xlLndhcm4oIlRIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIG1hdGVyaWFsIixnKSxmLnB1c2gobltnXSl9cmV0dXJuIGZ9cmV0dXJuIG5bZF09PT12b2lkIDAmJmNvbnNvbGUud2FybigiVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgbWF0ZXJpYWwiLGQpLG5bZF19fWZ1bmN0aW9uIGMoZCl7cmV0dXJuIGlbZF09PT12b2lkIDAmJmNvbnNvbGUud2FybigiVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgdGV4dHVyZSIsZCksaVtkXX1sZXQgaCx1O3N3aXRjaCh0LnR5cGUpe2Nhc2UiU2NlbmUiOmE9bmV3ICRhLHQuYmFja2dyb3VuZCE9PXZvaWQgMCYmKE51bWJlci5pc0ludGVnZXIodC5iYWNrZ3JvdW5kKT9hLmJhY2tncm91bmQ9bmV3IHV0KHQuYmFja2dyb3VuZCk6YS5iYWNrZ3JvdW5kPWModC5iYWNrZ3JvdW5kKSksdC5lbnZpcm9ubWVudCE9PXZvaWQgMCYmKGEuZW52aXJvbm1lbnQ9Yyh0LmVudmlyb25tZW50KSksdC5mb2chPT12b2lkIDAmJih0LmZvZy50eXBlPT09IkZvZyI/YS5mb2c9bmV3IEphKHQuZm9nLmNvbG9yLHQuZm9nLm5lYXIsdC5mb2cuZmFyKTp0LmZvZy50eXBlPT09IkZvZ0V4cDIiJiYoYS5mb2c9bmV3IFphKHQuZm9nLmNvbG9yLHQuZm9nLmRlbnNpdHkpKSx0LmZvZy5uYW1lIT09IiImJihhLmZvZy5uYW1lPXQuZm9nLm5hbWUpKSx0LmJhY2tncm91bmRCbHVycmluZXNzIT09dm9pZCAwJiYoYS5iYWNrZ3JvdW5kQmx1cnJpbmVzcz10LmJhY2tncm91bmRCbHVycmluZXNzKSx0LmJhY2tncm91bmRJbnRlbnNpdHkhPT12b2lkIDAmJihhLmJhY2tncm91bmRJbnRlbnNpdHk9dC5iYWNrZ3JvdW5kSW50ZW5zaXR5KTticmVhaztjYXNlIlBlcnNwZWN0aXZlQ2FtZXJhIjphPW5ldyB2ZSh0LmZvdix0LmFzcGVjdCx0Lm5lYXIsdC5mYXIpLHQuZm9jdXMhPT12b2lkIDAmJihhLmZvY3VzPXQuZm9jdXMpLHQuem9vbSE9PXZvaWQgMCYmKGEuem9vbT10Lnpvb20pLHQuZmlsbUdhdWdlIT09dm9pZCAwJiYoYS5maWxtR2F1Z2U9dC5maWxtR2F1Z2UpLHQuZmlsbU9mZnNldCE9PXZvaWQgMCYmKGEuZmlsbU9mZnNldD10LmZpbG1PZmZzZXQpLHQudmlldyE9PXZvaWQgMCYmKGEudmlldz1PYmplY3QuYXNzaWduKHt9LHQudmlldykpO2JyZWFrO2Nhc2UiT3J0aG9ncmFwaGljQ2FtZXJhIjphPW5ldyBNcyh0LmxlZnQsdC5yaWdodCx0LnRvcCx0LmJvdHRvbSx0Lm5lYXIsdC5mYXIpLHQuem9vbSE9PXZvaWQgMCYmKGEuem9vbT10Lnpvb20pLHQudmlldyE9PXZvaWQgMCYmKGEudmlldz1PYmplY3QuYXNzaWduKHt9LHQudmlldykpO2JyZWFrO2Nhc2UiQW1iaWVudExpZ2h0IjphPW5ldyBIbyh0LmNvbG9yLHQuaW50ZW5zaXR5KTticmVhaztjYXNlIkRpcmVjdGlvbmFsTGlnaHQiOmE9bmV3IGtvKHQuY29sb3IsdC5pbnRlbnNpdHkpO2JyZWFrO2Nhc2UiUG9pbnRMaWdodCI6YT1uZXcgVm8odC5jb2xvcix0LmludGVuc2l0eSx0LmRpc3RhbmNlLHQuZGVjYXkpO2JyZWFrO2Nhc2UiUmVjdEFyZWFMaWdodCI6YT1uZXcgR28odC5jb2xvcix0LmludGVuc2l0eSx0LndpZHRoLHQuaGVpZ2h0KTticmVhaztjYXNlIlNwb3RMaWdodCI6YT1uZXcgem8odC5jb2xvcix0LmludGVuc2l0eSx0LmRpc3RhbmNlLHQuYW5nbGUsdC5wZW51bWJyYSx0LmRlY2F5KTticmVhaztjYXNlIkhlbWlzcGhlcmVMaWdodCI6YT1uZXcgQm8odC5jb2xvcix0Lmdyb3VuZENvbG9yLHQuaW50ZW5zaXR5KTticmVhaztjYXNlIkxpZ2h0UHJvYmUiOmE9bmV3IFhvKCkuZnJvbUpTT04odCk7YnJlYWs7Y2FzZSJTa2lubmVkTWVzaCI6aD1vKHQuZ2VvbWV0cnkpLHU9bCh0Lm1hdGVyaWFsKSxhPW5ldyBqYShoLHUpLHQuYmluZE1vZGUhPT12b2lkIDAmJihhLmJpbmRNb2RlPXQuYmluZE1vZGUpLHQuYmluZE1hdHJpeCE9PXZvaWQgMCYmYS5iaW5kTWF0cml4LmZyb21BcnJheSh0LmJpbmRNYXRyaXgpLHQuc2tlbGV0b24hPT12b2lkIDAmJihhLnNrZWxldG9uPXQuc2tlbGV0b24pO2JyZWFrO2Nhc2UiTWVzaCI6aD1vKHQuZ2VvbWV0cnkpLHU9bCh0Lm1hdGVyaWFsKSxhPW5ldyBkZShoLHUpO2JyZWFrO2Nhc2UiSW5zdGFuY2VkTWVzaCI6aD1vKHQuZ2VvbWV0cnkpLHU9bCh0Lm1hdGVyaWFsKTtsZXQgZD10LmNvdW50LGY9dC5pbnN0YW5jZU1hdHJpeCxtPXQuaW5zdGFuY2VDb2xvcjthPW5ldyBlbyhoLHUsZCksYS5pbnN0YW5jZU1hdHJpeD1uZXcgaWkobmV3IEZsb2F0MzJBcnJheShmLmFycmF5KSwxNiksbSE9PXZvaWQgMCYmKGEuaW5zdGFuY2VDb2xvcj1uZXcgaWkobmV3IEZsb2F0MzJBcnJheShtLmFycmF5KSxtLml0ZW1TaXplKSk7YnJlYWs7Y2FzZSJCYXRjaGVkTWVzaCI6aD1vKHQuZ2VvbWV0cnkpLHU9bCh0Lm1hdGVyaWFsKSxhPW5ldyBubyh0Lm1heEdlb21ldHJ5Q291bnQsdC5tYXhWZXJ0ZXhDb3VudCx0Lm1heEluZGV4Q291bnQsdSksYS5nZW9tZXRyeT1oLGEucGVyT2JqZWN0RnJ1c3R1bUN1bGxlZD10LnBlck9iamVjdEZydXN0dW1DdWxsZWQsYS5zb3J0T2JqZWN0cz10LnNvcnRPYmplY3RzLGEuX2RyYXdSYW5nZXM9dC5kcmF3UmFuZ2VzLGEuX3Jlc2VydmVkUmFuZ2VzPXQucmVzZXJ2ZWRSYW5nZXMsYS5fdmlzaWJpbGl0eT10LnZpc2liaWxpdHksYS5fYWN0aXZlPXQuYWN0aXZlLGEuX2JvdW5kcz10LmJvdW5kcy5tYXAoXz0+e2xldCBnPW5ldyB3ZTtnLm1pbi5mcm9tQXJyYXkoXy5ib3hNaW4pLGcubWF4LmZyb21BcnJheShfLmJveE1heCk7bGV0IHA9bmV3IEVlO3JldHVybiBwLnJhZGl1cz1fLnNwaGVyZVJhZGl1cyxwLmNlbnRlci5mcm9tQXJyYXkoXy5zcGhlcmVDZW50ZXIpLHtib3hJbml0aWFsaXplZDpfLmJveEluaXRpYWxpemVkLGJveDpnLHNwaGVyZUluaXRpYWxpemVkOl8uc3BoZXJlSW5pdGlhbGl6ZWQsc3BoZXJlOnB9fSksYS5fbWF4R2VvbWV0cnlDb3VudD10Lm1heEdlb21ldHJ5Q291bnQsYS5fbWF4VmVydGV4Q291bnQ9dC5tYXhWZXJ0ZXhDb3VudCxhLl9tYXhJbmRleENvdW50PXQubWF4SW5kZXhDb3VudCxhLl9nZW9tZXRyeUluaXRpYWxpemVkPXQuZ2VvbWV0cnlJbml0aWFsaXplZCxhLl9nZW9tZXRyeUNvdW50PXQuZ2VvbWV0cnlDb3VudCxhLl9tYXRyaWNlc1RleHR1cmU9Yyh0Lm1hdHJpY2VzVGV4dHVyZS51dWlkKTticmVhaztjYXNlIkxPRCI6YT1uZXcgUWE7YnJlYWs7Y2FzZSJMaW5lIjphPW5ldyB2bihvKHQuZ2VvbWV0cnkpLGwodC5tYXRlcmlhbCkpO2JyZWFrO2Nhc2UiTGluZUxvb3AiOmE9bmV3IGlvKG8odC5nZW9tZXRyeSksbCh0Lm1hdGVyaWFsKSk7YnJlYWs7Y2FzZSJMaW5lU2VnbWVudHMiOmE9bmV3IG5uKG8odC5nZW9tZXRyeSksbCh0Lm1hdGVyaWFsKSk7YnJlYWs7Y2FzZSJQb2ludENsb3VkIjpjYXNlIlBvaW50cyI6YT1uZXcgc28obyh0Lmdlb21ldHJ5KSxsKHQubWF0ZXJpYWwpKTticmVhaztjYXNlIlNwcml0ZSI6YT1uZXcgS2EobCh0Lm1hdGVyaWFsKSk7YnJlYWs7Y2FzZSJHcm91cCI6YT1uZXcgS247YnJlYWs7Y2FzZSJCb25lIjphPW5ldyBncjticmVhaztkZWZhdWx0OmE9bmV3IEp0fWlmKGEudXVpZD10LnV1aWQsdC5uYW1lIT09dm9pZCAwJiYoYS5uYW1lPXQubmFtZSksdC5tYXRyaXghPT12b2lkIDA/KGEubWF0cml4LmZyb21BcnJheSh0Lm1hdHJpeCksdC5tYXRyaXhBdXRvVXBkYXRlIT09dm9pZCAwJiYoYS5tYXRyaXhBdXRvVXBkYXRlPXQubWF0cml4QXV0b1VwZGF0ZSksYS5tYXRyaXhBdXRvVXBkYXRlJiZhLm1hdHJpeC5kZWNvbXBvc2UoYS5wb3NpdGlvbixhLnF1YXRlcm5pb24sYS5zY2FsZSkpOih0LnBvc2l0aW9uIT09dm9pZCAwJiZhLnBvc2l0aW9uLmZyb21BcnJheSh0LnBvc2l0aW9uKSx0LnJvdGF0aW9uIT09dm9pZCAwJiZhLnJvdGF0aW9uLmZyb21BcnJheSh0LnJvdGF0aW9uKSx0LnF1YXRlcm5pb24hPT12b2lkIDAmJmEucXVhdGVybmlvbi5mcm9tQXJyYXkodC5xdWF0ZXJuaW9uKSx0LnNjYWxlIT09dm9pZCAwJiZhLnNjYWxlLmZyb21BcnJheSh0LnNjYWxlKSksdC51cCE9PXZvaWQgMCYmYS51cC5mcm9tQXJyYXkodC51cCksdC5jYXN0U2hhZG93IT09dm9pZCAwJiYoYS5jYXN0U2hhZG93PXQuY2FzdFNoYWRvdyksdC5yZWNlaXZlU2hhZG93IT09dm9pZCAwJiYoYS5yZWNlaXZlU2hhZG93PXQucmVjZWl2ZVNoYWRvdyksdC5zaGFkb3cmJih0LnNoYWRvdy5iaWFzIT09dm9pZCAwJiYoYS5zaGFkb3cuYmlhcz10LnNoYWRvdy5iaWFzKSx0LnNoYWRvdy5ub3JtYWxCaWFzIT09dm9pZCAwJiYoYS5zaGFkb3cubm9ybWFsQmlhcz10LnNoYWRvdy5ub3JtYWxCaWFzKSx0LnNoYWRvdy5yYWRpdXMhPT12b2lkIDAmJihhLnNoYWRvdy5yYWRpdXM9dC5zaGFkb3cucmFkaXVzKSx0LnNoYWRvdy5tYXBTaXplIT09dm9pZCAwJiZhLnNoYWRvdy5tYXBTaXplLmZyb21BcnJheSh0LnNoYWRvdy5tYXBTaXplKSx0LnNoYWRvdy5jYW1lcmEhPT12b2lkIDAmJihhLnNoYWRvdy5jYW1lcmE9dGhpcy5wYXJzZU9iamVjdCh0LnNoYWRvdy5jYW1lcmEpKSksdC52aXNpYmxlIT09dm9pZCAwJiYoYS52aXNpYmxlPXQudmlzaWJsZSksdC5mcnVzdHVtQ3VsbGVkIT09dm9pZCAwJiYoYS5mcnVzdHVtQ3VsbGVkPXQuZnJ1c3R1bUN1bGxlZCksdC5yZW5kZXJPcmRlciE9PXZvaWQgMCYmKGEucmVuZGVyT3JkZXI9dC5yZW5kZXJPcmRlciksdC51c2VyRGF0YSE9PXZvaWQgMCYmKGEudXNlckRhdGE9dC51c2VyRGF0YSksdC5sYXllcnMhPT12b2lkIDAmJihhLmxheWVycy5tYXNrPXQubGF5ZXJzKSx0LmNoaWxkcmVuIT09dm9pZCAwKXtsZXQgZD10LmNoaWxkcmVuO2ZvcihsZXQgZj0wO2Y8ZC5sZW5ndGg7ZisrKWEuYWRkKHRoaXMucGFyc2VPYmplY3QoZFtmXSxlLG4saSxyKSl9aWYodC5hbmltYXRpb25zIT09dm9pZCAwKXtsZXQgZD10LmFuaW1hdGlvbnM7Zm9yKGxldCBmPTA7ZjxkLmxlbmd0aDtmKyspe2xldCBtPWRbZl07YS5hbmltYXRpb25zLnB1c2goclttXSl9fWlmKHQudHlwZT09PSJMT0QiKXt0LmF1dG9VcGRhdGUhPT12b2lkIDAmJihhLmF1dG9VcGRhdGU9dC5hdXRvVXBkYXRlKTtsZXQgZD10LmxldmVscztmb3IobGV0IGY9MDtmPGQubGVuZ3RoO2YrKyl7bGV0IG09ZFtmXSxfPWEuZ2V0T2JqZWN0QnlQcm9wZXJ0eSgidXVpZCIsbS5vYmplY3QpO18hPT12b2lkIDAmJmEuYWRkTGV2ZWwoXyxtLmRpc3RhbmNlLG0uaHlzdGVyZXNpcyl9fXJldHVybiBhfWJpbmRTa2VsZXRvbnModCxlKXtPYmplY3Qua2V5cyhlKS5sZW5ndGghPT0wJiZ0LnRyYXZlcnNlKGZ1bmN0aW9uKG4pe2lmKG4uaXNTa2lubmVkTWVzaD09PSEwJiZuLnNrZWxldG9uIT09dm9pZCAwKXtsZXQgaT1lW24uc2tlbGV0b25dO2k9PT12b2lkIDA/Y29uc29sZS53YXJuKCJUSFJFRS5PYmplY3RMb2FkZXI6IE5vIHNrZWxldG9uIGZvdW5kIHdpdGggVVVJRDoiLG4uc2tlbGV0b24pOm4uYmluZChpLG4uYmluZE1hdHJpeCl9fSl9fSxqdj17VVZNYXBwaW5nOnRsLEN1YmVSZWZsZWN0aW9uTWFwcGluZzp6bixDdWJlUmVmcmFjdGlvbk1hcHBpbmc6ZWksRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc6WXMsRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc6WnMsQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmc6VHN9LENkPXtSZXBlYXRXcmFwcGluZzpKcyxDbGFtcFRvRWRnZVdyYXBwaW5nOlVlLE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6JHN9LFBkPXtOZWFyZXN0RmlsdGVyOm1lLE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyOnphLE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXI6TWksTGluZWFyRmlsdGVyOm9lLExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXI6a3MsTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyOnBufSxkaD1jbGFzcyBleHRlbmRzIE5le2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMuaXNJbWFnZUJpdG1hcExvYWRlcj0hMCx0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXA+InUiJiZjb25zb2xlLndhcm4oIlRIUkVFLkltYWdlQml0bWFwTG9hZGVyOiBjcmVhdGVJbWFnZUJpdG1hcCgpIG5vdCBzdXBwb3J0ZWQuIiksdHlwZW9mIGZldGNoPiJ1IiYmY29uc29sZS53YXJuKCJUSFJFRS5JbWFnZUJpdG1hcExvYWRlcjogZmV0Y2goKSBub3Qgc3VwcG9ydGVkLiIpLHRoaXMub3B0aW9ucz17cHJlbXVsdGlwbHlBbHBoYToibm9uZSJ9fXNldE9wdGlvbnModCl7cmV0dXJuIHRoaXMub3B0aW9ucz10LHRoaXN9bG9hZCh0LGUsbixpKXt0PT09dm9pZCAwJiYodD0iIiksdGhpcy5wYXRoIT09dm9pZCAwJiYodD10aGlzLnBhdGgrdCksdD10aGlzLm1hbmFnZXIucmVzb2x2ZVVSTCh0KTtsZXQgcj10aGlzLGE9SW4uZ2V0KHQpO2lmKGEhPT12b2lkIDApe2lmKHIubWFuYWdlci5pdGVtU3RhcnQodCksYS50aGVuKXthLnRoZW4oYz0+e2UmJmUoYyksci5tYW5hZ2VyLml0ZW1FbmQodCl9KS5jYXRjaChjPT57aSYmaShjKX0pO3JldHVybn1yZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe2UmJmUoYSksci5tYW5hZ2VyLml0ZW1FbmQodCl9LDApLGF9bGV0IG89e307by5jcmVkZW50aWFscz10aGlzLmNyb3NzT3JpZ2luPT09ImFub255bW91cyI/InNhbWUtb3JpZ2luIjoiaW5jbHVkZSIsby5oZWFkZXJzPXRoaXMucmVxdWVzdEhlYWRlcjtsZXQgbD1mZXRjaCh0LG8pLnRoZW4oZnVuY3Rpb24oYyl7cmV0dXJuIGMuYmxvYigpfSkudGhlbihmdW5jdGlvbihjKXtyZXR1cm4gY3JlYXRlSW1hZ2VCaXRtYXAoYyxPYmplY3QuYXNzaWduKHIub3B0aW9ucyx7Y29sb3JTcGFjZUNvbnZlcnNpb246Im5vbmUifSkpfSkudGhlbihmdW5jdGlvbihjKXtyZXR1cm4gSW4uYWRkKHQsYyksZSYmZShjKSxyLm1hbmFnZXIuaXRlbUVuZCh0KSxjfSkuY2F0Y2goZnVuY3Rpb24oYyl7aSYmaShjKSxJbi5yZW1vdmUodCksci5tYW5hZ2VyLml0ZW1FcnJvcih0KSxyLm1hbmFnZXIuaXRlbUVuZCh0KX0pO0luLmFkZCh0LGwpLHIubWFuYWdlci5pdGVtU3RhcnQodCl9fSxFYSxOcj1jbGFzc3tzdGF0aWMgZ2V0Q29udGV4dCgpe3JldHVybiBFYT09PXZvaWQgMCYmKEVhPW5ldyh3aW5kb3cuQXVkaW9Db250ZXh0fHx3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KSksRWF9c3RhdGljIHNldENvbnRleHQodCl7RWE9dH19LGZoPWNsYXNzIGV4dGVuZHMgTmV7Y29uc3RydWN0b3IodCl7c3VwZXIodCl9bG9hZCh0LGUsbixpKXtsZXQgcj10aGlzLGE9bmV3IGNuKHRoaXMubWFuYWdlcik7YS5zZXRSZXNwb25zZVR5cGUoImFycmF5YnVmZmVyIiksYS5zZXRQYXRoKHRoaXMucGF0aCksYS5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlciksYS5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpLGEubG9hZCh0LGZ1bmN0aW9uKGwpe3RyeXtsZXQgYz1sLnNsaWNlKDApO05yLmdldENvbnRleHQoKS5kZWNvZGVBdWRpb0RhdGEoYyxmdW5jdGlvbih1KXtlKHUpfSkuY2F0Y2gobyl9Y2F0Y2goYyl7byhjKX19LG4saSk7ZnVuY3Rpb24gbyhsKXtpP2kobCk6Y29uc29sZS5lcnJvcihsKSxyLm1hbmFnZXIuaXRlbUVycm9yKHQpfX19LExkPW5ldyBMdCxJZD1uZXcgTHQscGk9bmV3IEx0LHBoPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy50eXBlPSJTdGVyZW9DYW1lcmEiLHRoaXMuYXNwZWN0PTEsdGhpcy5leWVTZXA9LjA2NCx0aGlzLmNhbWVyYUw9bmV3IHZlLHRoaXMuY2FtZXJhTC5sYXllcnMuZW5hYmxlKDEpLHRoaXMuY2FtZXJhTC5tYXRyaXhBdXRvVXBkYXRlPSExLHRoaXMuY2FtZXJhUj1uZXcgdmUsdGhpcy5jYW1lcmFSLmxheWVycy5lbmFibGUoMiksdGhpcy5jYW1lcmFSLm1hdHJpeEF1dG9VcGRhdGU9ITEsdGhpcy5fY2FjaGU9e2ZvY3VzOm51bGwsZm92Om51bGwsYXNwZWN0Om51bGwsbmVhcjpudWxsLGZhcjpudWxsLHpvb206bnVsbCxleWVTZXA6bnVsbH19dXBkYXRlKHQpe2xldCBlPXRoaXMuX2NhY2hlO2lmKGUuZm9jdXMhPT10LmZvY3VzfHxlLmZvdiE9PXQuZm92fHxlLmFzcGVjdCE9PXQuYXNwZWN0KnRoaXMuYXNwZWN0fHxlLm5lYXIhPT10Lm5lYXJ8fGUuZmFyIT09dC5mYXJ8fGUuem9vbSE9PXQuem9vbXx8ZS5leWVTZXAhPT10aGlzLmV5ZVNlcCl7ZS5mb2N1cz10LmZvY3VzLGUuZm92PXQuZm92LGUuYXNwZWN0PXQuYXNwZWN0KnRoaXMuYXNwZWN0LGUubmVhcj10Lm5lYXIsZS5mYXI9dC5mYXIsZS56b29tPXQuem9vbSxlLmV5ZVNlcD10aGlzLmV5ZVNlcCxwaS5jb3B5KHQucHJvamVjdGlvbk1hdHJpeCk7bGV0IGk9ZS5leWVTZXAvMixyPWkqZS5uZWFyL2UuZm9jdXMsYT1lLm5lYXIqTWF0aC50YW4od2kqZS5mb3YqLjUpL2Uuem9vbSxvLGw7SWQuZWxlbWVudHNbMTJdPS1pLExkLmVsZW1lbnRzWzEyXT1pLG89LWEqZS5hc3BlY3QrcixsPWEqZS5hc3BlY3QrcixwaS5lbGVtZW50c1swXT0yKmUubmVhci8obC1vKSxwaS5lbGVtZW50c1s4XT0obCtvKS8obC1vKSx0aGlzLmNhbWVyYUwucHJvamVjdGlvbk1hdHJpeC5jb3B5KHBpKSxvPS1hKmUuYXNwZWN0LXIsbD1hKmUuYXNwZWN0LXIscGkuZWxlbWVudHNbMF09MiplLm5lYXIvKGwtbykscGkuZWxlbWVudHNbOF09KGwrbykvKGwtbyksdGhpcy5jYW1lcmFSLnByb2plY3Rpb25NYXRyaXguY29weShwaSl9dGhpcy5jYW1lcmFMLm1hdHJpeFdvcmxkLmNvcHkodC5tYXRyaXhXb3JsZCkubXVsdGlwbHkoSWQpLHRoaXMuY2FtZXJhUi5tYXRyaXhXb3JsZC5jb3B5KHQubWF0cml4V29ybGQpLm11bHRpcGx5KExkKX19LEpvPWNsYXNze2NvbnN0cnVjdG9yKHQ9ITApe3RoaXMuYXV0b1N0YXJ0PXQsdGhpcy5zdGFydFRpbWU9MCx0aGlzLm9sZFRpbWU9MCx0aGlzLmVsYXBzZWRUaW1lPTAsdGhpcy5ydW5uaW5nPSExfXN0YXJ0KCl7dGhpcy5zdGFydFRpbWU9VWQoKSx0aGlzLm9sZFRpbWU9dGhpcy5zdGFydFRpbWUsdGhpcy5lbGFwc2VkVGltZT0wLHRoaXMucnVubmluZz0hMH1zdG9wKCl7dGhpcy5nZXRFbGFwc2VkVGltZSgpLHRoaXMucnVubmluZz0hMSx0aGlzLmF1dG9TdGFydD0hMX1nZXRFbGFwc2VkVGltZSgpe3JldHVybiB0aGlzLmdldERlbHRhKCksdGhpcy5lbGFwc2VkVGltZX1nZXREZWx0YSgpe2xldCB0PTA7aWYodGhpcy5hdXRvU3RhcnQmJiF0aGlzLnJ1bm5pbmcpcmV0dXJuIHRoaXMuc3RhcnQoKSwwO2lmKHRoaXMucnVubmluZyl7bGV0IGU9VWQoKTt0PShlLXRoaXMub2xkVGltZSkvMWUzLHRoaXMub2xkVGltZT1lLHRoaXMuZWxhcHNlZFRpbWUrPXR9cmV0dXJuIHR9fTtmdW5jdGlvbiBVZCgpe3JldHVybih0eXBlb2YgcGVyZm9ybWFuY2U+InUiP0RhdGU6cGVyZm9ybWFuY2UpLm5vdygpfXZhciBtaT1uZXcgUixEZD1uZXcgRGUsdHk9bmV3IFIsZ2k9bmV3IFIsbWg9Y2xhc3MgZXh0ZW5kcyBKdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy50eXBlPSJBdWRpb0xpc3RlbmVyIix0aGlzLmNvbnRleHQ9TnIuZ2V0Q29udGV4dCgpLHRoaXMuZ2Fpbj10aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpLHRoaXMuZ2Fpbi5jb25uZWN0KHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiksdGhpcy5maWx0ZXI9bnVsbCx0aGlzLnRpbWVEZWx0YT0wLHRoaXMuX2Nsb2NrPW5ldyBKb31nZXRJbnB1dCgpe3JldHVybiB0aGlzLmdhaW59cmVtb3ZlRmlsdGVyKCl7cmV0dXJuIHRoaXMuZmlsdGVyIT09bnVsbCYmKHRoaXMuZ2Fpbi5kaXNjb25uZWN0KHRoaXMuZmlsdGVyKSx0aGlzLmZpbHRlci5kaXNjb25uZWN0KHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiksdGhpcy5nYWluLmNvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKSx0aGlzLmZpbHRlcj1udWxsKSx0aGlzfWdldEZpbHRlcigpe3JldHVybiB0aGlzLmZpbHRlcn1zZXRGaWx0ZXIodCl7cmV0dXJuIHRoaXMuZmlsdGVyIT09bnVsbD8odGhpcy5nYWluLmRpc2Nvbm5lY3QodGhpcy5maWx0ZXIpLHRoaXMuZmlsdGVyLmRpc2Nvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKSk6dGhpcy5nYWluLmRpc2Nvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKSx0aGlzLmZpbHRlcj10LHRoaXMuZ2Fpbi5jb25uZWN0KHRoaXMuZmlsdGVyKSx0aGlzLmZpbHRlci5jb25uZWN0KHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiksdGhpc31nZXRNYXN0ZXJWb2x1bWUoKXtyZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWV9c2V0TWFzdGVyVm9sdW1lKHQpe3JldHVybiB0aGlzLmdhaW4uZ2Fpbi5zZXRUYXJnZXRBdFRpbWUodCx0aGlzLmNvbnRleHQuY3VycmVudFRpbWUsLjAxKSx0aGlzfXVwZGF0ZU1hdHJpeFdvcmxkKHQpe3N1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKHQpO2xldCBlPXRoaXMuY29udGV4dC5saXN0ZW5lcixuPXRoaXMudXA7aWYodGhpcy50aW1lRGVsdGE9dGhpcy5fY2xvY2suZ2V0RGVsdGEoKSx0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZShtaSxEZCx0eSksZ2kuc2V0KDAsMCwtMSkuYXBwbHlRdWF0ZXJuaW9uKERkKSxlLnBvc2l0aW9uWCl7bGV0IGk9dGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lK3RoaXMudGltZURlbHRhO2UucG9zaXRpb25YLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKG1pLngsaSksZS5wb3NpdGlvblkubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUobWkueSxpKSxlLnBvc2l0aW9uWi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShtaS56LGkpLGUuZm9yd2FyZFgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoZ2kueCxpKSxlLmZvcndhcmRZLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKGdpLnksaSksZS5mb3J3YXJkWi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShnaS56LGkpLGUudXBYLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKG4ueCxpKSxlLnVwWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShuLnksaSksZS51cFoubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUobi56LGkpfWVsc2UgZS5zZXRQb3NpdGlvbihtaS54LG1pLnksbWkueiksZS5zZXRPcmllbnRhdGlvbihnaS54LGdpLnksZ2kueixuLngsbi55LG4ueil9fSwkbz1jbGFzcyBleHRlbmRzIEp0e2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy50eXBlPSJBdWRpbyIsdGhpcy5saXN0ZW5lcj10LHRoaXMuY29udGV4dD10LmNvbnRleHQsdGhpcy5nYWluPXRoaXMuY29udGV4dC5jcmVhdGVHYWluKCksdGhpcy5nYWluLmNvbm5lY3QodC5nZXRJbnB1dCgpKSx0aGlzLmF1dG9wbGF5PSExLHRoaXMuYnVmZmVyPW51bGwsdGhpcy5kZXR1bmU9MCx0aGlzLmxvb3A9ITEsdGhpcy5sb29wU3RhcnQ9MCx0aGlzLmxvb3BFbmQ9MCx0aGlzLm9mZnNldD0wLHRoaXMuZHVyYXRpb249dm9pZCAwLHRoaXMucGxheWJhY2tSYXRlPTEsdGhpcy5pc1BsYXlpbmc9ITEsdGhpcy5oYXNQbGF5YmFja0NvbnRyb2w9ITAsdGhpcy5zb3VyY2U9bnVsbCx0aGlzLnNvdXJjZVR5cGU9ImVtcHR5Iix0aGlzLl9zdGFydGVkQXQ9MCx0aGlzLl9wcm9ncmVzcz0wLHRoaXMuX2Nvbm5lY3RlZD0hMSx0aGlzLmZpbHRlcnM9W119Z2V0T3V0cHV0KCl7cmV0dXJuIHRoaXMuZ2Fpbn1zZXROb2RlU291cmNlKHQpe3JldHVybiB0aGlzLmhhc1BsYXliYWNrQ29udHJvbD0hMSx0aGlzLnNvdXJjZVR5cGU9ImF1ZGlvTm9kZSIsdGhpcy5zb3VyY2U9dCx0aGlzLmNvbm5lY3QoKSx0aGlzfXNldE1lZGlhRWxlbWVudFNvdXJjZSh0KXtyZXR1cm4gdGhpcy5oYXNQbGF5YmFja0NvbnRyb2w9ITEsdGhpcy5zb3VyY2VUeXBlPSJtZWRpYU5vZGUiLHRoaXMuc291cmNlPXRoaXMuY29udGV4dC5jcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UodCksdGhpcy5jb25uZWN0KCksdGhpc31zZXRNZWRpYVN0cmVhbVNvdXJjZSh0KXtyZXR1cm4gdGhpcy5oYXNQbGF5YmFja0NvbnRyb2w9ITEsdGhpcy5zb3VyY2VUeXBlPSJtZWRpYVN0cmVhbU5vZGUiLHRoaXMuc291cmNlPXRoaXMuY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZSh0KSx0aGlzLmNvbm5lY3QoKSx0aGlzfXNldEJ1ZmZlcih0KXtyZXR1cm4gdGhpcy5idWZmZXI9dCx0aGlzLnNvdXJjZVR5cGU9ImJ1ZmZlciIsdGhpcy5hdXRvcGxheSYmdGhpcy5wbGF5KCksdGhpc31wbGF5KHQ9MCl7aWYodGhpcy5pc1BsYXlpbmc9PT0hMCl7Y29uc29sZS53YXJuKCJUSFJFRS5BdWRpbzogQXVkaW8gaXMgYWxyZWFkeSBwbGF5aW5nLiIpO3JldHVybn1pZih0aGlzLmhhc1BsYXliYWNrQ29udHJvbD09PSExKXtjb25zb2xlLndhcm4oIlRIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLiIpO3JldHVybn10aGlzLl9zdGFydGVkQXQ9dGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lK3Q7bGV0IGU9dGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO3JldHVybiBlLmJ1ZmZlcj10aGlzLmJ1ZmZlcixlLmxvb3A9dGhpcy5sb29wLGUubG9vcFN0YXJ0PXRoaXMubG9vcFN0YXJ0LGUubG9vcEVuZD10aGlzLmxvb3BFbmQsZS5vbmVuZGVkPXRoaXMub25FbmRlZC5iaW5kKHRoaXMpLGUuc3RhcnQodGhpcy5fc3RhcnRlZEF0LHRoaXMuX3Byb2dyZXNzK3RoaXMub2Zmc2V0LHRoaXMuZHVyYXRpb24pLHRoaXMuaXNQbGF5aW5nPSEwLHRoaXMuc291cmNlPWUsdGhpcy5zZXREZXR1bmUodGhpcy5kZXR1bmUpLHRoaXMuc2V0UGxheWJhY2tSYXRlKHRoaXMucGxheWJhY2tSYXRlKSx0aGlzLmNvbm5lY3QoKX1wYXVzZSgpe2lmKHRoaXMuaGFzUGxheWJhY2tDb250cm9sPT09ITEpe2NvbnNvbGUud2FybigiVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuIik7cmV0dXJufXJldHVybiB0aGlzLmlzUGxheWluZz09PSEwJiYodGhpcy5fcHJvZ3Jlc3MrPU1hdGgubWF4KHRoaXMuY29udGV4dC5jdXJyZW50VGltZS10aGlzLl9zdGFydGVkQXQsMCkqdGhpcy5wbGF5YmFja1JhdGUsdGhpcy5sb29wPT09ITAmJih0aGlzLl9wcm9ncmVzcz10aGlzLl9wcm9ncmVzcyUodGhpcy5kdXJhdGlvbnx8dGhpcy5idWZmZXIuZHVyYXRpb24pKSx0aGlzLnNvdXJjZS5zdG9wKCksdGhpcy5zb3VyY2Uub25lbmRlZD1udWxsLHRoaXMuaXNQbGF5aW5nPSExKSx0aGlzfXN0b3AoKXtpZih0aGlzLmhhc1BsYXliYWNrQ29udHJvbD09PSExKXtjb25zb2xlLndhcm4oIlRIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLiIpO3JldHVybn1yZXR1cm4gdGhpcy5fcHJvZ3Jlc3M9MCx0aGlzLnNvdXJjZSE9PW51bGwmJih0aGlzLnNvdXJjZS5zdG9wKCksdGhpcy5zb3VyY2Uub25lbmRlZD1udWxsKSx0aGlzLmlzUGxheWluZz0hMSx0aGlzfWNvbm5lY3QoKXtpZih0aGlzLmZpbHRlcnMubGVuZ3RoPjApe3RoaXMuc291cmNlLmNvbm5lY3QodGhpcy5maWx0ZXJzWzBdKTtmb3IobGV0IHQ9MSxlPXRoaXMuZmlsdGVycy5sZW5ndGg7dDxlO3QrKyl0aGlzLmZpbHRlcnNbdC0xXS5jb25uZWN0KHRoaXMuZmlsdGVyc1t0XSk7dGhpcy5maWx0ZXJzW3RoaXMuZmlsdGVycy5sZW5ndGgtMV0uY29ubmVjdCh0aGlzLmdldE91dHB1dCgpKX1lbHNlIHRoaXMuc291cmNlLmNvbm5lY3QodGhpcy5nZXRPdXRwdXQoKSk7cmV0dXJuIHRoaXMuX2Nvbm5lY3RlZD0hMCx0aGlzfWRpc2Nvbm5lY3QoKXtpZih0aGlzLl9jb25uZWN0ZWQhPT0hMSl7aWYodGhpcy5maWx0ZXJzLmxlbmd0aD4wKXt0aGlzLnNvdXJjZS5kaXNjb25uZWN0KHRoaXMuZmlsdGVyc1swXSk7Zm9yKGxldCB0PTEsZT10aGlzLmZpbHRlcnMubGVuZ3RoO3Q8ZTt0KyspdGhpcy5maWx0ZXJzW3QtMV0uZGlzY29ubmVjdCh0aGlzLmZpbHRlcnNbdF0pO3RoaXMuZmlsdGVyc1t0aGlzLmZpbHRlcnMubGVuZ3RoLTFdLmRpc2Nvbm5lY3QodGhpcy5nZXRPdXRwdXQoKSl9ZWxzZSB0aGlzLnNvdXJjZS5kaXNjb25uZWN0KHRoaXMuZ2V0T3V0cHV0KCkpO3JldHVybiB0aGlzLl9jb25uZWN0ZWQ9ITEsdGhpc319Z2V0RmlsdGVycygpe3JldHVybiB0aGlzLmZpbHRlcnN9c2V0RmlsdGVycyh0KXtyZXR1cm4gdHx8KHQ9W10pLHRoaXMuX2Nvbm5lY3RlZD09PSEwPyh0aGlzLmRpc2Nvbm5lY3QoKSx0aGlzLmZpbHRlcnM9dC5zbGljZSgpLHRoaXMuY29ubmVjdCgpKTp0aGlzLmZpbHRlcnM9dC5zbGljZSgpLHRoaXN9c2V0RGV0dW5lKHQpe3JldHVybiB0aGlzLmRldHVuZT10LHRoaXMuaXNQbGF5aW5nPT09ITAmJnRoaXMuc291cmNlLmRldHVuZSE9PXZvaWQgMCYmdGhpcy5zb3VyY2UuZGV0dW5lLnNldFRhcmdldEF0VGltZSh0aGlzLmRldHVuZSx0aGlzLmNvbnRleHQuY3VycmVudFRpbWUsLjAxKSx0aGlzfWdldERldHVuZSgpe3JldHVybiB0aGlzLmRldHVuZX1nZXRGaWx0ZXIoKXtyZXR1cm4gdGhpcy5nZXRGaWx0ZXJzKClbMF19c2V0RmlsdGVyKHQpe3JldHVybiB0aGlzLnNldEZpbHRlcnModD9bdF06W10pfXNldFBsYXliYWNrUmF0ZSh0KXtpZih0aGlzLmhhc1BsYXliYWNrQ29udHJvbD09PSExKXtjb25zb2xlLndhcm4oIlRIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLiIpO3JldHVybn1yZXR1cm4gdGhpcy5wbGF5YmFja1JhdGU9dCx0aGlzLmlzUGxheWluZz09PSEwJiZ0aGlzLnNvdXJjZS5wbGF5YmFja1JhdGUuc2V0VGFyZ2V0QXRUaW1lKHRoaXMucGxheWJhY2tSYXRlLHRoaXMuY29udGV4dC5jdXJyZW50VGltZSwuMDEpLHRoaXN9Z2V0UGxheWJhY2tSYXRlKCl7cmV0dXJuIHRoaXMucGxheWJhY2tSYXRlfW9uRW5kZWQoKXt0aGlzLmlzUGxheWluZz0hMX1nZXRMb29wKCl7cmV0dXJuIHRoaXMuaGFzUGxheWJhY2tDb250cm9sPT09ITE/KGNvbnNvbGUud2FybigiVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuIiksITEpOnRoaXMubG9vcH1zZXRMb29wKHQpe2lmKHRoaXMuaGFzUGxheWJhY2tDb250cm9sPT09ITEpe2NvbnNvbGUud2FybigiVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuIik7cmV0dXJufXJldHVybiB0aGlzLmxvb3A9dCx0aGlzLmlzUGxheWluZz09PSEwJiYodGhpcy5zb3VyY2UubG9vcD10aGlzLmxvb3ApLHRoaXN9c2V0TG9vcFN0YXJ0KHQpe3JldHVybiB0aGlzLmxvb3BTdGFydD10LHRoaXN9c2V0TG9vcEVuZCh0KXtyZXR1cm4gdGhpcy5sb29wRW5kPXQsdGhpc31nZXRWb2x1bWUoKXtyZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWV9c2V0Vm9sdW1lKHQpe3JldHVybiB0aGlzLmdhaW4uZ2Fpbi5zZXRUYXJnZXRBdFRpbWUodCx0aGlzLmNvbnRleHQuY3VycmVudFRpbWUsLjAxKSx0aGlzfX0sX2k9bmV3IFIsTmQ9bmV3IERlLGV5PW5ldyBSLHhpPW5ldyBSLGdoPWNsYXNzIGV4dGVuZHMgJG97Y29uc3RydWN0b3IodCl7c3VwZXIodCksdGhpcy5wYW5uZXI9dGhpcy5jb250ZXh0LmNyZWF0ZVBhbm5lcigpLHRoaXMucGFubmVyLnBhbm5pbmdNb2RlbD0iSFJURiIsdGhpcy5wYW5uZXIuY29ubmVjdCh0aGlzLmdhaW4pfWNvbm5lY3QoKXtzdXBlci5jb25uZWN0KCksdGhpcy5wYW5uZXIuY29ubmVjdCh0aGlzLmdhaW4pfWRpc2Nvbm5lY3QoKXtzdXBlci5kaXNjb25uZWN0KCksdGhpcy5wYW5uZXIuZGlzY29ubmVjdCh0aGlzLmdhaW4pfWdldE91dHB1dCgpe3JldHVybiB0aGlzLnBhbm5lcn1nZXRSZWZEaXN0YW5jZSgpe3JldHVybiB0aGlzLnBhbm5lci5yZWZEaXN0YW5jZX1zZXRSZWZEaXN0YW5jZSh0KXtyZXR1cm4gdGhpcy5wYW5uZXIucmVmRGlzdGFuY2U9dCx0aGlzfWdldFJvbGxvZmZGYWN0b3IoKXtyZXR1cm4gdGhpcy5wYW5uZXIucm9sbG9mZkZhY3Rvcn1zZXRSb2xsb2ZmRmFjdG9yKHQpe3JldHVybiB0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yPXQsdGhpc31nZXREaXN0YW5jZU1vZGVsKCl7cmV0dXJuIHRoaXMucGFubmVyLmRpc3RhbmNlTW9kZWx9c2V0RGlzdGFuY2VNb2RlbCh0KXtyZXR1cm4gdGhpcy5wYW5uZXIuZGlzdGFuY2VNb2RlbD10LHRoaXN9Z2V0TWF4RGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5wYW5uZXIubWF4RGlzdGFuY2V9c2V0TWF4RGlzdGFuY2UodCl7cmV0dXJuIHRoaXMucGFubmVyLm1heERpc3RhbmNlPXQsdGhpc31zZXREaXJlY3Rpb25hbENvbmUodCxlLG4pe3JldHVybiB0aGlzLnBhbm5lci5jb25lSW5uZXJBbmdsZT10LHRoaXMucGFubmVyLmNvbmVPdXRlckFuZ2xlPWUsdGhpcy5wYW5uZXIuY29uZU91dGVyR2Fpbj1uLHRoaXN9dXBkYXRlTWF0cml4V29ybGQodCl7aWYoc3VwZXIudXBkYXRlTWF0cml4V29ybGQodCksdGhpcy5oYXNQbGF5YmFja0NvbnRyb2w9PT0hMCYmdGhpcy5pc1BsYXlpbmc9PT0hMSlyZXR1cm47dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoX2ksTmQsZXkpLHhpLnNldCgwLDAsMSkuYXBwbHlRdWF0ZXJuaW9uKE5kKTtsZXQgZT10aGlzLnBhbm5lcjtpZihlLnBvc2l0aW9uWCl7bGV0IG49dGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lK3RoaXMubGlzdGVuZXIudGltZURlbHRhO2UucG9zaXRpb25YLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKF9pLngsbiksZS5wb3NpdGlvblkubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoX2kueSxuKSxlLnBvc2l0aW9uWi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShfaS56LG4pLGUub3JpZW50YXRpb25YLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHhpLngsbiksZS5vcmllbnRhdGlvblkubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoeGkueSxuKSxlLm9yaWVudGF0aW9uWi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh4aS56LG4pfWVsc2UgZS5zZXRQb3NpdGlvbihfaS54LF9pLnksX2kueiksZS5zZXRPcmllbnRhdGlvbih4aS54LHhpLnkseGkueil9fSxfaD1jbGFzc3tjb25zdHJ1Y3Rvcih0LGU9MjA0OCl7dGhpcy5hbmFseXNlcj10LmNvbnRleHQuY3JlYXRlQW5hbHlzZXIoKSx0aGlzLmFuYWx5c2VyLmZmdFNpemU9ZSx0aGlzLmRhdGE9bmV3IFVpbnQ4QXJyYXkodGhpcy5hbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudCksdC5nZXRPdXRwdXQoKS5jb25uZWN0KHRoaXMuYW5hbHlzZXIpfWdldEZyZXF1ZW5jeURhdGEoKXtyZXR1cm4gdGhpcy5hbmFseXNlci5nZXRCeXRlRnJlcXVlbmN5RGF0YSh0aGlzLmRhdGEpLHRoaXMuZGF0YX1nZXRBdmVyYWdlRnJlcXVlbmN5KCl7bGV0IHQ9MCxlPXRoaXMuZ2V0RnJlcXVlbmN5RGF0YSgpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXQrPWVbbl07cmV0dXJuIHQvZS5sZW5ndGh9fSxLbz1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUsbil7dGhpcy5iaW5kaW5nPXQsdGhpcy52YWx1ZVNpemU9bjtsZXQgaSxyLGE7c3dpdGNoKGUpe2Nhc2UicXVhdGVybmlvbiI6aT10aGlzLl9zbGVycCxyPXRoaXMuX3NsZXJwQWRkaXRpdmUsYT10aGlzLl9zZXRBZGRpdGl2ZUlkZW50aXR5UXVhdGVybmlvbix0aGlzLmJ1ZmZlcj1uZXcgRmxvYXQ2NEFycmF5KG4qNiksdGhpcy5fd29ya0luZGV4PTU7YnJlYWs7Y2FzZSJzdHJpbmciOmNhc2UiYm9vbCI6aT10aGlzLl9zZWxlY3Qscj10aGlzLl9zZWxlY3QsYT10aGlzLl9zZXRBZGRpdGl2ZUlkZW50aXR5T3RoZXIsdGhpcy5idWZmZXI9bmV3IEFycmF5KG4qNSk7YnJlYWs7ZGVmYXVsdDppPXRoaXMuX2xlcnAscj10aGlzLl9sZXJwQWRkaXRpdmUsYT10aGlzLl9zZXRBZGRpdGl2ZUlkZW50aXR5TnVtZXJpYyx0aGlzLmJ1ZmZlcj1uZXcgRmxvYXQ2NEFycmF5KG4qNSl9dGhpcy5fbWl4QnVmZmVyUmVnaW9uPWksdGhpcy5fbWl4QnVmZmVyUmVnaW9uQWRkaXRpdmU9cix0aGlzLl9zZXRJZGVudGl0eT1hLHRoaXMuX29yaWdJbmRleD0zLHRoaXMuX2FkZEluZGV4PTQsdGhpcy5jdW11bGF0aXZlV2VpZ2h0PTAsdGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmU9MCx0aGlzLnVzZUNvdW50PTAsdGhpcy5yZWZlcmVuY2VDb3VudD0wfWFjY3VtdWxhdGUodCxlKXtsZXQgbj10aGlzLmJ1ZmZlcixpPXRoaXMudmFsdWVTaXplLHI9dCppK2ksYT10aGlzLmN1bXVsYXRpdmVXZWlnaHQ7aWYoYT09PTApe2ZvcihsZXQgbz0wO28hPT1pOysrbyluW3Irb109bltvXTthPWV9ZWxzZXthKz1lO2xldCBvPWUvYTt0aGlzLl9taXhCdWZmZXJSZWdpb24obixyLDAsbyxpKX10aGlzLmN1bXVsYXRpdmVXZWlnaHQ9YX1hY2N1bXVsYXRlQWRkaXRpdmUodCl7bGV0IGU9dGhpcy5idWZmZXIsbj10aGlzLnZhbHVlU2l6ZSxpPW4qdGhpcy5fYWRkSW5kZXg7dGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmU9PT0wJiZ0aGlzLl9zZXRJZGVudGl0eSgpLHRoaXMuX21peEJ1ZmZlclJlZ2lvbkFkZGl0aXZlKGUsaSwwLHQsbiksdGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmUrPXR9YXBwbHkodCl7bGV0IGU9dGhpcy52YWx1ZVNpemUsbj10aGlzLmJ1ZmZlcixpPXQqZStlLHI9dGhpcy5jdW11bGF0aXZlV2VpZ2h0LGE9dGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmUsbz10aGlzLmJpbmRpbmc7aWYodGhpcy5jdW11bGF0aXZlV2VpZ2h0PTAsdGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmU9MCxyPDEpe2xldCBsPWUqdGhpcy5fb3JpZ0luZGV4O3RoaXMuX21peEJ1ZmZlclJlZ2lvbihuLGksbCwxLXIsZSl9YT4wJiZ0aGlzLl9taXhCdWZmZXJSZWdpb25BZGRpdGl2ZShuLGksdGhpcy5fYWRkSW5kZXgqZSwxLGUpO2ZvcihsZXQgbD1lLGM9ZStlO2whPT1jOysrbClpZihuW2xdIT09bltsK2VdKXtvLnNldFZhbHVlKG4saSk7YnJlYWt9fXNhdmVPcmlnaW5hbFN0YXRlKCl7bGV0IHQ9dGhpcy5iaW5kaW5nLGU9dGhpcy5idWZmZXIsbj10aGlzLnZhbHVlU2l6ZSxpPW4qdGhpcy5fb3JpZ0luZGV4O3QuZ2V0VmFsdWUoZSxpKTtmb3IobGV0IHI9bixhPWk7ciE9PWE7KytyKWVbcl09ZVtpK3Ilbl07dGhpcy5fc2V0SWRlbnRpdHkoKSx0aGlzLmN1bXVsYXRpdmVXZWlnaHQ9MCx0aGlzLmN1bXVsYXRpdmVXZWlnaHRBZGRpdGl2ZT0wfXJlc3RvcmVPcmlnaW5hbFN0YXRlKCl7bGV0IHQ9dGhpcy52YWx1ZVNpemUqMzt0aGlzLmJpbmRpbmcuc2V0VmFsdWUodGhpcy5idWZmZXIsdCl9X3NldEFkZGl0aXZlSWRlbnRpdHlOdW1lcmljKCl7bGV0IHQ9dGhpcy5fYWRkSW5kZXgqdGhpcy52YWx1ZVNpemUsZT10K3RoaXMudmFsdWVTaXplO2ZvcihsZXQgbj10O248ZTtuKyspdGhpcy5idWZmZXJbbl09MH1fc2V0QWRkaXRpdmVJZGVudGl0eVF1YXRlcm5pb24oKXt0aGlzLl9zZXRBZGRpdGl2ZUlkZW50aXR5TnVtZXJpYygpLHRoaXMuYnVmZmVyW3RoaXMuX2FkZEluZGV4KnRoaXMudmFsdWVTaXplKzNdPTF9X3NldEFkZGl0aXZlSWRlbnRpdHlPdGhlcigpe2xldCB0PXRoaXMuX29yaWdJbmRleCp0aGlzLnZhbHVlU2l6ZSxlPXRoaXMuX2FkZEluZGV4KnRoaXMudmFsdWVTaXplO2ZvcihsZXQgbj0wO248dGhpcy52YWx1ZVNpemU7bisrKXRoaXMuYnVmZmVyW2Urbl09dGhpcy5idWZmZXJbdCtuXX1fc2VsZWN0KHQsZSxuLGkscil7aWYoaT49LjUpZm9yKGxldCBhPTA7YSE9PXI7KythKXRbZSthXT10W24rYV19X3NsZXJwKHQsZSxuLGkpe0RlLnNsZXJwRmxhdCh0LGUsdCxlLHQsbixpKX1fc2xlcnBBZGRpdGl2ZSh0LGUsbixpLHIpe2xldCBhPXRoaXMuX3dvcmtJbmRleCpyO0RlLm11bHRpcGx5UXVhdGVybmlvbnNGbGF0KHQsYSx0LGUsdCxuKSxEZS5zbGVycEZsYXQodCxlLHQsZSx0LGEsaSl9X2xlcnAodCxlLG4saSxyKXtsZXQgYT0xLWk7Zm9yKGxldCBvPTA7byE9PXI7KytvKXtsZXQgbD1lK287dFtsXT10W2xdKmErdFtuK29dKml9fV9sZXJwQWRkaXRpdmUodCxlLG4saSxyKXtmb3IobGV0IGE9MDthIT09cjsrK2Epe2xldCBvPWUrYTt0W29dPXRbb10rdFtuK2FdKml9fX0sYXU9IlxcW1xcXVxcLjpcXC8iLG55PW5ldyBSZWdFeHAoIlsiK2F1KyJdIiwiZyIpLG91PSJbXiIrYXUrIl0iLGl5PSJbXiIrYXUucmVwbGFjZSgiXFwuIiwiIikrIl0iLHN5PS8oKD86V0MrW1wvOl0pKikvLnNvdXJjZS5yZXBsYWNlKCJXQyIsb3UpLHJ5PS8oV0NPRCspPy8uc291cmNlLnJlcGxhY2UoIldDT0QiLGl5KSxheT0vKD86XC4oV0MrKSg/OlxbKC4rKVxdKT8pPy8uc291cmNlLnJlcGxhY2UoIldDIixvdSksb3k9L1wuKFdDKykoPzpcWyguKylcXSk/Ly5zb3VyY2UucmVwbGFjZSgiV0MiLG91KSxseT1uZXcgUmVnRXhwKCJeIitzeStyeStheStveSsiJCIpLGN5PVsibWF0ZXJpYWwiLCJtYXRlcmlhbHMiLCJib25lcyIsIm1hcCJdLHhoPWNsYXNze2NvbnN0cnVjdG9yKHQsZSxuKXtsZXQgaT1ufHxRdC5wYXJzZVRyYWNrTmFtZShlKTt0aGlzLl90YXJnZXRHcm91cD10LHRoaXMuX2JpbmRpbmdzPXQuc3Vic2NyaWJlXyhlLGkpfWdldFZhbHVlKHQsZSl7dGhpcy5iaW5kKCk7bGV0IG49dGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfLGk9dGhpcy5fYmluZGluZ3Nbbl07aSE9PXZvaWQgMCYmaS5nZXRWYWx1ZSh0LGUpfXNldFZhbHVlKHQsZSl7bGV0IG49dGhpcy5fYmluZGluZ3M7Zm9yKGxldCBpPXRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxyPW4ubGVuZ3RoO2khPT1yOysraSluW2ldLnNldFZhbHVlKHQsZSl9YmluZCgpe2xldCB0PXRoaXMuX2JpbmRpbmdzO2ZvcihsZXQgZT10aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sbj10Lmxlbmd0aDtlIT09bjsrK2UpdFtlXS5iaW5kKCl9dW5iaW5kKCl7bGV0IHQ9dGhpcy5fYmluZGluZ3M7Zm9yKGxldCBlPXRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxuPXQubGVuZ3RoO2UhPT1uOysrZSl0W2VdLnVuYmluZCgpfX0sUXQ9Y2xhc3Mgc3tjb25zdHJ1Y3Rvcih0LGUsbil7dGhpcy5wYXRoPWUsdGhpcy5wYXJzZWRQYXRoPW58fHMucGFyc2VUcmFja05hbWUoZSksdGhpcy5ub2RlPXMuZmluZE5vZGUodCx0aGlzLnBhcnNlZFBhdGgubm9kZU5hbWUpLHRoaXMucm9vdE5vZGU9dCx0aGlzLmdldFZhbHVlPXRoaXMuX2dldFZhbHVlX3VuYm91bmQsdGhpcy5zZXRWYWx1ZT10aGlzLl9zZXRWYWx1ZV91bmJvdW5kfXN0YXRpYyBjcmVhdGUodCxlLG4pe3JldHVybiB0JiZ0LmlzQW5pbWF0aW9uT2JqZWN0R3JvdXA/bmV3IHMuQ29tcG9zaXRlKHQsZSxuKTpuZXcgcyh0LGUsbil9c3RhdGljIHNhbml0aXplTm9kZU5hbWUodCl7cmV0dXJuIHQucmVwbGFjZSgvXHMvZywiXyIpLnJlcGxhY2UobnksIiIpfXN0YXRpYyBwYXJzZVRyYWNrTmFtZSh0KXtsZXQgZT1seS5leGVjKHQpO2lmKGU9PT1udWxsKXRocm93IG5ldyBFcnJvcigiUHJvcGVydHlCaW5kaW5nOiBDYW5ub3QgcGFyc2UgdHJhY2tOYW1lOiAiK3QpO2xldCBuPXtub2RlTmFtZTplWzJdLG9iamVjdE5hbWU6ZVszXSxvYmplY3RJbmRleDplWzRdLHByb3BlcnR5TmFtZTplWzVdLHByb3BlcnR5SW5kZXg6ZVs2XX0saT1uLm5vZGVOYW1lJiZuLm5vZGVOYW1lLmxhc3RJbmRleE9mKCIuIik7aWYoaSE9PXZvaWQgMCYmaSE9PS0xKXtsZXQgcj1uLm5vZGVOYW1lLnN1YnN0cmluZyhpKzEpO2N5LmluZGV4T2YocikhPT0tMSYmKG4ubm9kZU5hbWU9bi5ub2RlTmFtZS5zdWJzdHJpbmcoMCxpKSxuLm9iamVjdE5hbWU9cil9aWYobi5wcm9wZXJ0eU5hbWU9PT1udWxsfHxuLnByb3BlcnR5TmFtZS5sZW5ndGg9PT0wKXRocm93IG5ldyBFcnJvcigiUHJvcGVydHlCaW5kaW5nOiBjYW4gbm90IHBhcnNlIHByb3BlcnR5TmFtZSBmcm9tIHRyYWNrTmFtZTogIit0KTtyZXR1cm4gbn1zdGF0aWMgZmluZE5vZGUodCxlKXtpZihlPT09dm9pZCAwfHxlPT09IiJ8fGU9PT0iLiJ8fGU9PT0tMXx8ZT09PXQubmFtZXx8ZT09PXQudXVpZClyZXR1cm4gdDtpZih0LnNrZWxldG9uKXtsZXQgbj10LnNrZWxldG9uLmdldEJvbmVCeU5hbWUoZSk7aWYobiE9PXZvaWQgMClyZXR1cm4gbn1pZih0LmNoaWxkcmVuKXtsZXQgbj1mdW5jdGlvbihyKXtmb3IobGV0IGE9MDthPHIubGVuZ3RoO2ErKyl7bGV0IG89clthXTtpZihvLm5hbWU9PT1lfHxvLnV1aWQ9PT1lKXJldHVybiBvO2xldCBsPW4oby5jaGlsZHJlbik7aWYobClyZXR1cm4gbH1yZXR1cm4gbnVsbH0saT1uKHQuY2hpbGRyZW4pO2lmKGkpcmV0dXJuIGl9cmV0dXJuIG51bGx9X2dldFZhbHVlX3VuYXZhaWxhYmxlKCl7fV9zZXRWYWx1ZV91bmF2YWlsYWJsZSgpe31fZ2V0VmFsdWVfZGlyZWN0KHQsZSl7dFtlXT10aGlzLnRhcmdldE9iamVjdFt0aGlzLnByb3BlcnR5TmFtZV19X2dldFZhbHVlX2FycmF5KHQsZSl7bGV0IG49dGhpcy5yZXNvbHZlZFByb3BlcnR5O2ZvcihsZXQgaT0wLHI9bi5sZW5ndGg7aSE9PXI7KytpKXRbZSsrXT1uW2ldfV9nZXRWYWx1ZV9hcnJheUVsZW1lbnQodCxlKXt0W2VdPXRoaXMucmVzb2x2ZWRQcm9wZXJ0eVt0aGlzLnByb3BlcnR5SW5kZXhdfV9nZXRWYWx1ZV90b0FycmF5KHQsZSl7dGhpcy5yZXNvbHZlZFByb3BlcnR5LnRvQXJyYXkodCxlKX1fc2V0VmFsdWVfZGlyZWN0KHQsZSl7dGhpcy50YXJnZXRPYmplY3RbdGhpcy5wcm9wZXJ0eU5hbWVdPXRbZV19X3NldFZhbHVlX2RpcmVjdF9zZXROZWVkc1VwZGF0ZSh0LGUpe3RoaXMudGFyZ2V0T2JqZWN0W3RoaXMucHJvcGVydHlOYW1lXT10W2VdLHRoaXMudGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlPSEwfV9zZXRWYWx1ZV9kaXJlY3Rfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSh0LGUpe3RoaXMudGFyZ2V0T2JqZWN0W3RoaXMucHJvcGVydHlOYW1lXT10W2VdLHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ITB9X3NldFZhbHVlX2FycmF5KHQsZSl7bGV0IG49dGhpcy5yZXNvbHZlZFByb3BlcnR5O2ZvcihsZXQgaT0wLHI9bi5sZW5ndGg7aSE9PXI7KytpKW5baV09dFtlKytdfV9zZXRWYWx1ZV9hcnJheV9zZXROZWVkc1VwZGF0ZSh0LGUpe2xldCBuPXRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtmb3IobGV0IGk9MCxyPW4ubGVuZ3RoO2khPT1yOysraSluW2ldPXRbZSsrXTt0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZT0hMH1fc2V0VmFsdWVfYXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSh0LGUpe2xldCBuPXRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtmb3IobGV0IGk9MCxyPW4ubGVuZ3RoO2khPT1yOysraSluW2ldPXRbZSsrXTt0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPSEwfV9zZXRWYWx1ZV9hcnJheUVsZW1lbnQodCxlKXt0aGlzLnJlc29sdmVkUHJvcGVydHlbdGhpcy5wcm9wZXJ0eUluZGV4XT10W2VdfV9zZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TmVlZHNVcGRhdGUodCxlKXt0aGlzLnJlc29sdmVkUHJvcGVydHlbdGhpcy5wcm9wZXJ0eUluZGV4XT10W2VdLHRoaXMudGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlPSEwfV9zZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSh0LGUpe3RoaXMucmVzb2x2ZWRQcm9wZXJ0eVt0aGlzLnByb3BlcnR5SW5kZXhdPXRbZV0sdGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZT0hMH1fc2V0VmFsdWVfZnJvbUFycmF5KHQsZSl7dGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheSh0LGUpfV9zZXRWYWx1ZV9mcm9tQXJyYXlfc2V0TmVlZHNVcGRhdGUodCxlKXt0aGlzLnJlc29sdmVkUHJvcGVydHkuZnJvbUFycmF5KHQsZSksdGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGU9ITB9X3NldFZhbHVlX2Zyb21BcnJheV9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKHQsZSl7dGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheSh0LGUpLHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ITB9X2dldFZhbHVlX3VuYm91bmQodCxlKXt0aGlzLmJpbmQoKSx0aGlzLmdldFZhbHVlKHQsZSl9X3NldFZhbHVlX3VuYm91bmQodCxlKXt0aGlzLmJpbmQoKSx0aGlzLnNldFZhbHVlKHQsZSl9YmluZCgpe2xldCB0PXRoaXMubm9kZSxlPXRoaXMucGFyc2VkUGF0aCxuPWUub2JqZWN0TmFtZSxpPWUucHJvcGVydHlOYW1lLHI9ZS5wcm9wZXJ0eUluZGV4O2lmKHR8fCh0PXMuZmluZE5vZGUodGhpcy5yb290Tm9kZSxlLm5vZGVOYW1lKSx0aGlzLm5vZGU9dCksdGhpcy5nZXRWYWx1ZT10aGlzLl9nZXRWYWx1ZV91bmF2YWlsYWJsZSx0aGlzLnNldFZhbHVlPXRoaXMuX3NldFZhbHVlX3VuYXZhaWxhYmxlLCF0KXtjb25zb2xlLndhcm4oIlRIUkVFLlByb3BlcnR5QmluZGluZzogTm8gdGFyZ2V0IG5vZGUgZm91bmQgZm9yIHRyYWNrOiAiK3RoaXMucGF0aCsiLiIpO3JldHVybn1pZihuKXtsZXQgYz1lLm9iamVjdEluZGV4O3N3aXRjaChuKXtjYXNlIm1hdGVyaWFscyI6aWYoIXQubWF0ZXJpYWwpe2NvbnNvbGUuZXJyb3IoIlRIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFsLiIsdGhpcyk7cmV0dXJufWlmKCF0Lm1hdGVyaWFsLm1hdGVyaWFscyl7Y29uc29sZS5lcnJvcigiVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwubWF0ZXJpYWxzIGFzIG5vZGUubWF0ZXJpYWwgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFscyBhcnJheS4iLHRoaXMpO3JldHVybn10PXQubWF0ZXJpYWwubWF0ZXJpYWxzO2JyZWFrO2Nhc2UiYm9uZXMiOmlmKCF0LnNrZWxldG9uKXtjb25zb2xlLmVycm9yKCJUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBib25lcyBhcyBub2RlIGRvZXMgbm90IGhhdmUgYSBza2VsZXRvbi4iLHRoaXMpO3JldHVybn10PXQuc2tlbGV0b24uYm9uZXM7Zm9yKGxldCBoPTA7aDx0Lmxlbmd0aDtoKyspaWYodFtoXS5uYW1lPT09Yyl7Yz1oO2JyZWFrfWJyZWFrO2Nhc2UibWFwIjppZigibWFwImluIHQpe3Q9dC5tYXA7YnJlYWt9aWYoIXQubWF0ZXJpYWwpe2NvbnNvbGUuZXJyb3IoIlRIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFsLiIsdGhpcyk7cmV0dXJufWlmKCF0Lm1hdGVyaWFsLm1hcCl7Y29uc29sZS5lcnJvcigiVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwubWFwIGFzIG5vZGUubWF0ZXJpYWwgZG9lcyBub3QgaGF2ZSBhIG1hcC4iLHRoaXMpO3JldHVybn10PXQubWF0ZXJpYWwubWFwO2JyZWFrO2RlZmF1bHQ6aWYodFtuXT09PXZvaWQgMCl7Y29uc29sZS5lcnJvcigiVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gb2JqZWN0TmFtZSBvZiBub2RlIHVuZGVmaW5lZC4iLHRoaXMpO3JldHVybn10PXRbbl19aWYoYyE9PXZvaWQgMCl7aWYodFtjXT09PXZvaWQgMCl7Y29uc29sZS5lcnJvcigiVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBUcnlpbmcgdG8gYmluZCB0byBvYmplY3RJbmRleCBvZiBvYmplY3ROYW1lLCBidXQgaXMgdW5kZWZpbmVkLiIsdGhpcyx0KTtyZXR1cm59dD10W2NdfX1sZXQgYT10W2ldO2lmKGE9PT12b2lkIDApe2xldCBjPWUubm9kZU5hbWU7Y29uc29sZS5lcnJvcigiVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBUcnlpbmcgdG8gdXBkYXRlIHByb3BlcnR5IGZvciB0cmFjazogIitjKyIuIitpKyIgYnV0IGl0IHdhc24ndCBmb3VuZC4iLHQpO3JldHVybn1sZXQgbz10aGlzLlZlcnNpb25pbmcuTm9uZTt0aGlzLnRhcmdldE9iamVjdD10LHQubmVlZHNVcGRhdGUhPT12b2lkIDA/bz10aGlzLlZlcnNpb25pbmcuTmVlZHNVcGRhdGU6dC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlIT09dm9pZCAwJiYobz10aGlzLlZlcnNpb25pbmcuTWF0cml4V29ybGROZWVkc1VwZGF0ZSk7bGV0IGw9dGhpcy5CaW5kaW5nVHlwZS5EaXJlY3Q7aWYociE9PXZvaWQgMCl7aWYoaT09PSJtb3JwaFRhcmdldEluZmx1ZW5jZXMiKXtpZighdC5nZW9tZXRyeSl7Y29uc29sZS5lcnJvcigiVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGJlY2F1c2Ugbm9kZSBkb2VzIG5vdCBoYXZlIGEgZ2VvbWV0cnkuIix0aGlzKTtyZXR1cm59aWYoIXQuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzKXtjb25zb2xlLmVycm9yKCJUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtb3JwaFRhcmdldEluZmx1ZW5jZXMgYmVjYXVzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuIix0aGlzKTtyZXR1cm59dC5tb3JwaFRhcmdldERpY3Rpb25hcnlbcl0hPT12b2lkIDAmJihyPXQubW9ycGhUYXJnZXREaWN0aW9uYXJ5W3JdKX1sPXRoaXMuQmluZGluZ1R5cGUuQXJyYXlFbGVtZW50LHRoaXMucmVzb2x2ZWRQcm9wZXJ0eT1hLHRoaXMucHJvcGVydHlJbmRleD1yfWVsc2UgYS5mcm9tQXJyYXkhPT12b2lkIDAmJmEudG9BcnJheSE9PXZvaWQgMD8obD10aGlzLkJpbmRpbmdUeXBlLkhhc0Zyb21Ub0FycmF5LHRoaXMucmVzb2x2ZWRQcm9wZXJ0eT1hKTpBcnJheS5pc0FycmF5KGEpPyhsPXRoaXMuQmluZGluZ1R5cGUuRW50aXJlQXJyYXksdGhpcy5yZXNvbHZlZFByb3BlcnR5PWEpOnRoaXMucHJvcGVydHlOYW1lPWk7dGhpcy5nZXRWYWx1ZT10aGlzLkdldHRlckJ5QmluZGluZ1R5cGVbbF0sdGhpcy5zZXRWYWx1ZT10aGlzLlNldHRlckJ5QmluZGluZ1R5cGVBbmRWZXJzaW9uaW5nW2xdW29dfXVuYmluZCgpe3RoaXMubm9kZT1udWxsLHRoaXMuZ2V0VmFsdWU9dGhpcy5fZ2V0VmFsdWVfdW5ib3VuZCx0aGlzLnNldFZhbHVlPXRoaXMuX3NldFZhbHVlX3VuYm91bmR9fTtRdC5Db21wb3NpdGU9eGg7UXQucHJvdG90eXBlLkJpbmRpbmdUeXBlPXtEaXJlY3Q6MCxFbnRpcmVBcnJheToxLEFycmF5RWxlbWVudDoyLEhhc0Zyb21Ub0FycmF5OjN9O1F0LnByb3RvdHlwZS5WZXJzaW9uaW5nPXtOb25lOjAsTmVlZHNVcGRhdGU6MSxNYXRyaXhXb3JsZE5lZWRzVXBkYXRlOjJ9O1F0LnByb3RvdHlwZS5HZXR0ZXJCeUJpbmRpbmdUeXBlPVtRdC5wcm90b3R5cGUuX2dldFZhbHVlX2RpcmVjdCxRdC5wcm90b3R5cGUuX2dldFZhbHVlX2FycmF5LFF0LnByb3RvdHlwZS5fZ2V0VmFsdWVfYXJyYXlFbGVtZW50LFF0LnByb3RvdHlwZS5fZ2V0VmFsdWVfdG9BcnJheV07UXQucHJvdG90eXBlLlNldHRlckJ5QmluZGluZ1R5cGVBbmRWZXJzaW9uaW5nPVtbUXQucHJvdG90eXBlLl9zZXRWYWx1ZV9kaXJlY3QsUXQucHJvdG90eXBlLl9zZXRWYWx1ZV9kaXJlY3Rfc2V0TmVlZHNVcGRhdGUsUXQucHJvdG90eXBlLl9zZXRWYWx1ZV9kaXJlY3Rfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZV0sW1F0LnByb3RvdHlwZS5fc2V0VmFsdWVfYXJyYXksUXQucHJvdG90eXBlLl9zZXRWYWx1ZV9hcnJheV9zZXROZWVkc1VwZGF0ZSxRdC5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGVdLFtRdC5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5RWxlbWVudCxRdC5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5RWxlbWVudF9zZXROZWVkc1VwZGF0ZSxRdC5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5RWxlbWVudF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlXSxbUXQucHJvdG90eXBlLl9zZXRWYWx1ZV9mcm9tQXJyYXksUXQucHJvdG90eXBlLl9zZXRWYWx1ZV9mcm9tQXJyYXlfc2V0TmVlZHNVcGRhdGUsUXQucHJvdG90eXBlLl9zZXRWYWx1ZV9mcm9tQXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZV1dO3ZhciB2aD1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuaXNBbmltYXRpb25PYmplY3RHcm91cD0hMCx0aGlzLnV1aWQ9WWUoKSx0aGlzLl9vYmplY3RzPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksdGhpcy5uQ2FjaGVkT2JqZWN0c189MDtsZXQgdD17fTt0aGlzLl9pbmRpY2VzQnlVVUlEPXQ7Zm9yKGxldCBuPTAsaT1hcmd1bWVudHMubGVuZ3RoO24hPT1pOysrbil0W2FyZ3VtZW50c1tuXS51dWlkXT1uO3RoaXMuX3BhdGhzPVtdLHRoaXMuX3BhcnNlZFBhdGhzPVtdLHRoaXMuX2JpbmRpbmdzPVtdLHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aD17fTtsZXQgZT10aGlzO3RoaXMuc3RhdHM9e29iamVjdHM6e2dldCB0b3RhbCgpe3JldHVybiBlLl9vYmplY3RzLmxlbmd0aH0sZ2V0IGluVXNlKCl7cmV0dXJuIHRoaXMudG90YWwtZS5uQ2FjaGVkT2JqZWN0c199fSxnZXQgYmluZGluZ3NQZXJPYmplY3QoKXtyZXR1cm4gZS5fYmluZGluZ3MubGVuZ3RofX19YWRkKCl7bGV0IHQ9dGhpcy5fb2JqZWN0cyxlPXRoaXMuX2luZGljZXNCeVVVSUQsbj10aGlzLl9wYXRocyxpPXRoaXMuX3BhcnNlZFBhdGhzLHI9dGhpcy5fYmluZGluZ3MsYT1yLmxlbmd0aCxvLGw9dC5sZW5ndGgsYz10aGlzLm5DYWNoZWRPYmplY3RzXztmb3IobGV0IGg9MCx1PWFyZ3VtZW50cy5sZW5ndGg7aCE9PXU7KytoKXtsZXQgZD1hcmd1bWVudHNbaF0sZj1kLnV1aWQsbT1lW2ZdO2lmKG09PT12b2lkIDApe209bCsrLGVbZl09bSx0LnB1c2goZCk7Zm9yKGxldCBfPTAsZz1hO18hPT1nOysrXylyW19dLnB1c2gobmV3IFF0KGQsbltfXSxpW19dKSl9ZWxzZSBpZihtPGMpe289dFttXTtsZXQgXz0tLWMsZz10W19dO2VbZy51dWlkXT1tLHRbbV09ZyxlW2ZdPV8sdFtfXT1kO2ZvcihsZXQgcD0wLHY9YTtwIT09djsrK3Ape2xldCB4PXJbcF0sTT14W19dLEM9eFttXTt4W21dPU0sQz09PXZvaWQgMCYmKEM9bmV3IFF0KGQsbltwXSxpW3BdKSkseFtfXT1DfX1lbHNlIHRbbV0hPT1vJiZjb25zb2xlLmVycm9yKCJUSFJFRS5BbmltYXRpb25PYmplY3RHcm91cDogRGlmZmVyZW50IG9iamVjdHMgd2l0aCB0aGUgc2FtZSBVVUlEIGRldGVjdGVkLiBDbGVhbiB0aGUgY2FjaGVzIG9yIHJlY3JlYXRlIHlvdXIgaW5mcmFzdHJ1Y3R1cmUgd2hlbiByZWxvYWRpbmcgc2NlbmVzLiIpfXRoaXMubkNhY2hlZE9iamVjdHNfPWN9cmVtb3ZlKCl7bGV0IHQ9dGhpcy5fb2JqZWN0cyxlPXRoaXMuX2luZGljZXNCeVVVSUQsbj10aGlzLl9iaW5kaW5ncyxpPW4ubGVuZ3RoLHI9dGhpcy5uQ2FjaGVkT2JqZWN0c187Zm9yKGxldCBhPTAsbz1hcmd1bWVudHMubGVuZ3RoO2EhPT1vOysrYSl7bGV0IGw9YXJndW1lbnRzW2FdLGM9bC51dWlkLGg9ZVtjXTtpZihoIT09dm9pZCAwJiZoPj1yKXtsZXQgdT1yKyssZD10W3VdO2VbZC51dWlkXT1oLHRbaF09ZCxlW2NdPXUsdFt1XT1sO2ZvcihsZXQgZj0wLG09aTtmIT09bTsrK2Ype2xldCBfPW5bZl0sZz1fW3VdLHA9X1toXTtfW2hdPWcsX1t1XT1wfX19dGhpcy5uQ2FjaGVkT2JqZWN0c189cn11bmNhY2hlKCl7bGV0IHQ9dGhpcy5fb2JqZWN0cyxlPXRoaXMuX2luZGljZXNCeVVVSUQsbj10aGlzLl9iaW5kaW5ncyxpPW4ubGVuZ3RoLHI9dGhpcy5uQ2FjaGVkT2JqZWN0c18sYT10Lmxlbmd0aDtmb3IobGV0IG89MCxsPWFyZ3VtZW50cy5sZW5ndGg7byE9PWw7KytvKXtsZXQgYz1hcmd1bWVudHNbb10saD1jLnV1aWQsdT1lW2hdO2lmKHUhPT12b2lkIDApaWYoZGVsZXRlIGVbaF0sdTxyKXtsZXQgZD0tLXIsZj10W2RdLG09LS1hLF89dFttXTtlW2YudXVpZF09dSx0W3VdPWYsZVtfLnV1aWRdPWQsdFtkXT1fLHQucG9wKCk7Zm9yKGxldCBnPTAscD1pO2chPT1wOysrZyl7bGV0IHY9bltnXSx4PXZbZF0sTT12W21dO3ZbdV09eCx2W2RdPU0sdi5wb3AoKX19ZWxzZXtsZXQgZD0tLWEsZj10W2RdO2Q+MCYmKGVbZi51dWlkXT11KSx0W3VdPWYsdC5wb3AoKTtmb3IobGV0IG09MCxfPWk7bSE9PV87KyttKXtsZXQgZz1uW21dO2dbdV09Z1tkXSxnLnBvcCgpfX19dGhpcy5uQ2FjaGVkT2JqZWN0c189cn1zdWJzY3JpYmVfKHQsZSl7bGV0IG49dGhpcy5fYmluZGluZ3NJbmRpY2VzQnlQYXRoLGk9blt0XSxyPXRoaXMuX2JpbmRpbmdzO2lmKGkhPT12b2lkIDApcmV0dXJuIHJbaV07bGV0IGE9dGhpcy5fcGF0aHMsbz10aGlzLl9wYXJzZWRQYXRocyxsPXRoaXMuX29iamVjdHMsYz1sLmxlbmd0aCxoPXRoaXMubkNhY2hlZE9iamVjdHNfLHU9bmV3IEFycmF5KGMpO2k9ci5sZW5ndGgsblt0XT1pLGEucHVzaCh0KSxvLnB1c2goZSksci5wdXNoKHUpO2ZvcihsZXQgZD1oLGY9bC5sZW5ndGg7ZCE9PWY7KytkKXtsZXQgbT1sW2RdO3VbZF09bmV3IFF0KG0sdCxlKX1yZXR1cm4gdX11bnN1YnNjcmliZV8odCl7bGV0IGU9dGhpcy5fYmluZGluZ3NJbmRpY2VzQnlQYXRoLG49ZVt0XTtpZihuIT09dm9pZCAwKXtsZXQgaT10aGlzLl9wYXRocyxyPXRoaXMuX3BhcnNlZFBhdGhzLGE9dGhpcy5fYmluZGluZ3Msbz1hLmxlbmd0aC0xLGw9YVtvXSxjPXRbb107ZVtjXT1uLGFbbl09bCxhLnBvcCgpLHJbbl09cltvXSxyLnBvcCgpLGlbbl09aVtvXSxpLnBvcCgpfX19LFFvPWNsYXNze2NvbnN0cnVjdG9yKHQsZSxuPW51bGwsaT1lLmJsZW5kTW9kZSl7dGhpcy5fbWl4ZXI9dCx0aGlzLl9jbGlwPWUsdGhpcy5fbG9jYWxSb290PW4sdGhpcy5ibGVuZE1vZGU9aTtsZXQgcj1lLnRyYWNrcyxhPXIubGVuZ3RoLG89bmV3IEFycmF5KGEpLGw9e2VuZGluZ1N0YXJ0OmJpLGVuZGluZ0VuZDpiaX07Zm9yKGxldCBjPTA7YyE9PWE7KytjKXtsZXQgaD1yW2NdLmNyZWF0ZUludGVycG9sYW50KG51bGwpO29bY109aCxoLnNldHRpbmdzPWx9dGhpcy5faW50ZXJwb2xhbnRTZXR0aW5ncz1sLHRoaXMuX2ludGVycG9sYW50cz1vLHRoaXMuX3Byb3BlcnR5QmluZGluZ3M9bmV3IEFycmF5KGEpLHRoaXMuX2NhY2hlSW5kZXg9bnVsbCx0aGlzLl9ieUNsaXBDYWNoZUluZGV4PW51bGwsdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ9bnVsbCx0aGlzLl93ZWlnaHRJbnRlcnBvbGFudD1udWxsLHRoaXMubG9vcD1PZix0aGlzLl9sb29wQ291bnQ9LTEsdGhpcy5fc3RhcnRUaW1lPW51bGwsdGhpcy50aW1lPTAsdGhpcy50aW1lU2NhbGU9MSx0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGU9MSx0aGlzLndlaWdodD0xLHRoaXMuX2VmZmVjdGl2ZVdlaWdodD0xLHRoaXMucmVwZXRpdGlvbnM9MS8wLHRoaXMucGF1c2VkPSExLHRoaXMuZW5hYmxlZD0hMCx0aGlzLmNsYW1wV2hlbkZpbmlzaGVkPSExLHRoaXMuemVyb1Nsb3BlQXRTdGFydD0hMCx0aGlzLnplcm9TbG9wZUF0RW5kPSEwfXBsYXkoKXtyZXR1cm4gdGhpcy5fbWl4ZXIuX2FjdGl2YXRlQWN0aW9uKHRoaXMpLHRoaXN9c3RvcCgpe3JldHVybiB0aGlzLl9taXhlci5fZGVhY3RpdmF0ZUFjdGlvbih0aGlzKSx0aGlzLnJlc2V0KCl9cmVzZXQoKXtyZXR1cm4gdGhpcy5wYXVzZWQ9ITEsdGhpcy5lbmFibGVkPSEwLHRoaXMudGltZT0wLHRoaXMuX2xvb3BDb3VudD0tMSx0aGlzLl9zdGFydFRpbWU9bnVsbCx0aGlzLnN0b3BGYWRpbmcoKS5zdG9wV2FycGluZygpfWlzUnVubmluZygpe3JldHVybiB0aGlzLmVuYWJsZWQmJiF0aGlzLnBhdXNlZCYmdGhpcy50aW1lU2NhbGUhPT0wJiZ0aGlzLl9zdGFydFRpbWU9PT1udWxsJiZ0aGlzLl9taXhlci5faXNBY3RpdmVBY3Rpb24odGhpcyl9aXNTY2hlZHVsZWQoKXtyZXR1cm4gdGhpcy5fbWl4ZXIuX2lzQWN0aXZlQWN0aW9uKHRoaXMpfXN0YXJ0QXQodCl7cmV0dXJuIHRoaXMuX3N0YXJ0VGltZT10LHRoaXN9c2V0TG9vcCh0LGUpe3JldHVybiB0aGlzLmxvb3A9dCx0aGlzLnJlcGV0aXRpb25zPWUsdGhpc31zZXRFZmZlY3RpdmVXZWlnaHQodCl7cmV0dXJuIHRoaXMud2VpZ2h0PXQsdGhpcy5fZWZmZWN0aXZlV2VpZ2h0PXRoaXMuZW5hYmxlZD90OjAsdGhpcy5zdG9wRmFkaW5nKCl9Z2V0RWZmZWN0aXZlV2VpZ2h0KCl7cmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVdlaWdodH1mYWRlSW4odCl7cmV0dXJuIHRoaXMuX3NjaGVkdWxlRmFkaW5nKHQsMCwxKX1mYWRlT3V0KHQpe3JldHVybiB0aGlzLl9zY2hlZHVsZUZhZGluZyh0LDEsMCl9Y3Jvc3NGYWRlRnJvbSh0LGUsbil7aWYodC5mYWRlT3V0KGUpLHRoaXMuZmFkZUluKGUpLG4pe2xldCBpPXRoaXMuX2NsaXAuZHVyYXRpb24scj10Ll9jbGlwLmR1cmF0aW9uLGE9ci9pLG89aS9yO3Qud2FycCgxLGEsZSksdGhpcy53YXJwKG8sMSxlKX1yZXR1cm4gdGhpc31jcm9zc0ZhZGVUbyh0LGUsbil7cmV0dXJuIHQuY3Jvc3NGYWRlRnJvbSh0aGlzLGUsbil9c3RvcEZhZGluZygpe2xldCB0PXRoaXMuX3dlaWdodEludGVycG9sYW50O3JldHVybiB0IT09bnVsbCYmKHRoaXMuX3dlaWdodEludGVycG9sYW50PW51bGwsdGhpcy5fbWl4ZXIuX3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50KHQpKSx0aGlzfXNldEVmZmVjdGl2ZVRpbWVTY2FsZSh0KXtyZXR1cm4gdGhpcy50aW1lU2NhbGU9dCx0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGU9dGhpcy5wYXVzZWQ/MDp0LHRoaXMuc3RvcFdhcnBpbmcoKX1nZXRFZmZlY3RpdmVUaW1lU2NhbGUoKXtyZXR1cm4gdGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlfXNldER1cmF0aW9uKHQpe3JldHVybiB0aGlzLnRpbWVTY2FsZT10aGlzLl9jbGlwLmR1cmF0aW9uL3QsdGhpcy5zdG9wV2FycGluZygpfXN5bmNXaXRoKHQpe3JldHVybiB0aGlzLnRpbWU9dC50aW1lLHRoaXMudGltZVNjYWxlPXQudGltZVNjYWxlLHRoaXMuc3RvcFdhcnBpbmcoKX1oYWx0KHQpe3JldHVybiB0aGlzLndhcnAodGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlLDAsdCl9d2FycCh0LGUsbil7bGV0IGk9dGhpcy5fbWl4ZXIscj1pLnRpbWUsYT10aGlzLnRpbWVTY2FsZSxvPXRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50O289PT1udWxsJiYobz1pLl9sZW5kQ29udHJvbEludGVycG9sYW50KCksdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ9byk7bGV0IGw9by5wYXJhbWV0ZXJQb3NpdGlvbnMsYz1vLnNhbXBsZVZhbHVlcztyZXR1cm4gbFswXT1yLGxbMV09cituLGNbMF09dC9hLGNbMV09ZS9hLHRoaXN9c3RvcFdhcnBpbmcoKXtsZXQgdD10aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudDtyZXR1cm4gdCE9PW51bGwmJih0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudD1udWxsLHRoaXMuX21peGVyLl90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudCh0KSksdGhpc31nZXRNaXhlcigpe3JldHVybiB0aGlzLl9taXhlcn1nZXRDbGlwKCl7cmV0dXJuIHRoaXMuX2NsaXB9Z2V0Um9vdCgpe3JldHVybiB0aGlzLl9sb2NhbFJvb3R8fHRoaXMuX21peGVyLl9yb290fV91cGRhdGUodCxlLG4saSl7aWYoIXRoaXMuZW5hYmxlZCl7dGhpcy5fdXBkYXRlV2VpZ2h0KHQpO3JldHVybn1sZXQgcj10aGlzLl9zdGFydFRpbWU7aWYociE9PW51bGwpe2xldCBsPSh0LXIpKm47bDwwfHxuPT09MD9lPTA6KHRoaXMuX3N0YXJ0VGltZT1udWxsLGU9bipsKX1lKj10aGlzLl91cGRhdGVUaW1lU2NhbGUodCk7bGV0IGE9dGhpcy5fdXBkYXRlVGltZShlKSxvPXRoaXMuX3VwZGF0ZVdlaWdodCh0KTtpZihvPjApe2xldCBsPXRoaXMuX2ludGVycG9sYW50cyxjPXRoaXMuX3Byb3BlcnR5QmluZGluZ3M7c3dpdGNoKHRoaXMuYmxlbmRNb2RlKXtjYXNlIGpoOmZvcihsZXQgaD0wLHU9bC5sZW5ndGg7aCE9PXU7KytoKWxbaF0uZXZhbHVhdGUoYSksY1toXS5hY2N1bXVsYXRlQWRkaXRpdmUobyk7YnJlYWs7Y2FzZSBubDpkZWZhdWx0OmZvcihsZXQgaD0wLHU9bC5sZW5ndGg7aCE9PXU7KytoKWxbaF0uZXZhbHVhdGUoYSksY1toXS5hY2N1bXVsYXRlKGksbyl9fX1fdXBkYXRlV2VpZ2h0KHQpe2xldCBlPTA7aWYodGhpcy5lbmFibGVkKXtlPXRoaXMud2VpZ2h0O2xldCBuPXRoaXMuX3dlaWdodEludGVycG9sYW50O2lmKG4hPT1udWxsKXtsZXQgaT1uLmV2YWx1YXRlKHQpWzBdO2UqPWksdD5uLnBhcmFtZXRlclBvc2l0aW9uc1sxXSYmKHRoaXMuc3RvcEZhZGluZygpLGk9PT0wJiYodGhpcy5lbmFibGVkPSExKSl9fXJldHVybiB0aGlzLl9lZmZlY3RpdmVXZWlnaHQ9ZSxlfV91cGRhdGVUaW1lU2NhbGUodCl7bGV0IGU9MDtpZighdGhpcy5wYXVzZWQpe2U9dGhpcy50aW1lU2NhbGU7bGV0IG49dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ7aWYobiE9PW51bGwpe2xldCBpPW4uZXZhbHVhdGUodClbMF07ZSo9aSx0Pm4ucGFyYW1ldGVyUG9zaXRpb25zWzFdJiYodGhpcy5zdG9wV2FycGluZygpLGU9PT0wP3RoaXMucGF1c2VkPSEwOnRoaXMudGltZVNjYWxlPWUpfX1yZXR1cm4gdGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlPWUsZX1fdXBkYXRlVGltZSh0KXtsZXQgZT10aGlzLl9jbGlwLmR1cmF0aW9uLG49dGhpcy5sb29wLGk9dGhpcy50aW1lK3Qscj10aGlzLl9sb29wQ291bnQsYT1uPT09RmY7aWYodD09PTApcmV0dXJuIHI9PT0tMT9pOmEmJihyJjEpPT09MT9lLWk6aTtpZihuPT09TmYpe3I9PT0tMSYmKHRoaXMuX2xvb3BDb3VudD0wLHRoaXMuX3NldEVuZGluZ3MoITAsITAsITEpKTt0OntpZihpPj1lKWk9ZTtlbHNlIGlmKGk8MClpPTA7ZWxzZXt0aGlzLnRpbWU9aTticmVhayB0fXRoaXMuY2xhbXBXaGVuRmluaXNoZWQ/dGhpcy5wYXVzZWQ9ITA6dGhpcy5lbmFibGVkPSExLHRoaXMudGltZT1pLHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImZpbmlzaGVkIixhY3Rpb246dGhpcyxkaXJlY3Rpb246dDwwPy0xOjF9KX19ZWxzZXtpZihyPT09LTEmJih0Pj0wPyhyPTAsdGhpcy5fc2V0RW5kaW5ncyghMCx0aGlzLnJlcGV0aXRpb25zPT09MCxhKSk6dGhpcy5fc2V0RW5kaW5ncyh0aGlzLnJlcGV0aXRpb25zPT09MCwhMCxhKSksaT49ZXx8aTwwKXtsZXQgbz1NYXRoLmZsb29yKGkvZSk7aS09ZSpvLHIrPU1hdGguYWJzKG8pO2xldCBsPXRoaXMucmVwZXRpdGlvbnMtcjtpZihsPD0wKXRoaXMuY2xhbXBXaGVuRmluaXNoZWQ/dGhpcy5wYXVzZWQ9ITA6dGhpcy5lbmFibGVkPSExLGk9dD4wP2U6MCx0aGlzLnRpbWU9aSx0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KHt0eXBlOiJmaW5pc2hlZCIsYWN0aW9uOnRoaXMsZGlyZWN0aW9uOnQ+MD8xOi0xfSk7ZWxzZXtpZihsPT09MSl7bGV0IGM9dDwwO3RoaXMuX3NldEVuZGluZ3MoYywhYyxhKX1lbHNlIHRoaXMuX3NldEVuZGluZ3MoITEsITEsYSk7dGhpcy5fbG9vcENvdW50PXIsdGhpcy50aW1lPWksdGhpcy5fbWl4ZXIuZGlzcGF0Y2hFdmVudCh7dHlwZToibG9vcCIsYWN0aW9uOnRoaXMsbG9vcERlbHRhOm99KX19ZWxzZSB0aGlzLnRpbWU9aTtpZihhJiYociYxKT09PTEpcmV0dXJuIGUtaX1yZXR1cm4gaX1fc2V0RW5kaW5ncyh0LGUsbil7bGV0IGk9dGhpcy5faW50ZXJwb2xhbnRTZXR0aW5ncztuPyhpLmVuZGluZ1N0YXJ0PUVpLGkuZW5kaW5nRW5kPUVpKToodD9pLmVuZGluZ1N0YXJ0PXRoaXMuemVyb1Nsb3BlQXRTdGFydD9FaTpiaTppLmVuZGluZ1N0YXJ0PWpzLGU/aS5lbmRpbmdFbmQ9dGhpcy56ZXJvU2xvcGVBdEVuZD9FaTpiaTppLmVuZGluZ0VuZD1qcyl9X3NjaGVkdWxlRmFkaW5nKHQsZSxuKXtsZXQgaT10aGlzLl9taXhlcixyPWkudGltZSxhPXRoaXMuX3dlaWdodEludGVycG9sYW50O2E9PT1udWxsJiYoYT1pLl9sZW5kQ29udHJvbEludGVycG9sYW50KCksdGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQ9YSk7bGV0IG89YS5wYXJhbWV0ZXJQb3NpdGlvbnMsbD1hLnNhbXBsZVZhbHVlcztyZXR1cm4gb1swXT1yLGxbMF09ZSxvWzFdPXIrdCxsWzFdPW4sdGhpc319LGh5PW5ldyBGbG9hdDMyQXJyYXkoMSkseWg9Y2xhc3MgZXh0ZW5kcyBsbntjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuX3Jvb3Q9dCx0aGlzLl9pbml0TWVtb3J5TWFuYWdlcigpLHRoaXMuX2FjY3VJbmRleD0wLHRoaXMudGltZT0wLHRoaXMudGltZVNjYWxlPTF9X2JpbmRBY3Rpb24odCxlKXtsZXQgbj10Ll9sb2NhbFJvb3R8fHRoaXMuX3Jvb3QsaT10Ll9jbGlwLnRyYWNrcyxyPWkubGVuZ3RoLGE9dC5fcHJvcGVydHlCaW5kaW5ncyxvPXQuX2ludGVycG9sYW50cyxsPW4udXVpZCxjPXRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxoPWNbbF07aD09PXZvaWQgMCYmKGg9e30sY1tsXT1oKTtmb3IobGV0IHU9MDt1IT09cjsrK3Upe2xldCBkPWlbdV0sZj1kLm5hbWUsbT1oW2ZdO2lmKG0hPT12b2lkIDApKyttLnJlZmVyZW5jZUNvdW50LGFbdV09bTtlbHNle2lmKG09YVt1XSxtIT09dm9pZCAwKXttLl9jYWNoZUluZGV4PT09bnVsbCYmKCsrbS5yZWZlcmVuY2VDb3VudCx0aGlzLl9hZGRJbmFjdGl2ZUJpbmRpbmcobSxsLGYpKTtjb250aW51ZX1sZXQgXz1lJiZlLl9wcm9wZXJ0eUJpbmRpbmdzW3VdLmJpbmRpbmcucGFyc2VkUGF0aDttPW5ldyBLbyhRdC5jcmVhdGUobixmLF8pLGQuVmFsdWVUeXBlTmFtZSxkLmdldFZhbHVlU2l6ZSgpKSwrK20ucmVmZXJlbmNlQ291bnQsdGhpcy5fYWRkSW5hY3RpdmVCaW5kaW5nKG0sbCxmKSxhW3VdPW19b1t1XS5yZXN1bHRCdWZmZXI9bS5idWZmZXJ9fV9hY3RpdmF0ZUFjdGlvbih0KXtpZighdGhpcy5faXNBY3RpdmVBY3Rpb24odCkpe2lmKHQuX2NhY2hlSW5kZXg9PT1udWxsKXtsZXQgbj0odC5fbG9jYWxSb290fHx0aGlzLl9yb290KS51dWlkLGk9dC5fY2xpcC51dWlkLHI9dGhpcy5fYWN0aW9uc0J5Q2xpcFtpXTt0aGlzLl9iaW5kQWN0aW9uKHQsciYmci5rbm93bkFjdGlvbnNbMF0pLHRoaXMuX2FkZEluYWN0aXZlQWN0aW9uKHQsaSxuKX1sZXQgZT10Ll9wcm9wZXJ0eUJpbmRpbmdzO2ZvcihsZXQgbj0wLGk9ZS5sZW5ndGg7biE9PWk7KytuKXtsZXQgcj1lW25dO3IudXNlQ291bnQrKz09PTAmJih0aGlzLl9sZW5kQmluZGluZyhyKSxyLnNhdmVPcmlnaW5hbFN0YXRlKCkpfXRoaXMuX2xlbmRBY3Rpb24odCl9fV9kZWFjdGl2YXRlQWN0aW9uKHQpe2lmKHRoaXMuX2lzQWN0aXZlQWN0aW9uKHQpKXtsZXQgZT10Ll9wcm9wZXJ0eUJpbmRpbmdzO2ZvcihsZXQgbj0wLGk9ZS5sZW5ndGg7biE9PWk7KytuKXtsZXQgcj1lW25dOy0tci51c2VDb3VudD09PTAmJihyLnJlc3RvcmVPcmlnaW5hbFN0YXRlKCksdGhpcy5fdGFrZUJhY2tCaW5kaW5nKHIpKX10aGlzLl90YWtlQmFja0FjdGlvbih0KX19X2luaXRNZW1vcnlNYW5hZ2VyKCl7dGhpcy5fYWN0aW9ucz1bXSx0aGlzLl9uQWN0aXZlQWN0aW9ucz0wLHRoaXMuX2FjdGlvbnNCeUNsaXA9e30sdGhpcy5fYmluZGluZ3M9W10sdGhpcy5fbkFjdGl2ZUJpbmRpbmdzPTAsdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lPXt9LHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHM9W10sdGhpcy5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHM9MDtsZXQgdD10aGlzO3RoaXMuc3RhdHM9e2FjdGlvbnM6e2dldCB0b3RhbCgpe3JldHVybiB0Ll9hY3Rpb25zLmxlbmd0aH0sZ2V0IGluVXNlKCl7cmV0dXJuIHQuX25BY3RpdmVBY3Rpb25zfX0sYmluZGluZ3M6e2dldCB0b3RhbCgpe3JldHVybiB0Ll9iaW5kaW5ncy5sZW5ndGh9LGdldCBpblVzZSgpe3JldHVybiB0Ll9uQWN0aXZlQmluZGluZ3N9fSxjb250cm9sSW50ZXJwb2xhbnRzOntnZXQgdG90YWwoKXtyZXR1cm4gdC5fY29udHJvbEludGVycG9sYW50cy5sZW5ndGh9LGdldCBpblVzZSgpe3JldHVybiB0Ll9uQWN0aXZlQ29udHJvbEludGVycG9sYW50c319fX1faXNBY3RpdmVBY3Rpb24odCl7bGV0IGU9dC5fY2FjaGVJbmRleDtyZXR1cm4gZSE9PW51bGwmJmU8dGhpcy5fbkFjdGl2ZUFjdGlvbnN9X2FkZEluYWN0aXZlQWN0aW9uKHQsZSxuKXtsZXQgaT10aGlzLl9hY3Rpb25zLHI9dGhpcy5fYWN0aW9uc0J5Q2xpcCxhPXJbZV07aWYoYT09PXZvaWQgMClhPXtrbm93bkFjdGlvbnM6W3RdLGFjdGlvbkJ5Um9vdDp7fX0sdC5fYnlDbGlwQ2FjaGVJbmRleD0wLHJbZV09YTtlbHNle2xldCBvPWEua25vd25BY3Rpb25zO3QuX2J5Q2xpcENhY2hlSW5kZXg9by5sZW5ndGgsby5wdXNoKHQpfXQuX2NhY2hlSW5kZXg9aS5sZW5ndGgsaS5wdXNoKHQpLGEuYWN0aW9uQnlSb290W25dPXR9X3JlbW92ZUluYWN0aXZlQWN0aW9uKHQpe2xldCBlPXRoaXMuX2FjdGlvbnMsbj1lW2UubGVuZ3RoLTFdLGk9dC5fY2FjaGVJbmRleDtuLl9jYWNoZUluZGV4PWksZVtpXT1uLGUucG9wKCksdC5fY2FjaGVJbmRleD1udWxsO2xldCByPXQuX2NsaXAudXVpZCxhPXRoaXMuX2FjdGlvbnNCeUNsaXAsbz1hW3JdLGw9by5rbm93bkFjdGlvbnMsYz1sW2wubGVuZ3RoLTFdLGg9dC5fYnlDbGlwQ2FjaGVJbmRleDtjLl9ieUNsaXBDYWNoZUluZGV4PWgsbFtoXT1jLGwucG9wKCksdC5fYnlDbGlwQ2FjaGVJbmRleD1udWxsO2xldCB1PW8uYWN0aW9uQnlSb290LGQ9KHQuX2xvY2FsUm9vdHx8dGhpcy5fcm9vdCkudXVpZDtkZWxldGUgdVtkXSxsLmxlbmd0aD09PTAmJmRlbGV0ZSBhW3JdLHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb24odCl9X3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb24odCl7bGV0IGU9dC5fcHJvcGVydHlCaW5kaW5ncztmb3IobGV0IG49MCxpPWUubGVuZ3RoO24hPT1pOysrbil7bGV0IHI9ZVtuXTstLXIucmVmZXJlbmNlQ291bnQ9PT0wJiZ0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmcocil9fV9sZW5kQWN0aW9uKHQpe2xldCBlPXRoaXMuX2FjdGlvbnMsbj10Ll9jYWNoZUluZGV4LGk9dGhpcy5fbkFjdGl2ZUFjdGlvbnMrKyxyPWVbaV07dC5fY2FjaGVJbmRleD1pLGVbaV09dCxyLl9jYWNoZUluZGV4PW4sZVtuXT1yfV90YWtlQmFja0FjdGlvbih0KXtsZXQgZT10aGlzLl9hY3Rpb25zLG49dC5fY2FjaGVJbmRleCxpPS0tdGhpcy5fbkFjdGl2ZUFjdGlvbnMscj1lW2ldO3QuX2NhY2hlSW5kZXg9aSxlW2ldPXQsci5fY2FjaGVJbmRleD1uLGVbbl09cn1fYWRkSW5hY3RpdmVCaW5kaW5nKHQsZSxuKXtsZXQgaT10aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUscj10aGlzLl9iaW5kaW5ncyxhPWlbZV07YT09PXZvaWQgMCYmKGE9e30saVtlXT1hKSxhW25dPXQsdC5fY2FjaGVJbmRleD1yLmxlbmd0aCxyLnB1c2godCl9X3JlbW92ZUluYWN0aXZlQmluZGluZyh0KXtsZXQgZT10aGlzLl9iaW5kaW5ncyxuPXQuYmluZGluZyxpPW4ucm9vdE5vZGUudXVpZCxyPW4ucGF0aCxhPXRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxvPWFbaV0sbD1lW2UubGVuZ3RoLTFdLGM9dC5fY2FjaGVJbmRleDtsLl9jYWNoZUluZGV4PWMsZVtjXT1sLGUucG9wKCksZGVsZXRlIG9bcl0sT2JqZWN0LmtleXMobykubGVuZ3RoPT09MCYmZGVsZXRlIGFbaV19X2xlbmRCaW5kaW5nKHQpe2xldCBlPXRoaXMuX2JpbmRpbmdzLG49dC5fY2FjaGVJbmRleCxpPXRoaXMuX25BY3RpdmVCaW5kaW5ncysrLHI9ZVtpXTt0Ll9jYWNoZUluZGV4PWksZVtpXT10LHIuX2NhY2hlSW5kZXg9bixlW25dPXJ9X3Rha2VCYWNrQmluZGluZyh0KXtsZXQgZT10aGlzLl9iaW5kaW5ncyxuPXQuX2NhY2hlSW5kZXgsaT0tLXRoaXMuX25BY3RpdmVCaW5kaW5ncyxyPWVbaV07dC5fY2FjaGVJbmRleD1pLGVbaV09dCxyLl9jYWNoZUluZGV4PW4sZVtuXT1yfV9sZW5kQ29udHJvbEludGVycG9sYW50KCl7bGV0IHQ9dGhpcy5fY29udHJvbEludGVycG9sYW50cyxlPXRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzKyssbj10W2VdO3JldHVybiBuPT09dm9pZCAwJiYobj1uZXcgUHIobmV3IEZsb2F0MzJBcnJheSgyKSxuZXcgRmxvYXQzMkFycmF5KDIpLDEsaHkpLG4uX19jYWNoZUluZGV4PWUsdFtlXT1uKSxufV90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudCh0KXtsZXQgZT10aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzLG49dC5fX2NhY2hlSW5kZXgsaT0tLXRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzLHI9ZVtpXTt0Ll9fY2FjaGVJbmRleD1pLGVbaV09dCxyLl9fY2FjaGVJbmRleD1uLGVbbl09cn1jbGlwQWN0aW9uKHQsZSxuKXtsZXQgaT1lfHx0aGlzLl9yb290LHI9aS51dWlkLGE9dHlwZW9mIHQ9PSJzdHJpbmciP3ppLmZpbmRCeU5hbWUoaSx0KTp0LG89YSE9PW51bGw/YS51dWlkOnQsbD10aGlzLl9hY3Rpb25zQnlDbGlwW29dLGM9bnVsbDtpZihuPT09dm9pZCAwJiYoYSE9PW51bGw/bj1hLmJsZW5kTW9kZTpuPW5sKSxsIT09dm9pZCAwKXtsZXQgdT1sLmFjdGlvbkJ5Um9vdFtyXTtpZih1IT09dm9pZCAwJiZ1LmJsZW5kTW9kZT09PW4pcmV0dXJuIHU7Yz1sLmtub3duQWN0aW9uc1swXSxhPT09bnVsbCYmKGE9Yy5fY2xpcCl9aWYoYT09PW51bGwpcmV0dXJuIG51bGw7bGV0IGg9bmV3IFFvKHRoaXMsYSxlLG4pO3JldHVybiB0aGlzLl9iaW5kQWN0aW9uKGgsYyksdGhpcy5fYWRkSW5hY3RpdmVBY3Rpb24oaCxvLHIpLGh9ZXhpc3RpbmdBY3Rpb24odCxlKXtsZXQgbj1lfHx0aGlzLl9yb290LGk9bi51dWlkLHI9dHlwZW9mIHQ9PSJzdHJpbmciP3ppLmZpbmRCeU5hbWUobix0KTp0LGE9cj9yLnV1aWQ6dCxvPXRoaXMuX2FjdGlvbnNCeUNsaXBbYV07cmV0dXJuIG8hPT12b2lkIDAmJm8uYWN0aW9uQnlSb290W2ldfHxudWxsfXN0b3BBbGxBY3Rpb24oKXtsZXQgdD10aGlzLl9hY3Rpb25zLGU9dGhpcy5fbkFjdGl2ZUFjdGlvbnM7Zm9yKGxldCBuPWUtMTtuPj0wOy0tbil0W25dLnN0b3AoKTtyZXR1cm4gdGhpc311cGRhdGUodCl7dCo9dGhpcy50aW1lU2NhbGU7bGV0IGU9dGhpcy5fYWN0aW9ucyxuPXRoaXMuX25BY3RpdmVBY3Rpb25zLGk9dGhpcy50aW1lKz10LHI9TWF0aC5zaWduKHQpLGE9dGhpcy5fYWNjdUluZGV4Xj0xO2ZvcihsZXQgYz0wO2MhPT1uOysrYyllW2NdLl91cGRhdGUoaSx0LHIsYSk7bGV0IG89dGhpcy5fYmluZGluZ3MsbD10aGlzLl9uQWN0aXZlQmluZGluZ3M7Zm9yKGxldCBjPTA7YyE9PWw7KytjKW9bY10uYXBwbHkoYSk7cmV0dXJuIHRoaXN9c2V0VGltZSh0KXt0aGlzLnRpbWU9MDtmb3IobGV0IGU9MDtlPHRoaXMuX2FjdGlvbnMubGVuZ3RoO2UrKyl0aGlzLl9hY3Rpb25zW2VdLnRpbWU9MDtyZXR1cm4gdGhpcy51cGRhdGUodCl9Z2V0Um9vdCgpe3JldHVybiB0aGlzLl9yb290fXVuY2FjaGVDbGlwKHQpe2xldCBlPXRoaXMuX2FjdGlvbnMsbj10LnV1aWQsaT10aGlzLl9hY3Rpb25zQnlDbGlwLHI9aVtuXTtpZihyIT09dm9pZCAwKXtsZXQgYT1yLmtub3duQWN0aW9ucztmb3IobGV0IG89MCxsPWEubGVuZ3RoO28hPT1sOysrbyl7bGV0IGM9YVtvXTt0aGlzLl9kZWFjdGl2YXRlQWN0aW9uKGMpO2xldCBoPWMuX2NhY2hlSW5kZXgsdT1lW2UubGVuZ3RoLTFdO2MuX2NhY2hlSW5kZXg9bnVsbCxjLl9ieUNsaXBDYWNoZUluZGV4PW51bGwsdS5fY2FjaGVJbmRleD1oLGVbaF09dSxlLnBvcCgpLHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb24oYyl9ZGVsZXRlIGlbbl19fXVuY2FjaGVSb290KHQpe2xldCBlPXQudXVpZCxuPXRoaXMuX2FjdGlvbnNCeUNsaXA7Zm9yKGxldCBhIGluIG4pe2xldCBvPW5bYV0uYWN0aW9uQnlSb290LGw9b1tlXTtsIT09dm9pZCAwJiYodGhpcy5fZGVhY3RpdmF0ZUFjdGlvbihsKSx0aGlzLl9yZW1vdmVJbmFjdGl2ZUFjdGlvbihsKSl9bGV0IGk9dGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLHI9aVtlXTtpZihyIT09dm9pZCAwKWZvcihsZXQgYSBpbiByKXtsZXQgbz1yW2FdO28ucmVzdG9yZU9yaWdpbmFsU3RhdGUoKSx0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmcobyl9fXVuY2FjaGVBY3Rpb24odCxlKXtsZXQgbj10aGlzLmV4aXN0aW5nQWN0aW9uKHQsZSk7biE9PW51bGwmJih0aGlzLl9kZWFjdGl2YXRlQWN0aW9uKG4pLHRoaXMuX3JlbW92ZUluYWN0aXZlQWN0aW9uKG4pKX19LE1oPWNsYXNzIHN7Y29uc3RydWN0b3IodCl7dGhpcy52YWx1ZT10fWNsb25lKCl7cmV0dXJuIG5ldyBzKHRoaXMudmFsdWUuY2xvbmU9PT12b2lkIDA/dGhpcy52YWx1ZTp0aGlzLnZhbHVlLmNsb25lKCkpfX0sdXk9MCxTaD1jbGFzcyBleHRlbmRzIGxue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLmlzVW5pZm9ybXNHcm91cD0hMCxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiaWQiLHt2YWx1ZTp1eSsrfSksdGhpcy5uYW1lPSIiLHRoaXMudXNhZ2U9aXIsdGhpcy51bmlmb3Jtcz1bXX1hZGQodCl7cmV0dXJuIHRoaXMudW5pZm9ybXMucHVzaCh0KSx0aGlzfXJlbW92ZSh0KXtsZXQgZT10aGlzLnVuaWZvcm1zLmluZGV4T2YodCk7cmV0dXJuIGUhPT0tMSYmdGhpcy51bmlmb3Jtcy5zcGxpY2UoZSwxKSx0aGlzfXNldE5hbWUodCl7cmV0dXJuIHRoaXMubmFtZT10LHRoaXN9c2V0VXNhZ2UodCl7cmV0dXJuIHRoaXMudXNhZ2U9dCx0aGlzfWRpc3Bvc2UoKXtyZXR1cm4gdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJkaXNwb3NlIn0pLHRoaXN9Y29weSh0KXt0aGlzLm5hbWU9dC5uYW1lLHRoaXMudXNhZ2U9dC51c2FnZTtsZXQgZT10LnVuaWZvcm1zO3RoaXMudW5pZm9ybXMubGVuZ3RoPTA7Zm9yKGxldCBuPTAsaT1lLmxlbmd0aDtuPGk7bisrKXtsZXQgcj1BcnJheS5pc0FycmF5KGVbbl0pP2Vbbl06W2Vbbl1dO2ZvcihsZXQgYT0wO2E8ci5sZW5ndGg7YSsrKXRoaXMudW5pZm9ybXMucHVzaChyW2FdLmNsb25lKCkpfXJldHVybiB0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX19LGJoPWNsYXNzIGV4dGVuZHMgU3N7Y29uc3RydWN0b3IodCxlLG49MSl7c3VwZXIodCxlKSx0aGlzLmlzSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXI9ITAsdGhpcy5tZXNoUGVyQXR0cmlidXRlPW59Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLm1lc2hQZXJBdHRyaWJ1dGU9dC5tZXNoUGVyQXR0cmlidXRlLHRoaXN9Y2xvbmUodCl7bGV0IGU9c3VwZXIuY2xvbmUodCk7cmV0dXJuIGUubWVzaFBlckF0dHJpYnV0ZT10aGlzLm1lc2hQZXJBdHRyaWJ1dGUsZX10b0pTT04odCl7bGV0IGU9c3VwZXIudG9KU09OKHQpO3JldHVybiBlLmlzSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXI9ITAsZS5tZXNoUGVyQXR0cmlidXRlPXRoaXMubWVzaFBlckF0dHJpYnV0ZSxlfX0sRWg9Y2xhc3N7Y29uc3RydWN0b3IodCxlLG4saSxyKXt0aGlzLmlzR0xCdWZmZXJBdHRyaWJ1dGU9ITAsdGhpcy5uYW1lPSIiLHRoaXMuYnVmZmVyPXQsdGhpcy50eXBlPWUsdGhpcy5pdGVtU2l6ZT1uLHRoaXMuZWxlbWVudFNpemU9aSx0aGlzLmNvdW50PXIsdGhpcy52ZXJzaW9uPTB9c2V0IG5lZWRzVXBkYXRlKHQpe3Q9PT0hMCYmdGhpcy52ZXJzaW9uKyt9c2V0QnVmZmVyKHQpe3JldHVybiB0aGlzLmJ1ZmZlcj10LHRoaXN9c2V0VHlwZSh0LGUpe3JldHVybiB0aGlzLnR5cGU9dCx0aGlzLmVsZW1lbnRTaXplPWUsdGhpc31zZXRJdGVtU2l6ZSh0KXtyZXR1cm4gdGhpcy5pdGVtU2l6ZT10LHRoaXN9c2V0Q291bnQodCl7cmV0dXJuIHRoaXMuY291bnQ9dCx0aGlzfX0sQWg9Y2xhc3N7Y29uc3RydWN0b3IodCxlLG49MCxpPTEvMCl7dGhpcy5yYXk9bmV3IG5pKHQsZSksdGhpcy5uZWFyPW4sdGhpcy5mYXI9aSx0aGlzLmNhbWVyYT1udWxsLHRoaXMubGF5ZXJzPW5ldyBfcyx0aGlzLnBhcmFtcz17TWVzaDp7fSxMaW5lOnt0aHJlc2hvbGQ6MX0sTE9EOnt9LFBvaW50czp7dGhyZXNob2xkOjF9LFNwcml0ZTp7fX19c2V0KHQsZSl7dGhpcy5yYXkuc2V0KHQsZSl9c2V0RnJvbUNhbWVyYSh0LGUpe2UuaXNQZXJzcGVjdGl2ZUNhbWVyYT8odGhpcy5yYXkub3JpZ2luLnNldEZyb21NYXRyaXhQb3NpdGlvbihlLm1hdHJpeFdvcmxkKSx0aGlzLnJheS5kaXJlY3Rpb24uc2V0KHQueCx0LnksLjUpLnVucHJvamVjdChlKS5zdWIodGhpcy5yYXkub3JpZ2luKS5ub3JtYWxpemUoKSx0aGlzLmNhbWVyYT1lKTplLmlzT3J0aG9ncmFwaGljQ2FtZXJhPyh0aGlzLnJheS5vcmlnaW4uc2V0KHQueCx0LnksKGUubmVhcitlLmZhcikvKGUubmVhci1lLmZhcikpLnVucHJvamVjdChlKSx0aGlzLnJheS5kaXJlY3Rpb24uc2V0KDAsMCwtMSkudHJhbnNmb3JtRGlyZWN0aW9uKGUubWF0cml4V29ybGQpLHRoaXMuY2FtZXJhPWUpOmNvbnNvbGUuZXJyb3IoIlRIUkVFLlJheWNhc3RlcjogVW5zdXBwb3J0ZWQgY2FtZXJhIHR5cGU6ICIrZS50eXBlKX1pbnRlcnNlY3RPYmplY3QodCxlPSEwLG49W10pe3JldHVybiBUaCh0LHRoaXMsbixlKSxuLnNvcnQoT2QpLG59aW50ZXJzZWN0T2JqZWN0cyh0LGU9ITAsbj1bXSl7Zm9yKGxldCBpPTAscj10Lmxlbmd0aDtpPHI7aSsrKVRoKHRbaV0sdGhpcyxuLGUpO3JldHVybiBuLnNvcnQoT2QpLG59fTtmdW5jdGlvbiBPZChzLHQpe3JldHVybiBzLmRpc3RhbmNlLXQuZGlzdGFuY2V9ZnVuY3Rpb24gVGgocyx0LGUsbil7aWYocy5sYXllcnMudGVzdCh0LmxheWVycykmJnMucmF5Y2FzdCh0LGUpLG49PT0hMCl7bGV0IGk9cy5jaGlsZHJlbjtmb3IobGV0IHI9MCxhPWkubGVuZ3RoO3I8YTtyKyspVGgoaVtyXSx0LGUsITApfX12YXIgd2g9Y2xhc3N7Y29uc3RydWN0b3IodD0xLGU9MCxuPTApe3JldHVybiB0aGlzLnJhZGl1cz10LHRoaXMucGhpPWUsdGhpcy50aGV0YT1uLHRoaXN9c2V0KHQsZSxuKXtyZXR1cm4gdGhpcy5yYWRpdXM9dCx0aGlzLnBoaT1lLHRoaXMudGhldGE9bix0aGlzfWNvcHkodCl7cmV0dXJuIHRoaXMucmFkaXVzPXQucmFkaXVzLHRoaXMucGhpPXQucGhpLHRoaXMudGhldGE9dC50aGV0YSx0aGlzfW1ha2VTYWZlKCl7cmV0dXJuIHRoaXMucGhpPU1hdGgubWF4KDFlLTYsTWF0aC5taW4oTWF0aC5QSS0xZS02LHRoaXMucGhpKSksdGhpc31zZXRGcm9tVmVjdG9yMyh0KXtyZXR1cm4gdGhpcy5zZXRGcm9tQ2FydGVzaWFuQ29vcmRzKHQueCx0LnksdC56KX1zZXRGcm9tQ2FydGVzaWFuQ29vcmRzKHQsZSxuKXtyZXR1cm4gdGhpcy5yYWRpdXM9TWF0aC5zcXJ0KHQqdCtlKmUrbipuKSx0aGlzLnJhZGl1cz09PTA/KHRoaXMudGhldGE9MCx0aGlzLnBoaT0wKToodGhpcy50aGV0YT1NYXRoLmF0YW4yKHQsbiksdGhpcy5waGk9TWF0aC5hY29zKHVlKGUvdGhpcy5yYWRpdXMsLTEsMSkpKSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX19LFJoPWNsYXNze2NvbnN0cnVjdG9yKHQ9MSxlPTAsbj0wKXtyZXR1cm4gdGhpcy5yYWRpdXM9dCx0aGlzLnRoZXRhPWUsdGhpcy55PW4sdGhpc31zZXQodCxlLG4pe3JldHVybiB0aGlzLnJhZGl1cz10LHRoaXMudGhldGE9ZSx0aGlzLnk9bix0aGlzfWNvcHkodCl7cmV0dXJuIHRoaXMucmFkaXVzPXQucmFkaXVzLHRoaXMudGhldGE9dC50aGV0YSx0aGlzLnk9dC55LHRoaXN9c2V0RnJvbVZlY3RvcjModCl7cmV0dXJuIHRoaXMuc2V0RnJvbUNhcnRlc2lhbkNvb3Jkcyh0LngsdC55LHQueil9c2V0RnJvbUNhcnRlc2lhbkNvb3Jkcyh0LGUsbil7cmV0dXJuIHRoaXMucmFkaXVzPU1hdGguc3FydCh0KnQrbipuKSx0aGlzLnRoZXRhPU1hdGguYXRhbjIodCxuKSx0aGlzLnk9ZSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX19LEZkPW5ldyBaLENoPWNsYXNze2NvbnN0cnVjdG9yKHQ9bmV3IFooMS8wLDEvMCksZT1uZXcgWigtMS8wLC0xLzApKXt0aGlzLmlzQm94Mj0hMCx0aGlzLm1pbj10LHRoaXMubWF4PWV9c2V0KHQsZSl7cmV0dXJuIHRoaXMubWluLmNvcHkodCksdGhpcy5tYXguY29weShlKSx0aGlzfXNldEZyb21Qb2ludHModCl7dGhpcy5tYWtlRW1wdHkoKTtmb3IobGV0IGU9MCxuPXQubGVuZ3RoO2U8bjtlKyspdGhpcy5leHBhbmRCeVBvaW50KHRbZV0pO3JldHVybiB0aGlzfXNldEZyb21DZW50ZXJBbmRTaXplKHQsZSl7bGV0IG49RmQuY29weShlKS5tdWx0aXBseVNjYWxhciguNSk7cmV0dXJuIHRoaXMubWluLmNvcHkodCkuc3ViKG4pLHRoaXMubWF4LmNvcHkodCkuYWRkKG4pLHRoaXN9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpfWNvcHkodCl7cmV0dXJuIHRoaXMubWluLmNvcHkodC5taW4pLHRoaXMubWF4LmNvcHkodC5tYXgpLHRoaXN9bWFrZUVtcHR5KCl7cmV0dXJuIHRoaXMubWluLng9dGhpcy5taW4ueT0xLzAsdGhpcy5tYXgueD10aGlzLm1heC55PS0xLzAsdGhpc31pc0VtcHR5KCl7cmV0dXJuIHRoaXMubWF4Lng8dGhpcy5taW4ueHx8dGhpcy5tYXgueTx0aGlzLm1pbi55fWdldENlbnRlcih0KXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/dC5zZXQoMCwwKTp0LmFkZFZlY3RvcnModGhpcy5taW4sdGhpcy5tYXgpLm11bHRpcGx5U2NhbGFyKC41KX1nZXRTaXplKHQpe3JldHVybiB0aGlzLmlzRW1wdHkoKT90LnNldCgwLDApOnQuc3ViVmVjdG9ycyh0aGlzLm1heCx0aGlzLm1pbil9ZXhwYW5kQnlQb2ludCh0KXtyZXR1cm4gdGhpcy5taW4ubWluKHQpLHRoaXMubWF4Lm1heCh0KSx0aGlzfWV4cGFuZEJ5VmVjdG9yKHQpe3JldHVybiB0aGlzLm1pbi5zdWIodCksdGhpcy5tYXguYWRkKHQpLHRoaXN9ZXhwYW5kQnlTY2FsYXIodCl7cmV0dXJuIHRoaXMubWluLmFkZFNjYWxhcigtdCksdGhpcy5tYXguYWRkU2NhbGFyKHQpLHRoaXN9Y29udGFpbnNQb2ludCh0KXtyZXR1cm4hKHQueDx0aGlzLm1pbi54fHx0Lng+dGhpcy5tYXgueHx8dC55PHRoaXMubWluLnl8fHQueT50aGlzLm1heC55KX1jb250YWluc0JveCh0KXtyZXR1cm4gdGhpcy5taW4ueDw9dC5taW4ueCYmdC5tYXgueDw9dGhpcy5tYXgueCYmdGhpcy5taW4ueTw9dC5taW4ueSYmdC5tYXgueTw9dGhpcy5tYXgueX1nZXRQYXJhbWV0ZXIodCxlKXtyZXR1cm4gZS5zZXQoKHQueC10aGlzLm1pbi54KS8odGhpcy5tYXgueC10aGlzLm1pbi54KSwodC55LXRoaXMubWluLnkpLyh0aGlzLm1heC55LXRoaXMubWluLnkpKX1pbnRlcnNlY3RzQm94KHQpe3JldHVybiEodC5tYXgueDx0aGlzLm1pbi54fHx0Lm1pbi54PnRoaXMubWF4Lnh8fHQubWF4Lnk8dGhpcy5taW4ueXx8dC5taW4ueT50aGlzLm1heC55KX1jbGFtcFBvaW50KHQsZSl7cmV0dXJuIGUuY29weSh0KS5jbGFtcCh0aGlzLm1pbix0aGlzLm1heCl9ZGlzdGFuY2VUb1BvaW50KHQpe3JldHVybiB0aGlzLmNsYW1wUG9pbnQodCxGZCkuZGlzdGFuY2VUbyh0KX1pbnRlcnNlY3QodCl7cmV0dXJuIHRoaXMubWluLm1heCh0Lm1pbiksdGhpcy5tYXgubWluKHQubWF4KSx0aGlzLmlzRW1wdHkoKSYmdGhpcy5tYWtlRW1wdHkoKSx0aGlzfXVuaW9uKHQpe3JldHVybiB0aGlzLm1pbi5taW4odC5taW4pLHRoaXMubWF4Lm1heCh0Lm1heCksdGhpc310cmFuc2xhdGUodCl7cmV0dXJuIHRoaXMubWluLmFkZCh0KSx0aGlzLm1heC5hZGQodCksdGhpc31lcXVhbHModCl7cmV0dXJuIHQubWluLmVxdWFscyh0aGlzLm1pbikmJnQubWF4LmVxdWFscyh0aGlzLm1heCl9fSxCZD1uZXcgUixBYT1uZXcgUixQaD1jbGFzc3tjb25zdHJ1Y3Rvcih0PW5ldyBSLGU9bmV3IFIpe3RoaXMuc3RhcnQ9dCx0aGlzLmVuZD1lfXNldCh0LGUpe3JldHVybiB0aGlzLnN0YXJ0LmNvcHkodCksdGhpcy5lbmQuY29weShlKSx0aGlzfWNvcHkodCl7cmV0dXJuIHRoaXMuc3RhcnQuY29weSh0LnN0YXJ0KSx0aGlzLmVuZC5jb3B5KHQuZW5kKSx0aGlzfWdldENlbnRlcih0KXtyZXR1cm4gdC5hZGRWZWN0b3JzKHRoaXMuc3RhcnQsdGhpcy5lbmQpLm11bHRpcGx5U2NhbGFyKC41KX1kZWx0YSh0KXtyZXR1cm4gdC5zdWJWZWN0b3JzKHRoaXMuZW5kLHRoaXMuc3RhcnQpfWRpc3RhbmNlU3EoKXtyZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvU3F1YXJlZCh0aGlzLmVuZCl9ZGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvKHRoaXMuZW5kKX1hdCh0LGUpe3JldHVybiB0aGlzLmRlbHRhKGUpLm11bHRpcGx5U2NhbGFyKHQpLmFkZCh0aGlzLnN0YXJ0KX1jbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyKHQsZSl7QmQuc3ViVmVjdG9ycyh0LHRoaXMuc3RhcnQpLEFhLnN1YlZlY3RvcnModGhpcy5lbmQsdGhpcy5zdGFydCk7bGV0IG49QWEuZG90KEFhKSxyPUFhLmRvdChCZCkvbjtyZXR1cm4gZSYmKHI9dWUociwwLDEpKSxyfWNsb3Nlc3RQb2ludFRvUG9pbnQodCxlLG4pe2xldCBpPXRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlcih0LGUpO3JldHVybiB0aGlzLmRlbHRhKG4pLm11bHRpcGx5U2NhbGFyKGkpLmFkZCh0aGlzLnN0YXJ0KX1hcHBseU1hdHJpeDQodCl7cmV0dXJuIHRoaXMuc3RhcnQuYXBwbHlNYXRyaXg0KHQpLHRoaXMuZW5kLmFwcGx5TWF0cml4NCh0KSx0aGlzfWVxdWFscyh0KXtyZXR1cm4gdC5zdGFydC5lcXVhbHModGhpcy5zdGFydCkmJnQuZW5kLmVxdWFscyh0aGlzLmVuZCl9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpfX0semQ9bmV3IFIsTGg9Y2xhc3MgZXh0ZW5kcyBKdHtjb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKCksdGhpcy5saWdodD10LHRoaXMubWF0cml4PXQubWF0cml4V29ybGQsdGhpcy5tYXRyaXhBdXRvVXBkYXRlPSExLHRoaXMuY29sb3I9ZSx0aGlzLnR5cGU9IlNwb3RMaWdodEhlbHBlciI7bGV0IG49bmV3IEh0LGk9WzAsMCwwLDAsMCwxLDAsMCwwLDEsMCwxLDAsMCwwLC0xLDAsMSwwLDAsMCwwLDEsMSwwLDAsMCwwLC0xLDFdO2ZvcihsZXQgYT0wLG89MSxsPTMyO2E8bDthKyssbysrKXtsZXQgYz1hL2wqTWF0aC5QSSoyLGg9by9sKk1hdGguUEkqMjtpLnB1c2goTWF0aC5jb3MoYyksTWF0aC5zaW4oYyksMSxNYXRoLmNvcyhoKSxNYXRoLnNpbihoKSwxKX1uLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBndChpLDMpKTtsZXQgcj1uZXcgUmUoe2ZvZzohMSx0b25lTWFwcGVkOiExfSk7dGhpcy5jb25lPW5ldyBubihuLHIpLHRoaXMuYWRkKHRoaXMuY29uZSksdGhpcy51cGRhdGUoKX1kaXNwb3NlKCl7dGhpcy5jb25lLmdlb21ldHJ5LmRpc3Bvc2UoKSx0aGlzLmNvbmUubWF0ZXJpYWwuZGlzcG9zZSgpfXVwZGF0ZSgpe3RoaXMubGlnaHQudXBkYXRlV29ybGRNYXRyaXgoITAsITEpLHRoaXMubGlnaHQudGFyZ2V0LnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKTtsZXQgdD10aGlzLmxpZ2h0LmRpc3RhbmNlP3RoaXMubGlnaHQuZGlzdGFuY2U6MWUzLGU9dCpNYXRoLnRhbih0aGlzLmxpZ2h0LmFuZ2xlKTt0aGlzLmNvbmUuc2NhbGUuc2V0KGUsZSx0KSx6ZC5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQpLHRoaXMuY29uZS5sb29rQXQoemQpLHRoaXMuY29sb3IhPT12b2lkIDA/dGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLnNldCh0aGlzLmNvbG9yKTp0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3IuY29weSh0aGlzLmxpZ2h0LmNvbG9yKX19LEpuPW5ldyBSLFRhPW5ldyBMdCxYbD1uZXcgTHQsSWg9Y2xhc3MgZXh0ZW5kcyBubntjb25zdHJ1Y3Rvcih0KXtsZXQgZT1mcCh0KSxuPW5ldyBIdCxpPVtdLHI9W10sYT1uZXcgdXQoMCwwLDEpLG89bmV3IHV0KDAsMSwwKTtmb3IobGV0IGM9MDtjPGUubGVuZ3RoO2MrKyl7bGV0IGg9ZVtjXTtoLnBhcmVudCYmaC5wYXJlbnQuaXNCb25lJiYoaS5wdXNoKDAsMCwwKSxpLnB1c2goMCwwLDApLHIucHVzaChhLnIsYS5nLGEuYiksci5wdXNoKG8ucixvLmcsby5iKSl9bi5zZXRBdHRyaWJ1dGUoInBvc2l0aW9uIixuZXcgZ3QoaSwzKSksbi5zZXRBdHRyaWJ1dGUoImNvbG9yIixuZXcgZ3QociwzKSk7bGV0IGw9bmV3IFJlKHt2ZXJ0ZXhDb2xvcnM6ITAsZGVwdGhUZXN0OiExLGRlcHRoV3JpdGU6ITEsdG9uZU1hcHBlZDohMSx0cmFuc3BhcmVudDohMH0pO3N1cGVyKG4sbCksdGhpcy5pc1NrZWxldG9uSGVscGVyPSEwLHRoaXMudHlwZT0iU2tlbGV0b25IZWxwZXIiLHRoaXMucm9vdD10LHRoaXMuYm9uZXM9ZSx0aGlzLm1hdHJpeD10Lm1hdHJpeFdvcmxkLHRoaXMubWF0cml4QXV0b1VwZGF0ZT0hMX11cGRhdGVNYXRyaXhXb3JsZCh0KXtsZXQgZT10aGlzLmJvbmVzLG49dGhpcy5nZW9tZXRyeSxpPW4uZ2V0QXR0cmlidXRlKCJwb3NpdGlvbiIpO1hsLmNvcHkodGhpcy5yb290Lm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtmb3IobGV0IHI9MCxhPTA7cjxlLmxlbmd0aDtyKyspe2xldCBvPWVbcl07by5wYXJlbnQmJm8ucGFyZW50LmlzQm9uZSYmKFRhLm11bHRpcGx5TWF0cmljZXMoWGwsby5tYXRyaXhXb3JsZCksSm4uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKFRhKSxpLnNldFhZWihhLEpuLngsSm4ueSxKbi56KSxUYS5tdWx0aXBseU1hdHJpY2VzKFhsLG8ucGFyZW50Lm1hdHJpeFdvcmxkKSxKbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oVGEpLGkuc2V0WFlaKGErMSxKbi54LEpuLnksSm4ueiksYSs9Mil9bi5nZXRBdHRyaWJ1dGUoInBvc2l0aW9uIikubmVlZHNVcGRhdGU9ITAsc3VwZXIudXBkYXRlTWF0cml4V29ybGQodCl9ZGlzcG9zZSgpe3RoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpLHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpfX07ZnVuY3Rpb24gZnAocyl7bGV0IHQ9W107cy5pc0JvbmU9PT0hMCYmdC5wdXNoKHMpO2ZvcihsZXQgZT0wO2U8cy5jaGlsZHJlbi5sZW5ndGg7ZSsrKXQucHVzaC5hcHBseSh0LGZwKHMuY2hpbGRyZW5bZV0pKTtyZXR1cm4gdH12YXIgVWg9Y2xhc3MgZXh0ZW5kcyBkZXtjb25zdHJ1Y3Rvcih0LGUsbil7bGV0IGk9bmV3IFJyKGUsNCwyKSxyPW5ldyB4bih7d2lyZWZyYW1lOiEwLGZvZzohMSx0b25lTWFwcGVkOiExfSk7c3VwZXIoaSxyKSx0aGlzLmxpZ2h0PXQsdGhpcy5jb2xvcj1uLHRoaXMudHlwZT0iUG9pbnRMaWdodEhlbHBlciIsdGhpcy5tYXRyaXg9dGhpcy5saWdodC5tYXRyaXhXb3JsZCx0aGlzLm1hdHJpeEF1dG9VcGRhdGU9ITEsdGhpcy51cGRhdGUoKX1kaXNwb3NlKCl7dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCksdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCl9dXBkYXRlKCl7dGhpcy5saWdodC51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSksdGhpcy5jb2xvciE9PXZvaWQgMD90aGlzLm1hdGVyaWFsLmNvbG9yLnNldCh0aGlzLmNvbG9yKTp0aGlzLm1hdGVyaWFsLmNvbG9yLmNvcHkodGhpcy5saWdodC5jb2xvcil9fSxkeT1uZXcgUixWZD1uZXcgdXQsa2Q9bmV3IHV0LERoPWNsYXNzIGV4dGVuZHMgSnR7Y29uc3RydWN0b3IodCxlLG4pe3N1cGVyKCksdGhpcy5saWdodD10LHRoaXMubWF0cml4PXQubWF0cml4V29ybGQsdGhpcy5tYXRyaXhBdXRvVXBkYXRlPSExLHRoaXMuY29sb3I9bix0aGlzLnR5cGU9IkhlbWlzcGhlcmVMaWdodEhlbHBlciI7bGV0IGk9bmV3IHdyKGUpO2kucm90YXRlWShNYXRoLlBJKi41KSx0aGlzLm1hdGVyaWFsPW5ldyB4bih7d2lyZWZyYW1lOiEwLGZvZzohMSx0b25lTWFwcGVkOiExfSksdGhpcy5jb2xvcj09PXZvaWQgMCYmKHRoaXMubWF0ZXJpYWwudmVydGV4Q29sb3JzPSEwKTtsZXQgcj1pLmdldEF0dHJpYnV0ZSgicG9zaXRpb24iKSxhPW5ldyBGbG9hdDMyQXJyYXkoci5jb3VudCozKTtpLnNldEF0dHJpYnV0ZSgiY29sb3IiLG5ldyBadChhLDMpKSx0aGlzLmFkZChuZXcgZGUoaSx0aGlzLm1hdGVyaWFsKSksdGhpcy51cGRhdGUoKX1kaXNwb3NlKCl7dGhpcy5jaGlsZHJlblswXS5nZW9tZXRyeS5kaXNwb3NlKCksdGhpcy5jaGlsZHJlblswXS5tYXRlcmlhbC5kaXNwb3NlKCl9dXBkYXRlKCl7bGV0IHQ9dGhpcy5jaGlsZHJlblswXTtpZih0aGlzLmNvbG9yIT09dm9pZCAwKXRoaXMubWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuY29sb3IpO2Vsc2V7bGV0IGU9dC5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoImNvbG9yIik7VmQuY29weSh0aGlzLmxpZ2h0LmNvbG9yKSxrZC5jb3B5KHRoaXMubGlnaHQuZ3JvdW5kQ29sb3IpO2ZvcihsZXQgbj0wLGk9ZS5jb3VudDtuPGk7bisrKXtsZXQgcj1uPGkvMj9WZDprZDtlLnNldFhZWihuLHIucixyLmcsci5iKX1lLm5lZWRzVXBkYXRlPSEwfXRoaXMubGlnaHQudXBkYXRlV29ybGRNYXRyaXgoITAsITEpLHQubG9va0F0KGR5LnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkKS5uZWdhdGUoKSl9fSxOaD1jbGFzcyBleHRlbmRzIG5ue2NvbnN0cnVjdG9yKHQ9MTAsZT0xMCxuPTQ0NzM5MjQsaT04OTQ3ODQ4KXtuPW5ldyB1dChuKSxpPW5ldyB1dChpKTtsZXQgcj1lLzIsYT10L2Usbz10LzIsbD1bXSxjPVtdO2ZvcihsZXQgZD0wLGY9MCxtPS1vO2Q8PWU7ZCsrLG0rPWEpe2wucHVzaCgtbywwLG0sbywwLG0pLGwucHVzaChtLDAsLW8sbSwwLG8pO2xldCBfPWQ9PT1yP246aTtfLnRvQXJyYXkoYyxmKSxmKz0zLF8udG9BcnJheShjLGYpLGYrPTMsXy50b0FycmF5KGMsZiksZis9MyxfLnRvQXJyYXkoYyxmKSxmKz0zfWxldCBoPW5ldyBIdDtoLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBndChsLDMpKSxoLnNldEF0dHJpYnV0ZSgiY29sb3IiLG5ldyBndChjLDMpKTtsZXQgdT1uZXcgUmUoe3ZlcnRleENvbG9yczohMCx0b25lTWFwcGVkOiExfSk7c3VwZXIoaCx1KSx0aGlzLnR5cGU9IkdyaWRIZWxwZXIifWRpc3Bvc2UoKXt0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKSx0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKX19LE9oPWNsYXNzIGV4dGVuZHMgbm57Y29uc3RydWN0b3IodD0xMCxlPTE2LG49OCxpPTY0LHI9NDQ3MzkyNCxhPTg5NDc4NDgpe3I9bmV3IHV0KHIpLGE9bmV3IHV0KGEpO2xldCBvPVtdLGw9W107aWYoZT4xKWZvcihsZXQgdT0wO3U8ZTt1Kyspe2xldCBkPXUvZSooTWF0aC5QSSoyKSxmPU1hdGguc2luKGQpKnQsbT1NYXRoLmNvcyhkKSp0O28ucHVzaCgwLDAsMCksby5wdXNoKGYsMCxtKTtsZXQgXz11JjE/cjphO2wucHVzaChfLnIsXy5nLF8uYiksbC5wdXNoKF8ucixfLmcsXy5iKX1mb3IobGV0IHU9MDt1PG47dSsrKXtsZXQgZD11JjE/cjphLGY9dC10L24qdTtmb3IobGV0IG09MDttPGk7bSsrKXtsZXQgXz1tL2kqKE1hdGguUEkqMiksZz1NYXRoLnNpbihfKSpmLHA9TWF0aC5jb3MoXykqZjtvLnB1c2goZywwLHApLGwucHVzaChkLnIsZC5nLGQuYiksXz0obSsxKS9pKihNYXRoLlBJKjIpLGc9TWF0aC5zaW4oXykqZixwPU1hdGguY29zKF8pKmYsby5wdXNoKGcsMCxwKSxsLnB1c2goZC5yLGQuZyxkLmIpfX1sZXQgYz1uZXcgSHQ7Yy5zZXRBdHRyaWJ1dGUoInBvc2l0aW9uIixuZXcgZ3QobywzKSksYy5zZXRBdHRyaWJ1dGUoImNvbG9yIixuZXcgZ3QobCwzKSk7bGV0IGg9bmV3IFJlKHt2ZXJ0ZXhDb2xvcnM6ITAsdG9uZU1hcHBlZDohMX0pO3N1cGVyKGMsaCksdGhpcy50eXBlPSJQb2xhckdyaWRIZWxwZXIifWRpc3Bvc2UoKXt0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKSx0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKX19LEhkPW5ldyBSLHdhPW5ldyBSLEdkPW5ldyBSLEZoPWNsYXNzIGV4dGVuZHMgSnR7Y29uc3RydWN0b3IodCxlLG4pe3N1cGVyKCksdGhpcy5saWdodD10LHRoaXMubWF0cml4PXQubWF0cml4V29ybGQsdGhpcy5tYXRyaXhBdXRvVXBkYXRlPSExLHRoaXMuY29sb3I9bix0aGlzLnR5cGU9IkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIiLGU9PT12b2lkIDAmJihlPTEpO2xldCBpPW5ldyBIdDtpLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBndChbLWUsZSwwLGUsZSwwLGUsLWUsMCwtZSwtZSwwLC1lLGUsMF0sMykpO2xldCByPW5ldyBSZSh7Zm9nOiExLHRvbmVNYXBwZWQ6ITF9KTt0aGlzLmxpZ2h0UGxhbmU9bmV3IHZuKGksciksdGhpcy5hZGQodGhpcy5saWdodFBsYW5lKSxpPW5ldyBIdCxpLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBndChbMCwwLDAsMCwwLDFdLDMpKSx0aGlzLnRhcmdldExpbmU9bmV3IHZuKGksciksdGhpcy5hZGQodGhpcy50YXJnZXRMaW5lKSx0aGlzLnVwZGF0ZSgpfWRpc3Bvc2UoKXt0aGlzLmxpZ2h0UGxhbmUuZ2VvbWV0cnkuZGlzcG9zZSgpLHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5kaXNwb3NlKCksdGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LmRpc3Bvc2UoKSx0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuZGlzcG9zZSgpfXVwZGF0ZSgpe3RoaXMubGlnaHQudXBkYXRlV29ybGRNYXRyaXgoITAsITEpLHRoaXMubGlnaHQudGFyZ2V0LnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSxIZC5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5saWdodC5tYXRyaXhXb3JsZCksd2Euc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkKSxHZC5zdWJWZWN0b3JzKHdhLEhkKSx0aGlzLmxpZ2h0UGxhbmUubG9va0F0KHdhKSx0aGlzLmNvbG9yIT09dm9pZCAwPyh0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuY29sb3IpLHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5jb2xvci5zZXQodGhpcy5jb2xvcikpOih0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3IuY29weSh0aGlzLmxpZ2h0LmNvbG9yKSx0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuY29sb3IuY29weSh0aGlzLmxpZ2h0LmNvbG9yKSksdGhpcy50YXJnZXRMaW5lLmxvb2tBdCh3YSksdGhpcy50YXJnZXRMaW5lLnNjYWxlLno9R2QubGVuZ3RoKCl9fSxSYT1uZXcgUixoZT1uZXcgdnMsQmg9Y2xhc3MgZXh0ZW5kcyBubntjb25zdHJ1Y3Rvcih0KXtsZXQgZT1uZXcgSHQsbj1uZXcgUmUoe2NvbG9yOjE2Nzc3MjE1LHZlcnRleENvbG9yczohMCx0b25lTWFwcGVkOiExfSksaT1bXSxyPVtdLGE9e307bygibjEiLCJuMiIpLG8oIm4yIiwibjQiKSxvKCJuNCIsIm4zIiksbygibjMiLCJuMSIpLG8oImYxIiwiZjIiKSxvKCJmMiIsImY0IiksbygiZjQiLCJmMyIpLG8oImYzIiwiZjEiKSxvKCJuMSIsImYxIiksbygibjIiLCJmMiIpLG8oIm4zIiwiZjMiKSxvKCJuNCIsImY0IiksbygicCIsIm4xIiksbygicCIsIm4yIiksbygicCIsIm4zIiksbygicCIsIm40IiksbygidTEiLCJ1MiIpLG8oInUyIiwidTMiKSxvKCJ1MyIsInUxIiksbygiYyIsInQiKSxvKCJwIiwiYyIpLG8oImNuMSIsImNuMiIpLG8oImNuMyIsImNuNCIpLG8oImNmMSIsImNmMiIpLG8oImNmMyIsImNmNCIpO2Z1bmN0aW9uIG8obSxfKXtsKG0pLGwoXyl9ZnVuY3Rpb24gbChtKXtpLnB1c2goMCwwLDApLHIucHVzaCgwLDAsMCksYVttXT09PXZvaWQgMCYmKGFbbV09W10pLGFbbV0ucHVzaChpLmxlbmd0aC8zLTEpfWUuc2V0QXR0cmlidXRlKCJwb3NpdGlvbiIsbmV3IGd0KGksMykpLGUuc2V0QXR0cmlidXRlKCJjb2xvciIsbmV3IGd0KHIsMykpLHN1cGVyKGUsbiksdGhpcy50eXBlPSJDYW1lcmFIZWxwZXIiLHRoaXMuY2FtZXJhPXQsdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCYmdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpLHRoaXMubWF0cml4PXQubWF0cml4V29ybGQsdGhpcy5tYXRyaXhBdXRvVXBkYXRlPSExLHRoaXMucG9pbnRNYXA9YSx0aGlzLnVwZGF0ZSgpO2xldCBjPW5ldyB1dCgxNjc1NTIwMCksaD1uZXcgdXQoMTY3MTE2ODApLHU9bmV3IHV0KDQzNzc1KSxkPW5ldyB1dCgxNjc3NzIxNSksZj1uZXcgdXQoMzM1NTQ0Myk7dGhpcy5zZXRDb2xvcnMoYyxoLHUsZCxmKX1zZXRDb2xvcnModCxlLG4saSxyKXtsZXQgbz10aGlzLmdlb21ldHJ5LmdldEF0dHJpYnV0ZSgiY29sb3IiKTtvLnNldFhZWigwLHQucix0LmcsdC5iKSxvLnNldFhZWigxLHQucix0LmcsdC5iKSxvLnNldFhZWigyLHQucix0LmcsdC5iKSxvLnNldFhZWigzLHQucix0LmcsdC5iKSxvLnNldFhZWig0LHQucix0LmcsdC5iKSxvLnNldFhZWig1LHQucix0LmcsdC5iKSxvLnNldFhZWig2LHQucix0LmcsdC5iKSxvLnNldFhZWig3LHQucix0LmcsdC5iKSxvLnNldFhZWig4LHQucix0LmcsdC5iKSxvLnNldFhZWig5LHQucix0LmcsdC5iKSxvLnNldFhZWigxMCx0LnIsdC5nLHQuYiksby5zZXRYWVooMTEsdC5yLHQuZyx0LmIpLG8uc2V0WFlaKDEyLHQucix0LmcsdC5iKSxvLnNldFhZWigxMyx0LnIsdC5nLHQuYiksby5zZXRYWVooMTQsdC5yLHQuZyx0LmIpLG8uc2V0WFlaKDE1LHQucix0LmcsdC5iKSxvLnNldFhZWigxNix0LnIsdC5nLHQuYiksby5zZXRYWVooMTcsdC5yLHQuZyx0LmIpLG8uc2V0WFlaKDE4LHQucix0LmcsdC5iKSxvLnNldFhZWigxOSx0LnIsdC5nLHQuYiksby5zZXRYWVooMjAsdC5yLHQuZyx0LmIpLG8uc2V0WFlaKDIxLHQucix0LmcsdC5iKSxvLnNldFhZWigyMix0LnIsdC5nLHQuYiksby5zZXRYWVooMjMsdC5yLHQuZyx0LmIpLG8uc2V0WFlaKDI0LGUucixlLmcsZS5iKSxvLnNldFhZWigyNSxlLnIsZS5nLGUuYiksby5zZXRYWVooMjYsZS5yLGUuZyxlLmIpLG8uc2V0WFlaKDI3LGUucixlLmcsZS5iKSxvLnNldFhZWigyOCxlLnIsZS5nLGUuYiksby5zZXRYWVooMjksZS5yLGUuZyxlLmIpLG8uc2V0WFlaKDMwLGUucixlLmcsZS5iKSxvLnNldFhZWigzMSxlLnIsZS5nLGUuYiksby5zZXRYWVooMzIsbi5yLG4uZyxuLmIpLG8uc2V0WFlaKDMzLG4ucixuLmcsbi5iKSxvLnNldFhZWigzNCxuLnIsbi5nLG4uYiksby5zZXRYWVooMzUsbi5yLG4uZyxuLmIpLG8uc2V0WFlaKDM2LG4ucixuLmcsbi5iKSxvLnNldFhZWigzNyxuLnIsbi5nLG4uYiksby5zZXRYWVooMzgsaS5yLGkuZyxpLmIpLG8uc2V0WFlaKDM5LGkucixpLmcsaS5iKSxvLnNldFhZWig0MCxyLnIsci5nLHIuYiksby5zZXRYWVooNDEsci5yLHIuZyxyLmIpLG8uc2V0WFlaKDQyLHIucixyLmcsci5iKSxvLnNldFhZWig0MyxyLnIsci5nLHIuYiksby5zZXRYWVooNDQsci5yLHIuZyxyLmIpLG8uc2V0WFlaKDQ1LHIucixyLmcsci5iKSxvLnNldFhZWig0NixyLnIsci5nLHIuYiksby5zZXRYWVooNDcsci5yLHIuZyxyLmIpLG8uc2V0WFlaKDQ4LHIucixyLmcsci5iKSxvLnNldFhZWig0OSxyLnIsci5nLHIuYiksby5uZWVkc1VwZGF0ZT0hMH11cGRhdGUoKXtsZXQgdD10aGlzLmdlb21ldHJ5LGU9dGhpcy5wb2ludE1hcCxuPTEsaT0xO2hlLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLmNvcHkodGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeEludmVyc2UpLHBlKCJjIixlLHQsaGUsMCwwLC0xKSxwZSgidCIsZSx0LGhlLDAsMCwxKSxwZSgibjEiLGUsdCxoZSwtbiwtaSwtMSkscGUoIm4yIixlLHQsaGUsbiwtaSwtMSkscGUoIm4zIixlLHQsaGUsLW4saSwtMSkscGUoIm40IixlLHQsaGUsbixpLC0xKSxwZSgiZjEiLGUsdCxoZSwtbiwtaSwxKSxwZSgiZjIiLGUsdCxoZSxuLC1pLDEpLHBlKCJmMyIsZSx0LGhlLC1uLGksMSkscGUoImY0IixlLHQsaGUsbixpLDEpLHBlKCJ1MSIsZSx0LGhlLG4qLjcsaSoxLjEsLTEpLHBlKCJ1MiIsZSx0LGhlLC1uKi43LGkqMS4xLC0xKSxwZSgidTMiLGUsdCxoZSwwLGkqMiwtMSkscGUoImNmMSIsZSx0LGhlLC1uLDAsMSkscGUoImNmMiIsZSx0LGhlLG4sMCwxKSxwZSgiY2YzIixlLHQsaGUsMCwtaSwxKSxwZSgiY2Y0IixlLHQsaGUsMCxpLDEpLHBlKCJjbjEiLGUsdCxoZSwtbiwwLC0xKSxwZSgiY24yIixlLHQsaGUsbiwwLC0xKSxwZSgiY24zIixlLHQsaGUsMCwtaSwtMSkscGUoImNuNCIsZSx0LGhlLDAsaSwtMSksdC5nZXRBdHRyaWJ1dGUoInBvc2l0aW9uIikubmVlZHNVcGRhdGU9ITB9ZGlzcG9zZSgpe3RoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpLHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpfX07ZnVuY3Rpb24gcGUocyx0LGUsbixpLHIsYSl7UmEuc2V0KGkscixhKS51bnByb2plY3Qobik7bGV0IG89dFtzXTtpZihvIT09dm9pZCAwKXtsZXQgbD1lLmdldEF0dHJpYnV0ZSgicG9zaXRpb24iKTtmb3IobGV0IGM9MCxoPW8ubGVuZ3RoO2M8aDtjKyspbC5zZXRYWVoob1tjXSxSYS54LFJhLnksUmEueil9fXZhciBDYT1uZXcgd2Usemg9Y2xhc3MgZXh0ZW5kcyBubntjb25zdHJ1Y3Rvcih0LGU9MTY3NzY5NjApe2xldCBuPW5ldyBVaW50MTZBcnJheShbMCwxLDEsMiwyLDMsMywwLDQsNSw1LDYsNiw3LDcsNCwwLDQsMSw1LDIsNiwzLDddKSxpPW5ldyBGbG9hdDMyQXJyYXkoOCozKSxyPW5ldyBIdDtyLnNldEluZGV4KG5ldyBadChuLDEpKSxyLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBadChpLDMpKSxzdXBlcihyLG5ldyBSZSh7Y29sb3I6ZSx0b25lTWFwcGVkOiExfSkpLHRoaXMub2JqZWN0PXQsdGhpcy50eXBlPSJCb3hIZWxwZXIiLHRoaXMubWF0cml4QXV0b1VwZGF0ZT0hMSx0aGlzLnVwZGF0ZSgpfXVwZGF0ZSh0KXtpZih0IT09dm9pZCAwJiZjb25zb2xlLndhcm4oIlRIUkVFLkJveEhlbHBlcjogLnVwZGF0ZSgpIGhhcyBubyBsb25nZXIgYXJndW1lbnRzLiIpLHRoaXMub2JqZWN0IT09dm9pZCAwJiZDYS5zZXRGcm9tT2JqZWN0KHRoaXMub2JqZWN0KSxDYS5pc0VtcHR5KCkpcmV0dXJuO2xldCBlPUNhLm1pbixuPUNhLm1heCxpPXRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbixyPWkuYXJyYXk7clswXT1uLngsclsxXT1uLnksclsyXT1uLnosclszXT1lLngscls0XT1uLnkscls1XT1uLnoscls2XT1lLngscls3XT1lLnkscls4XT1uLnoscls5XT1uLngsclsxMF09ZS55LHJbMTFdPW4ueixyWzEyXT1uLngsclsxM109bi55LHJbMTRdPWUueixyWzE1XT1lLngsclsxNl09bi55LHJbMTddPWUueixyWzE4XT1lLngsclsxOV09ZS55LHJbMjBdPWUueixyWzIxXT1uLngsclsyMl09ZS55LHJbMjNdPWUueixpLm5lZWRzVXBkYXRlPSEwLHRoaXMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCl9c2V0RnJvbU9iamVjdCh0KXtyZXR1cm4gdGhpcy5vYmplY3Q9dCx0aGlzLnVwZGF0ZSgpLHRoaXN9Y29weSh0LGUpe3JldHVybiBzdXBlci5jb3B5KHQsZSksdGhpcy5vYmplY3Q9dC5vYmplY3QsdGhpc31kaXNwb3NlKCl7dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCksdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCl9fSxWaD1jbGFzcyBleHRlbmRzIG5ue2NvbnN0cnVjdG9yKHQsZT0xNjc3Njk2MCl7bGV0IG49bmV3IFVpbnQxNkFycmF5KFswLDEsMSwyLDIsMywzLDAsNCw1LDUsNiw2LDcsNyw0LDAsNCwxLDUsMiw2LDMsN10pLGk9WzEsMSwxLC0xLDEsMSwtMSwtMSwxLDEsLTEsMSwxLDEsLTEsLTEsMSwtMSwtMSwtMSwtMSwxLC0xLC0xXSxyPW5ldyBIdDtyLnNldEluZGV4KG5ldyBadChuLDEpKSxyLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBndChpLDMpKSxzdXBlcihyLG5ldyBSZSh7Y29sb3I6ZSx0b25lTWFwcGVkOiExfSkpLHRoaXMuYm94PXQsdGhpcy50eXBlPSJCb3gzSGVscGVyIix0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpfXVwZGF0ZU1hdHJpeFdvcmxkKHQpe2xldCBlPXRoaXMuYm94O2UuaXNFbXB0eSgpfHwoZS5nZXRDZW50ZXIodGhpcy5wb3NpdGlvbiksZS5nZXRTaXplKHRoaXMuc2NhbGUpLHRoaXMuc2NhbGUubXVsdGlwbHlTY2FsYXIoLjUpLHN1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKHQpKX1kaXNwb3NlKCl7dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCksdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCl9fSxraD1jbGFzcyBleHRlbmRzIHZue2NvbnN0cnVjdG9yKHQsZT0xLG49MTY3NzY5NjApe2xldCBpPW4scj1bMSwtMSwwLC0xLDEsMCwtMSwtMSwwLDEsMSwwLC0xLDEsMCwtMSwtMSwwLDEsLTEsMCwxLDEsMF0sYT1uZXcgSHQ7YS5zZXRBdHRyaWJ1dGUoInBvc2l0aW9uIixuZXcgZ3QociwzKSksYS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKSxzdXBlcihhLG5ldyBSZSh7Y29sb3I6aSx0b25lTWFwcGVkOiExfSkpLHRoaXMudHlwZT0iUGxhbmVIZWxwZXIiLHRoaXMucGxhbmU9dCx0aGlzLnNpemU9ZTtsZXQgbz1bMSwxLDAsLTEsMSwwLC0xLC0xLDAsMSwxLDAsLTEsLTEsMCwxLC0xLDBdLGw9bmV3IEh0O2wuc2V0QXR0cmlidXRlKCJwb3NpdGlvbiIsbmV3IGd0KG8sMykpLGwuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCksdGhpcy5hZGQobmV3IGRlKGwsbmV3IHhuKHtjb2xvcjppLG9wYWNpdHk6LjIsdHJhbnNwYXJlbnQ6ITAsZGVwdGhXcml0ZTohMSx0b25lTWFwcGVkOiExfSkpKX11cGRhdGVNYXRyaXhXb3JsZCh0KXt0aGlzLnBvc2l0aW9uLnNldCgwLDAsMCksdGhpcy5zY2FsZS5zZXQoLjUqdGhpcy5zaXplLC41KnRoaXMuc2l6ZSwxKSx0aGlzLmxvb2tBdCh0aGlzLnBsYW5lLm5vcm1hbCksdGhpcy50cmFuc2xhdGVaKC10aGlzLnBsYW5lLmNvbnN0YW50KSxzdXBlci51cGRhdGVNYXRyaXhXb3JsZCh0KX1kaXNwb3NlKCl7dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCksdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCksdGhpcy5jaGlsZHJlblswXS5nZW9tZXRyeS5kaXNwb3NlKCksdGhpcy5jaGlsZHJlblswXS5tYXRlcmlhbC5kaXNwb3NlKCl9fSxXZD1uZXcgUixQYSxxbCxIaD1jbGFzcyBleHRlbmRzIEp0e2NvbnN0cnVjdG9yKHQ9bmV3IFIoMCwwLDEpLGU9bmV3IFIoMCwwLDApLG49MSxpPTE2Nzc2OTYwLHI9biouMixhPXIqLjIpe3N1cGVyKCksdGhpcy50eXBlPSJBcnJvd0hlbHBlciIsUGE9PT12b2lkIDAmJihQYT1uZXcgSHQsUGEuc2V0QXR0cmlidXRlKCJwb3NpdGlvbiIsbmV3IGd0KFswLDAsMCwwLDEsMF0sMykpLHFsPW5ldyBBcygwLC41LDEsNSwxKSxxbC50cmFuc2xhdGUoMCwtLjUsMCkpLHRoaXMucG9zaXRpb24uY29weShlKSx0aGlzLmxpbmU9bmV3IHZuKFBhLG5ldyBSZSh7Y29sb3I6aSx0b25lTWFwcGVkOiExfSkpLHRoaXMubGluZS5tYXRyaXhBdXRvVXBkYXRlPSExLHRoaXMuYWRkKHRoaXMubGluZSksdGhpcy5jb25lPW5ldyBkZShxbCxuZXcgeG4oe2NvbG9yOmksdG9uZU1hcHBlZDohMX0pKSx0aGlzLmNvbmUubWF0cml4QXV0b1VwZGF0ZT0hMSx0aGlzLmFkZCh0aGlzLmNvbmUpLHRoaXMuc2V0RGlyZWN0aW9uKHQpLHRoaXMuc2V0TGVuZ3RoKG4scixhKX1zZXREaXJlY3Rpb24odCl7aWYodC55Pi45OTk5OSl0aGlzLnF1YXRlcm5pb24uc2V0KDAsMCwwLDEpO2Vsc2UgaWYodC55PC0uOTk5OTkpdGhpcy5xdWF0ZXJuaW9uLnNldCgxLDAsMCwwKTtlbHNle1dkLnNldCh0LnosMCwtdC54KS5ub3JtYWxpemUoKTtsZXQgZT1NYXRoLmFjb3ModC55KTt0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZShXZCxlKX19c2V0TGVuZ3RoKHQsZT10Ki4yLG49ZSouMil7dGhpcy5saW5lLnNjYWxlLnNldCgxLE1hdGgubWF4KDFlLTQsdC1lKSwxKSx0aGlzLmxpbmUudXBkYXRlTWF0cml4KCksdGhpcy5jb25lLnNjYWxlLnNldChuLGUsbiksdGhpcy5jb25lLnBvc2l0aW9uLnk9dCx0aGlzLmNvbmUudXBkYXRlTWF0cml4KCl9c2V0Q29sb3IodCl7dGhpcy5saW5lLm1hdGVyaWFsLmNvbG9yLnNldCh0KSx0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3Iuc2V0KHQpfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCwhMSksdGhpcy5saW5lLmNvcHkodC5saW5lKSx0aGlzLmNvbmUuY29weSh0LmNvbmUpLHRoaXN9ZGlzcG9zZSgpe3RoaXMubGluZS5nZW9tZXRyeS5kaXNwb3NlKCksdGhpcy5saW5lLm1hdGVyaWFsLmRpc3Bvc2UoKSx0aGlzLmNvbmUuZ2VvbWV0cnkuZGlzcG9zZSgpLHRoaXMuY29uZS5tYXRlcmlhbC5kaXNwb3NlKCl9fSxHaD1jbGFzcyBleHRlbmRzIG5ue2NvbnN0cnVjdG9yKHQ9MSl7bGV0IGU9WzAsMCwwLHQsMCwwLDAsMCwwLDAsdCwwLDAsMCwwLDAsMCx0XSxuPVsxLDAsMCwxLC42LDAsMCwxLDAsLjYsMSwwLDAsMCwxLDAsLjYsMV0saT1uZXcgSHQ7aS5zZXRBdHRyaWJ1dGUoInBvc2l0aW9uIixuZXcgZ3QoZSwzKSksaS5zZXRBdHRyaWJ1dGUoImNvbG9yIixuZXcgZ3QobiwzKSk7bGV0IHI9bmV3IFJlKHt2ZXJ0ZXhDb2xvcnM6ITAsdG9uZU1hcHBlZDohMX0pO3N1cGVyKGksciksdGhpcy50eXBlPSJBeGVzSGVscGVyIn1zZXRDb2xvcnModCxlLG4pe2xldCBpPW5ldyB1dCxyPXRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5hcnJheTtyZXR1cm4gaS5zZXQodCksaS50b0FycmF5KHIsMCksaS50b0FycmF5KHIsMyksaS5zZXQoZSksaS50b0FycmF5KHIsNiksaS50b0FycmF5KHIsOSksaS5zZXQobiksaS50b0FycmF5KHIsMTIpLGkudG9BcnJheShyLDE1KSx0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IubmVlZHNVcGRhdGU9ITAsdGhpc31kaXNwb3NlKCl7dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCksdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCl9fSxXaD1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMudHlwZT0iU2hhcGVQYXRoIix0aGlzLmNvbG9yPW5ldyB1dCx0aGlzLnN1YlBhdGhzPVtdLHRoaXMuY3VycmVudFBhdGg9bnVsbH1tb3ZlVG8odCxlKXtyZXR1cm4gdGhpcy5jdXJyZW50UGF0aD1uZXcgRGksdGhpcy5zdWJQYXRocy5wdXNoKHRoaXMuY3VycmVudFBhdGgpLHRoaXMuY3VycmVudFBhdGgubW92ZVRvKHQsZSksdGhpc31saW5lVG8odCxlKXtyZXR1cm4gdGhpcy5jdXJyZW50UGF0aC5saW5lVG8odCxlKSx0aGlzfXF1YWRyYXRpY0N1cnZlVG8odCxlLG4saSl7cmV0dXJuIHRoaXMuY3VycmVudFBhdGgucXVhZHJhdGljQ3VydmVUbyh0LGUsbixpKSx0aGlzfWJlemllckN1cnZlVG8odCxlLG4saSxyLGEpe3JldHVybiB0aGlzLmN1cnJlbnRQYXRoLmJlemllckN1cnZlVG8odCxlLG4saSxyLGEpLHRoaXN9c3BsaW5lVGhydSh0KXtyZXR1cm4gdGhpcy5jdXJyZW50UGF0aC5zcGxpbmVUaHJ1KHQpLHRoaXN9dG9TaGFwZXModCl7ZnVuY3Rpb24gZShwKXtsZXQgdj1bXTtmb3IobGV0IHg9MCxNPXAubGVuZ3RoO3g8TTt4Kyspe2xldCBDPXBbeF0sQT1uZXcgRm47QS5jdXJ2ZXM9Qy5jdXJ2ZXMsdi5wdXNoKEEpfXJldHVybiB2fWZ1bmN0aW9uIG4ocCx2KXtsZXQgeD12Lmxlbmd0aCxNPSExO2ZvcihsZXQgQz14LTEsQT0wO0E8eDtDPUErKyl7bGV0IFQ9dltDXSxVPXZbQV0saz1VLngtVC54LHk9VS55LVQueTtpZihNYXRoLmFicyh5KT5OdW1iZXIuRVBTSUxPTil7aWYoeTwwJiYoVD12W0FdLGs9LWssVT12W0NdLHk9LXkpLHAueTxULnl8fHAueT5VLnkpY29udGludWU7aWYocC55PT09VC55KXtpZihwLng9PT1ULngpcmV0dXJuITB9ZWxzZXtsZXQgdz15KihwLngtVC54KS1rKihwLnktVC55KTtpZih3PT09MClyZXR1cm4hMDtpZih3PDApY29udGludWU7TT0hTX19ZWxzZXtpZihwLnkhPT1ULnkpY29udGludWU7aWYoVS54PD1wLngmJnAueDw9VC54fHxULng8PXAueCYmcC54PD1VLngpcmV0dXJuITB9fXJldHVybiBNfWxldCBpPWduLmlzQ2xvY2tXaXNlLHI9dGhpcy5zdWJQYXRocztpZihyLmxlbmd0aD09PTApcmV0dXJuW107bGV0IGEsbyxsLGM9W107aWYoci5sZW5ndGg9PT0xKXJldHVybiBvPXJbMF0sbD1uZXcgRm4sbC5jdXJ2ZXM9by5jdXJ2ZXMsYy5wdXNoKGwpLGM7bGV0IGg9IWkoclswXS5nZXRQb2ludHMoKSk7aD10PyFoOmg7bGV0IHU9W10sZD1bXSxmPVtdLG09MCxfO2RbbV09dm9pZCAwLGZbbV09W107Zm9yKGxldCBwPTAsdj1yLmxlbmd0aDtwPHY7cCsrKW89cltwXSxfPW8uZ2V0UG9pbnRzKCksYT1pKF8pLGE9dD8hYTphLGE/KCFoJiZkW21dJiZtKyssZFttXT17czpuZXcgRm4scDpffSxkW21dLnMuY3VydmVzPW8uY3VydmVzLGgmJm0rKyxmW21dPVtdKTpmW21dLnB1c2goe2g6byxwOl9bMF19KTtpZighZFswXSlyZXR1cm4gZShyKTtpZihkLmxlbmd0aD4xKXtsZXQgcD0hMSx2PTA7Zm9yKGxldCB4PTAsTT1kLmxlbmd0aDt4PE07eCsrKXVbeF09W107Zm9yKGxldCB4PTAsTT1kLmxlbmd0aDt4PE07eCsrKXtsZXQgQz1mW3hdO2ZvcihsZXQgQT0wO0E8Qy5sZW5ndGg7QSsrKXtsZXQgVD1DW0FdLFU9ITA7Zm9yKGxldCBrPTA7azxkLmxlbmd0aDtrKyspbihULnAsZFtrXS5wKSYmKHghPT1rJiZ2KyssVT8oVT0hMSx1W2tdLnB1c2goVCkpOnA9ITApO1UmJnVbeF0ucHVzaChUKX19dj4wJiZwPT09ITEmJihmPXUpfWxldCBnO2ZvcihsZXQgcD0wLHY9ZC5sZW5ndGg7cDx2O3ArKyl7bD1kW3BdLnMsYy5wdXNoKGwpLGc9ZltwXTtmb3IobGV0IHg9MCxNPWcubGVuZ3RoO3g8TTt4KyspbC5ob2xlcy5wdXNoKGdbeF0uaCl9cmV0dXJuIGN9fTt0eXBlb2YgX19USFJFRV9ERVZUT09MU19fPCJ1IiYmX19USFJFRV9ERVZUT09MU19fLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCJyZWdpc3RlciIse2RldGFpbDp7cmV2aXNpb246am99fSkpO3R5cGVvZiB3aW5kb3c8InUiJiYod2luZG93Ll9fVEhSRUVfXz9jb25zb2xlLndhcm4oIldBUk5JTkc6IE11bHRpcGxlIGluc3RhbmNlcyBvZiBUaHJlZS5qcyBiZWluZyBpbXBvcnRlZC4iKTp3aW5kb3cuX19USFJFRV9fPWpvKTtyZXR1cm4gRXAoZnkpO30pKCk7Ci8qISBCdW5kbGVkIGxpY2Vuc2UgaW5mb3JtYXRpb246Cgp0aHJlZS9idWlsZC90aHJlZS5tb2R1bGUuanM6CiAgKCoqCiAgICogQGxpY2Vuc2UKICAgKiBDb3B5cmlnaHQgMjAxMC0yMDIzIFRocmVlLmpzIEF1dGhvcnMKICAgKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUCiAgICopCiovCmdsb2JhbFRoaXMuVEhSRUUgPSBUSFJFRTsKLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyZWUubWluLmpzLm1hcAo=";
  var GLTF_LOADER_BASE64 = "Ly8gR0xURkxvYWRlciB0aGF0IHVzZXMgZ2xvYmFsIFRIUkVFCmlmICh0eXBlb2YgZ2xvYmFsVGhpcy5USFJFRSA9PT0gInVuZGVmaW5lZCIpIHsKICB0aHJvdyBuZXcgRXJyb3IoJ1RIUkVFLmpzIG11c3QgYmUgbG9hZGVkIGJlZm9yZSBHTFRGTG9hZGVyJyk7Cn0KdmFyIEdMVEZMb2FkZXJNb2R1bGU9KCgpPT57dmFyIHdlPU9iamVjdC5jcmVhdGU7dmFyIGs9T2JqZWN0LmRlZmluZVByb3BlcnR5O3ZhciB5ZT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO3ZhciBfZT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lczt2YXIgU2U9T2JqZWN0LmdldFByb3RvdHlwZU9mLE1lPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIEllPShkLHQpPT4oKT0+KHR8fGQoKHQ9e2V4cG9ydHM6e319KS5leHBvcnRzLHQpLHQuZXhwb3J0cyksTmU9KGQsdCk9Pntmb3IodmFyIGUgaW4gdClrKGQsZSx7Z2V0OnRbZV0sZW51bWVyYWJsZTohMH0pfSxtZT0oZCx0LGUsbyk9PntpZih0JiZ0eXBlb2YgdD09Im9iamVjdCJ8fHR5cGVvZiB0PT0iZnVuY3Rpb24iKWZvcihsZXQgbiBvZiBfZSh0KSkhTWUuY2FsbChkLG4pJiZuIT09ZSYmayhkLG4se2dldDooKT0+dFtuXSxlbnVtZXJhYmxlOiEobz15ZSh0LG4pKXx8by5lbnVtZXJhYmxlfSk7cmV0dXJuIGR9O3ZhciBnZT0oZCx0LGUpPT4oZT1kIT1udWxsP3dlKFNlKGQpKTp7fSxtZSh0fHwhZHx8IWQuX19lc01vZHVsZT9rKGUsImRlZmF1bHQiLHt2YWx1ZTpkLGVudW1lcmFibGU6ITB9KTplLGQpKSxMZT1kPT5tZShrKHt9LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxkKTt2YXIgdj1JZSgoS2UsQWUpPT57QWUuZXhwb3J0cz1nbG9iYWxUaGlzLlRIUkVFfSk7dmFyIEdlPXt9O05lKEdlLHtHTFRGTG9hZGVyOigpPT5LfSk7dmFyIGE9Z2UodigpLDEpO3ZhciB3PWdlKHYoKSwxKTtmdW5jdGlvbiBVKGQsdCl7aWYodD09PXcuVHJpYW5nbGVzRHJhd01vZGUpcmV0dXJuIGNvbnNvbGUud2FybigiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IEdlb21ldHJ5IGFscmVhZHkgZGVmaW5lZCBhcyB0cmlhbmdsZXMuIiksZDtpZih0PT09dy5UcmlhbmdsZUZhbkRyYXdNb2RlfHx0PT09dy5UcmlhbmdsZVN0cmlwRHJhd01vZGUpe2xldCBlPWQuZ2V0SW5kZXgoKTtpZihlPT09bnVsbCl7bGV0IHM9W10sYz1kLmdldEF0dHJpYnV0ZSgicG9zaXRpb24iKTtpZihjIT09dm9pZCAwKXtmb3IobGV0IGk9MDtpPGMuY291bnQ7aSsrKXMucHVzaChpKTtkLnNldEluZGV4KHMpLGU9ZC5nZXRJbmRleCgpfWVsc2UgcmV0dXJuIGNvbnNvbGUuZXJyb3IoIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmRlZmluZWQgcG9zaXRpb24gYXR0cmlidXRlLiBQcm9jZXNzaW5nIG5vdCBwb3NzaWJsZS4iKSxkfWxldCBvPWUuY291bnQtMixuPVtdO2lmKHQ9PT13LlRyaWFuZ2xlRmFuRHJhd01vZGUpZm9yKGxldCBzPTE7czw9bztzKyspbi5wdXNoKGUuZ2V0WCgwKSksbi5wdXNoKGUuZ2V0WChzKSksbi5wdXNoKGUuZ2V0WChzKzEpKTtlbHNlIGZvcihsZXQgcz0wO3M8bztzKyspcyUyPT09MD8obi5wdXNoKGUuZ2V0WChzKSksbi5wdXNoKGUuZ2V0WChzKzEpKSxuLnB1c2goZS5nZXRYKHMrMikpKToobi5wdXNoKGUuZ2V0WChzKzIpKSxuLnB1c2goZS5nZXRYKHMrMSkpLG4ucHVzaChlLmdldFgocykpKTtuLmxlbmd0aC8zIT09byYmY29uc29sZS5lcnJvcigiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IFVuYWJsZSB0byBnZW5lcmF0ZSBjb3JyZWN0IGFtb3VudCBvZiB0cmlhbmdsZXMuIik7bGV0IHI9ZC5jbG9uZSgpO3JldHVybiByLnNldEluZGV4KG4pLHIuY2xlYXJHcm91cHMoKSxyfWVsc2UgcmV0dXJuIGNvbnNvbGUuZXJyb3IoIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmtub3duIGRyYXcgbW9kZToiLHQpLGR9dmFyIEs9Y2xhc3MgZXh0ZW5kcyBhLkxvYWRlcntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSx0aGlzLmRyYWNvTG9hZGVyPW51bGwsdGhpcy5rdHgyTG9hZGVyPW51bGwsdGhpcy5tZXNob3B0RGVjb2Rlcj1udWxsLHRoaXMucGx1Z2luQ2FsbGJhY2tzPVtdLHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBZKGUpfSksdGhpcy5yZWdpc3RlcihmdW5jdGlvbihlKXtyZXR1cm4gbmV3IG5lKGUpfSksdGhpcy5yZWdpc3RlcihmdW5jdGlvbihlKXtyZXR1cm4gbmV3IHNlKGUpfSksdGhpcy5yZWdpc3RlcihmdW5jdGlvbihlKXtyZXR1cm4gbmV3IHJlKGUpfSksdGhpcy5yZWdpc3RlcihmdW5jdGlvbihlKXtyZXR1cm4gbmV3IFcoZSl9KSx0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgWihlKX0pLHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBRKGUpfSksdGhpcy5yZWdpc3RlcihmdW5jdGlvbihlKXtyZXR1cm4gbmV3IEooZSl9KSx0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgWChlKX0pLHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyAkKGUpfSksdGhpcy5yZWdpc3RlcihmdW5jdGlvbihlKXtyZXR1cm4gbmV3IHEoZSl9KSx0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdGUoZSl9KSx0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgZWUoZSl9KSx0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgeihlKX0pLHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBvZShlKX0pLHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBpZShlKX0pfWxvYWQodCxlLG8sbil7bGV0IHI9dGhpcyxzO2lmKHRoaXMucmVzb3VyY2VQYXRoIT09IiIpcz10aGlzLnJlc291cmNlUGF0aDtlbHNlIGlmKHRoaXMucGF0aCE9PSIiKXtsZXQgdT1hLkxvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKHQpO3M9YS5Mb2FkZXJVdGlscy5yZXNvbHZlVVJMKHUsdGhpcy5wYXRoKX1lbHNlIHM9YS5Mb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSh0KTt0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KHQpO2xldCBjPWZ1bmN0aW9uKHUpe24/bih1KTpjb25zb2xlLmVycm9yKHUpLHIubWFuYWdlci5pdGVtRXJyb3IodCksci5tYW5hZ2VyLml0ZW1FbmQodCl9LGk9bmV3IGEuRmlsZUxvYWRlcih0aGlzLm1hbmFnZXIpO2kuc2V0UGF0aCh0aGlzLnBhdGgpLGkuc2V0UmVzcG9uc2VUeXBlKCJhcnJheWJ1ZmZlciIpLGkuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpLGkuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKSxpLmxvYWQodCxmdW5jdGlvbih1KXt0cnl7ci5wYXJzZSh1LHMsZnVuY3Rpb24oZil7ZShmKSxyLm1hbmFnZXIuaXRlbUVuZCh0KX0sYyl9Y2F0Y2goZil7YyhmKX19LG8sYyl9c2V0RFJBQ09Mb2FkZXIodCl7cmV0dXJuIHRoaXMuZHJhY29Mb2FkZXI9dCx0aGlzfXNldEREU0xvYWRlcigpe3Rocm93IG5ldyBFcnJvcignVEhSRUUuR0xURkxvYWRlcjogIk1TRlRfdGV4dHVyZV9kZHMiIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFBsZWFzZSB1cGRhdGUgdG8gIktIUl90ZXh0dXJlX2Jhc2lzdSIuJyl9c2V0S1RYMkxvYWRlcih0KXtyZXR1cm4gdGhpcy5rdHgyTG9hZGVyPXQsdGhpc31zZXRNZXNob3B0RGVjb2Rlcih0KXtyZXR1cm4gdGhpcy5tZXNob3B0RGVjb2Rlcj10LHRoaXN9cmVnaXN0ZXIodCl7cmV0dXJuIHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YodCk9PT0tMSYmdGhpcy5wbHVnaW5DYWxsYmFja3MucHVzaCh0KSx0aGlzfXVucmVnaXN0ZXIodCl7cmV0dXJuIHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YodCkhPT0tMSYmdGhpcy5wbHVnaW5DYWxsYmFja3Muc3BsaWNlKHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YodCksMSksdGhpc31wYXJzZSh0LGUsbyxuKXtsZXQgcixzPXt9LGM9e30saT1uZXcgVGV4dERlY29kZXI7aWYodHlwZW9mIHQ9PSJzdHJpbmciKXI9SlNPTi5wYXJzZSh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilpZihpLmRlY29kZShuZXcgVWludDhBcnJheSh0LDAsNCkpPT09YmUpe3RyeXtzW0EuS0hSX0JJTkFSWV9HTFRGXT1uZXcgYWUodCl9Y2F0Y2gobCl7biYmbihsKTtyZXR1cm59cj1KU09OLnBhcnNlKHNbQS5LSFJfQklOQVJZX0dMVEZdLmNvbnRlbnQpfWVsc2Ugcj1KU09OLnBhcnNlKGkuZGVjb2RlKHQpKTtlbHNlIHI9dDtpZihyLmFzc2V0PT09dm9pZCAwfHxyLmFzc2V0LnZlcnNpb25bMF08Mil7biYmbihuZXcgRXJyb3IoIlRIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGFzc2V0LiBnbFRGIHZlcnNpb25zID49Mi4wIGFyZSBzdXBwb3J0ZWQuIikpO3JldHVybn1sZXQgdT1uZXcgcGUocix7cGF0aDplfHx0aGlzLnJlc291cmNlUGF0aHx8IiIsY3Jvc3NPcmlnaW46dGhpcy5jcm9zc09yaWdpbixyZXF1ZXN0SGVhZGVyOnRoaXMucmVxdWVzdEhlYWRlcixtYW5hZ2VyOnRoaXMubWFuYWdlcixrdHgyTG9hZGVyOnRoaXMua3R4MkxvYWRlcixtZXNob3B0RGVjb2Rlcjp0aGlzLm1lc2hvcHREZWNvZGVyfSk7dS5maWxlTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtmb3IobGV0IGY9MDtmPHRoaXMucGx1Z2luQ2FsbGJhY2tzLmxlbmd0aDtmKyspe2xldCBsPXRoaXMucGx1Z2luQ2FsbGJhY2tzW2ZdKHUpO2wubmFtZXx8Y29uc29sZS5lcnJvcigiVEhSRUUuR0xURkxvYWRlcjogSW52YWxpZCBwbHVnaW4gZm91bmQ6IG1pc3NpbmcgbmFtZSIpLGNbbC5uYW1lXT1sLHNbbC5uYW1lXT0hMH1pZihyLmV4dGVuc2lvbnNVc2VkKWZvcihsZXQgZj0wO2Y8ci5leHRlbnNpb25zVXNlZC5sZW5ndGg7KytmKXtsZXQgbD1yLmV4dGVuc2lvbnNVc2VkW2ZdLGg9ci5leHRlbnNpb25zUmVxdWlyZWR8fFtdO3N3aXRjaChsKXtjYXNlIEEuS0hSX01BVEVSSUFMU19VTkxJVDpzW2xdPW5ldyBWO2JyZWFrO2Nhc2UgQS5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTjpzW2xdPW5ldyBjZShyLHRoaXMuZHJhY29Mb2FkZXIpO2JyZWFrO2Nhc2UgQS5LSFJfVEVYVFVSRV9UUkFOU0ZPUk06c1tsXT1uZXcgdWU7YnJlYWs7Y2FzZSBBLktIUl9NRVNIX1FVQU5USVpBVElPTjpzW2xdPW5ldyBsZTticmVhaztkZWZhdWx0OmguaW5kZXhPZihsKT49MCYmY1tsXT09PXZvaWQgMCYmY29uc29sZS53YXJuKCdUSFJFRS5HTFRGTG9hZGVyOiBVbmtub3duIGV4dGVuc2lvbiAiJytsKyciLicpfX11LnNldEV4dGVuc2lvbnMocyksdS5zZXRQbHVnaW5zKGMpLHUucGFyc2UobyxuKX1wYXJzZUFzeW5jKHQsZSl7bGV0IG89dGhpcztyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24obixyKXtvLnBhcnNlKHQsZSxuLHIpfSl9fTtmdW5jdGlvbiBPZSgpe2xldCBkPXt9O3JldHVybntnZXQ6ZnVuY3Rpb24odCl7cmV0dXJuIGRbdF19LGFkZDpmdW5jdGlvbih0LGUpe2RbdF09ZX0scmVtb3ZlOmZ1bmN0aW9uKHQpe2RlbGV0ZSBkW3RdfSxyZW1vdmVBbGw6ZnVuY3Rpb24oKXtkPXt9fX19dmFyIEE9e0tIUl9CSU5BUllfR0xURjoiS0hSX2JpbmFyeV9nbFRGIixLSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTjoiS0hSX2RyYWNvX21lc2hfY29tcHJlc3Npb24iLEtIUl9MSUdIVFNfUFVOQ1RVQUw6IktIUl9saWdodHNfcHVuY3R1YWwiLEtIUl9NQVRFUklBTFNfQ0xFQVJDT0FUOiJLSFJfbWF0ZXJpYWxzX2NsZWFyY29hdCIsS0hSX01BVEVSSUFMU19JT1I6IktIUl9tYXRlcmlhbHNfaW9yIixLSFJfTUFURVJJQUxTX1NIRUVOOiJLSFJfbWF0ZXJpYWxzX3NoZWVuIixLSFJfTUFURVJJQUxTX1NQRUNVTEFSOiJLSFJfbWF0ZXJpYWxzX3NwZWN1bGFyIixLSFJfTUFURVJJQUxTX1RSQU5TTUlTU0lPTjoiS0hSX21hdGVyaWFsc190cmFuc21pc3Npb24iLEtIUl9NQVRFUklBTFNfSVJJREVTQ0VOQ0U6IktIUl9tYXRlcmlhbHNfaXJpZGVzY2VuY2UiLEtIUl9NQVRFUklBTFNfQU5JU09UUk9QWToiS0hSX21hdGVyaWFsc19hbmlzb3Ryb3B5IixLSFJfTUFURVJJQUxTX1VOTElUOiJLSFJfbWF0ZXJpYWxzX3VubGl0IixLSFJfTUFURVJJQUxTX1ZPTFVNRToiS0hSX21hdGVyaWFsc192b2x1bWUiLEtIUl9URVhUVVJFX0JBU0lTVToiS0hSX3RleHR1cmVfYmFzaXN1IixLSFJfVEVYVFVSRV9UUkFOU0ZPUk06IktIUl90ZXh0dXJlX3RyYW5zZm9ybSIsS0hSX01FU0hfUVVBTlRJWkFUSU9OOiJLSFJfbWVzaF9xdWFudGl6YXRpb24iLEtIUl9NQVRFUklBTFNfRU1JU1NJVkVfU1RSRU5HVEg6IktIUl9tYXRlcmlhbHNfZW1pc3NpdmVfc3RyZW5ndGgiLEVYVF9NQVRFUklBTFNfQlVNUDoiRVhUX21hdGVyaWFsc19idW1wIixFWFRfVEVYVFVSRV9XRUJQOiJFWFRfdGV4dHVyZV93ZWJwIixFWFRfVEVYVFVSRV9BVklGOiJFWFRfdGV4dHVyZV9hdmlmIixFWFRfTUVTSE9QVF9DT01QUkVTU0lPTjoiRVhUX21lc2hvcHRfY29tcHJlc3Npb24iLEVYVF9NRVNIX0dQVV9JTlNUQU5DSU5HOiJFWFRfbWVzaF9ncHVfaW5zdGFuY2luZyJ9LHo9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5wYXJzZXI9dCx0aGlzLm5hbWU9QS5LSFJfTElHSFRTX1BVTkNUVUFMLHRoaXMuY2FjaGU9e3JlZnM6e30sdXNlczp7fX19X21hcmtEZWZzKCl7bGV0IHQ9dGhpcy5wYXJzZXIsZT10aGlzLnBhcnNlci5qc29uLm5vZGVzfHxbXTtmb3IobGV0IG89MCxuPWUubGVuZ3RoO288bjtvKyspe2xldCByPWVbb107ci5leHRlbnNpb25zJiZyLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSYmci5leHRlbnNpb25zW3RoaXMubmFtZV0ubGlnaHQhPT12b2lkIDAmJnQuX2FkZE5vZGVSZWYodGhpcy5jYWNoZSxyLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5saWdodCl9fV9sb2FkTGlnaHQodCl7bGV0IGU9dGhpcy5wYXJzZXIsbz0ibGlnaHQ6Iit0LG49ZS5jYWNoZS5nZXQobyk7aWYobilyZXR1cm4gbjtsZXQgcj1lLmpzb24saT0oKHIuZXh0ZW5zaW9ucyYmci5leHRlbnNpb25zW3RoaXMubmFtZV18fHt9KS5saWdodHN8fFtdKVt0XSx1LGY9bmV3IGEuQ29sb3IoMTY3NzcyMTUpO2kuY29sb3IhPT12b2lkIDAmJmYuc2V0UkdCKGkuY29sb3JbMF0saS5jb2xvclsxXSxpLmNvbG9yWzJdLGEuTGluZWFyU1JHQkNvbG9yU3BhY2UpO2xldCBsPWkucmFuZ2UhPT12b2lkIDA/aS5yYW5nZTowO3N3aXRjaChpLnR5cGUpe2Nhc2UiZGlyZWN0aW9uYWwiOnU9bmV3IGEuRGlyZWN0aW9uYWxMaWdodChmKSx1LnRhcmdldC5wb3NpdGlvbi5zZXQoMCwwLC0xKSx1LmFkZCh1LnRhcmdldCk7YnJlYWs7Y2FzZSJwb2ludCI6dT1uZXcgYS5Qb2ludExpZ2h0KGYpLHUuZGlzdGFuY2U9bDticmVhaztjYXNlInNwb3QiOnU9bmV3IGEuU3BvdExpZ2h0KGYpLHUuZGlzdGFuY2U9bCxpLnNwb3Q9aS5zcG90fHx7fSxpLnNwb3QuaW5uZXJDb25lQW5nbGU9aS5zcG90LmlubmVyQ29uZUFuZ2xlIT09dm9pZCAwP2kuc3BvdC5pbm5lckNvbmVBbmdsZTowLGkuc3BvdC5vdXRlckNvbmVBbmdsZT1pLnNwb3Qub3V0ZXJDb25lQW5nbGUhPT12b2lkIDA/aS5zcG90Lm91dGVyQ29uZUFuZ2xlOk1hdGguUEkvNCx1LmFuZ2xlPWkuc3BvdC5vdXRlckNvbmVBbmdsZSx1LnBlbnVtYnJhPTEtaS5zcG90LmlubmVyQ29uZUFuZ2xlL2kuc3BvdC5vdXRlckNvbmVBbmdsZSx1LnRhcmdldC5wb3NpdGlvbi5zZXQoMCwwLC0xKSx1LmFkZCh1LnRhcmdldCk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLkdMVEZMb2FkZXI6IFVuZXhwZWN0ZWQgbGlnaHQgdHlwZTogIitpLnR5cGUpfXJldHVybiB1LnBvc2l0aW9uLnNldCgwLDAsMCksdS5kZWNheT0yLEwodSxpKSxpLmludGVuc2l0eSE9PXZvaWQgMCYmKHUuaW50ZW5zaXR5PWkuaW50ZW5zaXR5KSx1Lm5hbWU9ZS5jcmVhdGVVbmlxdWVOYW1lKGkubmFtZXx8ImxpZ2h0XyIrdCksbj1Qcm9taXNlLnJlc29sdmUodSksZS5jYWNoZS5hZGQobyxuKSxufWdldERlcGVuZGVuY3kodCxlKXtpZih0PT09ImxpZ2h0IilyZXR1cm4gdGhpcy5fbG9hZExpZ2h0KGUpfWNyZWF0ZU5vZGVBdHRhY2htZW50KHQpe2xldCBlPXRoaXMsbz10aGlzLnBhcnNlcixyPW8uanNvbi5ub2Rlc1t0XSxjPShyLmV4dGVuc2lvbnMmJnIuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdfHx7fSkubGlnaHQ7cmV0dXJuIGM9PT12b2lkIDA/bnVsbDp0aGlzLl9sb2FkTGlnaHQoYykudGhlbihmdW5jdGlvbihpKXtyZXR1cm4gby5fZ2V0Tm9kZVJlZihlLmNhY2hlLGMsaSl9KX19LFY9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLm5hbWU9QS5LSFJfTUFURVJJQUxTX1VOTElUfWdldE1hdGVyaWFsVHlwZSgpe3JldHVybiBhLk1lc2hCYXNpY01hdGVyaWFsfWV4dGVuZFBhcmFtcyh0LGUsbyl7bGV0IG49W107dC5jb2xvcj1uZXcgYS5Db2xvcigxLDEsMSksdC5vcGFjaXR5PTE7bGV0IHI9ZS5wYnJNZXRhbGxpY1JvdWdobmVzcztpZihyKXtpZihBcnJheS5pc0FycmF5KHIuYmFzZUNvbG9yRmFjdG9yKSl7bGV0IHM9ci5iYXNlQ29sb3JGYWN0b3I7dC5jb2xvci5zZXRSR0Ioc1swXSxzWzFdLHNbMl0sYS5MaW5lYXJTUkdCQ29sb3JTcGFjZSksdC5vcGFjaXR5PXNbM119ci5iYXNlQ29sb3JUZXh0dXJlIT09dm9pZCAwJiZuLnB1c2goby5hc3NpZ25UZXh0dXJlKHQsIm1hcCIsci5iYXNlQ29sb3JUZXh0dXJlLGEuU1JHQkNvbG9yU3BhY2UpKX1yZXR1cm4gUHJvbWlzZS5hbGwobil9fSxYPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMucGFyc2VyPXQsdGhpcy5uYW1lPUEuS0hSX01BVEVSSUFMU19FTUlTU0lWRV9TVFJFTkdUSH1leHRlbmRNYXRlcmlhbFBhcmFtcyh0LGUpe2xldCBuPXRoaXMucGFyc2VyLmpzb24ubWF0ZXJpYWxzW3RdO2lmKCFuLmV4dGVuc2lvbnN8fCFuLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7bGV0IHI9bi5leHRlbnNpb25zW3RoaXMubmFtZV0uZW1pc3NpdmVTdHJlbmd0aDtyZXR1cm4gciE9PXZvaWQgMCYmKGUuZW1pc3NpdmVJbnRlbnNpdHk9ciksUHJvbWlzZS5yZXNvbHZlKCl9fSxZPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMucGFyc2VyPXQsdGhpcy5uYW1lPUEuS0hSX01BVEVSSUFMU19DTEVBUkNPQVR9Z2V0TWF0ZXJpYWxUeXBlKHQpe2xldCBvPXRoaXMucGFyc2VyLmpzb24ubWF0ZXJpYWxzW3RdO3JldHVybiFvLmV4dGVuc2lvbnN8fCFvLmV4dGVuc2lvbnNbdGhpcy5uYW1lXT9udWxsOmEuTWVzaFBoeXNpY2FsTWF0ZXJpYWx9ZXh0ZW5kTWF0ZXJpYWxQYXJhbXModCxlKXtsZXQgbz10aGlzLnBhcnNlcixuPW8uanNvbi5tYXRlcmlhbHNbdF07aWYoIW4uZXh0ZW5zaW9uc3x8IW4uZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKXJldHVybiBQcm9taXNlLnJlc29sdmUoKTtsZXQgcj1bXSxzPW4uZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO2lmKHMuY2xlYXJjb2F0RmFjdG9yIT09dm9pZCAwJiYoZS5jbGVhcmNvYXQ9cy5jbGVhcmNvYXRGYWN0b3IpLHMuY2xlYXJjb2F0VGV4dHVyZSE9PXZvaWQgMCYmci5wdXNoKG8uYXNzaWduVGV4dHVyZShlLCJjbGVhcmNvYXRNYXAiLHMuY2xlYXJjb2F0VGV4dHVyZSkpLHMuY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yIT09dm9pZCAwJiYoZS5jbGVhcmNvYXRSb3VnaG5lc3M9cy5jbGVhcmNvYXRSb3VnaG5lc3NGYWN0b3IpLHMuY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSE9PXZvaWQgMCYmci5wdXNoKG8uYXNzaWduVGV4dHVyZShlLCJjbGVhcmNvYXRSb3VnaG5lc3NNYXAiLHMuY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSkpLHMuY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSE9PXZvaWQgMCYmKHIucHVzaChvLmFzc2lnblRleHR1cmUoZSwiY2xlYXJjb2F0Tm9ybWFsTWFwIixzLmNsZWFyY29hdE5vcm1hbFRleHR1cmUpKSxzLmNsZWFyY29hdE5vcm1hbFRleHR1cmUuc2NhbGUhPT12b2lkIDApKXtsZXQgYz1zLmNsZWFyY29hdE5vcm1hbFRleHR1cmUuc2NhbGU7ZS5jbGVhcmNvYXROb3JtYWxTY2FsZT1uZXcgYS5WZWN0b3IyKGMsYyl9cmV0dXJuIFByb21pc2UuYWxsKHIpfX0scT1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnBhcnNlcj10LHRoaXMubmFtZT1BLktIUl9NQVRFUklBTFNfSVJJREVTQ0VOQ0V9Z2V0TWF0ZXJpYWxUeXBlKHQpe2xldCBvPXRoaXMucGFyc2VyLmpzb24ubWF0ZXJpYWxzW3RdO3JldHVybiFvLmV4dGVuc2lvbnN8fCFvLmV4dGVuc2lvbnNbdGhpcy5uYW1lXT9udWxsOmEuTWVzaFBoeXNpY2FsTWF0ZXJpYWx9ZXh0ZW5kTWF0ZXJpYWxQYXJhbXModCxlKXtsZXQgbz10aGlzLnBhcnNlcixuPW8uanNvbi5tYXRlcmlhbHNbdF07aWYoIW4uZXh0ZW5zaW9uc3x8IW4uZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKXJldHVybiBQcm9taXNlLnJlc29sdmUoKTtsZXQgcj1bXSxzPW4uZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO3JldHVybiBzLmlyaWRlc2NlbmNlRmFjdG9yIT09dm9pZCAwJiYoZS5pcmlkZXNjZW5jZT1zLmlyaWRlc2NlbmNlRmFjdG9yKSxzLmlyaWRlc2NlbmNlVGV4dHVyZSE9PXZvaWQgMCYmci5wdXNoKG8uYXNzaWduVGV4dHVyZShlLCJpcmlkZXNjZW5jZU1hcCIscy5pcmlkZXNjZW5jZVRleHR1cmUpKSxzLmlyaWRlc2NlbmNlSW9yIT09dm9pZCAwJiYoZS5pcmlkZXNjZW5jZUlPUj1zLmlyaWRlc2NlbmNlSW9yKSxlLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2U9PT12b2lkIDAmJihlLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2U9WzEwMCw0MDBdKSxzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bSE9PXZvaWQgMCYmKGUuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZVswXT1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bSkscy5pcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW0hPT12b2lkIDAmJihlLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2VbMV09cy5pcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW0pLHMuaXJpZGVzY2VuY2VUaGlja25lc3NUZXh0dXJlIT09dm9pZCAwJiZyLnB1c2goby5hc3NpZ25UZXh0dXJlKGUsImlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwIixzLmlyaWRlc2NlbmNlVGhpY2tuZXNzVGV4dHVyZSkpLFByb21pc2UuYWxsKHIpfX0sVz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnBhcnNlcj10LHRoaXMubmFtZT1BLktIUl9NQVRFUklBTFNfU0hFRU59Z2V0TWF0ZXJpYWxUeXBlKHQpe2xldCBvPXRoaXMucGFyc2VyLmpzb24ubWF0ZXJpYWxzW3RdO3JldHVybiFvLmV4dGVuc2lvbnN8fCFvLmV4dGVuc2lvbnNbdGhpcy5uYW1lXT9udWxsOmEuTWVzaFBoeXNpY2FsTWF0ZXJpYWx9ZXh0ZW5kTWF0ZXJpYWxQYXJhbXModCxlKXtsZXQgbz10aGlzLnBhcnNlcixuPW8uanNvbi5tYXRlcmlhbHNbdF07aWYoIW4uZXh0ZW5zaW9uc3x8IW4uZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKXJldHVybiBQcm9taXNlLnJlc29sdmUoKTtsZXQgcj1bXTtlLnNoZWVuQ29sb3I9bmV3IGEuQ29sb3IoMCwwLDApLGUuc2hlZW5Sb3VnaG5lc3M9MCxlLnNoZWVuPTE7bGV0IHM9bi5leHRlbnNpb25zW3RoaXMubmFtZV07aWYocy5zaGVlbkNvbG9yRmFjdG9yIT09dm9pZCAwKXtsZXQgYz1zLnNoZWVuQ29sb3JGYWN0b3I7ZS5zaGVlbkNvbG9yLnNldFJHQihjWzBdLGNbMV0sY1syXSxhLkxpbmVhclNSR0JDb2xvclNwYWNlKX1yZXR1cm4gcy5zaGVlblJvdWdobmVzc0ZhY3RvciE9PXZvaWQgMCYmKGUuc2hlZW5Sb3VnaG5lc3M9cy5zaGVlblJvdWdobmVzc0ZhY3Rvcikscy5zaGVlbkNvbG9yVGV4dHVyZSE9PXZvaWQgMCYmci5wdXNoKG8uYXNzaWduVGV4dHVyZShlLCJzaGVlbkNvbG9yTWFwIixzLnNoZWVuQ29sb3JUZXh0dXJlLGEuU1JHQkNvbG9yU3BhY2UpKSxzLnNoZWVuUm91Z2huZXNzVGV4dHVyZSE9PXZvaWQgMCYmci5wdXNoKG8uYXNzaWduVGV4dHVyZShlLCJzaGVlblJvdWdobmVzc01hcCIscy5zaGVlblJvdWdobmVzc1RleHR1cmUpKSxQcm9taXNlLmFsbChyKX19LFo9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5wYXJzZXI9dCx0aGlzLm5hbWU9QS5LSFJfTUFURVJJQUxTX1RSQU5TTUlTU0lPTn1nZXRNYXRlcmlhbFR5cGUodCl7bGV0IG89dGhpcy5wYXJzZXIuanNvbi5tYXRlcmlhbHNbdF07cmV0dXJuIW8uZXh0ZW5zaW9uc3x8IW8uZXh0ZW5zaW9uc1t0aGlzLm5hbWVdP251bGw6YS5NZXNoUGh5c2ljYWxNYXRlcmlhbH1leHRlbmRNYXRlcmlhbFBhcmFtcyh0LGUpe2xldCBvPXRoaXMucGFyc2VyLG49by5qc29uLm1hdGVyaWFsc1t0XTtpZighbi5leHRlbnNpb25zfHwhbi5leHRlbnNpb25zW3RoaXMubmFtZV0pcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO2xldCByPVtdLHM9bi5leHRlbnNpb25zW3RoaXMubmFtZV07cmV0dXJuIHMudHJhbnNtaXNzaW9uRmFjdG9yIT09dm9pZCAwJiYoZS50cmFuc21pc3Npb249cy50cmFuc21pc3Npb25GYWN0b3IpLHMudHJhbnNtaXNzaW9uVGV4dHVyZSE9PXZvaWQgMCYmci5wdXNoKG8uYXNzaWduVGV4dHVyZShlLCJ0cmFuc21pc3Npb25NYXAiLHMudHJhbnNtaXNzaW9uVGV4dHVyZSkpLFByb21pc2UuYWxsKHIpfX0sUT1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnBhcnNlcj10LHRoaXMubmFtZT1BLktIUl9NQVRFUklBTFNfVk9MVU1FfWdldE1hdGVyaWFsVHlwZSh0KXtsZXQgbz10aGlzLnBhcnNlci5qc29uLm1hdGVyaWFsc1t0XTtyZXR1cm4hby5leHRlbnNpb25zfHwhby5leHRlbnNpb25zW3RoaXMubmFtZV0/bnVsbDphLk1lc2hQaHlzaWNhbE1hdGVyaWFsfWV4dGVuZE1hdGVyaWFsUGFyYW1zKHQsZSl7bGV0IG89dGhpcy5wYXJzZXIsbj1vLmpzb24ubWF0ZXJpYWxzW3RdO2lmKCFuLmV4dGVuc2lvbnN8fCFuLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7bGV0IHI9W10scz1uLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtlLnRoaWNrbmVzcz1zLnRoaWNrbmVzc0ZhY3RvciE9PXZvaWQgMD9zLnRoaWNrbmVzc0ZhY3RvcjowLHMudGhpY2tuZXNzVGV4dHVyZSE9PXZvaWQgMCYmci5wdXNoKG8uYXNzaWduVGV4dHVyZShlLCJ0aGlja25lc3NNYXAiLHMudGhpY2tuZXNzVGV4dHVyZSkpLGUuYXR0ZW51YXRpb25EaXN0YW5jZT1zLmF0dGVudWF0aW9uRGlzdGFuY2V8fDEvMDtsZXQgYz1zLmF0dGVudWF0aW9uQ29sb3J8fFsxLDEsMV07cmV0dXJuIGUuYXR0ZW51YXRpb25Db2xvcj1uZXcgYS5Db2xvcigpLnNldFJHQihjWzBdLGNbMV0sY1syXSxhLkxpbmVhclNSR0JDb2xvclNwYWNlKSxQcm9taXNlLmFsbChyKX19LEo9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5wYXJzZXI9dCx0aGlzLm5hbWU9QS5LSFJfTUFURVJJQUxTX0lPUn1nZXRNYXRlcmlhbFR5cGUodCl7bGV0IG89dGhpcy5wYXJzZXIuanNvbi5tYXRlcmlhbHNbdF07cmV0dXJuIW8uZXh0ZW5zaW9uc3x8IW8uZXh0ZW5zaW9uc1t0aGlzLm5hbWVdP251bGw6YS5NZXNoUGh5c2ljYWxNYXRlcmlhbH1leHRlbmRNYXRlcmlhbFBhcmFtcyh0LGUpe2xldCBuPXRoaXMucGFyc2VyLmpzb24ubWF0ZXJpYWxzW3RdO2lmKCFuLmV4dGVuc2lvbnN8fCFuLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7bGV0IHI9bi5leHRlbnNpb25zW3RoaXMubmFtZV07cmV0dXJuIGUuaW9yPXIuaW9yIT09dm9pZCAwP3IuaW9yOjEuNSxQcm9taXNlLnJlc29sdmUoKX19LCQ9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5wYXJzZXI9dCx0aGlzLm5hbWU9QS5LSFJfTUFURVJJQUxTX1NQRUNVTEFSfWdldE1hdGVyaWFsVHlwZSh0KXtsZXQgbz10aGlzLnBhcnNlci5qc29uLm1hdGVyaWFsc1t0XTtyZXR1cm4hby5leHRlbnNpb25zfHwhby5leHRlbnNpb25zW3RoaXMubmFtZV0/bnVsbDphLk1lc2hQaHlzaWNhbE1hdGVyaWFsfWV4dGVuZE1hdGVyaWFsUGFyYW1zKHQsZSl7bGV0IG89dGhpcy5wYXJzZXIsbj1vLmpzb24ubWF0ZXJpYWxzW3RdO2lmKCFuLmV4dGVuc2lvbnN8fCFuLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7bGV0IHI9W10scz1uLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtlLnNwZWN1bGFySW50ZW5zaXR5PXMuc3BlY3VsYXJGYWN0b3IhPT12b2lkIDA/cy5zcGVjdWxhckZhY3RvcjoxLHMuc3BlY3VsYXJUZXh0dXJlIT09dm9pZCAwJiZyLnB1c2goby5hc3NpZ25UZXh0dXJlKGUsInNwZWN1bGFySW50ZW5zaXR5TWFwIixzLnNwZWN1bGFyVGV4dHVyZSkpO2xldCBjPXMuc3BlY3VsYXJDb2xvckZhY3Rvcnx8WzEsMSwxXTtyZXR1cm4gZS5zcGVjdWxhckNvbG9yPW5ldyBhLkNvbG9yKCkuc2V0UkdCKGNbMF0sY1sxXSxjWzJdLGEuTGluZWFyU1JHQkNvbG9yU3BhY2UpLHMuc3BlY3VsYXJDb2xvclRleHR1cmUhPT12b2lkIDAmJnIucHVzaChvLmFzc2lnblRleHR1cmUoZSwic3BlY3VsYXJDb2xvck1hcCIscy5zcGVjdWxhckNvbG9yVGV4dHVyZSxhLlNSR0JDb2xvclNwYWNlKSksUHJvbWlzZS5hbGwocil9fSxlZT1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnBhcnNlcj10LHRoaXMubmFtZT1BLkVYVF9NQVRFUklBTFNfQlVNUH1nZXRNYXRlcmlhbFR5cGUodCl7bGV0IG89dGhpcy5wYXJzZXIuanNvbi5tYXRlcmlhbHNbdF07cmV0dXJuIW8uZXh0ZW5zaW9uc3x8IW8uZXh0ZW5zaW9uc1t0aGlzLm5hbWVdP251bGw6YS5NZXNoUGh5c2ljYWxNYXRlcmlhbH1leHRlbmRNYXRlcmlhbFBhcmFtcyh0LGUpe2xldCBvPXRoaXMucGFyc2VyLG49by5qc29uLm1hdGVyaWFsc1t0XTtpZighbi5leHRlbnNpb25zfHwhbi5leHRlbnNpb25zW3RoaXMubmFtZV0pcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO2xldCByPVtdLHM9bi5leHRlbnNpb25zW3RoaXMubmFtZV07cmV0dXJuIGUuYnVtcFNjYWxlPXMuYnVtcEZhY3RvciE9PXZvaWQgMD9zLmJ1bXBGYWN0b3I6MSxzLmJ1bXBUZXh0dXJlIT09dm9pZCAwJiZyLnB1c2goby5hc3NpZ25UZXh0dXJlKGUsImJ1bXBNYXAiLHMuYnVtcFRleHR1cmUpKSxQcm9taXNlLmFsbChyKX19LHRlPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMucGFyc2VyPXQsdGhpcy5uYW1lPUEuS0hSX01BVEVSSUFMU19BTklTT1RST1BZfWdldE1hdGVyaWFsVHlwZSh0KXtsZXQgbz10aGlzLnBhcnNlci5qc29uLm1hdGVyaWFsc1t0XTtyZXR1cm4hby5leHRlbnNpb25zfHwhby5leHRlbnNpb25zW3RoaXMubmFtZV0/bnVsbDphLk1lc2hQaHlzaWNhbE1hdGVyaWFsfWV4dGVuZE1hdGVyaWFsUGFyYW1zKHQsZSl7bGV0IG89dGhpcy5wYXJzZXIsbj1vLmpzb24ubWF0ZXJpYWxzW3RdO2lmKCFuLmV4dGVuc2lvbnN8fCFuLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7bGV0IHI9W10scz1uLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtyZXR1cm4gcy5hbmlzb3Ryb3B5U3RyZW5ndGghPT12b2lkIDAmJihlLmFuaXNvdHJvcHk9cy5hbmlzb3Ryb3B5U3RyZW5ndGgpLHMuYW5pc290cm9weVJvdGF0aW9uIT09dm9pZCAwJiYoZS5hbmlzb3Ryb3B5Um90YXRpb249cy5hbmlzb3Ryb3B5Um90YXRpb24pLHMuYW5pc290cm9weVRleHR1cmUhPT12b2lkIDAmJnIucHVzaChvLmFzc2lnblRleHR1cmUoZSwiYW5pc290cm9weU1hcCIscy5hbmlzb3Ryb3B5VGV4dHVyZSkpLFByb21pc2UuYWxsKHIpfX0sbmU9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5wYXJzZXI9dCx0aGlzLm5hbWU9QS5LSFJfVEVYVFVSRV9CQVNJU1V9bG9hZFRleHR1cmUodCl7bGV0IGU9dGhpcy5wYXJzZXIsbz1lLmpzb24sbj1vLnRleHR1cmVzW3RdO2lmKCFuLmV4dGVuc2lvbnN8fCFuLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlyZXR1cm4gbnVsbDtsZXQgcj1uLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSxzPWUub3B0aW9ucy5rdHgyTG9hZGVyO2lmKCFzKXtpZihvLmV4dGVuc2lvbnNSZXF1aXJlZCYmby5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZih0aGlzLm5hbWUpPj0wKXRocm93IG5ldyBFcnJvcigiVEhSRUUuR0xURkxvYWRlcjogc2V0S1RYMkxvYWRlciBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgbG9hZGluZyBLVFgyIHRleHR1cmVzIik7cmV0dXJuIG51bGx9cmV0dXJuIGUubG9hZFRleHR1cmVJbWFnZSh0LHIuc291cmNlLHMpfX0sc2U9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5wYXJzZXI9dCx0aGlzLm5hbWU9QS5FWFRfVEVYVFVSRV9XRUJQLHRoaXMuaXNTdXBwb3J0ZWQ9bnVsbH1sb2FkVGV4dHVyZSh0KXtsZXQgZT10aGlzLm5hbWUsbz10aGlzLnBhcnNlcixuPW8uanNvbixyPW4udGV4dHVyZXNbdF07aWYoIXIuZXh0ZW5zaW9uc3x8IXIuZXh0ZW5zaW9uc1tlXSlyZXR1cm4gbnVsbDtsZXQgcz1yLmV4dGVuc2lvbnNbZV0sYz1uLmltYWdlc1tzLnNvdXJjZV0saT1vLnRleHR1cmVMb2FkZXI7aWYoYy51cmkpe2xldCB1PW8ub3B0aW9ucy5tYW5hZ2VyLmdldEhhbmRsZXIoYy51cmkpO3UhPT1udWxsJiYoaT11KX1yZXR1cm4gdGhpcy5kZXRlY3RTdXBwb3J0KCkudGhlbihmdW5jdGlvbih1KXtpZih1KXJldHVybiBvLmxvYWRUZXh0dXJlSW1hZ2UodCxzLnNvdXJjZSxpKTtpZihuLmV4dGVuc2lvbnNSZXF1aXJlZCYmbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZihlKT49MCl0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLkdMVEZMb2FkZXI6IFdlYlAgcmVxdWlyZWQgYnkgYXNzZXQgYnV0IHVuc3VwcG9ydGVkLiIpO3JldHVybiBvLmxvYWRUZXh0dXJlKHQpfSl9ZGV0ZWN0U3VwcG9ydCgpe3JldHVybiB0aGlzLmlzU3VwcG9ydGVkfHwodGhpcy5pc1N1cHBvcnRlZD1uZXcgUHJvbWlzZShmdW5jdGlvbih0KXtsZXQgZT1uZXcgSW1hZ2U7ZS5zcmM9ImRhdGE6aW1hZ2Uvd2VicDtiYXNlNjQsVWtsR1JpSUFBQUJYUlVKUVZsQTRJQllBQUFBd0FRQ2RBU29CQUFFQURzRCtKYVFBQTNBQUFBQUEiLGUub25sb2FkPWUub25lcnJvcj1mdW5jdGlvbigpe3QoZS5oZWlnaHQ9PT0xKX19KSksdGhpcy5pc1N1cHBvcnRlZH19LHJlPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMucGFyc2VyPXQsdGhpcy5uYW1lPUEuRVhUX1RFWFRVUkVfQVZJRix0aGlzLmlzU3VwcG9ydGVkPW51bGx9bG9hZFRleHR1cmUodCl7bGV0IGU9dGhpcy5uYW1lLG89dGhpcy5wYXJzZXIsbj1vLmpzb24scj1uLnRleHR1cmVzW3RdO2lmKCFyLmV4dGVuc2lvbnN8fCFyLmV4dGVuc2lvbnNbZV0pcmV0dXJuIG51bGw7bGV0IHM9ci5leHRlbnNpb25zW2VdLGM9bi5pbWFnZXNbcy5zb3VyY2VdLGk9by50ZXh0dXJlTG9hZGVyO2lmKGMudXJpKXtsZXQgdT1vLm9wdGlvbnMubWFuYWdlci5nZXRIYW5kbGVyKGMudXJpKTt1IT09bnVsbCYmKGk9dSl9cmV0dXJuIHRoaXMuZGV0ZWN0U3VwcG9ydCgpLnRoZW4oZnVuY3Rpb24odSl7aWYodSlyZXR1cm4gby5sb2FkVGV4dHVyZUltYWdlKHQscy5zb3VyY2UsaSk7aWYobi5leHRlbnNpb25zUmVxdWlyZWQmJm4uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YoZSk+PTApdGhyb3cgbmV3IEVycm9yKCJUSFJFRS5HTFRGTG9hZGVyOiBBVklGIHJlcXVpcmVkIGJ5IGFzc2V0IGJ1dCB1bnN1cHBvcnRlZC4iKTtyZXR1cm4gby5sb2FkVGV4dHVyZSh0KX0pfWRldGVjdFN1cHBvcnQoKXtyZXR1cm4gdGhpcy5pc1N1cHBvcnRlZHx8KHRoaXMuaXNTdXBwb3J0ZWQ9bmV3IFByb21pc2UoZnVuY3Rpb24odCl7bGV0IGU9bmV3IEltYWdlO2Uuc3JjPSJkYXRhOmltYWdlL2F2aWY7YmFzZTY0LEFBQUFJR1owZVhCaGRtbG1BQUFBQUdGMmFXWnRhV1l4YldsaFprMUJNVUlBQUFEeWJXVjBZUUFBQUFBQUFBQW9hR1JzY2dBQUFBQUFBQUFBY0dsamRBQUFBQUFBQUFBQUFBQUFBR3hwWW1GMmFXWUFBQUFBRG5CcGRHMEFBQUFBQUFFQUFBQWVhV3h2WXdBQUFBQkVBQUFCQUFFQUFBQUJBQUFCR2dBQUFCY0FBQUFvYVdsdVpnQUFBQUFBQVFBQUFCcHBibVpsQWdBQUFBQUJBQUJoZGpBeFEyOXNiM0lBQUFBQWFtbHdjbkFBQUFCTGFYQmpid0FBQUJScGMzQmxBQUFBQUFBQUFBRUFBQUFCQUFBQUVIQnBlR2tBQUFBQUF3Z0lDQUFBQUF4aGRqRkRnUUFNQUFBQUFCTmpiMnh5Ym1Oc2VBQUNBQUlBQm9BQUFBQVhhWEJ0WVFBQUFBQUFBQUFCQUFFRUFRS0RCQUFBQUI5dFpHRjBFZ0FLQ0JnQUJvZ1FFRFFnTWdrUUFBQUFCOGRTTGZJPSIsZS5vbmxvYWQ9ZS5vbmVycm9yPWZ1bmN0aW9uKCl7dChlLmhlaWdodD09PTEpfX0pKSx0aGlzLmlzU3VwcG9ydGVkfX0sb2U9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5uYW1lPUEuRVhUX01FU0hPUFRfQ09NUFJFU1NJT04sdGhpcy5wYXJzZXI9dH1sb2FkQnVmZmVyVmlldyh0KXtsZXQgZT10aGlzLnBhcnNlci5qc29uLG89ZS5idWZmZXJWaWV3c1t0XTtpZihvLmV4dGVuc2lvbnMmJm8uZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKXtsZXQgbj1vLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSxyPXRoaXMucGFyc2VyLmdldERlcGVuZGVuY3koImJ1ZmZlciIsbi5idWZmZXIpLHM9dGhpcy5wYXJzZXIub3B0aW9ucy5tZXNob3B0RGVjb2RlcjtpZighc3x8IXMuc3VwcG9ydGVkKXtpZihlLmV4dGVuc2lvbnNSZXF1aXJlZCYmZS5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZih0aGlzLm5hbWUpPj0wKXRocm93IG5ldyBFcnJvcigiVEhSRUUuR0xURkxvYWRlcjogc2V0TWVzaG9wdERlY29kZXIgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGxvYWRpbmcgY29tcHJlc3NlZCBmaWxlcyIpO3JldHVybiBudWxsfXJldHVybiByLnRoZW4oZnVuY3Rpb24oYyl7bGV0IGk9bi5ieXRlT2Zmc2V0fHwwLHU9bi5ieXRlTGVuZ3RofHwwLGY9bi5jb3VudCxsPW4uYnl0ZVN0cmlkZSxoPW5ldyBVaW50OEFycmF5KGMsaSx1KTtyZXR1cm4gcy5kZWNvZGVHbHRmQnVmZmVyQXN5bmM/cy5kZWNvZGVHbHRmQnVmZmVyQXN5bmMoZixsLGgsbi5tb2RlLG4uZmlsdGVyKS50aGVuKGZ1bmN0aW9uKHApe3JldHVybiBwLmJ1ZmZlcn0pOnMucmVhZHkudGhlbihmdW5jdGlvbigpe2xldCBwPW5ldyBBcnJheUJ1ZmZlcihmKmwpO3JldHVybiBzLmRlY29kZUdsdGZCdWZmZXIobmV3IFVpbnQ4QXJyYXkocCksZixsLGgsbi5tb2RlLG4uZmlsdGVyKSxwfSl9KX1lbHNlIHJldHVybiBudWxsfX0saWU9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5uYW1lPUEuRVhUX01FU0hfR1BVX0lOU1RBTkNJTkcsdGhpcy5wYXJzZXI9dH1jcmVhdGVOb2RlTWVzaCh0KXtsZXQgZT10aGlzLnBhcnNlci5qc29uLG89ZS5ub2Rlc1t0XTtpZighby5leHRlbnNpb25zfHwhby5leHRlbnNpb25zW3RoaXMubmFtZV18fG8ubWVzaD09PXZvaWQgMClyZXR1cm4gbnVsbDtsZXQgbj1lLm1lc2hlc1tvLm1lc2hdO2ZvcihsZXQgdSBvZiBuLnByaW1pdGl2ZXMpaWYodS5tb2RlIT09eS5UUklBTkdMRVMmJnUubW9kZSE9PXkuVFJJQU5HTEVfU1RSSVAmJnUubW9kZSE9PXkuVFJJQU5HTEVfRkFOJiZ1Lm1vZGUhPT12b2lkIDApcmV0dXJuIG51bGw7bGV0IHM9by5leHRlbnNpb25zW3RoaXMubmFtZV0uYXR0cmlidXRlcyxjPVtdLGk9e307Zm9yKGxldCB1IGluIHMpYy5wdXNoKHRoaXMucGFyc2VyLmdldERlcGVuZGVuY3koImFjY2Vzc29yIixzW3VdKS50aGVuKGY9PihpW3VdPWYsaVt1XSkpKTtyZXR1cm4gYy5sZW5ndGg8MT9udWxsOihjLnB1c2godGhpcy5wYXJzZXIuY3JlYXRlTm9kZU1lc2godCkpLFByb21pc2UuYWxsKGMpLnRoZW4odT0+e2xldCBmPXUucG9wKCksbD1mLmlzR3JvdXA/Zi5jaGlsZHJlbjpbZl0saD11WzBdLmNvdW50LHA9W107Zm9yKGxldCBtIG9mIGwpe2xldCBSPW5ldyBhLk1hdHJpeDQsZz1uZXcgYS5WZWN0b3IzLFQ9bmV3IGEuUXVhdGVybmlvbixFPW5ldyBhLlZlY3RvcjMoMSwxLDEpLGI9bmV3IGEuSW5zdGFuY2VkTWVzaChtLmdlb21ldHJ5LG0ubWF0ZXJpYWwsaCk7Zm9yKGxldCB4PTA7eDxoO3grKylpLlRSQU5TTEFUSU9OJiZnLmZyb21CdWZmZXJBdHRyaWJ1dGUoaS5UUkFOU0xBVElPTix4KSxpLlJPVEFUSU9OJiZULmZyb21CdWZmZXJBdHRyaWJ1dGUoaS5ST1RBVElPTix4KSxpLlNDQUxFJiZFLmZyb21CdWZmZXJBdHRyaWJ1dGUoaS5TQ0FMRSx4KSxiLnNldE1hdHJpeEF0KHgsUi5jb21wb3NlKGcsVCxFKSk7Zm9yKGxldCB4IGluIGkpaWYoeD09PSJfQ09MT1JfMCIpe2xldCBTPWlbeF07Yi5pbnN0YW5jZUNvbG9yPW5ldyBhLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZShTLmFycmF5LFMuaXRlbVNpemUsUy5ub3JtYWxpemVkKX1lbHNlIHghPT0iVFJBTlNMQVRJT04iJiZ4IT09IlJPVEFUSU9OIiYmeCE9PSJTQ0FMRSImJm0uZ2VvbWV0cnkuc2V0QXR0cmlidXRlKHgsaVt4XSk7YS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKGIsbSksdGhpcy5wYXJzZXIuYXNzaWduRmluYWxNYXRlcmlhbChiKSxwLnB1c2goYil9cmV0dXJuIGYuaXNHcm91cD8oZi5jbGVhcigpLGYuYWRkKC4uLnApLGYpOnBbMF19KSl9fSxiZT0iZ2xURiIsRD0xMixUZT17SlNPTjoxMzEzODIxNTE0LEJJTjo1MTMwNTYyfSxhZT1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLm5hbWU9QS5LSFJfQklOQVJZX0dMVEYsdGhpcy5jb250ZW50PW51bGwsdGhpcy5ib2R5PW51bGw7bGV0IGU9bmV3IERhdGFWaWV3KHQsMCxEKSxvPW5ldyBUZXh0RGVjb2RlcjtpZih0aGlzLmhlYWRlcj17bWFnaWM6by5kZWNvZGUobmV3IFVpbnQ4QXJyYXkodC5zbGljZSgwLDQpKSksdmVyc2lvbjplLmdldFVpbnQzMig0LCEwKSxsZW5ndGg6ZS5nZXRVaW50MzIoOCwhMCl9LHRoaXMuaGVhZGVyLm1hZ2ljIT09YmUpdGhyb3cgbmV3IEVycm9yKCJUSFJFRS5HTFRGTG9hZGVyOiBVbnN1cHBvcnRlZCBnbFRGLUJpbmFyeSBoZWFkZXIuIik7aWYodGhpcy5oZWFkZXIudmVyc2lvbjwyKXRocm93IG5ldyBFcnJvcigiVEhSRUUuR0xURkxvYWRlcjogTGVnYWN5IGJpbmFyeSBmaWxlIGRldGVjdGVkLiIpO2xldCBuPXRoaXMuaGVhZGVyLmxlbmd0aC1ELHI9bmV3IERhdGFWaWV3KHQsRCkscz0wO2Zvcig7czxuOyl7bGV0IGM9ci5nZXRVaW50MzIocywhMCk7cys9NDtsZXQgaT1yLmdldFVpbnQzMihzLCEwKTtpZihzKz00LGk9PT1UZS5KU09OKXtsZXQgdT1uZXcgVWludDhBcnJheSh0LEQrcyxjKTt0aGlzLmNvbnRlbnQ9by5kZWNvZGUodSl9ZWxzZSBpZihpPT09VGUuQklOKXtsZXQgdT1EK3M7dGhpcy5ib2R5PXQuc2xpY2UodSx1K2MpfXMrPWN9aWYodGhpcy5jb250ZW50PT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLkdMVEZMb2FkZXI6IEpTT04gY29udGVudCBub3QgZm91bmQuIil9fSxjZT1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUpe2lmKCFlKXRocm93IG5ldyBFcnJvcigiVEhSRUUuR0xURkxvYWRlcjogTm8gRFJBQ09Mb2FkZXIgaW5zdGFuY2UgcHJvdmlkZWQuIik7dGhpcy5uYW1lPUEuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT04sdGhpcy5qc29uPXQsdGhpcy5kcmFjb0xvYWRlcj1lLHRoaXMuZHJhY29Mb2FkZXIucHJlbG9hZCgpfWRlY29kZVByaW1pdGl2ZSh0LGUpe2xldCBvPXRoaXMuanNvbixuPXRoaXMuZHJhY29Mb2FkZXIscj10LmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5idWZmZXJWaWV3LHM9dC5leHRlbnNpb25zW3RoaXMubmFtZV0uYXR0cmlidXRlcyxjPXt9LGk9e30sdT17fTtmb3IobGV0IGYgaW4gcyl7bGV0IGw9ZGVbZl18fGYudG9Mb3dlckNhc2UoKTtjW2xdPXNbZl19Zm9yKGxldCBmIGluIHQuYXR0cmlidXRlcyl7bGV0IGw9ZGVbZl18fGYudG9Mb3dlckNhc2UoKTtpZihzW2ZdIT09dm9pZCAwKXtsZXQgaD1vLmFjY2Vzc29yc1t0LmF0dHJpYnV0ZXNbZl1dLHA9Q1toLmNvbXBvbmVudFR5cGVdO3VbbF09cC5uYW1lLGlbbF09aC5ub3JtYWxpemVkPT09ITB9fXJldHVybiBlLmdldERlcGVuZGVuY3koImJ1ZmZlclZpZXciLHIpLnRoZW4oZnVuY3Rpb24oZil7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGwsaCl7bi5kZWNvZGVEcmFjb0ZpbGUoZixmdW5jdGlvbihwKXtmb3IobGV0IG0gaW4gcC5hdHRyaWJ1dGVzKXtsZXQgUj1wLmF0dHJpYnV0ZXNbbV0sZz1pW21dO2chPT12b2lkIDAmJihSLm5vcm1hbGl6ZWQ9Zyl9bChwKX0sYyx1LGEuTGluZWFyU1JHQkNvbG9yU3BhY2UsaCl9KX0pfX0sdWU9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLm5hbWU9QS5LSFJfVEVYVFVSRV9UUkFOU0ZPUk19ZXh0ZW5kVGV4dHVyZSh0LGUpe3JldHVybihlLnRleENvb3JkPT09dm9pZCAwfHxlLnRleENvb3JkPT09dC5jaGFubmVsKSYmZS5vZmZzZXQ9PT12b2lkIDAmJmUucm90YXRpb249PT12b2lkIDAmJmUuc2NhbGU9PT12b2lkIDB8fCh0PXQuY2xvbmUoKSxlLnRleENvb3JkIT09dm9pZCAwJiYodC5jaGFubmVsPWUudGV4Q29vcmQpLGUub2Zmc2V0IT09dm9pZCAwJiZ0Lm9mZnNldC5mcm9tQXJyYXkoZS5vZmZzZXQpLGUucm90YXRpb24hPT12b2lkIDAmJih0LnJvdGF0aW9uPWUucm90YXRpb24pLGUuc2NhbGUhPT12b2lkIDAmJnQucmVwZWF0LmZyb21BcnJheShlLnNjYWxlKSx0Lm5lZWRzVXBkYXRlPSEwKSx0fX0sbGU9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLm5hbWU9QS5LSFJfTUVTSF9RVUFOVElaQVRJT059fSxIPWNsYXNzIGV4dGVuZHMgYS5JbnRlcnBvbGFudHtjb25zdHJ1Y3Rvcih0LGUsbyxuKXtzdXBlcih0LGUsbyxuKX1jb3B5U2FtcGxlVmFsdWVfKHQpe2xldCBlPXRoaXMucmVzdWx0QnVmZmVyLG89dGhpcy5zYW1wbGVWYWx1ZXMsbj10aGlzLnZhbHVlU2l6ZSxyPXQqbiozK247Zm9yKGxldCBzPTA7cyE9PW47cysrKWVbc109b1tyK3NdO3JldHVybiBlfWludGVycG9sYXRlXyh0LGUsbyxuKXtsZXQgcj10aGlzLnJlc3VsdEJ1ZmZlcixzPXRoaXMuc2FtcGxlVmFsdWVzLGM9dGhpcy52YWx1ZVNpemUsaT1jKjIsdT1jKjMsZj1uLWUsbD0oby1lKS9mLGg9bCpsLHA9aCpsLG09dCp1LFI9bS11LGc9LTIqcCszKmgsVD1wLWgsRT0xLWcsYj1ULWgrbDtmb3IobGV0IHg9MDt4IT09Yzt4Kyspe2xldCBTPXNbUit4K2NdLE09c1tSK3graV0qZixfPXNbbSt4K2NdLEI9c1ttK3hdKmY7clt4XT1FKlMrYipNK2cqXytUKkJ9cmV0dXJuIHJ9fSxDZT1uZXcgYS5RdWF0ZXJuaW9uLGZlPWNsYXNzIGV4dGVuZHMgSHtpbnRlcnBvbGF0ZV8odCxlLG8sbil7bGV0IHI9c3VwZXIuaW50ZXJwb2xhdGVfKHQsZSxvLG4pO3JldHVybiBDZS5mcm9tQXJyYXkocikubm9ybWFsaXplKCkudG9BcnJheShyKSxyfX0seT17RkxPQVQ6NTEyNixGTE9BVF9NQVQzOjM1Njc1LEZMT0FUX01BVDQ6MzU2NzYsRkxPQVRfVkVDMjozNTY2NCxGTE9BVF9WRUMzOjM1NjY1LEZMT0FUX1ZFQzQ6MzU2NjYsTElORUFSOjk3MjksUkVQRUFUOjEwNDk3LFNBTVBMRVJfMkQ6MzU2NzgsUE9JTlRTOjAsTElORVM6MSxMSU5FX0xPT1A6MixMSU5FX1NUUklQOjMsVFJJQU5HTEVTOjQsVFJJQU5HTEVfU1RSSVA6NSxUUklBTkdMRV9GQU46NixVTlNJR05FRF9CWVRFOjUxMjEsVU5TSUdORURfU0hPUlQ6NTEyM30sQz17NTEyMDpJbnQ4QXJyYXksNTEyMTpVaW50OEFycmF5LDUxMjI6SW50MTZBcnJheSw1MTIzOlVpbnQxNkFycmF5LDUxMjU6VWludDMyQXJyYXksNTEyNjpGbG9hdDMyQXJyYXl9LFJlPXs5NzI4OmEuTmVhcmVzdEZpbHRlciw5NzI5OmEuTGluZWFyRmlsdGVyLDk5ODQ6YS5OZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlciw5OTg1OmEuTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciw5OTg2OmEuTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlciw5OTg3OmEuTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyfSx4ZT17MzMwNzE6YS5DbGFtcFRvRWRnZVdyYXBwaW5nLDMzNjQ4OmEuTWlycm9yZWRSZXBlYXRXcmFwcGluZywxMDQ5NzphLlJlcGVhdFdyYXBwaW5nfSxGPXtTQ0FMQVI6MSxWRUMyOjIsVkVDMzozLFZFQzQ6NCxNQVQyOjQsTUFUMzo5LE1BVDQ6MTZ9LGRlPXtQT1NJVElPTjoicG9zaXRpb24iLE5PUk1BTDoibm9ybWFsIixUQU5HRU5UOiJ0YW5nZW50IixURVhDT09SRF8wOiJ1diIsVEVYQ09PUkRfMToidXYxIixURVhDT09SRF8yOiJ1djIiLFRFWENPT1JEXzM6InV2MyIsQ09MT1JfMDoiY29sb3IiLFdFSUdIVFNfMDoic2tpbldlaWdodCIsSk9JTlRTXzA6InNraW5JbmRleCJ9LE49e3NjYWxlOiJzY2FsZSIsdHJhbnNsYXRpb246InBvc2l0aW9uIixyb3RhdGlvbjoicXVhdGVybmlvbiIsd2VpZ2h0czoibW9ycGhUYXJnZXRJbmZsdWVuY2VzIn0sQmU9e0NVQklDU1BMSU5FOnZvaWQgMCxMSU5FQVI6YS5JbnRlcnBvbGF0ZUxpbmVhcixTVEVQOmEuSW50ZXJwb2xhdGVEaXNjcmV0ZX0sRz17T1BBUVVFOiJPUEFRVUUiLE1BU0s6Ik1BU0siLEJMRU5EOiJCTEVORCJ9O2Z1bmN0aW9uIERlKGQpe3JldHVybiBkLkRlZmF1bHRNYXRlcmlhbD09PXZvaWQgMCYmKGQuRGVmYXVsdE1hdGVyaWFsPW5ldyBhLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHtjb2xvcjoxNjc3NzIxNSxlbWlzc2l2ZTowLG1ldGFsbmVzczoxLHJvdWdobmVzczoxLHRyYW5zcGFyZW50OiExLGRlcHRoVGVzdDohMCxzaWRlOmEuRnJvbnRTaWRlfSkpLGQuRGVmYXVsdE1hdGVyaWFsfWZ1bmN0aW9uIE8oZCx0LGUpe2ZvcihsZXQgbyBpbiBlLmV4dGVuc2lvbnMpZFtvXT09PXZvaWQgMCYmKHQudXNlckRhdGEuZ2x0ZkV4dGVuc2lvbnM9dC51c2VyRGF0YS5nbHRmRXh0ZW5zaW9uc3x8e30sdC51c2VyRGF0YS5nbHRmRXh0ZW5zaW9uc1tvXT1lLmV4dGVuc2lvbnNbb10pfWZ1bmN0aW9uIEwoZCx0KXt0LmV4dHJhcyE9PXZvaWQgMCYmKHR5cGVvZiB0LmV4dHJhcz09Im9iamVjdCI/T2JqZWN0LmFzc2lnbihkLnVzZXJEYXRhLHQuZXh0cmFzKTpjb25zb2xlLndhcm4oIlRIUkVFLkdMVEZMb2FkZXI6IElnbm9yaW5nIHByaW1pdGl2ZSB0eXBlIC5leHRyYXMsICIrdC5leHRyYXMpKX1mdW5jdGlvbiBrZShkLHQsZSl7bGV0IG89ITEsbj0hMSxyPSExO2ZvcihsZXQgdT0wLGY9dC5sZW5ndGg7dTxmO3UrKyl7bGV0IGw9dFt1XTtpZihsLlBPU0lUSU9OIT09dm9pZCAwJiYobz0hMCksbC5OT1JNQUwhPT12b2lkIDAmJihuPSEwKSxsLkNPTE9SXzAhPT12b2lkIDAmJihyPSEwKSxvJiZuJiZyKWJyZWFrfWlmKCFvJiYhbiYmIXIpcmV0dXJuIFByb21pc2UucmVzb2x2ZShkKTtsZXQgcz1bXSxjPVtdLGk9W107Zm9yKGxldCB1PTAsZj10Lmxlbmd0aDt1PGY7dSsrKXtsZXQgbD10W3VdO2lmKG8pe2xldCBoPWwuUE9TSVRJT04hPT12b2lkIDA/ZS5nZXREZXBlbmRlbmN5KCJhY2Nlc3NvciIsbC5QT1NJVElPTik6ZC5hdHRyaWJ1dGVzLnBvc2l0aW9uO3MucHVzaChoKX1pZihuKXtsZXQgaD1sLk5PUk1BTCE9PXZvaWQgMD9lLmdldERlcGVuZGVuY3koImFjY2Vzc29yIixsLk5PUk1BTCk6ZC5hdHRyaWJ1dGVzLm5vcm1hbDtjLnB1c2goaCl9aWYocil7bGV0IGg9bC5DT0xPUl8wIT09dm9pZCAwP2UuZ2V0RGVwZW5kZW5jeSgiYWNjZXNzb3IiLGwuQ09MT1JfMCk6ZC5hdHRyaWJ1dGVzLmNvbG9yO2kucHVzaChoKX19cmV0dXJuIFByb21pc2UuYWxsKFtQcm9taXNlLmFsbChzKSxQcm9taXNlLmFsbChjKSxQcm9taXNlLmFsbChpKV0pLnRoZW4oZnVuY3Rpb24odSl7bGV0IGY9dVswXSxsPXVbMV0saD11WzJdO3JldHVybiBvJiYoZC5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb249ZiksbiYmKGQubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbD1sKSxyJiYoZC5tb3JwaEF0dHJpYnV0ZXMuY29sb3I9aCksZC5tb3JwaFRhcmdldHNSZWxhdGl2ZT0hMCxkfSl9ZnVuY3Rpb24gSGUoZCx0KXtpZihkLnVwZGF0ZU1vcnBoVGFyZ2V0cygpLHQud2VpZ2h0cyE9PXZvaWQgMClmb3IobGV0IGU9MCxvPXQud2VpZ2h0cy5sZW5ndGg7ZTxvO2UrKylkLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tlXT10LndlaWdodHNbZV07aWYodC5leHRyYXMmJkFycmF5LmlzQXJyYXkodC5leHRyYXMudGFyZ2V0TmFtZXMpKXtsZXQgZT10LmV4dHJhcy50YXJnZXROYW1lcztpZihkLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5sZW5ndGg9PT1lLmxlbmd0aCl7ZC5tb3JwaFRhcmdldERpY3Rpb25hcnk9e307Zm9yKGxldCBvPTAsbj1lLmxlbmd0aDtvPG47bysrKWQubW9ycGhUYXJnZXREaWN0aW9uYXJ5W2Vbb11dPW99ZWxzZSBjb25zb2xlLndhcm4oIlRIUkVFLkdMVEZMb2FkZXI6IEludmFsaWQgZXh0cmFzLnRhcmdldE5hbWVzIGxlbmd0aC4gSWdub3JpbmcgbmFtZXMuIil9fWZ1bmN0aW9uIFBlKGQpe2xldCB0LGU9ZC5leHRlbnNpb25zJiZkLmV4dGVuc2lvbnNbQS5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTl07aWYoZT90PSJkcmFjbzoiK2UuYnVmZmVyVmlldysiOiIrZS5pbmRpY2VzKyI6IitqKGUuYXR0cmlidXRlcyk6dD1kLmluZGljZXMrIjoiK2ooZC5hdHRyaWJ1dGVzKSsiOiIrZC5tb2RlLGQudGFyZ2V0cyE9PXZvaWQgMClmb3IobGV0IG89MCxuPWQudGFyZ2V0cy5sZW5ndGg7bzxuO28rKyl0Kz0iOiIraihkLnRhcmdldHNbb10pO3JldHVybiB0fWZ1bmN0aW9uIGooZCl7bGV0IHQ9IiIsZT1PYmplY3Qua2V5cyhkKS5zb3J0KCk7Zm9yKGxldCBvPTAsbj1lLmxlbmd0aDtvPG47bysrKXQrPWVbb10rIjoiK2RbZVtvXV0rIjsiO3JldHVybiB0fWZ1bmN0aW9uIGhlKGQpe3N3aXRjaChkKXtjYXNlIEludDhBcnJheTpyZXR1cm4gMS8xMjc7Y2FzZSBVaW50OEFycmF5OnJldHVybiAxLzI1NTtjYXNlIEludDE2QXJyYXk6cmV0dXJuIDEvMzI3Njc7Y2FzZSBVaW50MTZBcnJheTpyZXR1cm4gMS82NTUzNTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgbm9ybWFsaXplZCBhY2Nlc3NvciBjb21wb25lbnQgdHlwZS4iKX19ZnVuY3Rpb24gdmUoZCl7cmV0dXJuIGQuc2VhcmNoKC9cLmpwZT9nKCR8XD8pL2kpPjB8fGQuc2VhcmNoKC9eZGF0YVw6aW1hZ2VcL2pwZWcvKT09PTA/ImltYWdlL2pwZWciOmQuc2VhcmNoKC9cLndlYnAoJHxcPykvaSk+MHx8ZC5zZWFyY2goL15kYXRhXDppbWFnZVwvd2VicC8pPT09MD8iaW1hZ2Uvd2VicCI6ImltYWdlL3BuZyJ9dmFyIFVlPW5ldyBhLk1hdHJpeDQscGU9Y2xhc3N7Y29uc3RydWN0b3IodD17fSxlPXt9KXt0aGlzLmpzb249dCx0aGlzLmV4dGVuc2lvbnM9e30sdGhpcy5wbHVnaW5zPXt9LHRoaXMub3B0aW9ucz1lLHRoaXMuY2FjaGU9bmV3IE9lLHRoaXMuYXNzb2NpYXRpb25zPW5ldyBNYXAsdGhpcy5wcmltaXRpdmVDYWNoZT17fSx0aGlzLm5vZGVDYWNoZT17fSx0aGlzLm1lc2hDYWNoZT17cmVmczp7fSx1c2VzOnt9fSx0aGlzLmNhbWVyYUNhY2hlPXtyZWZzOnt9LHVzZXM6e319LHRoaXMubGlnaHRDYWNoZT17cmVmczp7fSx1c2VzOnt9fSx0aGlzLnNvdXJjZUNhY2hlPXt9LHRoaXMudGV4dHVyZUNhY2hlPXt9LHRoaXMubm9kZU5hbWVzVXNlZD17fTtsZXQgbz0hMSxuPSExLHI9LTE7dHlwZW9mIG5hdmlnYXRvcjwidSImJihvPS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk9PT0hMCxuPW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiRmlyZWZveCIpPi0xLHI9bj9uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9GaXJlZm94XC8oWzAtOV0rKVwuLylbMV06LTEpLHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcD4idSJ8fG98fG4mJnI8OTg/dGhpcy50ZXh0dXJlTG9hZGVyPW5ldyBhLlRleHR1cmVMb2FkZXIodGhpcy5vcHRpb25zLm1hbmFnZXIpOnRoaXMudGV4dHVyZUxvYWRlcj1uZXcgYS5JbWFnZUJpdG1hcExvYWRlcih0aGlzLm9wdGlvbnMubWFuYWdlciksdGhpcy50ZXh0dXJlTG9hZGVyLnNldENyb3NzT3JpZ2luKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiksdGhpcy50ZXh0dXJlTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5vcHRpb25zLnJlcXVlc3RIZWFkZXIpLHRoaXMuZmlsZUxvYWRlcj1uZXcgYS5GaWxlTG9hZGVyKHRoaXMub3B0aW9ucy5tYW5hZ2VyKSx0aGlzLmZpbGVMb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCJhcnJheWJ1ZmZlciIpLHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbj09PSJ1c2UtY3JlZGVudGlhbHMiJiZ0aGlzLmZpbGVMb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCEwKX1zZXRFeHRlbnNpb25zKHQpe3RoaXMuZXh0ZW5zaW9ucz10fXNldFBsdWdpbnModCl7dGhpcy5wbHVnaW5zPXR9cGFyc2UodCxlKXtsZXQgbz10aGlzLG49dGhpcy5qc29uLHI9dGhpcy5leHRlbnNpb25zO3RoaXMuY2FjaGUucmVtb3ZlQWxsKCksdGhpcy5ub2RlQ2FjaGU9e30sdGhpcy5faW52b2tlQWxsKGZ1bmN0aW9uKHMpe3JldHVybiBzLl9tYXJrRGVmcyYmcy5fbWFya0RlZnMoKX0pLFByb21pc2UuYWxsKHRoaXMuX2ludm9rZUFsbChmdW5jdGlvbihzKXtyZXR1cm4gcy5iZWZvcmVSb290JiZzLmJlZm9yZVJvb3QoKX0pKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIFByb21pc2UuYWxsKFtvLmdldERlcGVuZGVuY2llcygic2NlbmUiKSxvLmdldERlcGVuZGVuY2llcygiYW5pbWF0aW9uIiksby5nZXREZXBlbmRlbmNpZXMoImNhbWVyYSIpXSl9KS50aGVuKGZ1bmN0aW9uKHMpe2xldCBjPXtzY2VuZTpzWzBdW24uc2NlbmV8fDBdLHNjZW5lczpzWzBdLGFuaW1hdGlvbnM6c1sxXSxjYW1lcmFzOnNbMl0sYXNzZXQ6bi5hc3NldCxwYXJzZXI6byx1c2VyRGF0YTp7fX07cmV0dXJuIE8ocixjLG4pLEwoYyxuKSxQcm9taXNlLmFsbChvLl9pbnZva2VBbGwoZnVuY3Rpb24oaSl7cmV0dXJuIGkuYWZ0ZXJSb290JiZpLmFmdGVyUm9vdChjKX0pKS50aGVuKGZ1bmN0aW9uKCl7dChjKX0pfSkuY2F0Y2goZSl9X21hcmtEZWZzKCl7bGV0IHQ9dGhpcy5qc29uLm5vZGVzfHxbXSxlPXRoaXMuanNvbi5za2luc3x8W10sbz10aGlzLmpzb24ubWVzaGVzfHxbXTtmb3IobGV0IG49MCxyPWUubGVuZ3RoO248cjtuKyspe2xldCBzPWVbbl0uam9pbnRzO2ZvcihsZXQgYz0wLGk9cy5sZW5ndGg7YzxpO2MrKyl0W3NbY11dLmlzQm9uZT0hMH1mb3IobGV0IG49MCxyPXQubGVuZ3RoO248cjtuKyspe2xldCBzPXRbbl07cy5tZXNoIT09dm9pZCAwJiYodGhpcy5fYWRkTm9kZVJlZih0aGlzLm1lc2hDYWNoZSxzLm1lc2gpLHMuc2tpbiE9PXZvaWQgMCYmKG9bcy5tZXNoXS5pc1NraW5uZWRNZXNoPSEwKSkscy5jYW1lcmEhPT12b2lkIDAmJnRoaXMuX2FkZE5vZGVSZWYodGhpcy5jYW1lcmFDYWNoZSxzLmNhbWVyYSl9fV9hZGROb2RlUmVmKHQsZSl7ZSE9PXZvaWQgMCYmKHQucmVmc1tlXT09PXZvaWQgMCYmKHQucmVmc1tlXT10LnVzZXNbZV09MCksdC5yZWZzW2VdKyspfV9nZXROb2RlUmVmKHQsZSxvKXtpZih0LnJlZnNbZV08PTEpcmV0dXJuIG87bGV0IG49by5jbG9uZSgpLHI9KHMsYyk9PntsZXQgaT10aGlzLmFzc29jaWF0aW9ucy5nZXQocyk7aSE9bnVsbCYmdGhpcy5hc3NvY2lhdGlvbnMuc2V0KGMsaSk7Zm9yKGxldFt1LGZdb2Ygcy5jaGlsZHJlbi5lbnRyaWVzKCkpcihmLGMuY2hpbGRyZW5bdV0pfTtyZXR1cm4gcihvLG4pLG4ubmFtZSs9Il9pbnN0YW5jZV8iK3QudXNlc1tlXSsrLG59X2ludm9rZU9uZSh0KXtsZXQgZT1PYmplY3QudmFsdWVzKHRoaXMucGx1Z2lucyk7ZS5wdXNoKHRoaXMpO2ZvcihsZXQgbz0wO288ZS5sZW5ndGg7bysrKXtsZXQgbj10KGVbb10pO2lmKG4pcmV0dXJuIG59cmV0dXJuIG51bGx9X2ludm9rZUFsbCh0KXtsZXQgZT1PYmplY3QudmFsdWVzKHRoaXMucGx1Z2lucyk7ZS51bnNoaWZ0KHRoaXMpO2xldCBvPVtdO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXtsZXQgcj10KGVbbl0pO3ImJm8ucHVzaChyKX1yZXR1cm4gb31nZXREZXBlbmRlbmN5KHQsZSl7bGV0IG89dCsiOiIrZSxuPXRoaXMuY2FjaGUuZ2V0KG8pO2lmKCFuKXtzd2l0Y2godCl7Y2FzZSJzY2VuZSI6bj10aGlzLmxvYWRTY2VuZShlKTticmVhaztjYXNlIm5vZGUiOm49dGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKHIpe3JldHVybiByLmxvYWROb2RlJiZyLmxvYWROb2RlKGUpfSk7YnJlYWs7Y2FzZSJtZXNoIjpuPXRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihyKXtyZXR1cm4gci5sb2FkTWVzaCYmci5sb2FkTWVzaChlKX0pO2JyZWFrO2Nhc2UiYWNjZXNzb3IiOm49dGhpcy5sb2FkQWNjZXNzb3IoZSk7YnJlYWs7Y2FzZSJidWZmZXJWaWV3IjpuPXRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihyKXtyZXR1cm4gci5sb2FkQnVmZmVyVmlldyYmci5sb2FkQnVmZmVyVmlldyhlKX0pO2JyZWFrO2Nhc2UiYnVmZmVyIjpuPXRoaXMubG9hZEJ1ZmZlcihlKTticmVhaztjYXNlIm1hdGVyaWFsIjpuPXRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihyKXtyZXR1cm4gci5sb2FkTWF0ZXJpYWwmJnIubG9hZE1hdGVyaWFsKGUpfSk7YnJlYWs7Y2FzZSJ0ZXh0dXJlIjpuPXRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihyKXtyZXR1cm4gci5sb2FkVGV4dHVyZSYmci5sb2FkVGV4dHVyZShlKX0pO2JyZWFrO2Nhc2Uic2tpbiI6bj10aGlzLmxvYWRTa2luKGUpO2JyZWFrO2Nhc2UiYW5pbWF0aW9uIjpuPXRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihyKXtyZXR1cm4gci5sb2FkQW5pbWF0aW9uJiZyLmxvYWRBbmltYXRpb24oZSl9KTticmVhaztjYXNlImNhbWVyYSI6bj10aGlzLmxvYWRDYW1lcmEoZSk7YnJlYWs7ZGVmYXVsdDppZihuPXRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihyKXtyZXR1cm4gciE9dGhpcyYmci5nZXREZXBlbmRlbmN5JiZyLmdldERlcGVuZGVuY3kodCxlKX0pLCFuKXRocm93IG5ldyBFcnJvcigiVW5rbm93biB0eXBlOiAiK3QpO2JyZWFrfXRoaXMuY2FjaGUuYWRkKG8sbil9cmV0dXJuIG59Z2V0RGVwZW5kZW5jaWVzKHQpe2xldCBlPXRoaXMuY2FjaGUuZ2V0KHQpO2lmKCFlKXtsZXQgbz10aGlzLG49dGhpcy5qc29uW3QrKHQ9PT0ibWVzaCI/ImVzIjoicyIpXXx8W107ZT1Qcm9taXNlLmFsbChuLm1hcChmdW5jdGlvbihyLHMpe3JldHVybiBvLmdldERlcGVuZGVuY3kodCxzKX0pKSx0aGlzLmNhY2hlLmFkZCh0LGUpfXJldHVybiBlfWxvYWRCdWZmZXIodCl7bGV0IGU9dGhpcy5qc29uLmJ1ZmZlcnNbdF0sbz10aGlzLmZpbGVMb2FkZXI7aWYoZS50eXBlJiZlLnR5cGUhPT0iYXJyYXlidWZmZXIiKXRocm93IG5ldyBFcnJvcigiVEhSRUUuR0xURkxvYWRlcjogIitlLnR5cGUrIiBidWZmZXIgdHlwZSBpcyBub3Qgc3VwcG9ydGVkLiIpO2lmKGUudXJpPT09dm9pZCAwJiZ0PT09MClyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZXh0ZW5zaW9uc1tBLktIUl9CSU5BUllfR0xURl0uYm9keSk7bGV0IG49dGhpcy5vcHRpb25zO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyLHMpe28ubG9hZChhLkxvYWRlclV0aWxzLnJlc29sdmVVUkwoZS51cmksbi5wYXRoKSxyLHZvaWQgMCxmdW5jdGlvbigpe3MobmV3IEVycm9yKCdUSFJFRS5HTFRGTG9hZGVyOiBGYWlsZWQgdG8gbG9hZCBidWZmZXIgIicrZS51cmkrJyIuJykpfSl9KX1sb2FkQnVmZmVyVmlldyh0KXtsZXQgZT10aGlzLmpzb24uYnVmZmVyVmlld3NbdF07cmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jeSgiYnVmZmVyIixlLmJ1ZmZlcikudGhlbihmdW5jdGlvbihvKXtsZXQgbj1lLmJ5dGVMZW5ndGh8fDAscj1lLmJ5dGVPZmZzZXR8fDA7cmV0dXJuIG8uc2xpY2UocixyK24pfSl9bG9hZEFjY2Vzc29yKHQpe2xldCBlPXRoaXMsbz10aGlzLmpzb24sbj10aGlzLmpzb24uYWNjZXNzb3JzW3RdO2lmKG4uYnVmZmVyVmlldz09PXZvaWQgMCYmbi5zcGFyc2U9PT12b2lkIDApe2xldCBzPUZbbi50eXBlXSxjPUNbbi5jb21wb25lbnRUeXBlXSxpPW4ubm9ybWFsaXplZD09PSEwLHU9bmV3IGMobi5jb3VudCpzKTtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBhLkJ1ZmZlckF0dHJpYnV0ZSh1LHMsaSkpfWxldCByPVtdO3JldHVybiBuLmJ1ZmZlclZpZXchPT12b2lkIDA/ci5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeSgiYnVmZmVyVmlldyIsbi5idWZmZXJWaWV3KSk6ci5wdXNoKG51bGwpLG4uc3BhcnNlIT09dm9pZCAwJiYoci5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeSgiYnVmZmVyVmlldyIsbi5zcGFyc2UuaW5kaWNlcy5idWZmZXJWaWV3KSksci5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeSgiYnVmZmVyVmlldyIsbi5zcGFyc2UudmFsdWVzLmJ1ZmZlclZpZXcpKSksUHJvbWlzZS5hbGwocikudGhlbihmdW5jdGlvbihzKXtsZXQgYz1zWzBdLGk9RltuLnR5cGVdLHU9Q1tuLmNvbXBvbmVudFR5cGVdLGY9dS5CWVRFU19QRVJfRUxFTUVOVCxsPWYqaSxoPW4uYnl0ZU9mZnNldHx8MCxwPW4uYnVmZmVyVmlldyE9PXZvaWQgMD9vLmJ1ZmZlclZpZXdzW24uYnVmZmVyVmlld10uYnl0ZVN0cmlkZTp2b2lkIDAsbT1uLm5vcm1hbGl6ZWQ9PT0hMCxSLGc7aWYocCYmcCE9PWwpe2xldCBUPU1hdGguZmxvb3IoaC9wKSxFPSJJbnRlcmxlYXZlZEJ1ZmZlcjoiK24uYnVmZmVyVmlldysiOiIrbi5jb21wb25lbnRUeXBlKyI6IitUKyI6IituLmNvdW50LGI9ZS5jYWNoZS5nZXQoRSk7Ynx8KFI9bmV3IHUoYyxUKnAsbi5jb3VudCpwL2YpLGI9bmV3IGEuSW50ZXJsZWF2ZWRCdWZmZXIoUixwL2YpLGUuY2FjaGUuYWRkKEUsYikpLGc9bmV3IGEuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoYixpLGglcC9mLG0pfWVsc2UgYz09PW51bGw/Uj1uZXcgdShuLmNvdW50KmkpOlI9bmV3IHUoYyxoLG4uY291bnQqaSksZz1uZXcgYS5CdWZmZXJBdHRyaWJ1dGUoUixpLG0pO2lmKG4uc3BhcnNlIT09dm9pZCAwKXtsZXQgVD1GLlNDQUxBUixFPUNbbi5zcGFyc2UuaW5kaWNlcy5jb21wb25lbnRUeXBlXSxiPW4uc3BhcnNlLmluZGljZXMuYnl0ZU9mZnNldHx8MCx4PW4uc3BhcnNlLnZhbHVlcy5ieXRlT2Zmc2V0fHwwLFM9bmV3IEUoc1sxXSxiLG4uc3BhcnNlLmNvdW50KlQpLE09bmV3IHUoc1syXSx4LG4uc3BhcnNlLmNvdW50KmkpO2MhPT1udWxsJiYoZz1uZXcgYS5CdWZmZXJBdHRyaWJ1dGUoZy5hcnJheS5zbGljZSgpLGcuaXRlbVNpemUsZy5ub3JtYWxpemVkKSk7Zm9yKGxldCBfPTAsQj1TLmxlbmd0aDtfPEI7XysrKXtsZXQgST1TW19dO2lmKGcuc2V0WChJLE1bXyppXSksaT49MiYmZy5zZXRZKEksTVtfKmkrMV0pLGk+PTMmJmcuc2V0WihJLE1bXyppKzJdKSxpPj00JiZnLnNldFcoSSxNW18qaSszXSksaT49NSl0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGl0ZW1TaXplIGluIHNwYXJzZSBCdWZmZXJBdHRyaWJ1dGUuIil9fXJldHVybiBnfSl9bG9hZFRleHR1cmUodCl7bGV0IGU9dGhpcy5qc29uLG89dGhpcy5vcHRpb25zLHI9ZS50ZXh0dXJlc1t0XS5zb3VyY2Uscz1lLmltYWdlc1tyXSxjPXRoaXMudGV4dHVyZUxvYWRlcjtpZihzLnVyaSl7bGV0IGk9by5tYW5hZ2VyLmdldEhhbmRsZXIocy51cmkpO2khPT1udWxsJiYoYz1pKX1yZXR1cm4gdGhpcy5sb2FkVGV4dHVyZUltYWdlKHQscixjKX1sb2FkVGV4dHVyZUltYWdlKHQsZSxvKXtsZXQgbj10aGlzLHI9dGhpcy5qc29uLHM9ci50ZXh0dXJlc1t0XSxjPXIuaW1hZ2VzW2VdLGk9KGMudXJpfHxjLmJ1ZmZlclZpZXcpKyI6IitzLnNhbXBsZXI7aWYodGhpcy50ZXh0dXJlQ2FjaGVbaV0pcmV0dXJuIHRoaXMudGV4dHVyZUNhY2hlW2ldO2xldCB1PXRoaXMubG9hZEltYWdlU291cmNlKGUsbykudGhlbihmdW5jdGlvbihmKXtmLmZsaXBZPSExLGYubmFtZT1zLm5hbWV8fGMubmFtZXx8IiIsZi5uYW1lPT09IiImJnR5cGVvZiBjLnVyaT09InN0cmluZyImJmMudXJpLnN0YXJ0c1dpdGgoImRhdGE6aW1hZ2UvIik9PT0hMSYmKGYubmFtZT1jLnVyaSk7bGV0IGg9KHIuc2FtcGxlcnN8fHt9KVtzLnNhbXBsZXJdfHx7fTtyZXR1cm4gZi5tYWdGaWx0ZXI9UmVbaC5tYWdGaWx0ZXJdfHxhLkxpbmVhckZpbHRlcixmLm1pbkZpbHRlcj1SZVtoLm1pbkZpbHRlcl18fGEuTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyLGYud3JhcFM9eGVbaC53cmFwU118fGEuUmVwZWF0V3JhcHBpbmcsZi53cmFwVD14ZVtoLndyYXBUXXx8YS5SZXBlYXRXcmFwcGluZyxuLmFzc29jaWF0aW9ucy5zZXQoZix7dGV4dHVyZXM6dH0pLGZ9KS5jYXRjaChmdW5jdGlvbigpe3JldHVybiBudWxsfSk7cmV0dXJuIHRoaXMudGV4dHVyZUNhY2hlW2ldPXUsdX1sb2FkSW1hZ2VTb3VyY2UodCxlKXtsZXQgbz10aGlzLG49dGhpcy5qc29uLHI9dGhpcy5vcHRpb25zO2lmKHRoaXMuc291cmNlQ2FjaGVbdF0hPT12b2lkIDApcmV0dXJuIHRoaXMuc291cmNlQ2FjaGVbdF0udGhlbihsPT5sLmNsb25lKCkpO2xldCBzPW4uaW1hZ2VzW3RdLGM9c2VsZi5VUkx8fHNlbGYud2Via2l0VVJMLGk9cy51cml8fCIiLHU9ITE7aWYocy5idWZmZXJWaWV3IT09dm9pZCAwKWk9by5nZXREZXBlbmRlbmN5KCJidWZmZXJWaWV3IixzLmJ1ZmZlclZpZXcpLnRoZW4oZnVuY3Rpb24obCl7dT0hMDtsZXQgaD1uZXcgQmxvYihbbF0se3R5cGU6cy5taW1lVHlwZX0pO3JldHVybiBpPWMuY3JlYXRlT2JqZWN0VVJMKGgpLGl9KTtlbHNlIGlmKHMudXJpPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcigiVEhSRUUuR0xURkxvYWRlcjogSW1hZ2UgIit0KyIgaXMgbWlzc2luZyBVUkkgYW5kIGJ1ZmZlclZpZXciKTtsZXQgZj1Qcm9taXNlLnJlc29sdmUoaSkudGhlbihmdW5jdGlvbihsKXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oaCxwKXtsZXQgbT1oO2UuaXNJbWFnZUJpdG1hcExvYWRlcj09PSEwJiYobT1mdW5jdGlvbihSKXtsZXQgZz1uZXcgYS5UZXh0dXJlKFIpO2cubmVlZHNVcGRhdGU9ITAsaChnKX0pLGUubG9hZChhLkxvYWRlclV0aWxzLnJlc29sdmVVUkwobCxyLnBhdGgpLG0sdm9pZCAwLHApfSl9KS50aGVuKGZ1bmN0aW9uKGwpe3JldHVybiB1PT09ITAmJmMucmV2b2tlT2JqZWN0VVJMKGkpLGwudXNlckRhdGEubWltZVR5cGU9cy5taW1lVHlwZXx8dmUocy51cmkpLGx9KS5jYXRjaChmdW5jdGlvbihsKXt0aHJvdyBjb25zb2xlLmVycm9yKCJUSFJFRS5HTFRGTG9hZGVyOiBDb3VsZG4ndCBsb2FkIHRleHR1cmUiLGkpLGx9KTtyZXR1cm4gdGhpcy5zb3VyY2VDYWNoZVt0XT1mLGZ9YXNzaWduVGV4dHVyZSh0LGUsbyxuKXtsZXQgcj10aGlzO3JldHVybiB0aGlzLmdldERlcGVuZGVuY3koInRleHR1cmUiLG8uaW5kZXgpLnRoZW4oZnVuY3Rpb24ocyl7aWYoIXMpcmV0dXJuIG51bGw7aWYoby50ZXhDb29yZCE9PXZvaWQgMCYmby50ZXhDb29yZD4wJiYocz1zLmNsb25lKCkscy5jaGFubmVsPW8udGV4Q29vcmQpLHIuZXh0ZW5zaW9uc1tBLktIUl9URVhUVVJFX1RSQU5TRk9STV0pe2xldCBjPW8uZXh0ZW5zaW9ucyE9PXZvaWQgMD9vLmV4dGVuc2lvbnNbQS5LSFJfVEVYVFVSRV9UUkFOU0ZPUk1dOnZvaWQgMDtpZihjKXtsZXQgaT1yLmFzc29jaWF0aW9ucy5nZXQocyk7cz1yLmV4dGVuc2lvbnNbQS5LSFJfVEVYVFVSRV9UUkFOU0ZPUk1dLmV4dGVuZFRleHR1cmUocyxjKSxyLmFzc29jaWF0aW9ucy5zZXQocyxpKX19cmV0dXJuIG4hPT12b2lkIDAmJihzLmNvbG9yU3BhY2U9biksdFtlXT1zLHN9KX1hc3NpZ25GaW5hbE1hdGVyaWFsKHQpe2xldCBlPXQuZ2VvbWV0cnksbz10Lm1hdGVyaWFsLG49ZS5hdHRyaWJ1dGVzLnRhbmdlbnQ9PT12b2lkIDAscj1lLmF0dHJpYnV0ZXMuY29sb3IhPT12b2lkIDAscz1lLmF0dHJpYnV0ZXMubm9ybWFsPT09dm9pZCAwO2lmKHQuaXNQb2ludHMpe2xldCBjPSJQb2ludHNNYXRlcmlhbDoiK28udXVpZCxpPXRoaXMuY2FjaGUuZ2V0KGMpO2l8fChpPW5ldyBhLlBvaW50c01hdGVyaWFsLGEuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbChpLG8pLGkuY29sb3IuY29weShvLmNvbG9yKSxpLm1hcD1vLm1hcCxpLnNpemVBdHRlbnVhdGlvbj0hMSx0aGlzLmNhY2hlLmFkZChjLGkpKSxvPWl9ZWxzZSBpZih0LmlzTGluZSl7bGV0IGM9IkxpbmVCYXNpY01hdGVyaWFsOiIrby51dWlkLGk9dGhpcy5jYWNoZS5nZXQoYyk7aXx8KGk9bmV3IGEuTGluZUJhc2ljTWF0ZXJpYWwsYS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKGksbyksaS5jb2xvci5jb3B5KG8uY29sb3IpLGkubWFwPW8ubWFwLHRoaXMuY2FjaGUuYWRkKGMsaSkpLG89aX1pZihufHxyfHxzKXtsZXQgYz0iQ2xvbmVkTWF0ZXJpYWw6IitvLnV1aWQrIjoiO24mJihjKz0iZGVyaXZhdGl2ZS10YW5nZW50czoiKSxyJiYoYys9InZlcnRleC1jb2xvcnM6IikscyYmKGMrPSJmbGF0LXNoYWRpbmc6Iik7bGV0IGk9dGhpcy5jYWNoZS5nZXQoYyk7aXx8KGk9by5jbG9uZSgpLHImJihpLnZlcnRleENvbG9ycz0hMCkscyYmKGkuZmxhdFNoYWRpbmc9ITApLG4mJihpLm5vcm1hbFNjYWxlJiYoaS5ub3JtYWxTY2FsZS55Kj0tMSksaS5jbGVhcmNvYXROb3JtYWxTY2FsZSYmKGkuY2xlYXJjb2F0Tm9ybWFsU2NhbGUueSo9LTEpKSx0aGlzLmNhY2hlLmFkZChjLGkpLHRoaXMuYXNzb2NpYXRpb25zLnNldChpLHRoaXMuYXNzb2NpYXRpb25zLmdldChvKSkpLG89aX10Lm1hdGVyaWFsPW99Z2V0TWF0ZXJpYWxUeXBlKCl7cmV0dXJuIGEuTWVzaFN0YW5kYXJkTWF0ZXJpYWx9bG9hZE1hdGVyaWFsKHQpe2xldCBlPXRoaXMsbz10aGlzLmpzb24sbj10aGlzLmV4dGVuc2lvbnMscj1vLm1hdGVyaWFsc1t0XSxzLGM9e30saT1yLmV4dGVuc2lvbnN8fHt9LHU9W107aWYoaVtBLktIUl9NQVRFUklBTFNfVU5MSVRdKXtsZXQgbD1uW0EuS0hSX01BVEVSSUFMU19VTkxJVF07cz1sLmdldE1hdGVyaWFsVHlwZSgpLHUucHVzaChsLmV4dGVuZFBhcmFtcyhjLHIsZSkpfWVsc2V7bGV0IGw9ci5wYnJNZXRhbGxpY1JvdWdobmVzc3x8e307aWYoYy5jb2xvcj1uZXcgYS5Db2xvcigxLDEsMSksYy5vcGFjaXR5PTEsQXJyYXkuaXNBcnJheShsLmJhc2VDb2xvckZhY3Rvcikpe2xldCBoPWwuYmFzZUNvbG9yRmFjdG9yO2MuY29sb3Iuc2V0UkdCKGhbMF0saFsxXSxoWzJdLGEuTGluZWFyU1JHQkNvbG9yU3BhY2UpLGMub3BhY2l0eT1oWzNdfWwuYmFzZUNvbG9yVGV4dHVyZSE9PXZvaWQgMCYmdS5wdXNoKGUuYXNzaWduVGV4dHVyZShjLCJtYXAiLGwuYmFzZUNvbG9yVGV4dHVyZSxhLlNSR0JDb2xvclNwYWNlKSksYy5tZXRhbG5lc3M9bC5tZXRhbGxpY0ZhY3RvciE9PXZvaWQgMD9sLm1ldGFsbGljRmFjdG9yOjEsYy5yb3VnaG5lc3M9bC5yb3VnaG5lc3NGYWN0b3IhPT12b2lkIDA/bC5yb3VnaG5lc3NGYWN0b3I6MSxsLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSE9PXZvaWQgMCYmKHUucHVzaChlLmFzc2lnblRleHR1cmUoYywibWV0YWxuZXNzTWFwIixsLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSkpLHUucHVzaChlLmFzc2lnblRleHR1cmUoYywicm91Z2huZXNzTWFwIixsLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSkpKSxzPXRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihoKXtyZXR1cm4gaC5nZXRNYXRlcmlhbFR5cGUmJmguZ2V0TWF0ZXJpYWxUeXBlKHQpfSksdS5wdXNoKFByb21pc2UuYWxsKHRoaXMuX2ludm9rZUFsbChmdW5jdGlvbihoKXtyZXR1cm4gaC5leHRlbmRNYXRlcmlhbFBhcmFtcyYmaC5leHRlbmRNYXRlcmlhbFBhcmFtcyh0LGMpfSkpKX1yLmRvdWJsZVNpZGVkPT09ITAmJihjLnNpZGU9YS5Eb3VibGVTaWRlKTtsZXQgZj1yLmFscGhhTW9kZXx8Ry5PUEFRVUU7aWYoZj09PUcuQkxFTkQ/KGMudHJhbnNwYXJlbnQ9ITAsYy5kZXB0aFdyaXRlPSExKTooYy50cmFuc3BhcmVudD0hMSxmPT09Ry5NQVNLJiYoYy5hbHBoYVRlc3Q9ci5hbHBoYUN1dG9mZiE9PXZvaWQgMD9yLmFscGhhQ3V0b2ZmOi41KSksci5ub3JtYWxUZXh0dXJlIT09dm9pZCAwJiZzIT09YS5NZXNoQmFzaWNNYXRlcmlhbCYmKHUucHVzaChlLmFzc2lnblRleHR1cmUoYywibm9ybWFsTWFwIixyLm5vcm1hbFRleHR1cmUpKSxjLm5vcm1hbFNjYWxlPW5ldyBhLlZlY3RvcjIoMSwxKSxyLm5vcm1hbFRleHR1cmUuc2NhbGUhPT12b2lkIDApKXtsZXQgbD1yLm5vcm1hbFRleHR1cmUuc2NhbGU7Yy5ub3JtYWxTY2FsZS5zZXQobCxsKX1pZihyLm9jY2x1c2lvblRleHR1cmUhPT12b2lkIDAmJnMhPT1hLk1lc2hCYXNpY01hdGVyaWFsJiYodS5wdXNoKGUuYXNzaWduVGV4dHVyZShjLCJhb01hcCIsci5vY2NsdXNpb25UZXh0dXJlKSksci5vY2NsdXNpb25UZXh0dXJlLnN0cmVuZ3RoIT09dm9pZCAwJiYoYy5hb01hcEludGVuc2l0eT1yLm9jY2x1c2lvblRleHR1cmUuc3RyZW5ndGgpKSxyLmVtaXNzaXZlRmFjdG9yIT09dm9pZCAwJiZzIT09YS5NZXNoQmFzaWNNYXRlcmlhbCl7bGV0IGw9ci5lbWlzc2l2ZUZhY3RvcjtjLmVtaXNzaXZlPW5ldyBhLkNvbG9yKCkuc2V0UkdCKGxbMF0sbFsxXSxsWzJdLGEuTGluZWFyU1JHQkNvbG9yU3BhY2UpfXJldHVybiByLmVtaXNzaXZlVGV4dHVyZSE9PXZvaWQgMCYmcyE9PWEuTWVzaEJhc2ljTWF0ZXJpYWwmJnUucHVzaChlLmFzc2lnblRleHR1cmUoYywiZW1pc3NpdmVNYXAiLHIuZW1pc3NpdmVUZXh0dXJlLGEuU1JHQkNvbG9yU3BhY2UpKSxQcm9taXNlLmFsbCh1KS50aGVuKGZ1bmN0aW9uKCl7bGV0IGw9bmV3IHMoYyk7cmV0dXJuIHIubmFtZSYmKGwubmFtZT1yLm5hbWUpLEwobCxyKSxlLmFzc29jaWF0aW9ucy5zZXQobCx7bWF0ZXJpYWxzOnR9KSxyLmV4dGVuc2lvbnMmJk8obixsLHIpLGx9KX1jcmVhdGVVbmlxdWVOYW1lKHQpe2xldCBlPWEuUHJvcGVydHlCaW5kaW5nLnNhbml0aXplTm9kZU5hbWUodHx8IiIpO3JldHVybiBlIGluIHRoaXMubm9kZU5hbWVzVXNlZD9lKyJfIisgKyt0aGlzLm5vZGVOYW1lc1VzZWRbZV06KHRoaXMubm9kZU5hbWVzVXNlZFtlXT0wLGUpfWxvYWRHZW9tZXRyaWVzKHQpe2xldCBlPXRoaXMsbz10aGlzLmV4dGVuc2lvbnMsbj10aGlzLnByaW1pdGl2ZUNhY2hlO2Z1bmN0aW9uIHIoYyl7cmV0dXJuIG9bQS5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTl0uZGVjb2RlUHJpbWl0aXZlKGMsZSkudGhlbihmdW5jdGlvbihpKXtyZXR1cm4gRWUoaSxjLGUpfSl9bGV0IHM9W107Zm9yKGxldCBjPTAsaT10Lmxlbmd0aDtjPGk7YysrKXtsZXQgdT10W2NdLGY9UGUodSksbD1uW2ZdO2lmKGwpcy5wdXNoKGwucHJvbWlzZSk7ZWxzZXtsZXQgaDt1LmV4dGVuc2lvbnMmJnUuZXh0ZW5zaW9uc1tBLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OXT9oPXIodSk6aD1FZShuZXcgYS5CdWZmZXJHZW9tZXRyeSx1LGUpLG5bZl09e3ByaW1pdGl2ZTp1LHByb21pc2U6aH0scy5wdXNoKGgpfX1yZXR1cm4gUHJvbWlzZS5hbGwocyl9bG9hZE1lc2godCl7bGV0IGU9dGhpcyxvPXRoaXMuanNvbixuPXRoaXMuZXh0ZW5zaW9ucyxyPW8ubWVzaGVzW3RdLHM9ci5wcmltaXRpdmVzLGM9W107Zm9yKGxldCBpPTAsdT1zLmxlbmd0aDtpPHU7aSsrKXtsZXQgZj1zW2ldLm1hdGVyaWFsPT09dm9pZCAwP0RlKHRoaXMuY2FjaGUpOnRoaXMuZ2V0RGVwZW5kZW5jeSgibWF0ZXJpYWwiLHNbaV0ubWF0ZXJpYWwpO2MucHVzaChmKX1yZXR1cm4gYy5wdXNoKGUubG9hZEdlb21ldHJpZXMocykpLFByb21pc2UuYWxsKGMpLnRoZW4oZnVuY3Rpb24oaSl7bGV0IHU9aS5zbGljZSgwLGkubGVuZ3RoLTEpLGY9aVtpLmxlbmd0aC0xXSxsPVtdO2ZvcihsZXQgcD0wLG09Zi5sZW5ndGg7cDxtO3ArKyl7bGV0IFI9ZltwXSxnPXNbcF0sVCxFPXVbcF07aWYoZy5tb2RlPT09eS5UUklBTkdMRVN8fGcubW9kZT09PXkuVFJJQU5HTEVfU1RSSVB8fGcubW9kZT09PXkuVFJJQU5HTEVfRkFOfHxnLm1vZGU9PT12b2lkIDApVD1yLmlzU2tpbm5lZE1lc2g9PT0hMD9uZXcgYS5Ta2lubmVkTWVzaChSLEUpOm5ldyBhLk1lc2goUixFKSxULmlzU2tpbm5lZE1lc2g9PT0hMCYmVC5ub3JtYWxpemVTa2luV2VpZ2h0cygpLGcubW9kZT09PXkuVFJJQU5HTEVfU1RSSVA/VC5nZW9tZXRyeT1VKFQuZ2VvbWV0cnksYS5UcmlhbmdsZVN0cmlwRHJhd01vZGUpOmcubW9kZT09PXkuVFJJQU5HTEVfRkFOJiYoVC5nZW9tZXRyeT1VKFQuZ2VvbWV0cnksYS5UcmlhbmdsZUZhbkRyYXdNb2RlKSk7ZWxzZSBpZihnLm1vZGU9PT15LkxJTkVTKVQ9bmV3IGEuTGluZVNlZ21lbnRzKFIsRSk7ZWxzZSBpZihnLm1vZGU9PT15LkxJTkVfU1RSSVApVD1uZXcgYS5MaW5lKFIsRSk7ZWxzZSBpZihnLm1vZGU9PT15LkxJTkVfTE9PUClUPW5ldyBhLkxpbmVMb29wKFIsRSk7ZWxzZSBpZihnLm1vZGU9PT15LlBPSU5UUylUPW5ldyBhLlBvaW50cyhSLEUpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCJUSFJFRS5HTFRGTG9hZGVyOiBQcmltaXRpdmUgbW9kZSB1bnN1cHBvcnRlZDogIitnLm1vZGUpO09iamVjdC5rZXlzKFQuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzKS5sZW5ndGg+MCYmSGUoVCxyKSxULm5hbWU9ZS5jcmVhdGVVbmlxdWVOYW1lKHIubmFtZXx8Im1lc2hfIit0KSxMKFQsciksZy5leHRlbnNpb25zJiZPKG4sVCxnKSxlLmFzc2lnbkZpbmFsTWF0ZXJpYWwoVCksbC5wdXNoKFQpfWZvcihsZXQgcD0wLG09bC5sZW5ndGg7cDxtO3ArKyllLmFzc29jaWF0aW9ucy5zZXQobFtwXSx7bWVzaGVzOnQscHJpbWl0aXZlczpwfSk7aWYobC5sZW5ndGg9PT0xKXJldHVybiByLmV4dGVuc2lvbnMmJk8obixsWzBdLHIpLGxbMF07bGV0IGg9bmV3IGEuR3JvdXA7ci5leHRlbnNpb25zJiZPKG4saCxyKSxlLmFzc29jaWF0aW9ucy5zZXQoaCx7bWVzaGVzOnR9KTtmb3IobGV0IHA9MCxtPWwubGVuZ3RoO3A8bTtwKyspaC5hZGQobFtwXSk7cmV0dXJuIGh9KX1sb2FkQ2FtZXJhKHQpe2xldCBlLG89dGhpcy5qc29uLmNhbWVyYXNbdF0sbj1vW28udHlwZV07aWYoIW4pe2NvbnNvbGUud2FybigiVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBjYW1lcmEgcGFyYW1ldGVycy4iKTtyZXR1cm59cmV0dXJuIG8udHlwZT09PSJwZXJzcGVjdGl2ZSI/ZT1uZXcgYS5QZXJzcGVjdGl2ZUNhbWVyYShhLk1hdGhVdGlscy5yYWRUb0RlZyhuLnlmb3YpLG4uYXNwZWN0UmF0aW98fDEsbi56bmVhcnx8MSxuLnpmYXJ8fDJlNik6by50eXBlPT09Im9ydGhvZ3JhcGhpYyImJihlPW5ldyBhLk9ydGhvZ3JhcGhpY0NhbWVyYSgtbi54bWFnLG4ueG1hZyxuLnltYWcsLW4ueW1hZyxuLnpuZWFyLG4uemZhcikpLG8ubmFtZSYmKGUubmFtZT10aGlzLmNyZWF0ZVVuaXF1ZU5hbWUoby5uYW1lKSksTChlLG8pLFByb21pc2UucmVzb2x2ZShlKX1sb2FkU2tpbih0KXtsZXQgZT10aGlzLmpzb24uc2tpbnNbdF0sbz1bXTtmb3IobGV0IG49MCxyPWUuam9pbnRzLmxlbmd0aDtuPHI7bisrKW8ucHVzaCh0aGlzLl9sb2FkTm9kZVNoYWxsb3coZS5qb2ludHNbbl0pKTtyZXR1cm4gZS5pbnZlcnNlQmluZE1hdHJpY2VzIT09dm9pZCAwP28ucHVzaCh0aGlzLmdldERlcGVuZGVuY3koImFjY2Vzc29yIixlLmludmVyc2VCaW5kTWF0cmljZXMpKTpvLnB1c2gobnVsbCksUHJvbWlzZS5hbGwobykudGhlbihmdW5jdGlvbihuKXtsZXQgcj1uLnBvcCgpLHM9bixjPVtdLGk9W107Zm9yKGxldCB1PTAsZj1zLmxlbmd0aDt1PGY7dSsrKXtsZXQgbD1zW3VdO2lmKGwpe2MucHVzaChsKTtsZXQgaD1uZXcgYS5NYXRyaXg0O3IhPT1udWxsJiZoLmZyb21BcnJheShyLmFycmF5LHUqMTYpLGkucHVzaChoKX1lbHNlIGNvbnNvbGUud2FybignVEhSRUUuR0xURkxvYWRlcjogSm9pbnQgIiVzIiBjb3VsZCBub3QgYmUgZm91bmQuJyxlLmpvaW50c1t1XSl9cmV0dXJuIG5ldyBhLlNrZWxldG9uKGMsaSl9KX1sb2FkQW5pbWF0aW9uKHQpe2xldCBlPXRoaXMuanNvbixvPXRoaXMsbj1lLmFuaW1hdGlvbnNbdF0scj1uLm5hbWU/bi5uYW1lOiJhbmltYXRpb25fIit0LHM9W10sYz1bXSxpPVtdLHU9W10sZj1bXTtmb3IobGV0IGw9MCxoPW4uY2hhbm5lbHMubGVuZ3RoO2w8aDtsKyspe2xldCBwPW4uY2hhbm5lbHNbbF0sbT1uLnNhbXBsZXJzW3Auc2FtcGxlcl0sUj1wLnRhcmdldCxnPVIubm9kZSxUPW4ucGFyYW1ldGVycyE9PXZvaWQgMD9uLnBhcmFtZXRlcnNbbS5pbnB1dF06bS5pbnB1dCxFPW4ucGFyYW1ldGVycyE9PXZvaWQgMD9uLnBhcmFtZXRlcnNbbS5vdXRwdXRdOm0ub3V0cHV0O1Iubm9kZSE9PXZvaWQgMCYmKHMucHVzaCh0aGlzLmdldERlcGVuZGVuY3koIm5vZGUiLGcpKSxjLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KCJhY2Nlc3NvciIsVCkpLGkucHVzaCh0aGlzLmdldERlcGVuZGVuY3koImFjY2Vzc29yIixFKSksdS5wdXNoKG0pLGYucHVzaChSKSl9cmV0dXJuIFByb21pc2UuYWxsKFtQcm9taXNlLmFsbChzKSxQcm9taXNlLmFsbChjKSxQcm9taXNlLmFsbChpKSxQcm9taXNlLmFsbCh1KSxQcm9taXNlLmFsbChmKV0pLnRoZW4oZnVuY3Rpb24obCl7bGV0IGg9bFswXSxwPWxbMV0sbT1sWzJdLFI9bFszXSxnPWxbNF0sVD1bXTtmb3IobGV0IEU9MCxiPWgubGVuZ3RoO0U8YjtFKyspe2xldCB4PWhbRV0sUz1wW0VdLE09bVtFXSxfPVJbRV0sQj1nW0VdO2lmKHg9PT12b2lkIDApY29udGludWU7eC51cGRhdGVNYXRyaXgmJngudXBkYXRlTWF0cml4KCk7bGV0IEk9by5fY3JlYXRlQW5pbWF0aW9uVHJhY2tzKHgsUyxNLF8sQik7aWYoSSlmb3IobGV0IFA9MDtQPEkubGVuZ3RoO1ArKylULnB1c2goSVtQXSl9cmV0dXJuIG5ldyBhLkFuaW1hdGlvbkNsaXAocix2b2lkIDAsVCl9KX1jcmVhdGVOb2RlTWVzaCh0KXtsZXQgZT10aGlzLmpzb24sbz10aGlzLG49ZS5ub2Rlc1t0XTtyZXR1cm4gbi5tZXNoPT09dm9pZCAwP251bGw6by5nZXREZXBlbmRlbmN5KCJtZXNoIixuLm1lc2gpLnRoZW4oZnVuY3Rpb24ocil7bGV0IHM9by5fZ2V0Tm9kZVJlZihvLm1lc2hDYWNoZSxuLm1lc2gscik7cmV0dXJuIG4ud2VpZ2h0cyE9PXZvaWQgMCYmcy50cmF2ZXJzZShmdW5jdGlvbihjKXtpZihjLmlzTWVzaClmb3IobGV0IGk9MCx1PW4ud2VpZ2h0cy5sZW5ndGg7aTx1O2krKyljLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tpXT1uLndlaWdodHNbaV19KSxzfSl9bG9hZE5vZGUodCl7bGV0IGU9dGhpcy5qc29uLG89dGhpcyxuPWUubm9kZXNbdF0scj1vLl9sb2FkTm9kZVNoYWxsb3codCkscz1bXSxjPW4uY2hpbGRyZW58fFtdO2ZvcihsZXQgdT0wLGY9Yy5sZW5ndGg7dTxmO3UrKylzLnB1c2goby5nZXREZXBlbmRlbmN5KCJub2RlIixjW3VdKSk7bGV0IGk9bi5za2luPT09dm9pZCAwP1Byb21pc2UucmVzb2x2ZShudWxsKTpvLmdldERlcGVuZGVuY3koInNraW4iLG4uc2tpbik7cmV0dXJuIFByb21pc2UuYWxsKFtyLFByb21pc2UuYWxsKHMpLGldKS50aGVuKGZ1bmN0aW9uKHUpe2xldCBmPXVbMF0sbD11WzFdLGg9dVsyXTtoIT09bnVsbCYmZi50cmF2ZXJzZShmdW5jdGlvbihwKXtwLmlzU2tpbm5lZE1lc2gmJnAuYmluZChoLFVlKX0pO2ZvcihsZXQgcD0wLG09bC5sZW5ndGg7cDxtO3ArKylmLmFkZChsW3BdKTtyZXR1cm4gZn0pfV9sb2FkTm9kZVNoYWxsb3codCl7bGV0IGU9dGhpcy5qc29uLG89dGhpcy5leHRlbnNpb25zLG49dGhpcztpZih0aGlzLm5vZGVDYWNoZVt0XSE9PXZvaWQgMClyZXR1cm4gdGhpcy5ub2RlQ2FjaGVbdF07bGV0IHI9ZS5ub2Rlc1t0XSxzPXIubmFtZT9uLmNyZWF0ZVVuaXF1ZU5hbWUoci5uYW1lKToiIixjPVtdLGk9bi5faW52b2tlT25lKGZ1bmN0aW9uKHUpe3JldHVybiB1LmNyZWF0ZU5vZGVNZXNoJiZ1LmNyZWF0ZU5vZGVNZXNoKHQpfSk7cmV0dXJuIGkmJmMucHVzaChpKSxyLmNhbWVyYSE9PXZvaWQgMCYmYy5wdXNoKG4uZ2V0RGVwZW5kZW5jeSgiY2FtZXJhIixyLmNhbWVyYSkudGhlbihmdW5jdGlvbih1KXtyZXR1cm4gbi5fZ2V0Tm9kZVJlZihuLmNhbWVyYUNhY2hlLHIuY2FtZXJhLHUpfSkpLG4uX2ludm9rZUFsbChmdW5jdGlvbih1KXtyZXR1cm4gdS5jcmVhdGVOb2RlQXR0YWNobWVudCYmdS5jcmVhdGVOb2RlQXR0YWNobWVudCh0KX0pLmZvckVhY2goZnVuY3Rpb24odSl7Yy5wdXNoKHUpfSksdGhpcy5ub2RlQ2FjaGVbdF09UHJvbWlzZS5hbGwoYykudGhlbihmdW5jdGlvbih1KXtsZXQgZjtpZihyLmlzQm9uZT09PSEwP2Y9bmV3IGEuQm9uZTp1Lmxlbmd0aD4xP2Y9bmV3IGEuR3JvdXA6dS5sZW5ndGg9PT0xP2Y9dVswXTpmPW5ldyBhLk9iamVjdDNELGYhPT11WzBdKWZvcihsZXQgbD0wLGg9dS5sZW5ndGg7bDxoO2wrKylmLmFkZCh1W2xdKTtpZihyLm5hbWUmJihmLnVzZXJEYXRhLm5hbWU9ci5uYW1lLGYubmFtZT1zKSxMKGYsciksci5leHRlbnNpb25zJiZPKG8sZixyKSxyLm1hdHJpeCE9PXZvaWQgMCl7bGV0IGw9bmV3IGEuTWF0cml4NDtsLmZyb21BcnJheShyLm1hdHJpeCksZi5hcHBseU1hdHJpeDQobCl9ZWxzZSByLnRyYW5zbGF0aW9uIT09dm9pZCAwJiZmLnBvc2l0aW9uLmZyb21BcnJheShyLnRyYW5zbGF0aW9uKSxyLnJvdGF0aW9uIT09dm9pZCAwJiZmLnF1YXRlcm5pb24uZnJvbUFycmF5KHIucm90YXRpb24pLHIuc2NhbGUhPT12b2lkIDAmJmYuc2NhbGUuZnJvbUFycmF5KHIuc2NhbGUpO3JldHVybiBuLmFzc29jaWF0aW9ucy5oYXMoZil8fG4uYXNzb2NpYXRpb25zLnNldChmLHt9KSxuLmFzc29jaWF0aW9ucy5nZXQoZikubm9kZXM9dCxmfSksdGhpcy5ub2RlQ2FjaGVbdF19bG9hZFNjZW5lKHQpe2xldCBlPXRoaXMuZXh0ZW5zaW9ucyxvPXRoaXMuanNvbi5zY2VuZXNbdF0sbj10aGlzLHI9bmV3IGEuR3JvdXA7by5uYW1lJiYoci5uYW1lPW4uY3JlYXRlVW5pcXVlTmFtZShvLm5hbWUpKSxMKHIsbyksby5leHRlbnNpb25zJiZPKGUscixvKTtsZXQgcz1vLm5vZGVzfHxbXSxjPVtdO2ZvcihsZXQgaT0wLHU9cy5sZW5ndGg7aTx1O2krKyljLnB1c2gobi5nZXREZXBlbmRlbmN5KCJub2RlIixzW2ldKSk7cmV0dXJuIFByb21pc2UuYWxsKGMpLnRoZW4oZnVuY3Rpb24oaSl7Zm9yKGxldCBmPTAsbD1pLmxlbmd0aDtmPGw7ZisrKXIuYWRkKGlbZl0pO2xldCB1PWY9PntsZXQgbD1uZXcgTWFwO2ZvcihsZXRbaCxwXW9mIG4uYXNzb2NpYXRpb25zKShoIGluc3RhbmNlb2YgYS5NYXRlcmlhbHx8aCBpbnN0YW5jZW9mIGEuVGV4dHVyZSkmJmwuc2V0KGgscCk7cmV0dXJuIGYudHJhdmVyc2UoaD0+e2xldCBwPW4uYXNzb2NpYXRpb25zLmdldChoKTtwIT1udWxsJiZsLnNldChoLHApfSksbH07cmV0dXJuIG4uYXNzb2NpYXRpb25zPXUocikscn0pfV9jcmVhdGVBbmltYXRpb25UcmFja3ModCxlLG8sbixyKXtsZXQgcz1bXSxjPXQubmFtZT90Lm5hbWU6dC51dWlkLGk9W107TltyLnBhdGhdPT09Ti53ZWlnaHRzP3QudHJhdmVyc2UoZnVuY3Rpb24oaCl7aC5tb3JwaFRhcmdldEluZmx1ZW5jZXMmJmkucHVzaChoLm5hbWU/aC5uYW1lOmgudXVpZCl9KTppLnB1c2goYyk7bGV0IHU7c3dpdGNoKE5bci5wYXRoXSl7Y2FzZSBOLndlaWdodHM6dT1hLk51bWJlcktleWZyYW1lVHJhY2s7YnJlYWs7Y2FzZSBOLnJvdGF0aW9uOnU9YS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjazticmVhaztjYXNlIE4ucG9zaXRpb246Y2FzZSBOLnNjYWxlOnU9YS5WZWN0b3JLZXlmcmFtZVRyYWNrO2JyZWFrO2RlZmF1bHQ6c3dpdGNoKG8uaXRlbVNpemUpe2Nhc2UgMTp1PWEuTnVtYmVyS2V5ZnJhbWVUcmFjazticmVhaztjYXNlIDI6Y2FzZSAzOmRlZmF1bHQ6dT1hLlZlY3RvcktleWZyYW1lVHJhY2s7YnJlYWt9YnJlYWt9bGV0IGY9bi5pbnRlcnBvbGF0aW9uIT09dm9pZCAwP0JlW24uaW50ZXJwb2xhdGlvbl06YS5JbnRlcnBvbGF0ZUxpbmVhcixsPXRoaXMuX2dldEFycmF5RnJvbUFjY2Vzc29yKG8pO2ZvcihsZXQgaD0wLHA9aS5sZW5ndGg7aDxwO2grKyl7bGV0IG09bmV3IHUoaVtoXSsiLiIrTltyLnBhdGhdLGUuYXJyYXksbCxmKTtuLmludGVycG9sYXRpb249PT0iQ1VCSUNTUExJTkUiJiZ0aGlzLl9jcmVhdGVDdWJpY1NwbGluZVRyYWNrSW50ZXJwb2xhbnQobSkscy5wdXNoKG0pfXJldHVybiBzfV9nZXRBcnJheUZyb21BY2Nlc3Nvcih0KXtsZXQgZT10LmFycmF5O2lmKHQubm9ybWFsaXplZCl7bGV0IG89aGUoZS5jb25zdHJ1Y3Rvciksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKTtmb3IobGV0IHI9MCxzPWUubGVuZ3RoO3I8cztyKyspbltyXT1lW3JdKm87ZT1ufXJldHVybiBlfV9jcmVhdGVDdWJpY1NwbGluZVRyYWNrSW50ZXJwb2xhbnQodCl7dC5jcmVhdGVJbnRlcnBvbGFudD1mdW5jdGlvbihvKXtsZXQgbj10aGlzIGluc3RhbmNlb2YgYS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaz9mZTpIO3JldHVybiBuZXcgbih0aGlzLnRpbWVzLHRoaXMudmFsdWVzLHRoaXMuZ2V0VmFsdWVTaXplKCkvMyxvKX0sdC5jcmVhdGVJbnRlcnBvbGFudC5pc0ludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZT0hMH19O2Z1bmN0aW9uIEZlKGQsdCxlKXtsZXQgbz10LmF0dHJpYnV0ZXMsbj1uZXcgYS5Cb3gzO2lmKG8uUE9TSVRJT04hPT12b2lkIDApe2xldCBjPWUuanNvbi5hY2Nlc3NvcnNbby5QT1NJVElPTl0saT1jLm1pbix1PWMubWF4O2lmKGkhPT12b2lkIDAmJnUhPT12b2lkIDApe2lmKG4uc2V0KG5ldyBhLlZlY3RvcjMoaVswXSxpWzFdLGlbMl0pLG5ldyBhLlZlY3RvcjModVswXSx1WzFdLHVbMl0pKSxjLm5vcm1hbGl6ZWQpe2xldCBmPWhlKENbYy5jb21wb25lbnRUeXBlXSk7bi5taW4ubXVsdGlwbHlTY2FsYXIoZiksbi5tYXgubXVsdGlwbHlTY2FsYXIoZil9fWVsc2V7Y29uc29sZS53YXJuKCJUSFJFRS5HTFRGTG9hZGVyOiBNaXNzaW5nIG1pbi9tYXggcHJvcGVydGllcyBmb3IgYWNjZXNzb3IgUE9TSVRJT04uIik7cmV0dXJufX1lbHNlIHJldHVybjtsZXQgcj10LnRhcmdldHM7aWYociE9PXZvaWQgMCl7bGV0IGM9bmV3IGEuVmVjdG9yMyxpPW5ldyBhLlZlY3RvcjM7Zm9yKGxldCB1PTAsZj1yLmxlbmd0aDt1PGY7dSsrKXtsZXQgbD1yW3VdO2lmKGwuUE9TSVRJT04hPT12b2lkIDApe2xldCBoPWUuanNvbi5hY2Nlc3NvcnNbbC5QT1NJVElPTl0scD1oLm1pbixtPWgubWF4O2lmKHAhPT12b2lkIDAmJm0hPT12b2lkIDApe2lmKGkuc2V0WChNYXRoLm1heChNYXRoLmFicyhwWzBdKSxNYXRoLmFicyhtWzBdKSkpLGkuc2V0WShNYXRoLm1heChNYXRoLmFicyhwWzFdKSxNYXRoLmFicyhtWzFdKSkpLGkuc2V0WihNYXRoLm1heChNYXRoLmFicyhwWzJdKSxNYXRoLmFicyhtWzJdKSkpLGgubm9ybWFsaXplZCl7bGV0IFI9aGUoQ1toLmNvbXBvbmVudFR5cGVdKTtpLm11bHRpcGx5U2NhbGFyKFIpfWMubWF4KGkpfWVsc2UgY29uc29sZS53YXJuKCJUSFJFRS5HTFRGTG9hZGVyOiBNaXNzaW5nIG1pbi9tYXggcHJvcGVydGllcyBmb3IgYWNjZXNzb3IgUE9TSVRJT04uIil9fW4uZXhwYW5kQnlWZWN0b3IoYyl9ZC5ib3VuZGluZ0JveD1uO2xldCBzPW5ldyBhLlNwaGVyZTtuLmdldENlbnRlcihzLmNlbnRlcikscy5yYWRpdXM9bi5taW4uZGlzdGFuY2VUbyhuLm1heCkvMixkLmJvdW5kaW5nU3BoZXJlPXN9ZnVuY3Rpb24gRWUoZCx0LGUpe2xldCBvPXQuYXR0cmlidXRlcyxuPVtdO2Z1bmN0aW9uIHIocyxjKXtyZXR1cm4gZS5nZXREZXBlbmRlbmN5KCJhY2Nlc3NvciIscykudGhlbihmdW5jdGlvbihpKXtkLnNldEF0dHJpYnV0ZShjLGkpfSl9Zm9yKGxldCBzIGluIG8pe2xldCBjPWRlW3NdfHxzLnRvTG93ZXJDYXNlKCk7YyBpbiBkLmF0dHJpYnV0ZXN8fG4ucHVzaChyKG9bc10sYykpfWlmKHQuaW5kaWNlcyE9PXZvaWQgMCYmIWQuaW5kZXgpe2xldCBzPWUuZ2V0RGVwZW5kZW5jeSgiYWNjZXNzb3IiLHQuaW5kaWNlcykudGhlbihmdW5jdGlvbihjKXtkLnNldEluZGV4KGMpfSk7bi5wdXNoKHMpfXJldHVybiBhLkNvbG9yTWFuYWdlbWVudC53b3JraW5nQ29sb3JTcGFjZSE9PWEuTGluZWFyU1JHQkNvbG9yU3BhY2UmJiJDT0xPUl8wImluIG8mJmNvbnNvbGUud2FybihgVEhSRUUuR0xURkxvYWRlcjogQ29udmVydGluZyB2ZXJ0ZXggY29sb3JzIGZyb20gInNyZ2ItbGluZWFyIiB0byAiJHthLkNvbG9yTWFuYWdlbWVudC53b3JraW5nQ29sb3JTcGFjZX0iIG5vdCBzdXBwb3J0ZWQuYCksTChkLHQpLEZlKGQsdCxlKSxQcm9taXNlLmFsbChuKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHQudGFyZ2V0cyE9PXZvaWQgMD9rZShkLHQudGFyZ2V0cyxlKTpkfSl9cmV0dXJuIExlKEdlKTt9KSgpOwpnbG9iYWxUaGlzLkdMVEZMb2FkZXIgPSBHTFRGTG9hZGVyTW9kdWxlLkdMVEZMb2FkZXI7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsdGYtbG9hZGVyLm1pbi5qcy5tYXAK";
  var ORBIT_CONTROLS_BASE64 = "Ly8gT3JiaXRDb250cm9scyB0aGF0IHVzZXMgZ2xvYmFsIFRIUkVFCmlmICh0eXBlb2YgZ2xvYmFsVGhpcy5USFJFRSA9PT0gInVuZGVmaW5lZCIpIHsKICB0aHJvdyBuZXcgRXJyb3IoJ1RIUkVFLmpzIG11c3QgYmUgbG9hZGVkIGJlZm9yZSBPcmJpdENvbnRyb2xzJyk7Cn0KdmFyIE9yYml0Q29udHJvbHNNb2R1bGU9KCgpPT57dmFyIEZlPU9iamVjdC5jcmVhdGU7dmFyIFo9T2JqZWN0LmRlZmluZVByb3BlcnR5O3ZhciBWZT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO3ZhciBXZT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lczt2YXIgR2U9T2JqZWN0LmdldFByb3RvdHlwZU9mLHFlPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIEJlPSh1LGwpPT4oKT0+KGx8fHUoKGw9e2V4cG9ydHM6e319KS5leHBvcnRzLGwpLGwuZXhwb3J0cyksUWU9KHUsbCk9Pntmb3IodmFyIGggaW4gbClaKHUsaCx7Z2V0OmxbaF0sZW51bWVyYWJsZTohMH0pfSxFZT0odSxsLGgsZSk9PntpZihsJiZ0eXBlb2YgbD09Im9iamVjdCJ8fHR5cGVvZiBsPT0iZnVuY3Rpb24iKWZvcihsZXQgaSBvZiBXZShsKSkhcWUuY2FsbCh1LGkpJiZpIT09aCYmWih1LGkse2dldDooKT0+bFtpXSxlbnVtZXJhYmxlOiEoZT1WZShsLGkpKXx8ZS5lbnVtZXJhYmxlfSk7cmV0dXJuIHV9O3ZhciBKZT0odSxsLGgpPT4oaD11IT1udWxsP0ZlKEdlKHUpKTp7fSxFZShsfHwhdXx8IXUuX19lc01vZHVsZT9aKGgsImRlZmF1bHQiLHt2YWx1ZTp1LGVudW1lcmFibGU6ITB9KTpoLHUpKSwkZT11PT5FZShaKHt9LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSx1KTt2YXIgUGU9QmUoKGF0LFRlKT0+e1RlLmV4cG9ydHM9Z2xvYmFsVGhpcy5USFJFRX0pO3ZhciBldD17fTtRZShldCx7T3JiaXRDb250cm9sczooKT0+JH0pO3ZhciBuPUplKFBlKCksMSksd2U9e3R5cGU6ImNoYW5nZSJ9LEo9e3R5cGU6InN0YXJ0In0sT2U9e3R5cGU6ImVuZCJ9LEY9bmV3IG4uUmF5LE1lPW5ldyBuLlBsYW5lLHZlPU1hdGguY29zKDcwKm4uTWF0aFV0aWxzLkRFRzJSQUQpLCQ9Y2xhc3MgZXh0ZW5kcyBuLkV2ZW50RGlzcGF0Y2hlcntjb25zdHJ1Y3RvcihsLGgpe3N1cGVyKCksdGhpcy5vYmplY3Q9bCx0aGlzLmRvbUVsZW1lbnQ9aCx0aGlzLmRvbUVsZW1lbnQuc3R5bGUudG91Y2hBY3Rpb249Im5vbmUiLHRoaXMuZW5hYmxlZD0hMCx0aGlzLnRhcmdldD1uZXcgbi5WZWN0b3IzLHRoaXMuY3Vyc29yPW5ldyBuLlZlY3RvcjMsdGhpcy5taW5EaXN0YW5jZT0wLHRoaXMubWF4RGlzdGFuY2U9MS8wLHRoaXMubWluWm9vbT0wLHRoaXMubWF4Wm9vbT0xLzAsdGhpcy5taW5UYXJnZXRSYWRpdXM9MCx0aGlzLm1heFRhcmdldFJhZGl1cz0xLzAsdGhpcy5taW5Qb2xhckFuZ2xlPTAsdGhpcy5tYXhQb2xhckFuZ2xlPU1hdGguUEksdGhpcy5taW5BemltdXRoQW5nbGU9LTEvMCx0aGlzLm1heEF6aW11dGhBbmdsZT0xLzAsdGhpcy5lbmFibGVEYW1waW5nPSExLHRoaXMuZGFtcGluZ0ZhY3Rvcj0uMDUsdGhpcy5lbmFibGVab29tPSEwLHRoaXMuem9vbVNwZWVkPTEsdGhpcy5lbmFibGVSb3RhdGU9ITAsdGhpcy5yb3RhdGVTcGVlZD0xLHRoaXMuZW5hYmxlUGFuPSEwLHRoaXMucGFuU3BlZWQ9MSx0aGlzLnNjcmVlblNwYWNlUGFubmluZz0hMCx0aGlzLmtleVBhblNwZWVkPTcsdGhpcy56b29tVG9DdXJzb3I9ITEsdGhpcy5hdXRvUm90YXRlPSExLHRoaXMuYXV0b1JvdGF0ZVNwZWVkPTIsdGhpcy5rZXlzPXtMRUZUOiJBcnJvd0xlZnQiLFVQOiJBcnJvd1VwIixSSUdIVDoiQXJyb3dSaWdodCIsQk9UVE9NOiJBcnJvd0Rvd24ifSx0aGlzLm1vdXNlQnV0dG9ucz17TEVGVDpuLk1PVVNFLlJPVEFURSxNSURETEU6bi5NT1VTRS5ET0xMWSxSSUdIVDpuLk1PVVNFLlBBTn0sdGhpcy50b3VjaGVzPXtPTkU6bi5UT1VDSC5ST1RBVEUsVFdPOm4uVE9VQ0guRE9MTFlfUEFOfSx0aGlzLnRhcmdldDA9dGhpcy50YXJnZXQuY2xvbmUoKSx0aGlzLnBvc2l0aW9uMD10aGlzLm9iamVjdC5wb3NpdGlvbi5jbG9uZSgpLHRoaXMuem9vbTA9dGhpcy5vYmplY3Quem9vbSx0aGlzLl9kb21FbGVtZW50S2V5RXZlbnRzPW51bGwsdGhpcy5nZXRQb2xhckFuZ2xlPWZ1bmN0aW9uKCl7cmV0dXJuIGMucGhpfSx0aGlzLmdldEF6aW11dGhhbEFuZ2xlPWZ1bmN0aW9uKCl7cmV0dXJuIGMudGhldGF9LHRoaXMuZ2V0RGlzdGFuY2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vYmplY3QucG9zaXRpb24uZGlzdGFuY2VUbyh0aGlzLnRhcmdldCl9LHRoaXMubGlzdGVuVG9LZXlFdmVudHM9ZnVuY3Rpb24odCl7dC5hZGRFdmVudExpc3RlbmVyKCJrZXlkb3duIixRKSx0aGlzLl9kb21FbGVtZW50S2V5RXZlbnRzPXR9LHRoaXMuc3RvcExpc3RlblRvS2V5RXZlbnRzPWZ1bmN0aW9uKCl7dGhpcy5fZG9tRWxlbWVudEtleUV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyKCJrZXlkb3duIixRKSx0aGlzLl9kb21FbGVtZW50S2V5RXZlbnRzPW51bGx9LHRoaXMuc2F2ZVN0YXRlPWZ1bmN0aW9uKCl7ZS50YXJnZXQwLmNvcHkoZS50YXJnZXQpLGUucG9zaXRpb24wLmNvcHkoZS5vYmplY3QucG9zaXRpb24pLGUuem9vbTA9ZS5vYmplY3Quem9vbX0sdGhpcy5yZXNldD1mdW5jdGlvbigpe2UudGFyZ2V0LmNvcHkoZS50YXJnZXQwKSxlLm9iamVjdC5wb3NpdGlvbi5jb3B5KGUucG9zaXRpb24wKSxlLm9iamVjdC56b29tPWUuem9vbTAsZS5vYmplY3QudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpLGUuZGlzcGF0Y2hFdmVudCh3ZSksZS51cGRhdGUoKSxyPWkuTk9ORX0sdGhpcy51cGRhdGU9ZnVuY3Rpb24oKXtsZXQgdD1uZXcgbi5WZWN0b3IzLG89bmV3IG4uUXVhdGVybmlvbigpLnNldEZyb21Vbml0VmVjdG9ycyhsLnVwLG5ldyBuLlZlY3RvcjMoMCwxLDApKSxhPW8uY2xvbmUoKS5pbnZlcnQoKSxzPW5ldyBuLlZlY3RvcjMsZD1uZXcgbi5RdWF0ZXJuaW9uLFQ9bmV3IG4uVmVjdG9yMyxtPTIqTWF0aC5QSTtyZXR1cm4gZnVuY3Rpb24oWmU9bnVsbCl7bGV0IGdlPWUub2JqZWN0LnBvc2l0aW9uO3QuY29weShnZSkuc3ViKGUudGFyZ2V0KSx0LmFwcGx5UXVhdGVybmlvbihvKSxjLnNldEZyb21WZWN0b3IzKHQpLGUuYXV0b1JvdGF0ZSYmcj09PWkuTk9ORSYmSShqZShaZSkpLGUuZW5hYmxlRGFtcGluZz8oYy50aGV0YSs9Zi50aGV0YSplLmRhbXBpbmdGYWN0b3IsYy5waGkrPWYucGhpKmUuZGFtcGluZ0ZhY3Rvcik6KGMudGhldGErPWYudGhldGEsYy5waGkrPWYucGhpKTtsZXQgYj1lLm1pbkF6aW11dGhBbmdsZSx5PWUubWF4QXppbXV0aEFuZ2xlO2lzRmluaXRlKGIpJiZpc0Zpbml0ZSh5KSYmKGI8LU1hdGguUEk/Yis9bTpiPk1hdGguUEkmJihiLT1tKSx5PC1NYXRoLlBJP3krPW06eT5NYXRoLlBJJiYoeS09bSksYjw9eT9jLnRoZXRhPU1hdGgubWF4KGIsTWF0aC5taW4oeSxjLnRoZXRhKSk6Yy50aGV0YT1jLnRoZXRhPihiK3kpLzI/TWF0aC5tYXgoYixjLnRoZXRhKTpNYXRoLm1pbih5LGMudGhldGEpKSxjLnBoaT1NYXRoLm1heChlLm1pblBvbGFyQW5nbGUsTWF0aC5taW4oZS5tYXhQb2xhckFuZ2xlLGMucGhpKSksYy5tYWtlU2FmZSgpLGUuZW5hYmxlRGFtcGluZz09PSEwP2UudGFyZ2V0LmFkZFNjYWxlZFZlY3RvcihBLGUuZGFtcGluZ0ZhY3Rvcik6ZS50YXJnZXQuYWRkKEEpLGUudGFyZ2V0LnN1YihlLmN1cnNvciksZS50YXJnZXQuY2xhbXBMZW5ndGgoZS5taW5UYXJnZXRSYWRpdXMsZS5tYXhUYXJnZXRSYWRpdXMpLGUudGFyZ2V0LmFkZChlLmN1cnNvciksZS56b29tVG9DdXJzb3ImJnp8fGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhP2MucmFkaXVzPXEoYy5yYWRpdXMpOmMucmFkaXVzPXEoYy5yYWRpdXMqZyksdC5zZXRGcm9tU3BoZXJpY2FsKGMpLHQuYXBwbHlRdWF0ZXJuaW9uKGEpLGdlLmNvcHkoZS50YXJnZXQpLmFkZCh0KSxlLm9iamVjdC5sb29rQXQoZS50YXJnZXQpLGUuZW5hYmxlRGFtcGluZz09PSEwPyhmLnRoZXRhKj0xLWUuZGFtcGluZ0ZhY3RvcixmLnBoaSo9MS1lLmRhbXBpbmdGYWN0b3IsQS5tdWx0aXBseVNjYWxhcigxLWUuZGFtcGluZ0ZhY3RvcikpOihmLnNldCgwLDAsMCksQS5zZXQoMCwwLDApKTtsZXQgVT0hMTtpZihlLnpvb21Ub0N1cnNvciYmeil7bGV0IFk9bnVsbDtpZihlLm9iamVjdC5pc1BlcnNwZWN0aXZlQ2FtZXJhKXtsZXQgXz10Lmxlbmd0aCgpO1k9cShfKmcpO2xldCBYPV8tWTtlLm9iamVjdC5wb3NpdGlvbi5hZGRTY2FsZWRWZWN0b3IoZWUsWCksZS5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoKX1lbHNlIGlmKGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhKXtsZXQgXz1uZXcgbi5WZWN0b3IzKEUueCxFLnksMCk7Xy51bnByb2plY3QoZS5vYmplY3QpLGUub2JqZWN0Lnpvb209TWF0aC5tYXgoZS5taW5ab29tLE1hdGgubWluKGUubWF4Wm9vbSxlLm9iamVjdC56b29tL2cpKSxlLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCksVT0hMDtsZXQgWD1uZXcgbi5WZWN0b3IzKEUueCxFLnksMCk7WC51bnByb2plY3QoZS5vYmplY3QpLGUub2JqZWN0LnBvc2l0aW9uLnN1YihYKS5hZGQoXyksZS5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoKSxZPXQubGVuZ3RoKCl9ZWxzZSBjb25zb2xlLndhcm4oIldBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIHpvb20gdG8gY3Vyc29yIGRpc2FibGVkLiIpLGUuem9vbVRvQ3Vyc29yPSExO1khPT1udWxsJiYodGhpcy5zY3JlZW5TcGFjZVBhbm5pbmc/ZS50YXJnZXQuc2V0KDAsMCwtMSkudHJhbnNmb3JtRGlyZWN0aW9uKGUub2JqZWN0Lm1hdHJpeCkubXVsdGlwbHlTY2FsYXIoWSkuYWRkKGUub2JqZWN0LnBvc2l0aW9uKTooRi5vcmlnaW4uY29weShlLm9iamVjdC5wb3NpdGlvbiksRi5kaXJlY3Rpb24uc2V0KDAsMCwtMSkudHJhbnNmb3JtRGlyZWN0aW9uKGUub2JqZWN0Lm1hdHJpeCksTWF0aC5hYnMoZS5vYmplY3QudXAuZG90KEYuZGlyZWN0aW9uKSk8dmU/bC5sb29rQXQoZS50YXJnZXQpOihNZS5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludChlLm9iamVjdC51cCxlLnRhcmdldCksRi5pbnRlcnNlY3RQbGFuZShNZSxlLnRhcmdldCkpKSl9ZWxzZSBlLm9iamVjdC5pc09ydGhvZ3JhcGhpY0NhbWVyYSYmKFU9ZyE9PTEsVSYmKGUub2JqZWN0Lnpvb209TWF0aC5tYXgoZS5taW5ab29tLE1hdGgubWluKGUubWF4Wm9vbSxlLm9iamVjdC56b29tL2cpKSxlLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCkpKTtyZXR1cm4gZz0xLHo9ITEsVXx8cy5kaXN0YW5jZVRvU3F1YXJlZChlLm9iamVjdC5wb3NpdGlvbik+dnx8OCooMS1kLmRvdChlLm9iamVjdC5xdWF0ZXJuaW9uKSk+dnx8VC5kaXN0YW5jZVRvU3F1YXJlZChlLnRhcmdldCk+MD8oZS5kaXNwYXRjaEV2ZW50KHdlKSxzLmNvcHkoZS5vYmplY3QucG9zaXRpb24pLGQuY29weShlLm9iamVjdC5xdWF0ZXJuaW9uKSxULmNvcHkoZS50YXJnZXQpLCEwKTohMX19KCksdGhpcy5kaXNwb3NlPWZ1bmN0aW9uKCl7ZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoImNvbnRleHRtZW51IixiZSksZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoInBvaW50ZXJkb3duIixkZSksZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoInBvaW50ZXJjYW5jZWwiLEMpLGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCJ3aGVlbCIsbWUpLGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCJwb2ludGVybW92ZSIsQiksZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoInBvaW50ZXJ1cCIsQyksZS5fZG9tRWxlbWVudEtleUV2ZW50cyE9PW51bGwmJihlLl9kb21FbGVtZW50S2V5RXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIoImtleWRvd24iLFEpLGUuX2RvbUVsZW1lbnRLZXlFdmVudHM9bnVsbCl9O2xldCBlPXRoaXMsaT17Tk9ORTotMSxST1RBVEU6MCxET0xMWToxLFBBTjoyLFRPVUNIX1JPVEFURTozLFRPVUNIX1BBTjo0LFRPVUNIX0RPTExZX1BBTjo1LFRPVUNIX0RPTExZX1JPVEFURTo2fSxyPWkuTk9ORSx2PTFlLTYsYz1uZXcgbi5TcGhlcmljYWwsZj1uZXcgbi5TcGhlcmljYWwsZz0xLEE9bmV3IG4uVmVjdG9yMyxQPW5ldyBuLlZlY3RvcjIsdz1uZXcgbi5WZWN0b3IyLEw9bmV3IG4uVmVjdG9yMixPPW5ldyBuLlZlY3RvcjIsTT1uZXcgbi5WZWN0b3IyLEQ9bmV3IG4uVmVjdG9yMix4PW5ldyBuLlZlY3RvcjIsUj1uZXcgbi5WZWN0b3IyLGo9bmV3IG4uVmVjdG9yMixlZT1uZXcgbi5WZWN0b3IzLEU9bmV3IG4uVmVjdG9yMix6PSExLHA9W10saz17fSxWPSExO2Z1bmN0aW9uIGplKHQpe3JldHVybiB0IT09bnVsbD8yKk1hdGguUEkvNjAqZS5hdXRvUm90YXRlU3BlZWQqdDoyKk1hdGguUEkvNjAvNjAqZS5hdXRvUm90YXRlU3BlZWR9ZnVuY3Rpb24gSyh0KXtsZXQgbz1NYXRoLmFicyh0Ki4wMSk7cmV0dXJuIE1hdGgucG93KC45NSxlLnpvb21TcGVlZCpvKX1mdW5jdGlvbiBJKHQpe2YudGhldGEtPXR9ZnVuY3Rpb24gSCh0KXtmLnBoaS09dH1sZXQgdGU9ZnVuY3Rpb24oKXtsZXQgdD1uZXcgbi5WZWN0b3IzO3JldHVybiBmdW5jdGlvbihhLHMpe3Quc2V0RnJvbU1hdHJpeENvbHVtbihzLDApLHQubXVsdGlwbHlTY2FsYXIoLWEpLEEuYWRkKHQpfX0oKSxvZT1mdW5jdGlvbigpe2xldCB0PW5ldyBuLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGEscyl7ZS5zY3JlZW5TcGFjZVBhbm5pbmc9PT0hMD90LnNldEZyb21NYXRyaXhDb2x1bW4ocywxKToodC5zZXRGcm9tTWF0cml4Q29sdW1uKHMsMCksdC5jcm9zc1ZlY3RvcnMoZS5vYmplY3QudXAsdCkpLHQubXVsdGlwbHlTY2FsYXIoYSksQS5hZGQodCl9fSgpLE49ZnVuY3Rpb24oKXtsZXQgdD1uZXcgbi5WZWN0b3IzO3JldHVybiBmdW5jdGlvbihhLHMpe2xldCBkPWUuZG9tRWxlbWVudDtpZihlLm9iamVjdC5pc1BlcnNwZWN0aXZlQ2FtZXJhKXtsZXQgVD1lLm9iamVjdC5wb3NpdGlvbjt0LmNvcHkoVCkuc3ViKGUudGFyZ2V0KTtsZXQgbT10Lmxlbmd0aCgpO20qPU1hdGgudGFuKGUub2JqZWN0LmZvdi8yKk1hdGguUEkvMTgwKSx0ZSgyKmEqbS9kLmNsaWVudEhlaWdodCxlLm9iamVjdC5tYXRyaXgpLG9lKDIqcyptL2QuY2xpZW50SGVpZ2h0LGUub2JqZWN0Lm1hdHJpeCl9ZWxzZSBlLm9iamVjdC5pc09ydGhvZ3JhcGhpY0NhbWVyYT8odGUoYSooZS5vYmplY3QucmlnaHQtZS5vYmplY3QubGVmdCkvZS5vYmplY3Quem9vbS9kLmNsaWVudFdpZHRoLGUub2JqZWN0Lm1hdHJpeCksb2UocyooZS5vYmplY3QudG9wLWUub2JqZWN0LmJvdHRvbSkvZS5vYmplY3Quem9vbS9kLmNsaWVudEhlaWdodCxlLm9iamVjdC5tYXRyaXgpKTooY29uc29sZS53YXJuKCJXQVJOSU5HOiBPcmJpdENvbnRyb2xzLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBwYW4gZGlzYWJsZWQuIiksZS5lbmFibGVQYW49ITEpfX0oKTtmdW5jdGlvbiBXKHQpe2Uub2JqZWN0LmlzUGVyc3BlY3RpdmVDYW1lcmF8fGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhP2cvPXQ6KGNvbnNvbGUud2FybigiV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gZG9sbHkvem9vbSBkaXNhYmxlZC4iKSxlLmVuYWJsZVpvb209ITEpfWZ1bmN0aW9uIG5lKHQpe2Uub2JqZWN0LmlzUGVyc3BlY3RpdmVDYW1lcmF8fGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhP2cqPXQ6KGNvbnNvbGUud2FybigiV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gZG9sbHkvem9vbSBkaXNhYmxlZC4iKSxlLmVuYWJsZVpvb209ITEpfWZ1bmN0aW9uIEcodCxvKXtpZighZS56b29tVG9DdXJzb3IpcmV0dXJuO3o9ITA7bGV0IGE9ZS5kb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLHM9dC1hLmxlZnQsZD1vLWEudG9wLFQ9YS53aWR0aCxtPWEuaGVpZ2h0O0UueD1zL1QqMi0xLEUueT0tKGQvbSkqMisxLGVlLnNldChFLngsRS55LDEpLnVucHJvamVjdChlLm9iamVjdCkuc3ViKGUub2JqZWN0LnBvc2l0aW9uKS5ub3JtYWxpemUoKX1mdW5jdGlvbiBxKHQpe3JldHVybiBNYXRoLm1heChlLm1pbkRpc3RhbmNlLE1hdGgubWluKGUubWF4RGlzdGFuY2UsdCkpfWZ1bmN0aW9uIGFlKHQpe1Auc2V0KHQuY2xpZW50WCx0LmNsaWVudFkpfWZ1bmN0aW9uIEFlKHQpe0codC5jbGllbnRYLHQuY2xpZW50WCkseC5zZXQodC5jbGllbnRYLHQuY2xpZW50WSl9ZnVuY3Rpb24gaWUodCl7Ty5zZXQodC5jbGllbnRYLHQuY2xpZW50WSl9ZnVuY3Rpb24gTGUodCl7dy5zZXQodC5jbGllbnRYLHQuY2xpZW50WSksTC5zdWJWZWN0b3JzKHcsUCkubXVsdGlwbHlTY2FsYXIoZS5yb3RhdGVTcGVlZCk7bGV0IG89ZS5kb21FbGVtZW50O0koMipNYXRoLlBJKkwueC9vLmNsaWVudEhlaWdodCksSCgyKk1hdGguUEkqTC55L28uY2xpZW50SGVpZ2h0KSxQLmNvcHkodyksZS51cGRhdGUoKX1mdW5jdGlvbiBEZSh0KXtSLnNldCh0LmNsaWVudFgsdC5jbGllbnRZKSxqLnN1YlZlY3RvcnMoUix4KSxqLnk+MD9XKEsoai55KSk6ai55PDAmJm5lKEsoai55KSkseC5jb3B5KFIpLGUudXBkYXRlKCl9ZnVuY3Rpb24geGUodCl7TS5zZXQodC5jbGllbnRYLHQuY2xpZW50WSksRC5zdWJWZWN0b3JzKE0sTykubXVsdGlwbHlTY2FsYXIoZS5wYW5TcGVlZCksTihELngsRC55KSxPLmNvcHkoTSksZS51cGRhdGUoKX1mdW5jdGlvbiBSZSh0KXtHKHQuY2xpZW50WCx0LmNsaWVudFkpLHQuZGVsdGFZPDA/bmUoSyh0LmRlbHRhWSkpOnQuZGVsdGFZPjAmJlcoSyh0LmRlbHRhWSkpLGUudXBkYXRlKCl9ZnVuY3Rpb24gTmUodCl7bGV0IG89ITE7c3dpdGNoKHQuY29kZSl7Y2FzZSBlLmtleXMuVVA6dC5jdHJsS2V5fHx0Lm1ldGFLZXl8fHQuc2hpZnRLZXk/SCgyKk1hdGguUEkqZS5yb3RhdGVTcGVlZC9lLmRvbUVsZW1lbnQuY2xpZW50SGVpZ2h0KTpOKDAsZS5rZXlQYW5TcGVlZCksbz0hMDticmVhaztjYXNlIGUua2V5cy5CT1RUT006dC5jdHJsS2V5fHx0Lm1ldGFLZXl8fHQuc2hpZnRLZXk/SCgtMipNYXRoLlBJKmUucm90YXRlU3BlZWQvZS5kb21FbGVtZW50LmNsaWVudEhlaWdodCk6TigwLC1lLmtleVBhblNwZWVkKSxvPSEwO2JyZWFrO2Nhc2UgZS5rZXlzLkxFRlQ6dC5jdHJsS2V5fHx0Lm1ldGFLZXl8fHQuc2hpZnRLZXk/SSgyKk1hdGguUEkqZS5yb3RhdGVTcGVlZC9lLmRvbUVsZW1lbnQuY2xpZW50SGVpZ2h0KTpOKGUua2V5UGFuU3BlZWQsMCksbz0hMDticmVhaztjYXNlIGUua2V5cy5SSUdIVDp0LmN0cmxLZXl8fHQubWV0YUtleXx8dC5zaGlmdEtleT9JKC0yKk1hdGguUEkqZS5yb3RhdGVTcGVlZC9lLmRvbUVsZW1lbnQuY2xpZW50SGVpZ2h0KTpOKC1lLmtleVBhblNwZWVkLDApLG89ITA7YnJlYWt9byYmKHQucHJldmVudERlZmF1bHQoKSxlLnVwZGF0ZSgpKX1mdW5jdGlvbiBzZSh0KXtpZihwLmxlbmd0aD09PTEpUC5zZXQodC5wYWdlWCx0LnBhZ2VZKTtlbHNle2xldCBvPVModCksYT0uNSoodC5wYWdlWCtvLngpLHM9LjUqKHQucGFnZVkrby55KTtQLnNldChhLHMpfX1mdW5jdGlvbiByZSh0KXtpZihwLmxlbmd0aD09PTEpTy5zZXQodC5wYWdlWCx0LnBhZ2VZKTtlbHNle2xldCBvPVModCksYT0uNSoodC5wYWdlWCtvLngpLHM9LjUqKHQucGFnZVkrby55KTtPLnNldChhLHMpfX1mdW5jdGlvbiBjZSh0KXtsZXQgbz1TKHQpLGE9dC5wYWdlWC1vLngscz10LnBhZ2VZLW8ueSxkPU1hdGguc3FydChhKmErcypzKTt4LnNldCgwLGQpfWZ1bmN0aW9uIFNlKHQpe2UuZW5hYmxlWm9vbSYmY2UodCksZS5lbmFibGVQYW4mJnJlKHQpfWZ1bmN0aW9uIGtlKHQpe2UuZW5hYmxlWm9vbSYmY2UodCksZS5lbmFibGVSb3RhdGUmJnNlKHQpfWZ1bmN0aW9uIGxlKHQpe2lmKHAubGVuZ3RoPT0xKXcuc2V0KHQucGFnZVgsdC5wYWdlWSk7ZWxzZXtsZXQgYT1TKHQpLHM9LjUqKHQucGFnZVgrYS54KSxkPS41Kih0LnBhZ2VZK2EueSk7dy5zZXQocyxkKX1MLnN1YlZlY3RvcnModyxQKS5tdWx0aXBseVNjYWxhcihlLnJvdGF0ZVNwZWVkKTtsZXQgbz1lLmRvbUVsZW1lbnQ7SSgyKk1hdGguUEkqTC54L28uY2xpZW50SGVpZ2h0KSxIKDIqTWF0aC5QSSpMLnkvby5jbGllbnRIZWlnaHQpLFAuY29weSh3KX1mdW5jdGlvbiB1ZSh0KXtpZihwLmxlbmd0aD09PTEpTS5zZXQodC5wYWdlWCx0LnBhZ2VZKTtlbHNle2xldCBvPVModCksYT0uNSoodC5wYWdlWCtvLngpLHM9LjUqKHQucGFnZVkrby55KTtNLnNldChhLHMpfUQuc3ViVmVjdG9ycyhNLE8pLm11bHRpcGx5U2NhbGFyKGUucGFuU3BlZWQpLE4oRC54LEQueSksTy5jb3B5KE0pfWZ1bmN0aW9uIHBlKHQpe2xldCBvPVModCksYT10LnBhZ2VYLW8ueCxzPXQucGFnZVktby55LGQ9TWF0aC5zcXJ0KGEqYStzKnMpO1Iuc2V0KDAsZCksai5zZXQoMCxNYXRoLnBvdyhSLnkveC55LGUuem9vbVNwZWVkKSksVyhqLnkpLHguY29weShSKTtsZXQgVD0odC5wYWdlWCtvLngpKi41LG09KHQucGFnZVkrby55KSouNTtHKFQsbSl9ZnVuY3Rpb24gSWUodCl7ZS5lbmFibGVab29tJiZwZSh0KSxlLmVuYWJsZVBhbiYmdWUodCl9ZnVuY3Rpb24gQ2UodCl7ZS5lbmFibGVab29tJiZwZSh0KSxlLmVuYWJsZVJvdGF0ZSYmbGUodCl9ZnVuY3Rpb24gZGUodCl7ZS5lbmFibGVkIT09ITEmJihwLmxlbmd0aD09PTAmJihlLmRvbUVsZW1lbnQuc2V0UG9pbnRlckNhcHR1cmUodC5wb2ludGVySWQpLGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCJwb2ludGVybW92ZSIsQiksZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoInBvaW50ZXJ1cCIsQykpLFVlKHQpLHQucG9pbnRlclR5cGU9PT0idG91Y2giP2ZlKHQpOlllKHQpKX1mdW5jdGlvbiBCKHQpe2UuZW5hYmxlZCE9PSExJiYodC5wb2ludGVyVHlwZT09PSJ0b3VjaCI/SGUodCk6X2UodCkpfWZ1bmN0aW9uIEModCl7c3dpdGNoKFhlKHQpLHAubGVuZ3RoKXtjYXNlIDA6ZS5kb21FbGVtZW50LnJlbGVhc2VQb2ludGVyQ2FwdHVyZSh0LnBvaW50ZXJJZCksZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoInBvaW50ZXJtb3ZlIixCKSxlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigicG9pbnRlcnVwIixDKSxlLmRpc3BhdGNoRXZlbnQoT2UpLHI9aS5OT05FO2JyZWFrO2Nhc2UgMTpsZXQgbz1wWzBdLGE9a1tvXTtmZSh7cG9pbnRlcklkOm8scGFnZVg6YS54LHBhZ2VZOmEueX0pO2JyZWFrfX1mdW5jdGlvbiBZZSh0KXtsZXQgbztzd2l0Y2godC5idXR0b24pe2Nhc2UgMDpvPWUubW91c2VCdXR0b25zLkxFRlQ7YnJlYWs7Y2FzZSAxOm89ZS5tb3VzZUJ1dHRvbnMuTUlERExFO2JyZWFrO2Nhc2UgMjpvPWUubW91c2VCdXR0b25zLlJJR0hUO2JyZWFrO2RlZmF1bHQ6bz0tMX1zd2l0Y2gobyl7Y2FzZSBuLk1PVVNFLkRPTExZOmlmKGUuZW5hYmxlWm9vbT09PSExKXJldHVybjtBZSh0KSxyPWkuRE9MTFk7YnJlYWs7Y2FzZSBuLk1PVVNFLlJPVEFURTppZih0LmN0cmxLZXl8fHQubWV0YUtleXx8dC5zaGlmdEtleSl7aWYoZS5lbmFibGVQYW49PT0hMSlyZXR1cm47aWUodCkscj1pLlBBTn1lbHNle2lmKGUuZW5hYmxlUm90YXRlPT09ITEpcmV0dXJuO2FlKHQpLHI9aS5ST1RBVEV9YnJlYWs7Y2FzZSBuLk1PVVNFLlBBTjppZih0LmN0cmxLZXl8fHQubWV0YUtleXx8dC5zaGlmdEtleSl7aWYoZS5lbmFibGVSb3RhdGU9PT0hMSlyZXR1cm47YWUodCkscj1pLlJPVEFURX1lbHNle2lmKGUuZW5hYmxlUGFuPT09ITEpcmV0dXJuO2llKHQpLHI9aS5QQU59YnJlYWs7ZGVmYXVsdDpyPWkuTk9ORX1yIT09aS5OT05FJiZlLmRpc3BhdGNoRXZlbnQoSil9ZnVuY3Rpb24gX2UodCl7c3dpdGNoKHIpe2Nhc2UgaS5ST1RBVEU6aWYoZS5lbmFibGVSb3RhdGU9PT0hMSlyZXR1cm47TGUodCk7YnJlYWs7Y2FzZSBpLkRPTExZOmlmKGUuZW5hYmxlWm9vbT09PSExKXJldHVybjtEZSh0KTticmVhaztjYXNlIGkuUEFOOmlmKGUuZW5hYmxlUGFuPT09ITEpcmV0dXJuO3hlKHQpO2JyZWFrfX1mdW5jdGlvbiBtZSh0KXtlLmVuYWJsZWQ9PT0hMXx8ZS5lbmFibGVab29tPT09ITF8fHIhPT1pLk5PTkV8fCh0LnByZXZlbnREZWZhdWx0KCksZS5kaXNwYXRjaEV2ZW50KEopLFJlKHplKHQpKSxlLmRpc3BhdGNoRXZlbnQoT2UpKX1mdW5jdGlvbiB6ZSh0KXtsZXQgbz10LmRlbHRhTW9kZSxhPXtjbGllbnRYOnQuY2xpZW50WCxjbGllbnRZOnQuY2xpZW50WSxkZWx0YVk6dC5kZWx0YVl9O3N3aXRjaChvKXtjYXNlIDE6YS5kZWx0YVkqPTE2O2JyZWFrO2Nhc2UgMjphLmRlbHRhWSo9MTAwO2JyZWFrfXJldHVybiB0LmN0cmxLZXkmJiFWJiYoYS5kZWx0YVkqPTEwKSxhfWZ1bmN0aW9uIEtlKHQpe3Qua2V5PT09IkNvbnRyb2wiJiYoVj0hMCxlLmRvbUVsZW1lbnQuZ2V0Um9vdE5vZGUoKS5hZGRFdmVudExpc3RlbmVyKCJrZXl1cCIsaGUse3Bhc3NpdmU6ITAsY2FwdHVyZTohMH0pKX1mdW5jdGlvbiBoZSh0KXt0LmtleT09PSJDb250cm9sIiYmKFY9ITEsZS5kb21FbGVtZW50LmdldFJvb3ROb2RlKCkucmVtb3ZlRXZlbnRMaXN0ZW5lcigia2V5dXAiLGhlLHtwYXNzaXZlOiEwLGNhcHR1cmU6ITB9KSl9ZnVuY3Rpb24gUSh0KXtlLmVuYWJsZWQ9PT0hMXx8ZS5lbmFibGVQYW49PT0hMXx8TmUodCl9ZnVuY3Rpb24gZmUodCl7c3dpdGNoKHllKHQpLHAubGVuZ3RoKXtjYXNlIDE6c3dpdGNoKGUudG91Y2hlcy5PTkUpe2Nhc2Ugbi5UT1VDSC5ST1RBVEU6aWYoZS5lbmFibGVSb3RhdGU9PT0hMSlyZXR1cm47c2UodCkscj1pLlRPVUNIX1JPVEFURTticmVhaztjYXNlIG4uVE9VQ0guUEFOOmlmKGUuZW5hYmxlUGFuPT09ITEpcmV0dXJuO3JlKHQpLHI9aS5UT1VDSF9QQU47YnJlYWs7ZGVmYXVsdDpyPWkuTk9ORX1icmVhaztjYXNlIDI6c3dpdGNoKGUudG91Y2hlcy5UV08pe2Nhc2Ugbi5UT1VDSC5ET0xMWV9QQU46aWYoZS5lbmFibGVab29tPT09ITEmJmUuZW5hYmxlUGFuPT09ITEpcmV0dXJuO1NlKHQpLHI9aS5UT1VDSF9ET0xMWV9QQU47YnJlYWs7Y2FzZSBuLlRPVUNILkRPTExZX1JPVEFURTppZihlLmVuYWJsZVpvb209PT0hMSYmZS5lbmFibGVSb3RhdGU9PT0hMSlyZXR1cm47a2UodCkscj1pLlRPVUNIX0RPTExZX1JPVEFURTticmVhaztkZWZhdWx0OnI9aS5OT05FfWJyZWFrO2RlZmF1bHQ6cj1pLk5PTkV9ciE9PWkuTk9ORSYmZS5kaXNwYXRjaEV2ZW50KEopfWZ1bmN0aW9uIEhlKHQpe3N3aXRjaCh5ZSh0KSxyKXtjYXNlIGkuVE9VQ0hfUk9UQVRFOmlmKGUuZW5hYmxlUm90YXRlPT09ITEpcmV0dXJuO2xlKHQpLGUudXBkYXRlKCk7YnJlYWs7Y2FzZSBpLlRPVUNIX1BBTjppZihlLmVuYWJsZVBhbj09PSExKXJldHVybjt1ZSh0KSxlLnVwZGF0ZSgpO2JyZWFrO2Nhc2UgaS5UT1VDSF9ET0xMWV9QQU46aWYoZS5lbmFibGVab29tPT09ITEmJmUuZW5hYmxlUGFuPT09ITEpcmV0dXJuO0llKHQpLGUudXBkYXRlKCk7YnJlYWs7Y2FzZSBpLlRPVUNIX0RPTExZX1JPVEFURTppZihlLmVuYWJsZVpvb209PT0hMSYmZS5lbmFibGVSb3RhdGU9PT0hMSlyZXR1cm47Q2UodCksZS51cGRhdGUoKTticmVhaztkZWZhdWx0OnI9aS5OT05FfX1mdW5jdGlvbiBiZSh0KXtlLmVuYWJsZWQhPT0hMSYmdC5wcmV2ZW50RGVmYXVsdCgpfWZ1bmN0aW9uIFVlKHQpe3AucHVzaCh0LnBvaW50ZXJJZCl9ZnVuY3Rpb24gWGUodCl7ZGVsZXRlIGtbdC5wb2ludGVySWRdO2ZvcihsZXQgbz0wO288cC5sZW5ndGg7bysrKWlmKHBbb109PXQucG9pbnRlcklkKXtwLnNwbGljZShvLDEpO3JldHVybn19ZnVuY3Rpb24geWUodCl7bGV0IG89a1t0LnBvaW50ZXJJZF07bz09PXZvaWQgMCYmKG89bmV3IG4uVmVjdG9yMixrW3QucG9pbnRlcklkXT1vKSxvLnNldCh0LnBhZ2VYLHQucGFnZVkpfWZ1bmN0aW9uIFModCl7bGV0IG89dC5wb2ludGVySWQ9PT1wWzBdP3BbMV06cFswXTtyZXR1cm4ga1tvXX1lLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigiY29udGV4dG1lbnUiLGJlKSxlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigicG9pbnRlcmRvd24iLGRlKSxlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigicG9pbnRlcmNhbmNlbCIsQyksZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIndoZWVsIixtZSx7cGFzc2l2ZTohMX0pLGUuZG9tRWxlbWVudC5nZXRSb290Tm9kZSgpLmFkZEV2ZW50TGlzdGVuZXIoImtleWRvd24iLEtlLHtwYXNzaXZlOiEwLGNhcHR1cmU6ITB9KSx0aGlzLnVwZGF0ZSgpfX07cmV0dXJuICRlKGV0KTt9KSgpOwpnbG9iYWxUaGlzLlRIUkVFLk9yYml0Q29udHJvbHMgPSBPcmJpdENvbnRyb2xzTW9kdWxlLk9yYml0Q29udHJvbHM7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPW9yYml0LWNvbnRyb2xzLm1pbi5qcy5tYXAK";
  var ThreeJSLoader = class {
    static async loadThreeJS() {
      if (this.threeJsSource) {
        return this.threeJsSource;
      }
      console.log("[ThreeJS Loader] Using embedded base64 version");
      this.threeJsSource = this.getEmbeddedThreeJS();
      return this.threeJsSource;
    }
    static async loadGLTFLoader() {
      if (this.gltfLoaderSource) {
        return this.gltfLoaderSource;
      }
      console.log("[ThreeJS Loader] Using embedded GLTF Loader");
      this.gltfLoaderSource = this.getEmbeddedGLTFLoader();
      return this.gltfLoaderSource;
    }
    static async loadOrbitControls() {
      if (this.orbitControlsSource) {
        return this.orbitControlsSource;
      }
      console.log("[ThreeJS Loader] Using embedded OrbitControls");
      this.orbitControlsSource = this.getEmbeddedOrbitControls();
      return this.orbitControlsSource;
    }
    static getEmbeddedThreeJS() {
      try {
        return atob(THREEJS_BASE64);
      } catch (error) {
        console.error("[ThreeJS Loader] Failed to decode Three.js base64:", error);
        throw new Error("Failed to load Three.js");
      }
    }
    static getEmbeddedGLTFLoader() {
      try {
        return atob(GLTF_LOADER_BASE64);
      } catch (error) {
        console.error("[ThreeJS Loader] Failed to decode GLTF Loader base64:", error);
        throw new Error("Failed to load GLTF Loader");
      }
    }
    static getEmbeddedOrbitControls() {
      try {
        return atob(ORBIT_CONTROLS_BASE64);
      } catch (error) {
        console.error("[ThreeJS Loader] Failed to decode OrbitControls base64:", error);
        throw new Error("Failed to load OrbitControls");
      }
    }
  };
  ThreeJSLoader.threeJsSource = null;
  ThreeJSLoader.gltfLoaderSource = null;
  ThreeJSLoader.orbitControlsSource = null;

  // packages/z3d-object/src/editor/templates/builder.ts
  var EMBEDDED_TEMPLATE_ASSETS = {
    "html": {
      "main": '<!DOCTYPE html>\r\n<html lang="en">\r\n<head>\r\n    <meta charset="UTF-8">\r\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\r\n    <title>{{TITLE}}</title>\r\n    <style>\r\n        /* Styles will be injected here by template-builder */\r\n        {{STYLES}}\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class="z3d-editor" id="z3d-editor">\r\n        <!-- Top Bar with Help Menu -->\r\n        <div class="topbar" id="topbar">\r\n            <div class="topbar-left">\r\n                <div class="logo">Z3D Object Editor</div>\r\n            </div>\r\n            <div class="topbar-right">\r\n                <a href="https://discord.gg/7R8ctHyJtw" target="_blank" class="discord-link">\r\n                    <svg class="discord-icon" width="18" height="18" viewBox="0 0 24 24" fill="currentColor">\r\n                        <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0a12.64 12.64 0 0 0-.617-1.25a.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057a19.9 19.9 0 0 0 5.993 3.03a.078.078 0 0 0 .084-.028a14.09 14.09 0 0 0 1.226-1.994a.076.076 0 0 0-.041-.106a13.107 13.107 0 0 1-1.872-.892a.077.077 0 0 1-.008-.128a10.2 10.2 0 0 0 .372-.292a.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127a12.299 12.299 0 0 1-1.873.892a.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028a19.839 19.839 0 0 0 6.002-3.03a.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.956-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.955-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.946 2.418-2.157 2.418z"/>\r\n                    </svg>\r\n                    Discord Support\r\n                </a>\r\n            </div>\r\n        </div>\r\n\r\n        <!-- Main Content Area -->\r\n        <div class="main-content">\r\n            <!-- Left Region -->\r\n            <div class="left-region">\r\n                <!-- Viewport Area - SIMPLIFIED STRUCTURE -->\r\n                <div class="viewport-area" id="viewport-area">\r\n                    <!-- Canvas is now direct child -->\r\n                    <canvas id="three-canvas" class="three-canvas"></canvas>\r\n                    \r\n                    <!-- All overlays as siblings to canvas -->\r\n                    <div class="scene-topbar">\r\n                        <!-- Content will be populated by SceneTopbarControls -->\r\n                    </div>\r\n                    \r\n                    <!-- Viewport Gizmo (Top Right) -->\r\n                    <div class="viewport-gizmo" id="viewport-gizmo">\r\n                        <!-- three-viewport-gizmo will be inserted here -->\r\n                    </div>\r\n                    \r\n                    <!-- Stats Overlay (Top Left) -->\r\n                    <div class="stats-overlay" id="stats-overlay">\r\n                        <div class="stats-content">\r\n                            <div>Vertices: <span id="vertex-count">0</span></div>\r\n                            <div>Triangles: <span id="triangle-count">0</span></div>\r\n                            <div>FPS: <span id="fps-count">60</span></div>\r\n                        </div>\r\n                    </div>\r\n                    \r\n                    <!-- Loading Indicator -->\r\n                    <div id="loading-indicator" class="loading-indicator">\r\n                        <div class="loading-spinner"></div>\r\n                        <div class="loading-text">\u{1F680} Loading 3D Scene...</div>\r\n                    </div>\r\n                </div>\r\n                \r\n                <!-- Left Horizontal Resizer (KEPT) -->\r\n                <div class="left-horizontal-resizer" id="left-horizontal-resizer"></div>\r\n                \r\n                <!-- Bottom Viewer Area -->\r\n                <div class="viewer-area">\r\n                    <div class="viewer-topbar">\r\n                        <div class="viewer-controls">\r\n                            <select id="viewer-type" class="viewer-select">\r\n                                <option value="texture">Texture Viewer</option>\r\n                                <option value="animation">Animation Viewer</option>\r\n                            </select>\r\n                        </div>\r\n                    </div>\r\n                    <div class="viewer-content" id="viewer-content">\r\n                        <!-- Texture/Animation viewer will be populated here -->\r\n                        <div class="placeholder">Select viewer type above</div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            \r\n            <!-- Vertical Resizer -->\r\n            <div class="vertical-resizer" id="vertical-resizer"></div>\r\n            \r\n            <!-- Right Region -->\r\n            <div class="right-region">\r\n                <!-- Info Section -->\r\n                <div class="info-section">\r\n                    <h3>Z3D Object Editor</h3>\r\n                    <div class="instance-info" id="instance-info">Instance Loading...</div>\r\n                    <div class="version-info">Plugin v1.0.0</div>\r\n                </div>\r\n                \r\n                <!-- Node Tree -->\r\n                <div class="node-tree-section">\r\n                    <h4>GLB Structure</h4>\r\n                    <div class="node-tree" id="node-tree">\r\n                        <div class="placeholder">Loading model structure...</div>\r\n                    </div>\r\n                </div>\r\n                \r\n                <!-- Horizontal Resizer -->\r\n                <div class="horizontal-resizer" id="horizontal-resizer"></div>\r\n                \r\n                <!-- Side Tabs Panel -->\r\n                <div class="side-tabs-section">\r\n                    <div class="tab-bar" aria-label="Editor panels">\r\n                        <button class="tab-btn active" data-tab="object" aria-label="Object" title="Object">\r\n                            <span class="icon">\u{1F9CA}</span>\r\n                        </button>\r\n                        <button class="tab-btn" data-tab="viewport" aria-label="Viewport" title="Viewport">\r\n                            <span class="icon">\u{1F441}\uFE0F</span>\r\n                        </button>\r\n                    </div>\r\n                    <div class="tab-content">\r\n                        <div id="object-tab" class="tab-panel active" aria-labelledby="object">\r\n                            <div id="object-controls"></div>\r\n                        </div>\r\n                        <div id="viewport-tab" class="tab-panel" aria-labelledby="viewport">\r\n                            <div id="viewport-controls"></div>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n                \r\n                <!-- Status -->\r\n                <div class="status-bar">\r\n                    <div id="status-message">Ready</div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Hidden Config Data -->\r\n    <script type="application/json" id="build-config">{{CONFIG}}<\/script>\r\n    <script type="application/json" id="editor-config">{{EDITOR_CONFIG}}<\/script>\r\n    \r\n    <!-- Main Script will be injected as separate script tags -->\r\n</body>\r\n</html>'
    },
    "styles": {
      "base": "/* =============================================================================\r\n   TEMPLATE CSS FILES - Clean, Organized Styles\r\n   ============================================================================= */\r\n\r\n/* FILE: editor/z3d-object-editor/templates/styles/base.css */\r\n/* Base styles and CSS variables */\r\n* {\r\n    margin: 0;\r\n    padding: 0;\r\n    box-sizing: border-box;\r\n}\r\n\r\n:root {\r\n    /* Colors */\r\n    --bg-primary: #1e1e1e;\r\n    --bg-secondary: #2a2a2a;\r\n    --bg-tertiary: #252525;\r\n    --bg-elevated: #323232;\r\n    --border-color: #3e3e3e;\r\n    --border-light: #4a4a4a;\r\n    \r\n    /* Text */\r\n    --text-primary: #ffffff;\r\n    --text-secondary: #cccccc;\r\n    --text-muted: #888888;\r\n    --text-disabled: #555555;\r\n    \r\n    /* Accent Colors */\r\n    --accent-color: #4CAF50;\r\n    --accent-hover: #5CBF60;\r\n    --error-color: #f44336;\r\n    --warning-color: #ff9800;\r\n    --info-color: #007acc;\r\n    \r\n    /* Shadows */\r\n    --shadow-small: 0 2px 4px rgba(0, 0, 0, 0.3);\r\n    --shadow-medium: 0 4px 8px rgba(0, 0, 0, 0.4);\r\n    --shadow-large: 0 8px 16px rgba(0, 0, 0, 0.5);\r\n    \r\n    /* Transitions */\r\n    --transition-fast: 0.15s ease;\r\n    --transition-normal: 0.25s ease;\r\n    --transition-slow: 0.4s ease;\r\n    \r\n    /* Spacing */\r\n    --spacing-xs: 4px;\r\n    --spacing-sm: 8px;\r\n    --spacing-md: 16px;\r\n    --spacing-lg: 24px;\r\n    --spacing-xl: 32px;\r\n    \r\n    /* Border Radius */\r\n    --radius-sm: 4px;\r\n    --radius-md: 8px;\r\n    --radius-lg: 12px;\r\n}\r\n\r\nbody {\r\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\r\n    background: var(--bg-primary);\r\n    color: var(--text-primary);\r\n    height: 100vh;\r\n    overflow: hidden;\r\n    font-size: 13px;\r\n    line-height: 1.4;\r\n}\r\n\r\n/* Selection */\r\n::selection {\r\n    background: var(--accent-color);\r\n    color: white;\r\n}\r\n\r\n/* Scrollbars */\r\n::-webkit-scrollbar {\r\n    width: 8px;\r\n    height: 8px;\r\n}\r\n\r\n::-webkit-scrollbar-track {\r\n    background: var(--bg-secondary);\r\n}\r\n\r\n::-webkit-scrollbar-thumb {\r\n    background: var(--border-color);\r\n    border-radius: var(--radius-sm);\r\n}\r\n\r\n::-webkit-scrollbar-thumb:hover {\r\n    background: var(--border-light);\r\n}\r\n\r\n/* Focus styles */\r\nbutton:focus,\r\ninput:focus,\r\nselect:focus {\r\n    outline: 2px solid var(--accent-color);\r\n    outline-offset: 2px;\r\n}",
      "components": `/* FILE: editor/z3d-object-editor/templates/styles/components.css */\r
/* Reusable component styles */\r
\r
/* Buttons */\r
.btn {\r
    display: inline-flex;\r
    align-items: center;\r
    justify-content: center;\r
    padding: var(--spacing-sm) var(--spacing-md);\r
    border: 1px solid var(--border-color);\r
    border-radius: var(--radius-sm);\r
    background: var(--bg-tertiary);\r
    color: var(--text-secondary);\r
    font-size: 12px;\r
    font-weight: 500;\r
    cursor: pointer;\r
    transition: all var(--transition-fast);\r
    user-select: none;\r
\r
    /* Fixed vendor prefixes for appearance */\r
    -webkit-appearance: none;\r
    -moz-appearance: none;\r
    appearance: none;\r
}\r
\r
.btn:hover {\r
    background: var(--bg-elevated);\r
    border-color: var(--border-light);\r
    transform: translateY(-1px);\r
}\r
\r
.btn:active {\r
    transform: translateY(0);\r
}\r
\r
.btn-primary {\r
    background: var(--accent-color);\r
    color: white;\r
    border-color: var(--accent-color);\r
}\r
\r
.btn-primary:hover {\r
    background: var(--accent-hover);\r
    border-color: var(--accent-hover);\r
}\r
\r
.btn-secondary {\r
    background: var(--bg-secondary);\r
    border-color: var(--border-color);\r
}\r
\r
.btn-sm {\r
    padding: var(--spacing-xs) var(--spacing-sm);\r
    font-size: 11px;\r
    min-width: 28px;\r
    height: 28px;\r
}\r
\r
.btn-danger {\r
    background: var(--error-color);\r
    color: white;\r
    border-color: var(--error-color);\r
}\r
\r
/* Status Messages */\r
.status-message {\r
    margin-bottom: var(--spacing-lg);\r
    padding: var(--spacing-md);\r
    border-radius: var(--radius-md);\r
    text-align: center;\r
    font-size: 13px;\r
    border: 1px solid transparent;\r
    animation: fadeIn 0.3s ease;\r
}\r
\r
@keyframes fadeIn {\r
    from { opacity: 0; transform: translateY(-10px); }\r
    to { opacity: 1; transform: translateY(0); }\r
}\r
\r
.status-message.loading {\r
    background: rgba(0, 122, 204, 0.1);\r
    border-color: rgba(0, 122, 204, 0.3);\r
    color: var(--info-color);\r
}\r
\r
.status-message.success {\r
    background: rgba(76, 175, 80, 0.1);\r
    border-color: rgba(76, 175, 80, 0.3);\r
    color: var(--accent-color);\r
}\r
\r
.status-message.error {\r
    background: rgba(244, 67, 54, 0.1);\r
    border-color: rgba(244, 67, 54, 0.3);\r
    color: var(--error-color);\r
}\r
\r
.status-message.warning {\r
    background: rgba(255, 152, 0, 0.1);\r
    border-color: rgba(255, 152, 0, 0.3);\r
    color: var(--warning-color);\r
}\r
\r
/* Panel Sections */\r
.panel-section {\r
    margin-bottom: var(--spacing-lg);\r
    padding: var(--spacing-lg);\r
    background: var(--bg-tertiary);\r
    border-radius: var(--radius-md);\r
    border: 1px solid var(--border-color);\r
    transition: border-color var(--transition-fast);\r
}\r
\r
.panel-section:hover {\r
    border-color: var(--border-light);\r
}\r
\r
.panel-section h3 {\r
    color: var(--accent-color);\r
    margin-bottom: var(--spacing-md);\r
    font-size: 14px;\r
    font-weight: 600;\r
    display: flex;\r
    align-items: center;\r
    gap: var(--spacing-sm);\r
}\r
\r
.panel-section.collapsed .panel-content {\r
    display: none;\r
}\r
\r
.panel-section.collapsed h3::after {\r
    content: ' (collapsed)';\r
    color: var(--text-muted);\r
    font-weight: normal;\r
    font-size: 11px;\r
}\r
\r
/* Form Controls */\r
.control-row {\r
    margin-bottom: var(--spacing-md);\r
}\r
\r
.control-row:last-child {\r
    margin-bottom: 0;\r
}\r
\r
.control-row label {\r
    display: flex;\r
    justify-content: space-between;\r
    align-items: center;\r
    color: var(--text-secondary);\r
    margin-bottom: var(--spacing-sm);\r
    font-size: 12px;\r
    font-weight: 500;\r
}\r
\r
.control-value {\r
    color: var(--accent-color);\r
    font-weight: 600;\r
    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;\r
}\r
\r
.control-row input[type="range"] {\r
    width: 100%;\r
    height: 4px;\r
    border-radius: 2px;\r
    background: var(--border-color);\r
    outline: none;\r
    cursor: pointer;\r
    \r
    /* Fixed vendor prefixes for appearance */\r
    -webkit-appearance: none;\r
    -moz-appearance: none;\r
    appearance: none;\r
}\r
\r
.control-row input[type="range"]::-webkit-slider-thumb {\r
    -webkit-appearance: none;\r
    appearance: none;\r
    width: 16px;\r
    height: 16px;\r
    border-radius: 50%;\r
    background: var(--accent-color);\r
    cursor: pointer;\r
    box-shadow: var(--shadow-small);\r
    transition: all var(--transition-fast);\r
}\r
\r
.control-row input[type="range"]::-webkit-slider-thumb:hover {\r
    transform: scale(1.1);\r
    box-shadow: var(--shadow-medium);\r
}\r
\r
.control-row input[type="number"],\r
.control-row input[type="text"],\r
.control-row select {\r
    width: 100%;\r
    padding: var(--spacing-sm);\r
    background: var(--bg-secondary);\r
    border: 1px solid var(--border-color);\r
    border-radius: var(--radius-sm);\r
    color: var(--text-primary);\r
    font-size: 12px;\r
}\r
\r
.control-row input[type="number"]:focus,\r
.control-row input[type="text"]:focus,\r
.control-row select:focus {\r
    border-color: var(--accent-color);\r
    box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);\r
}\r
\r
/* Checkbox and Radio */\r
.control-row input[type="checkbox"],\r
.control-row input[type="radio"] {\r
    margin-right: var(--spacing-sm);\r
    accent-color: var(--accent-color);\r
}\r
\r
/* Button Groups */\r
.btn-group {\r
    display: flex;\r
    gap: 2px;\r
}\r
\r
.btn-group .btn {\r
    border-radius: 0;\r
}\r
\r
.btn-group .btn:first-child {\r
    border-top-left-radius: var(--radius-sm);\r
    border-bottom-left-radius: var(--radius-sm);\r
}\r
\r
.btn-group .btn:last-child {\r
    border-top-right-radius: var(--radius-sm);\r
    border-bottom-right-radius: var(--radius-sm);\r
}\r
\r
.btn-group .btn.active {\r
    background: var(--accent-color);\r
    color: white;\r
    border-color: var(--accent-color);\r
}\r
\r
/* Loading Spinner */\r
.loading-spinner {\r
    width: 32px;\r
    height: 32px;\r
    border: 3px solid rgba(76, 175, 80, 0.3);\r
    border-top: 3px solid var(--accent-color);\r
    border-radius: 50%;\r
    animation: spin 1s linear infinite;\r
    margin: 0 auto var(--spacing-sm);\r
}\r
\r
@keyframes spin {\r
    0% { transform: rotate(0deg); }\r
    100% { transform: rotate(360deg); }\r
}\r
\r
/* Context Menu */\r
.context-menu {\r
    position: fixed;\r
    background: var(--bg-elevated);\r
    border: 1px solid var(--border-color);\r
    border-radius: var(--radius-md);\r
    box-shadow: var(--shadow-large);\r
    z-index: 1000;\r
    min-width: 150px;\r
    padding: var(--spacing-sm) 0;\r
}\r
\r
.context-item {\r
    padding: var(--spacing-sm) var(--spacing-md);\r
    cursor: pointer;\r
    font-size: 12px;\r
    color: var(--text-secondary);\r
    transition: all var(--transition-fast);\r
}\r
\r
.context-item:hover {\r
    background: var(--bg-secondary);\r
    color: var(--text-primary);\r
}\r
\r
.context-divider {\r
    height: 1px;\r
    background: var(--border-color);\r
    margin: var(--spacing-sm) 0;\r
}`,
      "layout": `/* FILE: editor/z3d-object-editor/templates/styles/layout.css */\r
/* UPDATED: Flexbox layout, right-region stretch fix, unified control alignment */\r
\r
html, body {\r
    margin: 0;\r
    padding: 0;\r
    width: 100%;\r
    height: 100%;\r
}\r
\r
.z3d-editor {\r
    display: flex;\r
    flex-direction: column;\r
    height: 100vh;\r
    width: 100vw;\r
    overflow: hidden;\r
}\r
\r
/* Top Bar */\r
.topbar {\r
    height: 32px;\r
    display: flex;\r
    align-items: center;\r
    justify-content: space-between;\r
    padding: 0 var(--spacing-md);\r
    background: var(--bg-secondary);\r
    border-bottom: 1px solid var(--border-color);\r
    flex-shrink: 0; /* Never shrink */\r
}\r
\r
/* Main Content - Horizontal Split */\r
.main-content {\r
    flex: 1;\r
    display: flex;\r
    min-height: 0; /* Critical for nested flex */\r
    overflow: hidden;\r
}\r
\r
/* Left Region - Contains viewport and viewer */\r
.left-region {\r
    flex: 0 0 70%; /* Initial width reduced from 80% so resizer starts ~10% further left */\r
    display: flex;\r
    flex-direction: column;\r
    min-width: 400px;\r
    overflow: hidden;\r
}\r
\r
/* Viewport Area - Where canvas lives */\r
.viewport-area {\r
    flex: 0 0 70%; /* Changed from 80% to 70% */\r
    position: relative;\r
    background: var(--bg-secondary);\r
    min-height: 300px;\r
    overflow: hidden;\r
}\r
\r
/* CRITICAL: Canvas container must fill viewport area */\r
.viewport-container {\r
    position: absolute;\r
    top: 36px; /* Offset by topbar height */\r
    left: 0;\r
    right: 0;\r
    bottom: 0;\r
    overflow: hidden;\r
}\r
\r
/* CRITICAL: Canvas must fill container without inline styles */\r
.three-canvas {\r
    display: block;\r
    width: 100% !important;\r
    height: 100% !important;\r
    position: absolute !important;\r
    top: 0 !important;\r
    left: 0 !important;\r
    cursor: grab;\r
    background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-primary) 100%);\r
    z-index: 0 !important;\r
}\r
\r
.three-canvas:active {\r
    cursor: grabbing;\r
}\r
\r
/* Scene Top Bar Overlay - defined in topbar.css */\r
\r
/* Left Horizontal Resizer */\r
.left-horizontal-resizer {\r
    flex: 0 0 4px;\r
    height: 4px;\r
    background: var(--border-color);\r
    cursor: ns-resize;\r
    transition: background var(--transition-fast);\r
    position: relative;\r
    z-index: 10;\r
}\r
\r
.left-horizontal-resizer:hover,\r
.left-horizontal-resizer.resizing {\r
    background: var(--accent-color);\r
}\r
\r
/* Viewer Area */\r
.viewer-area {\r
    flex: 1 1 30%; /* Changed from 0 0 20% to 1 1 30% - flex-grow: 1 ensures it fills remaining space */\r
    display: flex;\r
    flex-direction: column;\r
    background: var(--bg-tertiary);\r
    min-height: 100px;\r
    overflow: hidden;\r
}\r
\r
/* Viewer Topbar - Tighter spacing to match object-controls */\r
.viewer-topbar {\r
    display: flex;\r
    align-items: center;\r
    padding: 6px 12px; /* Reduced from default padding */\r
    background: var(--bg-secondary);\r
    border-bottom: 1px solid var(--border-color);\r
    flex-shrink: 0;\r
    height: 32px; /* Fixed height to match other topbars */\r
}\r
\r
.viewer-controls {\r
    display: flex;\r
    align-items: center;\r
    gap: 8px;\r
}\r
\r
.viewer-select {\r
    padding: 4px 8px;\r
    background: #1a1a1a;\r
    border: 1px solid rgba(255, 255, 255, 0.1);\r
    border-radius: var(--radius-sm);\r
    color: #e0e0e0;\r
    font-size: 11px;\r
    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;\r
    cursor: pointer;\r
    outline: none;\r
    transition: all var(--transition-fast);\r
}\r
\r
.viewer-select:hover {\r
    border-color: rgba(255, 255, 255, 0.2);\r
    background: #1d1d1d;\r
}\r
\r
.viewer-select:focus {\r
    border-color: var(--accent-color);\r
    box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);\r
}\r
\r
/* Viewer Content - Ensure it fills remaining space */\r
.viewer-content {\r
    flex: 1;\r
    overflow-y: auto;\r
    overflow-x: hidden;\r
    display: flex;\r
    flex-direction: column;\r
}\r
\r
/* Vertical Resizer */\r
.vertical-resizer {\r
    flex: 0 0 4px;\r
    width: 4px;\r
    background: var(--border-color);\r
    cursor: ew-resize;\r
    transition: background var(--transition-fast);\r
    position: relative;\r
    z-index: 10;\r
}\r
\r
.vertical-resizer:hover,\r
.vertical-resizer.resizing {\r
    background: var(--accent-color);\r
}\r
\r
/* Right Region */\r
.right-region {\r
    flex: 1 1 auto; /* Allow expansion */\r
    display: flex;\r
    flex-direction: column;\r
    background: var(--bg-tertiary);\r
    min-width: 250px;\r
    overflow: hidden;\r
    align-self: stretch;\r
    max-width: 100%;\r
}\r
\r
/* Info Section */\r
.info-section {\r
    padding: var(--spacing-md);\r
    border-bottom: 1px solid var(--border-color);\r
    background: var(--bg-secondary);\r
    flex-shrink: 0;\r
}\r
\r
/* Node Tree Section */\r
.side-tabs-section {\r
    flex: 1 1 auto; /* fill remaining space above status bar */\r
    display: flex;\r
    flex-direction: row; /* vertical tab bar on left */\r
    min-height: 200px;\r
    min-height: 0; /* allow interior flex children to scroll */\r
    overflow: hidden;\r
}\r
.tab-bar {\r
    display: flex;\r
    flex-direction: column;\r
    background: var(--bg-secondary);\r
    border-right: 1px solid var(--border-color);\r
    width: 44px;\r
    flex-shrink: 0;\r
}\r
.tab-bar .tab-btn {\r
    padding: 6px 0;\r
    border: none;\r
    background: transparent;\r
    color: var(--text-secondary);\r
    cursor: pointer;\r
    font-size: 16px; /* larger icon */\r
    display: flex;\r
    justify-content: center;\r
    align-items: center;\r
    flex-direction: column;\r
    gap: 4px;\r
    position: relative;\r
}\r
.tab-bar .tab-btn .icon { line-height: 1; filter: drop-shadow(0 1px 1px rgba(0,0,0,0.4)); }\r
.tab-bar .tab-btn:hover { background: var(--bg-tertiary); color: var(--text-primary); }\r
.tab-bar .tab-btn.active {\r
    background: var(--bg-tertiary);\r
    color: var(--text-primary);\r
    border-left: 3px solid var(--accent-color);\r
}\r
\r
/* Compact object control layout helpers */\r
/* Unified label width + prevent wrapping so e.g. "Rotation Order" stays on one line */\r
.object-controls.compact-layout .vector-row label,\r
.object-controls.compact-layout .control-row.inline label { \r
    width: 96px; \r
    text-align: right; \r
    padding-right: 4px; \r
    white-space: nowrap;\r
}\r
.object-controls.compact-layout .vector-row { gap: 4px; }\r
.object-controls.compact-layout .drag-input { padding: 4px 6px; font-size: 10px; }\r
.object-controls.compact-layout .control-row.inline { display: flex; align-items: center; gap: 4px; }\r
.object-controls.compact-layout .control-row.inline input,\r
.object-controls.compact-layout .control-row.inline select { flex: 1; min-width: 0; }\r
\r
/* Force scalar control rows (Unit Scale, Scale, Rotation Order) to align with vector rows width */\r
/* Allow rows to stretch; width control handled by section padding */\r
.object-controls.compact-layout .scalar-controls,\r
.object-controls.compact-layout .control-row.inline,\r
.object-controls.compact-layout .vector-controls { max-width: none; }\r
\r
/* Ensure degree symbol spacing does not push width beyond set max */\r
.object-controls.compact-layout .vector-row .unit { flex: 0 0 14px; text-align: left; }\r
\r
/* Viewport controls labels alignment mirror object controls */\r
.viewport-controls-panel .vc-field label { width: 70px; text-align: right; }\r
\r
/* Prevent tab content from stretching child panels beyond intended width */\r
.tab-panel.active { align-items: stretch; }\r
\r
/* Rotation order select alignment */\r
/* Rotation order select should expand like other inputs */\r
.object-controls.compact-layout select#rotation-order { max-width: none; }\r
\r
/* Viewport controls unified row */\r
.viewport-controls-panel { padding: var(--spacing-sm); display: flex; flex-direction: column; gap: 6px; }\r
.viewport-controls-panel .controls-row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }\r
.viewport-controls-panel .vc-field { display: flex; align-items: center; gap: 4px; }\r
.viewport-controls-panel .vc-field label { width: 70px; text-align: right; white-space: nowrap; font-size: 11px; }\r
.viewport-controls-panel .vc-field input[type=number] { width: 64px; }\r
.viewport-controls-panel .vc-field.checkbox label { width: 70px; }\r
.viewport-controls-panel .vc-field.checkbox input[type=checkbox] { margin-left: 0; }\r
.tab-content {\r
    flex: 1;\r
    overflow-y: auto;\r
    display: flex;\r
    overflow-x: hidden; /* prevent horizontal scroll */\r
}\r
/* Ensure only the active tab-panel is visible */\r
.tab-panel { display: none; flex: 1; }\r
.tab-panel.active { display: flex; flex-direction: column; }\r
\r
/* Collapsible section styling */\r
.object-controls .collapsible-section {\r
    background: rgba(255,255,255,0.03);\r
    border: 1px solid rgba(255,255,255,0.06);\r
    border-radius: 6px;\r
    padding: 4px 6px 6px;\r
    margin: 6px 8px;\r
    position: relative;\r
}\r
.object-controls .collapsible-section.collapsed { opacity: 0.9; }\r
.object-controls .section-header {\r
    display: flex;\r
    align-items: center;\r
    gap: 6px;\r
    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;\r
    font-size: 11px;\r
    font-weight: 600;\r
    cursor: pointer;\r
    padding: 2px 2px 4px;\r
    user-select: none;\r
    color: var(--text-secondary);\r
}\r
.object-controls .section-header:hover { color: var(--text-primary); }\r
.object-controls .section-content { padding-top: 4px; }\r
\r
/* Field row layout stretching while keeping consistent internal widths */\r
.object-controls .field-row, .object-controls .vector-row { width: 100%; }\r
.object-controls { --oc-min-input-width: 64px; --oc-label-width: 96px; --oc-unit-col-width: 4px; }\r
.object-controls .vector-row, .object-controls .field-row {\r
    display: grid;\r
    grid-template-columns: var(--oc-label-width) 1fr var(--oc-unit-col-width);\r
    align-items: center;\r
    gap: 1px;\r
}\r
/* Inputs (position, rotation, scale, unit scale, master scale, rotation order) expand uniformly */\r
.object-controls .vector-row input.drag-input,\r
.object-controls .field-row input.drag-input,\r
.object-controls .field-row select {\r
    width: 100%;\r
    min-width: var(--oc-min-input-width);\r
}\r
.object-controls .unit-spacer { width: var(--oc-unit-col-width); display: inline-block; }\r
\r
/* Ensure all degree units align in a reserved spacer column */\r
.object-controls .vector-row span.unit { position: absolute; right: 8px; }\r
.object-controls .vector-row span.unit { width: var(--oc-unit-col-width); text-align: left; font-size: 10px; color: #808080; }\r
\r
/* Reduce right padding inside inputs so number is closer to unit */\r
.object-controls.compact-layout .drag-input { padding: 4px 2px; }\r
\r
/* Vertical grouping spacing */\r
/* Vector group internal spacing */\r
.object-controls .section-content > .vector-controls { display:flex; flex-direction:column; gap:4px; margin:0; }\r
/* Specific group spacing adjustments */\r
/* Primary transform group spacing (slightly reduced) */\r
.object-controls .section-content > .position-group { margin-bottom:16px; }\r
.object-controls .section-content > .rotation-group { margin-bottom:20px; }\r
.object-controls .section-content > .scale-vector-group { margin-bottom:16px; }\r
/* Scalar controls (unit scale + scale) as grid rows matching vector layout */\r
.object-controls .scalar-controls { display:flex; flex-direction:column; gap:4px; margin-bottom:16px; }\r
/* Reset inherited control-row margin from global components.css for compact layout */\r
.object-controls .control-row { margin-bottom:0; }\r
.object-controls .scalar-controls .field-row { display:grid; grid-template-columns: var(--oc-label-width) 1fr var(--oc-unit-col-width); align-items:center; gap:1px; }\r
.object-controls .scalar-controls .field-row + .field-row { margin-top:0; }\r
.object-controls .scalar-controls .field-row label { text-align:right !important; justify-self:end; width:var(--oc-label-width); display:block; }\r
/* Delta transform group spacing (match primary) */\r
.object-controls #delta-transform-content > .delta-position-group { margin-bottom:16px; }\r
.object-controls #delta-transform-content > .delta-rotation-group { margin-bottom:20px; }\r
.object-controls #delta-transform-content > .delta-scale-vector-group { margin-bottom:16px; }\r
/* Ensure rotation order row treated like other field rows */\r
.object-controls .field-row select#rotation-order { width:100%; }\r
\r
/* Prevent overflow past a comfortable reading max width */\r
/* Section content fills available width with internal right padding for unit column */\r
.object-controls .section-content { max-width: none; padding-right: 18px; }\r
\r
/* Make collapsible sections fill parent width */\r
.object-controls { width: 100%; }\r
.object-controls .collapsible-section { width: 100%; margin-left: 8px; margin-right: 8px; }\r
.object-controls { align-self: stretch; }\r
\r
/* Horizontal Resizer */\r
.horizontal-resizer {\r
    flex: 0 0 4px;\r
    height: 4px;\r
    background: var(--border-color);\r
    cursor: ns-resize;\r
    transition: background var(--transition-fast);\r
    position: relative;\r
    z-index: 10;\r
}\r
\r
.horizontal-resizer:hover,\r
.horizontal-resizer.resizing {\r
    background: var(--accent-color);\r
}\r
\r
\r
/* Status Bar */\r
.right-region { position: relative; }\r
.right-region > .status-bar { margin-top: auto; }\r
.status-bar {\r
    display: flex;\r
    align-items: center;\r
    gap: 8px;\r
    padding: 4px var(--spacing-md);\r
    background: var(--bg-secondary);\r
    border-top: 1px solid var(--border-color);\r
    font-size: 10px;\r
    line-height: 1.2;\r
    color: var(--text-muted);\r
    flex-shrink: 0;\r
    min-height: 28px;\r
}\r
\r
/* Overlay for stats */\r
.stats-overlay {\r
    position: absolute;\r
    top: 40px;\r
    left: var(--spacing-sm);\r
    background: rgba(37, 37, 37, 0.9);\r
    backdrop-filter: blur(10px);\r
    padding: var(--spacing-sm);\r
    border-radius: var(--radius-sm);\r
    font-size: 11px;\r
    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;\r
    color: var(--text-secondary);\r
    z-index: 100;\r
    pointer-events: none;\r
}\r
\r
/* Loading Indicator */\r
.loading-indicator {\r
    position: absolute;\r
    top: 50%;\r
    left: 50%;\r
    transform: translate(-50%, -50%);\r
    background: rgba(0, 0, 0, 0.85);\r
    padding: var(--spacing-xl);\r
    border-radius: var(--radius-lg);\r
    z-index: 200;\r
    pointer-events: none;\r
}\r
\r
.loading-indicator.hidden {\r
    display: none;\r
}\r
\r
/* Discord Support Link */\r
.discord-link {\r
    display: flex;\r
    align-items: center;\r
    gap: 8px;\r
    color: white;\r
    text-decoration: none;\r
    font-size: 13px;\r
    font-weight: 500;\r
    padding: 6px 12px;\r
    border-radius: var(--radius-sm);\r
    transition: all var(--transition-fast);\r
}\r
\r
.discord-link:hover {\r
    background: rgba(114, 137, 218, 0.2); /* Discord brand color with transparency */\r
    color: #7289da; /* Discord brand color */\r
}\r
\r
.discord-icon {\r
    width: 18px;\r
    height: 18px;\r
    flex-shrink: 0;\r
}\r
\r
/* Ensure topbar-right aligns properly */\r
.topbar-right {\r
    display: flex;\r
    align-items: center;\r
}\r
\r
.topbar-left {\r
    display: flex;\r
    align-items: center;\r
}\r
\r
.logo {\r
    font-weight: 600;\r
    font-size: 14px;\r
    color: var(--text-primary);\r
}`,
      "object-controls": `/* FILE: editor/z3d-object-editor/templates/styles/object-controls.css */\r
/* UPDATED: Better dark theme styling for number inputs */\r
\r
/* Vector Controls */\r
.vector-controls {\r
    display: flex;\r
    flex-direction: column;\r
    gap: var(--spacing-sm);\r
}\r
\r
.vector-row {\r
    display: flex;\r
    align-items: center;\r
    gap: var(--spacing-sm);\r
}\r
\r
.vector-row label {\r
    min-width: 20px;\r
    font-size: 11px;\r
    font-weight: 600;\r
    color: var(--text-secondary);\r
    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;\r
}\r
\r
/* Improved Drag Input Fields - Dark Theme */\r
.drag-input {\r
    flex: 1;\r
    padding: 6px 8px;\r
    background: #1a1a1a !important; /* Darker than container - force override */\r
    border: 1px solid rgba(255, 255, 255, 0.1);\r
    border-radius: var(--radius-sm);\r
    color: #e0e0e0 !important; /* Light text - force override */\r
    font-size: 11px;\r
    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;\r
    text-align: right;\r
    transition: all var(--transition-fast);\r
    cursor: text;\r
    outline: none;\r
    position: relative;\r
    -webkit-appearance: none; /* Remove default browser styling */\r
    -moz-appearance: textfield; /* Remove default browser styling */\r
    -webkit-user-select: text; /* Allow text selection */\r
    -moz-user-select: text;\r
    user-select: text;\r
}\r
\r
/* Prevent no-drag cursor when dragging selected text */\r
.drag-input::selection {\r
    background: rgba(76, 175, 80, 0.3);\r
    color: #ffffff;\r
}\r
\r
.drag-input::-moz-selection {\r
    background: rgba(76, 175, 80, 0.3);\r
    color: #ffffff;\r
}\r
\r
/* Force dark theme for all number inputs with drag-input class */\r
input[type="number"].drag-input {\r
    background: #1a1a1a !important;\r
    color: #e0e0e0 !important;\r
}\r
\r
.drag-input:hover {\r
    border-color: rgba(255, 255, 255, 0.2);\r
    background: #1d1d1d !important;\r
    color: #ffffff !important;\r
}\r
\r
.drag-input:focus {\r
    border-color: var(--accent-color);\r
    box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);\r
    background: #1a1a1a !important;\r
    color: #ffffff !important;\r
}\r
\r
/* Dragging state */\r
.drag-input.dragging {\r
    cursor: ns-resize !important;\r
    background: #222222 !important;\r
    border-color: var(--accent-color);\r
    color: #ffffff !important;\r
    -webkit-user-select: none !important;\r
    -moz-user-select: none !important; \r
    user-select: none !important;\r
}\r
\r
/* Remove spinner buttons for cleaner look */\r
.drag-input::-webkit-inner-spin-button,\r
.drag-input::-webkit-outer-spin-button {\r
    -webkit-appearance: none;\r
    margin: 0;\r
}\r
\r
.drag-input[type=number] {\r
    -moz-appearance: textfield;\r
}\r
\r
/* Visual feedback during drag */\r
.drag-input.dragging::after {\r
    content: '';\r
    position: absolute;\r
    top: -20px;\r
    left: 50%;\r
    transform: translateX(-50%);\r
    width: 0;\r
    height: 0;\r
    border-left: 4px solid transparent;\r
    border-right: 4px solid transparent;\r
    border-bottom: 6px solid var(--accent-color);\r
    opacity: 0;\r
    animation: dragIndicatorUp 0.3s ease-out;\r
}\r
\r
.drag-input.dragging.drag-down::after {\r
    top: auto;\r
    bottom: -20px;\r
    border-bottom: none;\r
    border-top: 6px solid var(--accent-color);\r
    animation: dragIndicatorDown 0.3s ease-out;\r
}\r
\r
@keyframes dragIndicatorUp {\r
    0% { opacity: 0; transform: translateX(-50%) translateY(5px); }\r
    50% { opacity: 1; }\r
    100% { opacity: 0; transform: translateX(-50%) translateY(-5px); }\r
}\r
\r
@keyframes dragIndicatorDown {\r
    0% { opacity: 0; transform: translateX(-50%) translateY(-5px); }\r
    50% { opacity: 1; }\r
    100% { opacity: 0; transform: translateX(-50%) translateY(5px); }\r
}\r
\r
/* Unit labels styling */\r
.unit {\r
    font-size: 10px;\r
    color: #808080;\r
    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;\r
    min-width: 15px;\r
}`,
      "outliner": "/* FILE: editor/z3d-object-editor/templates/styles/outliner.css */\r\n/* Enhanced Outliner/Node Tree Styles with Fixed Arrows and Text Selection */\r\n\r\n/* CSS Variables for consistency */\r\n:root {\r\n    --outliner-indent: 20px;\r\n    --outliner-arrow-size: 12px;\r\n}\r\n\r\n.node-tree-section {\r\n    flex: 0 0 50%;\r\n    display: flex;\r\n    flex-direction: column;\r\n    background: var(--bg-tertiary);\r\n    border-bottom: 1px solid var(--border-color);\r\n    min-height: 150px;\r\n    overflow: hidden;\r\n}\r\n\r\n.node-tree-section h4 {\r\n    padding: var(--spacing-sm) var(--spacing-md);\r\n    margin: 0;\r\n    font-size: 13px;\r\n    font-weight: 600;\r\n    color: var(--text-secondary);\r\n    background: var(--bg-secondary);\r\n    border-bottom: 1px solid var(--border-color);\r\n    flex-shrink: 0;\r\n}\r\n\r\n.node-tree {\r\n    flex: 1;\r\n    overflow: hidden;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n/* Outliner Container */\r\n.outliner-container {\r\n    display: flex;\r\n    flex-direction: column;\r\n    height: 100%;\r\n    background: var(--bg-tertiary);\r\n}\r\n\r\n/* Outliner Toolbar */\r\n.outliner-toolbar {\r\n    display: flex;\r\n    gap: 4px;\r\n    padding: 6px;\r\n    background: var(--bg-secondary);\r\n    border-bottom: 1px solid var(--border-color);\r\n    flex-shrink: 0;\r\n}\r\n\r\n.outliner-category-select {\r\n    min-width: 120px;\r\n    padding: 4px 8px;\r\n    background: var(--bg-primary);\r\n    border: 1px solid var(--border-color);\r\n    border-radius: var(--radius-sm);\r\n    color: var(--text-primary);\r\n    font-size: 11px;\r\n    cursor: pointer;\r\n}\r\n\r\n.outliner-search {\r\n    flex: 1;\r\n    padding: 4px 8px;\r\n    background: var(--bg-primary);\r\n    border: 1px solid var(--border-color);\r\n    border-radius: var(--radius-sm);\r\n    color: var(--text-primary);\r\n    font-size: 11px;\r\n    min-width: 0;\r\n}\r\n\r\n.outliner-search:focus {\r\n    border-color: var(--accent-color);\r\n    outline: none;\r\n}\r\n\r\n/* Outliner Tree */\r\n.outliner-tree {\r\n    flex: 1;\r\n    overflow-y: auto;\r\n    overflow-x: hidden;\r\n    padding: 4px 0;\r\n}\r\n\r\n/* Scene Explorer */\r\n.scene-explorer {\r\n    padding: 4px 0;\r\n}\r\n\r\n/* Category Sections */\r\n.category-section {\r\n    margin-bottom: 4px;\r\n    border-bottom: 1px solid var(--border-color);\r\n}\r\n\r\n.category-section:last-child {\r\n    border-bottom: none;\r\n}\r\n\r\n.category-header {\r\n    display: flex;\r\n    align-items: center;\r\n    padding: 8px 12px;\r\n    cursor: pointer;\r\n    user-select: none;\r\n    background: linear-gradient(135deg, #2a2a2a, #252525);\r\n    transition: background 0.2s;\r\n}\r\n\r\n.category-header:hover {\r\n    background: linear-gradient(135deg, #2d2d2d, #282828);\r\n}\r\n\r\n.category-header.empty {\r\n    opacity: 0.5;\r\n    cursor: default;\r\n}\r\n\r\n.category-toggle {\r\n    display: inline-flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    width: var(--outliner-arrow-size);\r\n    height: var(--outliner-arrow-size);\r\n    margin-right: 8px;\r\n    color: var(--text-muted);\r\n    font-size: 10px;\r\n    transition: transform 0.2s;\r\n    flex-shrink: 0;\r\n}\r\n\r\n.category-toggle.expanded {\r\n    transform: rotate(90deg);\r\n}\r\n\r\n.category-icon {\r\n    margin-right: 8px;\r\n    font-size: 14px;\r\n    filter: drop-shadow(0 1px 1px rgba(0,0,0,0.3));\r\n}\r\n\r\n.category-name {\r\n    flex: 1;\r\n    font-size: 12px;\r\n    font-weight: 600;\r\n    color: var(--text-primary);\r\n}\r\n\r\n.category-count {\r\n    font-size: 11px;\r\n    color: var(--text-muted);\r\n    opacity: 0.7;\r\n}\r\n\r\n.category-content {\r\n    padding: 2px 0;\r\n    background: rgba(0, 0, 0, 0.1);\r\n}\r\n\r\n/* Node Styles */\r\n.outliner-node {\r\n    font-size: 11px;\r\n    position: relative;\r\n}\r\n\r\n.node-row {\r\n    display: flex;\r\n    align-items: center;\r\n    padding: 2px 8px 2px 4px;\r\n    cursor: pointer;\r\n    transition: background var(--transition-fast);\r\n    white-space: nowrap;\r\n    overflow: hidden;\r\n    min-height: 22px;\r\n}\r\n\r\n.node-row:hover {\r\n    background: rgba(255, 255, 255, 0.05);\r\n}\r\n\r\n.outliner-node.selected > .node-row {\r\n    background: var(--accent-color);\r\n    color: white;\r\n}\r\n\r\n.outliner-node.hovered > .node-row {\r\n    background: rgba(76, 175, 80, 0.2);\r\n}\r\n\r\n/* Node Toggle Arrow - FIXED */\r\n.node-toggle {\r\n    display: inline-flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    width: var(--outliner-arrow-size);\r\n    height: var(--outliner-arrow-size);\r\n    margin-right: 4px;\r\n    cursor: pointer;\r\n    color: var(--text-muted);\r\n    font-size: 10px;\r\n    transition: transform 0.2s, color 0.2s;\r\n    flex-shrink: 0;\r\n    /* Ensure arrow is visible */\r\n    line-height: 1;\r\n    font-family: monospace;\r\n}\r\n\r\n.node-toggle:hover {\r\n    color: var(--text-primary);\r\n}\r\n\r\n.node-toggle.expanded {\r\n    transform: rotate(90deg);\r\n}\r\n\r\n.node-toggle-spacer {\r\n    display: inline-block;\r\n    width: var(--outliner-arrow-size);\r\n    margin-right: 4px;\r\n    flex-shrink: 0;\r\n}\r\n\r\n/* Node Icon */\r\n.node-icon {\r\n    margin: 0 6px;\r\n    flex-shrink: 0;\r\n    font-size: 14px;\r\n    filter: drop-shadow(0 1px 1px rgba(0,0,0,0.3));\r\n}\r\n\r\n/* Node Name - ENABLE TEXT SELECTION */\r\n.node-name {\r\n    flex: 1;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n    color: var(--text-primary);\r\n    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;\r\n    /* Enable text selection */\r\n    user-select: text !important;\r\n    -webkit-user-select: text !important;\r\n    -moz-user-select: text !important;\r\n    -ms-user-select: text !important;\r\n    cursor: text;\r\n}\r\n\r\n/* When hovering over node name, show text cursor */\r\n.node-name:hover {\r\n    cursor: text;\r\n}\r\n\r\n/* Selected text styling - MORE VISIBLE */\r\n.node-name::selection,\r\n.item-name::selection,\r\n.sub-item-name::selection,\r\n.metadata-value::selection {\r\n    background: #FF6B00 !important; /* Bright orange background */\r\n    color: #FFFFFF !important; /* White text */\r\n}\r\n\r\n.node-name::-moz-selection,\r\n.item-name::-moz-selection,\r\n.sub-item-name::-moz-selection,\r\n.metadata-value::-moz-selection {\r\n    background: #FF6B00 !important; /* Bright orange background */\r\n    color: #FFFFFF !important; /* White text */\r\n}\r\n\r\n/* When row is selected but text is being selected, reduce row opacity */\r\n.outliner-node.selected > .node-row:has(.node-name::selection),\r\n.list-item.selected:has(.item-name::selection) {\r\n    background: rgba(76, 175, 80, 0.3); /* Reduced opacity when selecting text */\r\n}\r\n\r\n/* Search match highlighting */\r\n.node-name.search-match {\r\n    background: rgba(255, 200, 0, 0.3);\r\n    padding: 0 2px;\r\n    border-radius: 2px;\r\n}\r\n\r\n/* Node Type */\r\n.node-type {\r\n    margin-left: auto;\r\n    padding-left: 8px;\r\n    color: var(--text-muted);\r\n    font-size: 10px;\r\n    opacity: 0.7;\r\n    font-style: italic;\r\n    user-select: none;\r\n}\r\n\r\n/* Visibility Toggle Button - NEW */\r\n.visibility-toggle {\r\n    display: inline-flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    width: 18px;\r\n    height: 18px;\r\n    margin-left: 6px;\r\n    padding: 0;\r\n    background: transparent;\r\n    border: none;\r\n    color: var(--text-primary);\r\n    font-size: 14px;\r\n    cursor: pointer;\r\n    transition: all 0.2s;\r\n    flex-shrink: 0;\r\n    opacity: 0.8;\r\n    filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));\r\n}\r\n\r\n.visibility-toggle:hover {\r\n    opacity: 1;\r\n    transform: scale(1.1);\r\n}\r\n\r\n.visibility-toggle.hidden {\r\n    opacity: 0.4;\r\n    color: var(--text-muted);\r\n    text-decoration: line-through;\r\n}\r\n\r\n/* Alternative hidden style with slash-eye */\r\n.visibility-toggle.hidden::after {\r\n    content: '';\r\n    position: absolute;\r\n    width: 14px;\r\n    height: 1px;\r\n    background: var(--text-muted);\r\n    transform: rotate(-45deg);\r\n}\r\n\r\n/* Metadata Toggle Button */\r\n.metadata-toggle {\r\n    display: inline-flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    width: 16px;\r\n    height: 16px;\r\n    margin-left: 6px;\r\n    padding: 0;\r\n    background: transparent;\r\n    border: 1px solid rgba(255, 255, 255, 0.2);\r\n    border-radius: 3px;\r\n    color: var(--text-muted);\r\n    font-size: 9px;\r\n    cursor: pointer;\r\n    transition: all 0.2s;\r\n    flex-shrink: 0;\r\n    opacity: 0.6;\r\n}\r\n\r\n.metadata-toggle:hover {\r\n    opacity: 1;\r\n    background: rgba(255, 255, 255, 0.1);\r\n    border-color: var(--accent-color);\r\n    color: var(--accent-color);\r\n}\r\n\r\n.metadata-toggle.expanded {\r\n    background: rgba(76, 175, 80, 0.2);\r\n    border-color: var(--accent-color);\r\n    color: var(--accent-color);\r\n    opacity: 1;\r\n}\r\n\r\n/* Hide metadata toggle when there's no metadata */\r\n.node-row:not(.has-metadata) .metadata-toggle {\r\n    display: none;\r\n}\r\n\r\n/* Node Children */\r\n.node-children {\r\n    position: relative;\r\n}\r\n\r\n.node-children::before {\r\n    content: '';\r\n    position: absolute;\r\n    left: 10px;\r\n    top: 0;\r\n    bottom: 0;\r\n    width: 1px;\r\n    background: var(--border-color);\r\n    opacity: 0.3;\r\n}\r\n\r\n/* Node Metadata */\r\n.node-metadata {\r\n    padding: 4px 0;\r\n    font-size: 10px;\r\n    color: var(--text-muted);\r\n}\r\n\r\n.metadata-group {\r\n    margin: 2px 0;\r\n    padding: 4px 8px;\r\n    background: rgba(0, 0, 0, 0.2);\r\n    border-left: 2px solid var(--accent-color);\r\n}\r\n\r\n.metadata-item {\r\n    display: flex;\r\n    gap: 8px;\r\n    padding: 1px 0;\r\n}\r\n\r\n.metadata-key {\r\n    color: var(--accent-color);\r\n    font-weight: 600;\r\n    min-width: 60px;\r\n}\r\n\r\n.metadata-value {\r\n    flex: 1;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n    white-space: nowrap;\r\n    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;\r\n    /* Enable text selection for metadata values */\r\n    user-select: text !important;\r\n    cursor: text;\r\n}\r\n\r\n.metadata-value.clickable {\r\n    color: var(--accent-color);\r\n    cursor: pointer;\r\n    text-decoration: underline;\r\n    user-select: none;\r\n}\r\n\r\n.metadata-value.clickable:hover {\r\n    color: var(--accent-light);\r\n}\r\n\r\n/* List Items (Materials, Textures, etc.) */\r\n.items-list {\r\n    padding: 4px 0;\r\n}\r\n\r\n.list-item {\r\n    display: flex;\r\n    align-items: center;\r\n    padding: 4px 12px;\r\n    cursor: pointer;\r\n    transition: background 0.2s;\r\n    font-size: 11px;\r\n}\r\n\r\n.list-item:hover {\r\n    background: rgba(255, 255, 255, 0.05);\r\n}\r\n\r\n.list-item.selected {\r\n    background: var(--accent-color);\r\n    color: white;\r\n}\r\n\r\n.item-toggle {\r\n    display: inline-flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    width: var(--outliner-arrow-size);\r\n    height: var(--outliner-arrow-size);\r\n    margin-right: 4px;\r\n    cursor: pointer;\r\n    color: var(--text-muted);\r\n    font-size: 10px;\r\n    transition: transform 0.2s;\r\n    flex-shrink: 0;\r\n}\r\n\r\n.item-toggle.expanded {\r\n    transform: rotate(90deg);\r\n}\r\n\r\n.item-icon {\r\n    margin: 0 8px;\r\n    font-size: 14px;\r\n    flex-shrink: 0;\r\n}\r\n\r\n.item-name {\r\n    flex: 1;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n    /* Enable text selection */\r\n    user-select: text !important;\r\n    cursor: text;\r\n}\r\n\r\n.item-type,\r\n.item-info {\r\n    margin-left: auto;\r\n    padding-left: 8px;\r\n    color: var(--text-muted);\r\n    font-size: 10px;\r\n    opacity: 0.7;\r\n    user-select: none;\r\n}\r\n\r\n.item-badge {\r\n    margin-left: 4px;\r\n    font-size: 10px;\r\n}\r\n\r\n/* Sub Items (Animation tracks, bones, etc.) */\r\n.sub-items {\r\n    padding-left: 24px;\r\n    background: rgba(0, 0, 0, 0.1);\r\n}\r\n\r\n.sub-item {\r\n    display: flex;\r\n    align-items: center;\r\n    padding: 2px 12px;\r\n    font-size: 10px;\r\n    color: var(--text-muted);\r\n}\r\n\r\n.sub-item-icon {\r\n    margin-right: 6px;\r\n    font-size: 12px;\r\n    opacity: 0.7;\r\n}\r\n\r\n.sub-item-name {\r\n    flex: 1;\r\n    /* Enable text selection */\r\n    user-select: text !important;\r\n    cursor: text;\r\n}\r\n\r\n.sub-item-type,\r\n.sub-item-info {\r\n    margin-left: auto;\r\n    padding-left: 8px;\r\n    font-size: 9px;\r\n    opacity: 0.6;\r\n    user-select: none;\r\n}\r\n\r\n/* Loading State */\r\n.outliner-loading {\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    justify-content: center;\r\n    padding: var(--spacing-xl);\r\n    color: var(--text-muted);\r\n    gap: var(--spacing-sm);\r\n}\r\n\r\n.outliner-loading .loading-spinner.small {\r\n    width: 24px;\r\n    height: 24px;\r\n    border-width: 2px;\r\n}\r\n\r\n/* Empty State */\r\n.outliner-empty {\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    justify-content: center;\r\n    padding: var(--spacing-xl);\r\n    color: var(--text-muted);\r\n    gap: var(--spacing-sm);\r\n}\r\n\r\n.empty-icon {\r\n    font-size: 32px;\r\n    opacity: 0.5;\r\n}\r\n\r\n.empty-text {\r\n    font-size: 12px;\r\n}\r\n\r\n/* Stats */\r\n.outliner-stats {\r\n    padding: 8px;\r\n    background: var(--bg-secondary);\r\n    border-top: 1px solid var(--border-color);\r\n    font-size: 10px;\r\n    color: var(--text-muted);\r\n}\r\n\r\n.stats-row {\r\n    display: flex;\r\n    gap: 12px;\r\n    flex-wrap: wrap;\r\n}\r\n\r\n.stat-item {\r\n    white-space: nowrap;\r\n}\r\n\r\n/* Scrollbar for outliner */\r\n.outliner-tree::-webkit-scrollbar {\r\n    width: 6px;\r\n}\r\n\r\n.outliner-tree::-webkit-scrollbar-track {\r\n    background: transparent;\r\n}\r\n\r\n.outliner-tree::-webkit-scrollbar-thumb {\r\n    background: var(--border-color);\r\n    border-radius: 3px;\r\n}\r\n\r\n.outliner-tree::-webkit-scrollbar-thumb:hover {\r\n    background: var(--border-light);\r\n}\r\n\r\n/* Hidden node indicator */\r\n.node-hidden {\r\n    margin-left: 4px;\r\n    opacity: 0.5;\r\n    font-size: 10px;\r\n}",
      "animation": "/* FILE: editor/z3d-object-editor/templates/styles/animation.css */\r\n/* Animation Viewer Styles - Complete with Restored Styling */\r\n\r\n.animation-controls {\r\n    display: flex;\r\n    flex-direction: column;\r\n    height: 100%;\r\n    padding: 8px; /* Reduced from 12px */\r\n    gap: 8px; /* Reduced from 12px */\r\n    background: var(--bg-tertiary);\r\n}\r\n\r\n/* Compact Animation Header */\r\n.animation-header-compact {\r\n    padding-bottom: 6px; /* Reduced from 8px */\r\n    border-bottom: 1px solid var(--border-color);\r\n}\r\n\r\n.animation-select-row {\r\n    display: flex;\r\n    gap: 8px; /* Reduced from 12px */\r\n    align-items: center;\r\n}\r\n\r\n.animation-select {\r\n    flex: 1;\r\n    min-width: 0;\r\n    padding: 4px 8px; /* Reduced from 6px 8px */\r\n    background: #1a1a1a;\r\n    border: 1px solid rgba(255, 255, 255, 0.1);\r\n    border-radius: var(--radius-sm);\r\n    color: #e0e0e0;\r\n    font-size: 11px; /* Reduced from 12px */\r\n    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;\r\n    cursor: pointer;\r\n    outline: none;\r\n}\r\n\r\n.animation-select:hover {\r\n    border-color: rgba(255, 255, 255, 0.2);\r\n    background: #1d1d1d;\r\n}\r\n\r\n.animation-select:focus {\r\n    border-color: var(--accent-color);\r\n    box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);\r\n}\r\n\r\n.animation-select:disabled {\r\n    opacity: 0.5;\r\n    cursor: not-allowed;\r\n}\r\n\r\n.animation-info-inline {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 1px; /* Reduced from 2px */\r\n    min-width: 100px; /* Reduced from 120px */\r\n    text-align: right;\r\n}\r\n\r\n.animation-name {\r\n    font-size: 11px; /* Reduced from 12px */\r\n    font-weight: 600;\r\n    color: var(--text-primary);\r\n    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n    white-space: nowrap;\r\n}\r\n\r\n.animation-duration {\r\n    font-size: 9px; /* Reduced from 10px */\r\n    color: var(--text-muted);\r\n    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;\r\n}\r\n\r\n/* Playback Controls - RESTORED STYLING */\r\n.playback-controls {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 8px; /* Reduced from 10px */\r\n    padding: 6px; /* Reduced from 8px */\r\n    background: var(--bg-secondary);\r\n    border-radius: var(--radius-sm); /* Smaller radius */\r\n}\r\n\r\n.control-buttons {\r\n    display: flex;\r\n    gap: 6px; /* Reduced from 8px */\r\n    align-items: center;\r\n}\r\n\r\n.control-btn {\r\n    width: 28px; /* Reduced from 32px */\r\n    height: 28px; /* Reduced from 32px */\r\n    padding: 0;\r\n    background: #1a1a1a;\r\n    border: 1px solid rgba(255, 255, 255, 0.1);\r\n    border-radius: var(--radius-sm);\r\n    color: #e0e0e0;\r\n    font-size: 14px; /* Reduced from 16px */\r\n    cursor: pointer;\r\n    transition: all 0.2s;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    outline: none;\r\n}\r\n\r\n.control-btn:hover:not(:disabled) {\r\n    background: #1d1d1d;\r\n    border-color: var(--accent-color);\r\n    transform: scale(1.05);\r\n}\r\n\r\n.control-btn:active:not(:disabled) {\r\n    transform: scale(0.95);\r\n}\r\n\r\n.control-btn:focus:not(:disabled) {\r\n    border-color: var(--accent-color);\r\n    box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);\r\n}\r\n\r\n.control-btn:disabled {\r\n    opacity: 0.3;\r\n    cursor: not-allowed;\r\n}\r\n\r\n.control-btn.active {\r\n    background: rgba(76, 175, 80, 0.2);\r\n    border-color: var(--accent-color);\r\n    color: var(--accent-color);\r\n}\r\n\r\n.speed-control {\r\n    margin-left: auto;\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 4px; /* Reduced from 6px */\r\n}\r\n\r\n.speed-control label {\r\n    font-size: 10px; /* Reduced from 11px */\r\n    color: var(--text-secondary);\r\n    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;\r\n}\r\n\r\n.speed-select {\r\n    padding: 3px 6px; /* Reduced from 4px 6px */\r\n    background: #1a1a1a;\r\n    border: 1px solid rgba(255, 255, 255, 0.1);\r\n    border-radius: var(--radius-sm);\r\n    color: #e0e0e0;\r\n    font-size: 10px; /* Reduced from 11px */\r\n    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;\r\n    cursor: pointer;\r\n    outline: none;\r\n}\r\n\r\n.speed-select:focus {\r\n    border-color: var(--accent-color);\r\n    box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);\r\n}\r\n\r\n/* Timeline - RESTORED STYLING */\r\n.timeline-container {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 4px; /* Reduced from 6px */\r\n}\r\n\r\n.time-display {\r\n    display: flex;\r\n    justify-content: center;\r\n    font-size: 10px; /* Reduced from 11px */\r\n    color: var(--text-secondary);\r\n    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;\r\n}\r\n\r\n.timeline {\r\n    position: relative;\r\n    height: 20px; /* Reduced from 24px */\r\n    background: #1a1a1a;\r\n    border: 1px solid rgba(255, 255, 255, 0.1);\r\n    border-radius: 10px; /* Adjusted for smaller height */\r\n    overflow: hidden;\r\n}\r\n\r\n.time-slider {\r\n    position: relative;\r\n    width: 100%;\r\n    height: 100%;\r\n    -webkit-appearance: none;\r\n    appearance: none;\r\n    background: transparent;\r\n    cursor: pointer;\r\n    z-index: 2;\r\n    outline: none;\r\n}\r\n\r\n.time-slider::-webkit-slider-thumb {\r\n    width: 14px; /* Reduced from 16px */\r\n    height: 14px; /* Reduced from 16px */\r\n    background: var(--accent-color);\r\n    border-radius: 50%;\r\n    cursor: pointer;\r\n    border: 2px solid white;\r\n    box-shadow: 0 2px 4px rgba(0,0,0,0.3);\r\n}\r\n\r\n.time-slider::-moz-range-thumb {\r\n    width: 14px; /* Reduced from 16px */\r\n    height: 14px; /* Reduced from 16px */\r\n    background: var(--accent-color);\r\n    border-radius: 50%;\r\n    cursor: pointer;\r\n    border: 2px solid white;\r\n    box-shadow: 0 2px 4px rgba(0,0,0,0.3);\r\n}\r\n\r\n.timeline-progress {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    height: 100%;\r\n    background: linear-gradient(90deg, var(--accent-color), var(--accent-light));\r\n    border-radius: 12px;\r\n    transition: width 0.1s;\r\n    pointer-events: none;\r\n}\r\n\r\n/* Animation List with Working Scrolling */\r\n.animation-list {\r\n    flex: 1;\r\n    display: flex;\r\n    flex-direction: column;\r\n    background: var(--bg-secondary);\r\n    border-radius: var(--radius-sm);\r\n    overflow: hidden;\r\n    min-height: 100px; /* Reduced from 120px */\r\n    /* Remove max-height to allow it to grow */\r\n}\r\n\r\n.list-header {\r\n    padding: 6px 10px; /* Reduced from 8px 12px */\r\n    background: #1a1a1a;\r\n    border-bottom: 1px solid var(--border-color);\r\n    font-size: 10px; /* Reduced from 11px */\r\n    font-weight: 600;\r\n    color: var(--text-secondary);\r\n    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;\r\n    text-transform: uppercase;\r\n    letter-spacing: 0.5px;\r\n    flex-shrink: 0;\r\n}\r\n\r\n.list-content {\r\n    flex: 1;\r\n    overflow-y: auto;\r\n    overflow-x: hidden;\r\n    padding: 2px; /* Reduced from 4px */\r\n    min-height: 0;\r\n    /* Remove max-height to allow natural growth */\r\n}\r\n\r\n/* Working Scrollbar Styling */\r\n.list-content {\r\n    scrollbar-width: thin;\r\n    scrollbar-color: #4CAF50 #2a2a2a;\r\n}\r\n\r\n.list-content::-webkit-scrollbar {\r\n    width: 8px; /* Reduced from 12px */\r\n    background: #0a0a0a;\r\n}\r\n\r\n.list-content::-webkit-scrollbar-track {\r\n    background: #1a1a1a;\r\n    border-radius: 4px;\r\n    margin: 1px;\r\n}\r\n\r\n.list-content::-webkit-scrollbar-thumb {\r\n    background: #4CAF50;\r\n    border-radius: 4px;\r\n    border: 1px solid #1a1a1a; /* Reduced from 2px */\r\n    min-height: 20px;\r\n}\r\n\r\n.list-content::-webkit-scrollbar-thumb:hover {\r\n    background: #66BB6A;\r\n}\r\n\r\n.list-content::-webkit-scrollbar-thumb:active {\r\n    background: #388E3C;\r\n}\r\n\r\n/* Animation Items - RESTORED STYLING */\r\n.animation-item {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 6px; /* Reduced from 8px */\r\n    padding: 4px 6px; /* Reduced from 6px 8px */\r\n    margin-bottom: 1px; /* Reduced from 2px */\r\n    margin-right: 2px; /* Reduced from 4px */\r\n    background: #1a1a1a;\r\n    border: 1px solid transparent;\r\n    border-radius: var(--radius-sm);\r\n    cursor: pointer;\r\n    transition: all 0.2s;\r\n}\r\n\r\n.animation-item:hover {\r\n    background: #1d1d1d;\r\n    border-color: rgba(255, 255, 255, 0.1);\r\n    transform: translateX(2px);\r\n}\r\n\r\n.animation-item.active {\r\n    background: rgba(76, 175, 80, 0.15);\r\n    border-left: 3px solid var(--accent-color);\r\n    border-color: rgba(76, 175, 80, 0.3);\r\n}\r\n\r\n.anim-icon {\r\n    font-size: 12px; /* Reduced from 14px */\r\n    filter: drop-shadow(0 1px 1px rgba(0,0,0,0.3));\r\n    flex-shrink: 0;\r\n}\r\n\r\n.anim-name {\r\n    flex: 1;\r\n    font-size: 10px; /* Reduced from 11px */\r\n    color: #e0e0e0;\r\n    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n    white-space: nowrap;\r\n    min-width: 0;\r\n}\r\n\r\n.anim-duration {\r\n    font-size: 9px; /* Reduced from 10px */\r\n    color: var(--text-muted);\r\n    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;\r\n    flex-shrink: 0;\r\n}\r\n\r\n.empty-state {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    padding: 16px; /* Reduced from 24px */\r\n    color: var(--text-muted);\r\n    font-size: 10px; /* Reduced from 11px */\r\n    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;\r\n    text-align: center;\r\n}\r\n\r\n/* Responsive adjustments */\r\n@media (max-height: 600px) {\r\n    .animation-list {\r\n        min-height: 80px;\r\n    }\r\n    \r\n    .animation-controls {\r\n        gap: 8px;\r\n        padding: 8px;\r\n    }\r\n}",
      "texture": "/* FILE: editor/z3d-object-editor/templates/styles/texture.css */\r\n/* Texture Viewer Styles */\r\n\r\n.texture-controls {\r\n    display: flex;\r\n    flex-direction: column;\r\n    height: 100%;\r\n    padding: 8px; /* Reduced from 12px */\r\n    gap: 8px; /* Reduced from 12px */\r\n    background: var(--bg-tertiary);\r\n}\r\n\r\n/* Compact Texture Header - side by side layout */\r\n.texture-header {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 8px;\r\n    padding-bottom: 6px;\r\n    border-bottom: 1px solid var(--border-color);\r\n}\r\n\r\n.texture-select {\r\n    flex: 0 0 140px; /* Fixed width for select */\r\n    padding: 4px 8px;\r\n    background: var(--bg-primary);\r\n    border: 1px solid var(--border-color);\r\n    border-radius: var(--radius-sm);\r\n    color: var(--text-primary);\r\n    font-size: 11px;\r\n    cursor: pointer;\r\n}\r\n\r\n.texture-select:disabled {\r\n    opacity: 0.5;\r\n    cursor: not-allowed;\r\n}\r\n\r\n.texture-info {\r\n    flex: 1;\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 2px;\r\n    min-width: 0; /* Allow text truncation */\r\n}\r\n\r\n.texture-name {\r\n    font-size: 12px;\r\n    font-weight: 600;\r\n    color: var(--text-primary);\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n    white-space: nowrap;\r\n}\r\n\r\n.texture-stats {\r\n    display: flex;\r\n    gap: 8px;\r\n    font-size: 10px;\r\n    color: var(--text-muted);\r\n}\r\n\r\n.texture-format,\r\n.texture-dimensions,\r\n.texture-size {\r\n    font-family: monospace;\r\n    white-space: nowrap;\r\n}\r\n\r\n.texture-format {\r\n    color: var(--accent-color);\r\n}\r\n\r\n/* Texture Viewer */\r\n.texture-viewer {\r\n    flex: 1;\r\n    display: flex;\r\n    flex-direction: column;\r\n    background: var(--bg-secondary);\r\n    border-radius: var(--radius-md);\r\n    overflow: hidden;\r\n}\r\n\r\n.viewer-controls {\r\n    display: flex;\r\n    gap: 8px;\r\n    align-items: center;\r\n    padding: 8px;\r\n    background: var(--bg-primary);\r\n    border-bottom: 1px solid var(--border-color);\r\n}\r\n\r\n.zoom-btn {\r\n    padding: 4px 8px;\r\n    background: var(--bg-secondary);\r\n    border: 1px solid var(--border-color);\r\n    border-radius: var(--radius-sm);\r\n    color: var(--text-primary);\r\n    font-size: 12px;\r\n    cursor: pointer;\r\n    transition: all 0.2s;\r\n}\r\n\r\n/* Pixel mode button active state */\r\n.zoom-btn.active {\r\n    background: rgba(76, 175, 80, 0.2);\r\n    border-color: var(--accent-color);\r\n    color: var(--accent-color);\r\n}\r\n\r\n.zoom-btn:hover {\r\n    background: var(--bg-hover);\r\n    border-color: var(--accent-color);\r\n}\r\n\r\n/* Remove persistent focus outline on buttons */\r\n.zoom-btn:focus {\r\n    outline: none;\r\n}\r\n\r\n/* Optional: Add a brief focus indication that fades */\r\n.zoom-btn:focus-visible {\r\n    outline: 2px solid var(--accent-color);\r\n    outline-offset: 2px;\r\n    animation: fadeOutline 0.5s ease-out forwards;\r\n}\r\n\r\n@keyframes fadeOutline {\r\n    0% {\r\n        outline-color: var(--accent-color);\r\n        outline-offset: 2px;\r\n    }\r\n    100% {\r\n        outline-color: transparent;\r\n        outline-offset: 4px;\r\n    }\r\n}\r\n\r\n.zoom-level {\r\n    margin-left: auto;\r\n    padding: 4px 8px;\r\n    background: var(--bg-primary);\r\n    border-radius: var(--radius-sm);\r\n    font-size: 11px;\r\n    font-family: monospace;\r\n    color: var(--text-secondary);\r\n}\r\n\r\n.canvas-container {\r\n    flex: 1;\r\n    position: relative;\r\n    overflow: hidden;\r\n    background-image: \r\n        repeating-conic-gradient(#1a1a1a 0% 25%, #242424 0% 50%) \r\n        50% / 20px 20px;\r\n}\r\n\r\n.texture-canvas {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    cursor: grab;\r\n    /* Removed pixelated rendering - now controlled by .pixel-art class */\r\n}\r\n\r\n/* Pixel art rendering mode - only when toggled on */\r\n.texture-canvas.pixel-art {\r\n    image-rendering: pixelated;\r\n    image-rendering: -moz-crisp-edges;\r\n    image-rendering: crisp-edges;\r\n}\r\n\r\n.texture-canvas:active {\r\n    cursor: grabbing;\r\n}\r\n\r\n.texture-placeholder {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    justify-content: center;\r\n    gap: 12px;\r\n    color: var(--text-muted);\r\n    font-size: 12px;\r\n    background: var(--bg-primary);\r\n}\r\n\r\n.texture-placeholder span:first-child {\r\n    font-size: 32px;\r\n    opacity: 0.5;\r\n}\r\n\r\n/* Texture List */\r\n.texture-list {\r\n    display: flex;\r\n    flex-direction: column;\r\n    background: var(--bg-secondary);\r\n    border-radius: var(--radius-md);\r\n    overflow: hidden;\r\n    max-height: 200px;\r\n}\r\n\r\n.list-header {\r\n    padding: 8px 12px;\r\n    background: var(--bg-primary);\r\n    border-bottom: 1px solid var(--border-color);\r\n    font-size: 11px;\r\n    font-weight: 600;\r\n    color: var(--text-secondary);\r\n    text-transform: uppercase;\r\n    letter-spacing: 0.5px;\r\n}\r\n\r\n.list-content {\r\n    flex: 1;\r\n    overflow-y: auto;\r\n    padding: 4px;\r\n}\r\n\r\n.texture-item {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 8px;\r\n    padding: 6px 8px;\r\n    margin-bottom: 2px;\r\n    background: var(--bg-primary);\r\n    border-radius: var(--radius-sm);\r\n    cursor: pointer;\r\n    transition: all 0.2s;\r\n}\r\n\r\n.texture-item:hover {\r\n    background: var(--bg-hover);\r\n    transform: translateX(2px);\r\n}\r\n\r\n.texture-item.active {\r\n    background: rgba(76, 175, 80, 0.2);\r\n    border-left: 3px solid var(--accent-color);\r\n}\r\n\r\n.tex-icon {\r\n    font-size: 14px;\r\n    filter: drop-shadow(0 1px 1px rgba(0,0,0,0.3));\r\n}\r\n\r\n.tex-name {\r\n    flex: 1;\r\n    font-size: 11px;\r\n    color: var(--text-primary);\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n    white-space: nowrap;\r\n}\r\n\r\n.tex-info {\r\n    font-size: 10px;\r\n    color: var(--text-muted);\r\n    font-family: monospace;\r\n}\r\n\r\n.tex-type {\r\n    font-size: 9px;\r\n    padding: 2px 4px;\r\n    background: var(--bg-secondary);\r\n    border-radius: var(--radius-sm);\r\n    color: var(--accent-color);\r\n    text-transform: uppercase;\r\n}\r\n\r\n.empty-state {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    padding: 24px;\r\n    color: var(--text-muted);\r\n    font-size: 11px;\r\n    text-align: center;\r\n}\r\n\r\n/* Scrollbar */\r\n.list-content::-webkit-scrollbar {\r\n    width: 4px;\r\n}\r\n\r\n.list-content::-webkit-scrollbar-track {\r\n    background: transparent;\r\n}\r\n\r\n.list-content::-webkit-scrollbar-thumb {\r\n    background: var(--border-color);\r\n    border-radius: 2px;\r\n}\r\n\r\n.list-content::-webkit-scrollbar-thumb:hover {\r\n    background: var(--border-light);\r\n}",
      "topbar": "/* FILE: editor/z3d-object-editor/templates/styles/topbar.css */\r\n/* Scene Topbar Styles with Three Container Layout */\r\n\r\n/* Scene Top Bar Container */\r\n.scene-topbar {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    right: 0;\r\n    width: 100%;\r\n    height: 36px;\r\n    background: rgba(37, 37, 37, 0.95);\r\n    backdrop-filter: blur(10px);\r\n    z-index: 1000 !important;\r\n    pointer-events: auto;\r\n    border-bottom: 1px solid var(--border-color);\r\n    box-sizing: border-box;\r\n}\r\n\r\n/* Controls Wrapper - Can be hidden/shown as a group */\r\n.topbar-controls-wrapper {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: space-between;\r\n    height: 100%;\r\n    padding: 0 12px;\r\n    width: 100%;\r\n    box-sizing: border-box;\r\n}\r\n\r\n/* Three Container Layout */\r\n.topbar-left,\r\n.topbar-center,\r\n.topbar-right {\r\n    display: flex;\r\n    align-items: center;\r\n}\r\n\r\n.topbar-left {\r\n    flex: 0 0 auto;\r\n    justify-content: flex-start;\r\n    gap: var(--spacing-xs);\r\n}\r\n\r\n.topbar-center {\r\n    flex: 1 1 auto;\r\n    justify-content: center;\r\n    text-align: center;\r\n    gap: var(--spacing-xs);\r\n}\r\n\r\n.topbar-right {\r\n    flex: 0 0 auto;\r\n    justify-content: flex-end;\r\n    margin-left: auto;\r\n    display: flex;\r\n    gap: 4px;\r\n}\r\n\r\n/* Add spacing between buttons in topbar-right */\r\n.topbar-right > * + * {\r\n    margin-left: 4px;\r\n}\r\n\r\n/* Topbar Buttons */\r\n.topbar-btn {\r\n    display: inline-flex;\r\n    align-items: center;\r\n    gap: 4px;\r\n    padding: 4px 10px;\r\n    background: rgba(255, 255, 255, 0.05);\r\n    border: 1px solid var(--border-color);\r\n    border-radius: var(--radius-sm);\r\n    color: var(--text-secondary);\r\n    font-size: 12px;\r\n    font-weight: 500;\r\n    cursor: pointer;\r\n    transition: all var(--transition-fast);\r\n    white-space: nowrap;\r\n    user-select: none;\r\n}\r\n\r\n.topbar-btn:hover:not(:disabled) {\r\n    background: rgba(255, 255, 255, 0.08);\r\n    border-color: var(--border-light);\r\n    color: var(--text-primary);\r\n}\r\n\r\n/* Remove focus outline and force blur */\r\n.topbar-btn:focus {\r\n    outline: none;\r\n}\r\n\r\n.topbar-btn:focus-visible {\r\n    outline: none;\r\n}\r\n\r\n/* Active state - matches animation control buttons */\r\nbutton.topbar-btn.active,\r\n.topbar-btn.active {\r\n    background: rgba(76, 175, 80, 0.2) !important;\r\n    border: 1px solid #4CAF50 !important;\r\n    color: #4CAF50 !important;\r\n    box-shadow: 0 0 0 1px #4CAF50 !important;\r\n}\r\n\r\nbutton.topbar-btn.active:hover,\r\n.topbar-btn.active:hover {\r\n    background: rgba(76, 175, 80, 0.3) !important;\r\n    border: 1px solid #4CAF50 !important;\r\n    color: #4CAF50 !important;\r\n    box-shadow: 0 0 0 1px #4CAF50 !important;\r\n}\r\n\r\n/* Make icon and text inherit color */\r\nbutton.topbar-btn.active .btn-icon,\r\nbutton.topbar-btn.active .btn-text,\r\n.topbar-btn.active .btn-icon,\r\n.topbar-btn.active .btn-text {\r\n    color: #4CAF50 !important;\r\n}\r\n\r\n.topbar-btn:disabled {\r\n    opacity: 0.3;\r\n    cursor: not-allowed;\r\n}\r\n\r\n.topbar-btn .btn-icon {\r\n    font-size: 14px;\r\n    line-height: 1;\r\n}\r\n\r\n.topbar-btn .btn-text {\r\n    font-size: 11px;\r\n    text-transform: uppercase;\r\n    letter-spacing: 0.5px;\r\n}\r\n\r\n/* Click feedback animation */\r\n.topbar-btn:active {\r\n    transform: scale(0.95);\r\n}\r\n\r\n.topbar-btn.clicked {\r\n    animation: buttonClick 0.3s ease-out;\r\n}\r\n\r\n@keyframes buttonClick {\r\n    0% {\r\n        box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.5);\r\n    }\r\n    100% {\r\n        box-shadow: 0 0 0 4px rgba(76, 175, 80, 0);\r\n    }\r\n}\r\n\r\n/* Stats Overlay Styles */\r\n.stats-overlay {\r\n    position: absolute;\r\n    top: 50px;\r\n    left: 10px;\r\n    background: rgba(30, 30, 30, 0.95);\r\n    backdrop-filter: blur(10px);\r\n    border: 1px solid var(--border-color);\r\n    border-radius: var(--radius-md);\r\n    padding: 0;\r\n    z-index: 110;\r\n    pointer-events: none;\r\n    user-select: none;\r\n    min-width: 180px;\r\n    box-shadow: var(--shadow-medium);\r\n    display: none; /* Hidden by default */\r\n}\r\n\r\n.stats-overlay.visible {\r\n    display: block;\r\n}\r\n\r\n.stats-header {\r\n    padding: 8px 12px;\r\n    background: var(--bg-secondary);\r\n    border-bottom: 1px solid var(--border-color);\r\n    border-radius: var(--radius-md) var(--radius-md) 0 0;\r\n    font-size: 11px;\r\n    font-weight: 600;\r\n    text-transform: uppercase;\r\n    letter-spacing: 0.5px;\r\n    color: var(--text-secondary);\r\n}\r\n\r\n.stats-content {\r\n    padding: 8px;\r\n}\r\n\r\n.stats-section {\r\n    padding: 4px 0;\r\n    border-bottom: 1px solid rgba(255, 255, 255, 0.05);\r\n}\r\n\r\n.stats-section:last-child {\r\n    border-bottom: none;\r\n}\r\n\r\n.stat-row {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    padding: 3px 4px;\r\n    font-size: 11px;\r\n    line-height: 1.3;\r\n}\r\n\r\n.stat-row:hover {\r\n    background: rgba(255, 255, 255, 0.03);\r\n    border-radius: 2px;\r\n}\r\n\r\n.stat-label {\r\n    color: var(--text-muted);\r\n    font-weight: 400;\r\n}\r\n\r\n.stat-value {\r\n    color: var(--text-primary);\r\n    font-weight: 500;\r\n    font-family: 'Consolas', 'Monaco', monospace;\r\n    text-align: right;\r\n}\r\n\r\n/* Special stat value colors */\r\n#stat-fps {\r\n    color: #4CAF50;\r\n}\r\n\r\n#stat-frametime {\r\n    color: #2196F3;\r\n}\r\n\r\n#stat-memory {\r\n    color: #FF9800;\r\n}\r\n\r\n/* Center content styles (for future use) */\r\n.topbar-info {\r\n    font-size: 12px;\r\n    color: var(--text-secondary);\r\n    padding: 4px 12px;\r\n    background: rgba(0, 0, 0, 0.2);\r\n    border-radius: var(--radius-sm);\r\n    white-space: nowrap;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n    max-width: 300px;\r\n}\r\n\r\n/* Responsive adjustments */\r\n@media (max-width: 768px) {\r\n    .topbar-btn .btn-text {\r\n        display: none;\r\n    }\r\n    \r\n    .topbar-btn {\r\n        padding: 4px 8px;\r\n    }\r\n    \r\n    .topbar-controls-wrapper {\r\n        padding: 0 4px;\r\n    }\r\n}"
    },
    "scripts": {
      "core": {
        "eventEmitter": "/* FILE: editor/z3d-object-editor/templates/scripts/core/event-emitter.js */\r\nclass EventEmitter {\r\n    constructor() {\r\n        this.events = {};\r\n    }\r\n    \r\n    on(event, callback) {\r\n        if (!this.events[event]) {\r\n            this.events[event] = [];\r\n        }\r\n        this.events[event].push(callback);\r\n    }\r\n    \r\n    off(event, callback) {\r\n        if (!this.events[event]) return;\r\n        this.events[event] = this.events[event].filter(cb => cb !== callback);\r\n    }\r\n    \r\n    emit(event, data) {\r\n        if (this.events[event]) {\r\n            this.events[event].forEach(callback => {\r\n                try {\r\n                    callback(data);\r\n                } catch (error) {\r\n                    console.error(`Event handler error for '${event}':`, error);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    \r\n    once(event, callback) {\r\n        const wrapper = (data) => {\r\n            callback(data);\r\n            this.off(event, wrapper);\r\n        };\r\n        this.on(event, wrapper);\r\n    }\r\n}",
        "uiManager": "/**\r\n * UI Manager - CLEANED VERSION\r\n * Simplified event handling and message flow\r\n */\r\n\r\nclass UIManager extends EventEmitter {\r\n    constructor(config) {\r\n        super();\r\n        this.config = config;\r\n        this.components = new Map();\r\n        this.isInitialized = false;\r\n        this._sendThrottleMs = 16; // ~60fps\r\n        this._lastSendTime = 0;\r\n    }\r\n    \r\n    async initialize() {\r\n        try {\r\n            await this._initializeComponents();\r\n            this._setupTabSwitching();\r\n            this._setupHelpMenu();\r\n            this._updateUIState();\r\n            \r\n            this.isInitialized = true;\r\n            this.emit('initialized');\r\n            \r\n        } catch (error) {\r\n            console.error('[UIManager] Initialization failed:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    \r\n    async _initializeComponents() {\r\n        const components = [\r\n            { name: 'objectControls', class: ObjectControls, container: 'object-controls' },\r\n            { name: 'viewportControls', class: ViewportControls, container: 'viewport-controls' },\r\n            { name: 'outlinerControls', class: OutlinerControls, container: 'node-tree' },\r\n            { name: 'animationControls', class: AnimationControls, container: 'animation-viewer' },\r\n            { name: 'resizer', class: Resizer, container: null }\r\n        ];\r\n        \r\n        for (const comp of components) {\r\n            try {\r\n                const container = comp.container ? document.getElementById(comp.container) : null;\r\n                if (comp.container && !container) continue;\r\n                \r\n                const instance = new comp.class(this.config);\r\n                await instance.initialize(container);\r\n                this.components.set(comp.name, instance);\r\n                \r\n                // Set on window for global access\r\n                if (comp.name === 'objectControls') {\r\n                    window.objectControls = instance;\r\n                } else if (comp.name === 'viewportControls') {\r\n                    window.viewportControls = instance;\r\n                }\r\n                \r\n                // Setup single event handler per component\r\n                this._setupComponentEvents(comp.name, instance);\r\n                \r\n            } catch (error) {\r\n                console.error(`[UIManager] ${comp.name} failed:`, error);\r\n            }\r\n        }\r\n    }\r\n    \r\n    _setupComponentEvents(name, instance) {\r\n        if (typeof instance.on !== 'function') return;\r\n        \r\n        // Single handler for all transform changes\r\n        instance.on('transforms-changed', (data) => {\r\n            // Only handle if it's from user interaction (source: 'editor')\r\n            if (data.source === 'editor') {\r\n                this._handleTransformsChange(data);\r\n            }\r\n        });\r\n        \r\n        // Settings changes\r\n        instance.on('setting-changed', (data) => {\r\n            if (window.worker) {\r\n                window.worker.postMessage({\r\n                    type: 'UPDATE_VIEWPORT_SETTING',\r\n                    data: data\r\n                });\r\n            }\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Single handler for all transform changes\r\n     */\r\n    _handleTransformsChange(data) {\r\n        const now = Date.now();\r\n        if (now - this._lastSendTime < this._sendThrottleMs) return;\r\n        this._lastSendTime = now;\r\n        \r\n        // Send to worker for rendering\r\n        if (window.worker) {\r\n            window.worker.postMessage({\r\n                type: 'UPDATE_STATE',\r\n                data: {\r\n                    transform: data.transform,\r\n                    deltaTransform: data.deltaTransform\r\n                }\r\n            });\r\n        }\r\n        \r\n        // Send to parent (C3)\r\n        if (window.sendTransformsToParent) {\r\n            window.sendTransformsToParent(data.transform, data.deltaTransform);\r\n        }\r\n    }\r\n    \r\n    _setupTabSwitching() {\r\n        document.querySelectorAll('.tab-btn').forEach(btn => {\r\n            btn.addEventListener('click', (e) => {\r\n                const tabName = e.currentTarget.getAttribute('data-tab');\r\n                if (!tabName) return;\r\n                \r\n                // Update button states\r\n                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));\r\n                e.currentTarget.classList.add('active');\r\n                \r\n                // Update panel visibility\r\n                document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));\r\n                const panel = document.getElementById(`${tabName}-tab`);\r\n                if (panel) panel.classList.add('active');\r\n            });\r\n        });\r\n    }\r\n    \r\n    _setupHelpMenu() {\r\n        const helpBtn = document.getElementById('help-btn');\r\n        const helpDropdown = document.getElementById('help-dropdown');\r\n        \r\n        if (helpBtn && helpDropdown) {\r\n            helpBtn.addEventListener('click', (e) => {\r\n                e.stopPropagation();\r\n                helpDropdown.classList.toggle('show');\r\n            });\r\n            \r\n            document.addEventListener('click', () => {\r\n                helpDropdown.classList.remove('show');\r\n            });\r\n        }\r\n    }\r\n    \r\n    _updateUIState() {\r\n        const infoEl = document.getElementById('instance-info');\r\n        if (infoEl) {\r\n            const instanceId = this.config.instanceId || 0;\r\n            const modelPath = this.config.modelPath || 'No Model';\r\n            infoEl.textContent = `Instance ${instanceId} | ${modelPath.split('/').pop()}`;\r\n        }\r\n        \r\n        const statusEl = document.getElementById('status-message');\r\n        if (statusEl) {\r\n            statusEl.textContent = 'Ready';\r\n        }\r\n    }\r\n    \r\n    getComponent(name) {\r\n        return this.components.get(name);\r\n    }\r\n    \r\n    dispose() {\r\n        this.components.forEach(component => {\r\n            if (typeof component.dispose === 'function') {\r\n                component.dispose();\r\n            }\r\n        });\r\n        this.components.clear();\r\n        this.emit('disposed');\r\n    }\r\n}"
      },
      "components": {
        "objectControls": `/**\r
 * Object Controls - COMPLETE CLEANED VERSION\r
 * All features preserved, single state object, unified event emission\r
 */\r
\r
class ObjectControls extends EventEmitter {\r
    constructor(config) {\r
        super();\r
        this.config = config;\r
        this.livePreview = true;\r
        this._debug = !!(this.config?.debugMode || (typeof window !== 'undefined' && window.Z3D_DEBUG));\r
        this._dlog = (...args) => { if (this._debug) console.log(...args); };\r
        \r
        // UI update coordination\r
        this._isBatching = false;\r
        this._needsUIUpdate = false;\r
        this._uiScheduled = false;\r
        this._lastEmittedTransform = null;\r
        \r
        // Single unified state\r
        // Get default unitScale from config or use 64 as fallback\r
        const defaultUnitScale = this.config?.unitScale || 64;\r
        \r
        this.state = {\r
            transform: {\r
                position: { x: 0, y: 0, z: 0 },\r
                rotation: { x: 0, y: 0, z: 0 },\r
                scale: { x: 1, y: 1, z: 1 },\r
                uniformScale: 1,\r
                unitScale: defaultUnitScale,\r
                rotationOrder: 'ZXY'\r
            },\r
            deltaTransform: {\r
                position: { x: 0, y: 0, z: 0 },\r
                rotation: { x: 0, y: 0, z: 0 },\r
                scale: { x: 1, y: 1, z: 1 }\r
            },\r
            wireframe: false\r
        };\r
        \r
        this.isInitialized = false;\r
        this.collapsedSections = new Set();\r
    }\r
    \r
    async initialize() {\r
        const container = document.getElementById('object-controls');\r
        if (!container) {\r
            throw new Error('Object controls container not found');\r
        }\r
        \r
        container.innerHTML = this._generateHTML();\r
        this._setupEventListeners();\r
        this._updateUI();\r
        \r
        // Initialize drag inputs after controls are created\r
        this.initializeDragInputs();\r
        \r
        this.isInitialized = true;\r
        this._dlog('[ObjectControls] \u2705 Initialized');\r
    }\r
    \r
    initializeDragInputs() {\r
        // Initialize all drag inputs\r
        if (window.initializeDragInputs) {\r
            window.initializeDragInputs();\r
        }\r
        \r
        // Listen for value changes from drag inputs\r
        const container = document.getElementById('object-controls');\r
        if (container) {\r
            container.addEventListener('drag-value-change', (e) => {\r
                const { value, property, isFinal } = e.detail;\r
                \r
                // Debug log for position X\r
                if (property === 'transform.position.x') {\r
                    if (!this._draggingX) {\r
                        this._draggingX = true;\r
                        this._dlog('[ObjectControls][X] Drag START: value =', value);\r
                    }\r
                    this._dlog('[ObjectControls][X] Drag UPDATE: value =', value);\r
                }\r
                \r
                // Always update on drag/typing\r
                this._handlePropertyChange(property, value);\r
                \r
                // Reset drag flag when done\r
                if (isFinal && property === 'transform.position.x') {\r
                    this._draggingX = false;\r
                    this._dlog('[ObjectControls][X] Drag END: value =', value);\r
                }\r
            });\r
        }\r
        \r
        this._dlog('[ObjectControls] Drag inputs initialized');\r
    }\r
    \r
    _generateHTML() {\r
        return \`\r
        <div class="object-controls compact-layout">\r
            <!-- Transform Section -->\r
            <div class="collapsible-section" data-section="transform">\r
                <div class="section-header" data-toggle="transform">\r
                    <span class="collapse-icon">\u25BE</span>\r
                    <span class="section-title">Transform</span>\r
                </div>\r
                <div class="section-content" id="transform-content">\r
                    <!-- Position Vector -->\r
                    <div class="vector-controls position-group">\r
                        <div class="vector-row">\r
                            <label>Position X</label>\r
                            <input type="number" id="pos-x" step="1" class="drag-input" data-prop="transform.position.x">\r
                            <span class="unit-spacer"></span>\r
                        </div>\r
                        <div class="vector-row">\r
                            <label>Y</label>\r
                            <input type="number" id="pos-y" step="1" class="drag-input" data-prop="transform.position.y">\r
                            <span class="unit-spacer"></span>\r
                        </div>\r
                        <div class="vector-row">\r
                            <label>Z</label>\r
                            <input type="number" id="pos-z" step="1" class="drag-input" data-prop="transform.position.z">\r
                            <span class="unit-spacer"></span>\r
                        </div>\r
                    </div>\r
                    <!-- Rotation Vector -->\r
                    <div class="vector-controls rotation-group">\r
                        <div class="vector-row">\r
                            <label>Rotation X</label>\r
                            <input type="number" id="rot-x" step="1" min="0" max="360" class="drag-input" data-prop="transform.rotation.x">\r
                            <span class="unit">\xB0</span>\r
                        </div>\r
                        <div class="vector-row">\r
                            <label>Y</label>\r
                            <input type="number" id="rot-y" step="1" min="0" max="360" class="drag-input" data-prop="transform.rotation.y">\r
                            <span class="unit">\xB0</span>\r
                        </div>\r
                        <div class="vector-row">\r
                            <label>Z</label>\r
                            <input type="number" id="rot-z" step="1" min="0" max="360" class="drag-input" data-prop="transform.rotation.z">\r
                            <span class="unit">\xB0</span>\r
                        </div>\r
                    </div>\r
                    <!-- Scale Scalar + Vector -->\r
                    <div class="scalar-controls">\r
                        <div class="control-row inline field-row">\r
                            <label>Unit Scale</label>\r
                            <input type="number" id="unit-scale" step="1" min="1" class="drag-input" data-prop="transform.unitScale">\r
                            <span class="unit-spacer"></span>\r
                        </div>\r
                        <div class="control-row inline field-row">\r
                            <label>Scale</label>\r
                            <input type="number" id="master-scale" step="0.1" min="0.01" class="drag-input" data-prop="transform.uniformScale">\r
                            <span class="unit-spacer"></span>\r
                        </div>\r
                    </div>\r
                    <div class="vector-controls scale-vector-group">\r
                        <div class="vector-row">\r
                            <label>Scale X</label>\r
                            <input type="number" id="scale-x" step="0.1" min="0.01" class="drag-input" data-prop="transform.scale.x">\r
                            <span class="unit-spacer"></span>\r
                        </div>\r
                        <div class="vector-row">\r
                            <label>Y</label>\r
                            <input type="number" id="scale-y" step="0.1" min="0.01" class="drag-input" data-prop="transform.scale.y">\r
                            <span class="unit-spacer"></span>\r
                        </div>\r
                        <div class="vector-row">\r
                            <label>Z</label>\r
                            <input type="number" id="scale-z" step="0.1" min="0.01" class="drag-input" data-prop="transform.scale.z">\r
                            <span class="unit-spacer"></span>\r
                        </div>\r
                    </div>\r
                    <div class="control-row inline field-row">\r
                        <label>Rotation Order</label>\r
                        <select id="rotation-order" data-prop="transform.rotationOrder">\r
                            <option value="XYZ">XYZ Euler</option>\r
                            <option value="XZY">XZY Euler</option>\r
                            <option value="YXZ">YXZ Euler</option>\r
                            <option value="YZX">YZX Euler</option>\r
                            <option value="ZXY">ZXY Euler</option>\r
                            <option value="ZYX">ZYX Euler</option>\r
                        </select>\r
                        <span class="unit-spacer"></span>\r
                    </div>\r
                </div>\r
            </div>\r
            <!-- Delta Transform Section -->\r
            <div class="collapsible-section" data-section="delta-transform">\r
                <div class="section-header" data-toggle="delta-transform">\r
                    <span class="collapse-icon">\u25BE</span>\r
                    <span class="section-title">Delta Transform</span>\r
                </div>\r
                <div class="section-content" id="delta-transform-content">\r
                    <!-- Delta Position Vector -->\r
                    <div class="vector-controls delta-position-group">\r
                        <div class="vector-row">\r
                            <label>Position X</label>\r
                            <input type="number" id="delta-pos-x" step="0.1" class="drag-input" data-prop="deltaTransform.position.x">\r
                            <span class="unit-spacer"></span>\r
                        </div>\r
                        <div class="vector-row">\r
                            <label>Y</label>\r
                            <input type="number" id="delta-pos-y" step="0.1" class="drag-input" data-prop="deltaTransform.position.y">\r
                            <span class="unit-spacer"></span>\r
                        </div>\r
                        <div class="vector-row">\r
                            <label>Z</label>\r
                            <input type="number" id="delta-pos-z" step="0.1" class="drag-input" data-prop="deltaTransform.position.z">\r
                            <span class="unit-spacer"></span>\r
                        </div>\r
                    </div>\r
                    <!-- Delta Rotation Vector -->\r
                    <div class="vector-controls delta-rotation-group">\r
                        <div class="vector-row">\r
                            <label>Rotation X</label>\r
                            <input type="number" id="delta-rot-x" step="1" class="drag-input" data-prop="deltaTransform.rotation.x">\r
                            <span class="unit">\xB0</span>\r
                        </div>\r
                        <div class="vector-row">\r
                            <label>Y</label>\r
                            <input type="number" id="delta-rot-y" step="1" class="drag-input" data-prop="deltaTransform.rotation.y">\r
                            <span class="unit">\xB0</span>\r
                        </div>\r
                        <div class="vector-row">\r
                            <label>Z</label>\r
                            <input type="number" id="delta-rot-z" step="1" class="drag-input" data-prop="deltaTransform.rotation.z">\r
                            <span class="unit">\xB0</span>\r
                        </div>\r
                    </div>\r
                    <!-- Delta Scale Vector -->\r
                    <div class="vector-controls delta-scale-vector-group">\r
                        <div class="vector-row">\r
                            <label>Scale X</label>\r
                            <input type="number" id="delta-scale-x" step="0.1" min="0.01" class="drag-input" data-prop="deltaTransform.scale.x">\r
                            <span class="unit-spacer"></span>\r
                        </div>\r
                        <div class="vector-row">\r
                            <label>Y</label>\r
                            <input type="number" id="delta-scale-y" step="0.1" min="0.01" class="drag-input" data-prop="deltaTransform.scale.y">\r
                            <span class="unit-spacer"></span>\r
                        </div>\r
                        <div class="vector-row">\r
                            <label>Z</label>\r
                            <input type="number" id="delta-scale-z" step="0.1" min="0.01" class="drag-input" data-prop="deltaTransform.scale.z">\r
                            <span class="unit-spacer"></span>\r
                        </div>\r
                    </div>\r
                </div>\r
            </div>\r
        </div>\`;\r
    }\r
    \r
    _setupEventListeners() {\r
        // Section collapse/expand toggles\r
        document.querySelectorAll('.section-header[data-toggle]').forEach(header => {\r
            header.addEventListener('click', (e) => {\r
                const section = e.currentTarget.dataset.toggle;\r
                this._toggleSection(section);\r
            });\r
        });\r
        \r
        // Select change handlers\r
        document.querySelectorAll('select[data-prop]').forEach(select => {\r
            select.addEventListener('change', (e) => {\r
                this._handlePropertyChange(e.target.dataset.prop, e.target.value);\r
            });\r
        });\r
        \r
        // Checkbox change handlers\r
        document.querySelectorAll('input[type="checkbox"][data-prop]').forEach(checkbox => {\r
            checkbox.addEventListener('change', (e) => {\r
                this._handlePropertyChange(e.target.dataset.prop, e.target.checked);\r
            });\r
        });\r
    }\r
    \r
    _toggleSection(sectionName) {\r
        const section = document.querySelector(\`[data-section="\${sectionName}"]\`);\r
        const content = document.getElementById(\`\${sectionName}-content\`);\r
        const icon = section.querySelector('.collapse-icon');\r
        \r
        if (this.collapsedSections.has(sectionName)) {\r
            // Expand\r
            this.collapsedSections.delete(sectionName);\r
            content.style.display = 'block';\r
            icon.textContent = '\u25BE';\r
            section.classList.remove('collapsed');\r
        } else {\r
            // Collapse\r
            this.collapsedSections.add(sectionName);\r
            content.style.display = 'none';\r
            icon.textContent = '\u25B6';\r
            section.classList.add('collapsed');\r
        }\r
    }\r
    \r
    _handlePropertyChange(propPath, value) {\r
        // Try to parse as number for known numeric properties\r
        const numericProps = new Set([\r
            'transform.position.x', 'transform.position.y', 'transform.position.z',\r
            'transform.rotation.x', 'transform.rotation.y', 'transform.rotation.z',\r
            'transform.unitScale', 'transform.uniformScale', \r
            'transform.scale.x', 'transform.scale.y', 'transform.scale.z',\r
            'deltaTransform.position.x', 'deltaTransform.position.y', 'deltaTransform.position.z',\r
            'deltaTransform.rotation.x', 'deltaTransform.rotation.y', 'deltaTransform.rotation.z',\r
            'deltaTransform.scale.x', 'deltaTransform.scale.y', 'deltaTransform.scale.z'\r
        ]);\r
        \r
        let parsedValue = value;\r
        if (numericProps.has(propPath)) {\r
            parsedValue = parseFloat(value);\r
            if (isNaN(parsedValue)) parsedValue = 0;\r
        }\r
        \r
        // Debug log for non-position properties\r
        if (!propPath.includes('position')) {\r
            this._dlog(\`[ObjectControls] Property changed: \${propPath} = \${parsedValue}\`);\r
        }\r
        \r
        // Update internal state\r
        this._setNestedProperty(this.state, propPath, parsedValue);\r
        \r
        // Update UI\r
        this._updateUI();\r
        \r
        // Emit unified event with both transforms\r
        this._emitTransformsChange();\r
    }\r
    \r
    _setNestedProperty(obj, path, value) {\r
        const parts = path.split('.');\r
        let current = obj;\r
        \r
        for (let i = 0; i < parts.length - 1; i++) {\r
            if (!current[parts[i]]) {\r
                current[parts[i]] = {};\r
            }\r
            current = current[parts[i]];\r
        }\r
        \r
        current[parts[parts.length - 1]] = value;\r
    }\r
    \r
    _emitTransformsChange() {\r
        // Calculate final transform for debugging\r
        const finalTransform = this._calculateFinalTransform();\r
        \r
        this._dlog('[ObjectControls] \u{1F4CA} Base transform:', this.state.transform);\r
        this._dlog('[ObjectControls] \u{1F4CA} Delta transform:', this.state.deltaTransform);\r
        this._dlog('[ObjectControls] \u{1F4CA} Final transform (with deltas):', finalTransform);\r
        \r
        // Emit single event with both transforms\r
        this.emit('transforms-changed', {\r
            transform: this.state.transform,\r
            deltaTransform: this.state.deltaTransform,\r
            source: 'editor'\r
        });\r
        \r
        // Store last emitted for echo suppression\r
        this._lastEmittedTransform = {\r
            transform: { ...this.state.transform },\r
            deltaTransform: { ...this.state.deltaTransform }\r
        };\r
    }\r
    \r
    // Calculate final transform values (for debugging/preview)\r
    _calculateFinalTransform() {\r
        const t = this.state.transform;\r
        const dt = this.state.deltaTransform;\r
        \r
        // Position: base + delta\r
        const finalPosition = {\r
            x: t.position.x + dt.position.x,\r
            y: t.position.y + dt.position.y,\r
            z: t.position.z + dt.position.z\r
        };\r
        \r
        // Rotation: base + delta\r
        const finalRotation = {\r
            x: t.rotation.x + dt.rotation.x,\r
            y: t.rotation.y + dt.rotation.y,\r
            z: t.rotation.z + dt.rotation.z\r
        };\r
        \r
        // Scale: base * delta\r
        const finalScale = {\r
            x: t.uniformScale * t.scale.x * dt.scale.x,\r
            y: t.uniformScale * t.scale.y * dt.scale.y,\r
            z: t.uniformScale * t.scale.z * dt.scale.z\r
        };\r
        \r
        return {\r
            position: finalPosition,\r
            rotation: finalRotation,\r
            scale: finalScale,\r
            rotationOrder: t.rotationOrder,\r
            unitScale: t.unitScale\r
        };\r
    }\r
    \r
    _updateUI() {\r
        // Coalesce UI work per-frame\r
        if (this._isBatching) {\r
            this._needsUIUpdate = true;\r
            return;\r
        }\r
        this._scheduleUIUpdate();\r
    }\r
    \r
    _scheduleUIUpdate() {\r
        if (this._uiScheduled) return;\r
        \r
        this._uiScheduled = true;\r
        requestAnimationFrame(() => {\r
            this._uiScheduled = false;\r
            this._renderUI();\r
        });\r
    }\r
    \r
    _renderUI() {\r
        // Update all input values from current state\r
        \r
        // Transform inputs\r
        this._updateInputValue('pos-x', this.state.transform.position.x);\r
        this._updateInputValue('pos-y', this.state.transform.position.y);\r
        this._updateInputValue('pos-z', this.state.transform.position.z);\r
        \r
        this._updateInputValue('rot-x', this.state.transform.rotation.x);\r
        this._updateInputValue('rot-y', this.state.transform.rotation.y);\r
        this._updateInputValue('rot-z', this.state.transform.rotation.z);\r
        \r
        this._updateInputValue('unit-scale', this.state.transform.unitScale);\r
        this._updateInputValue('master-scale', this.state.transform.uniformScale);\r
        this._updateInputValue('scale-x', this.state.transform.scale.x);\r
        this._updateInputValue('scale-y', this.state.transform.scale.y);\r
        this._updateInputValue('scale-z', this.state.transform.scale.z);\r
        \r
        this._updateSelectValue('rotation-order', this.state.transform.rotationOrder);\r
        \r
        // Delta transform inputs\r
        this._updateInputValue('delta-pos-x', this.state.deltaTransform.position.x);\r
        this._updateInputValue('delta-pos-y', this.state.deltaTransform.position.y);\r
        this._updateInputValue('delta-pos-z', this.state.deltaTransform.position.z);\r
        \r
        this._updateInputValue('delta-rot-x', this.state.deltaTransform.rotation.x);\r
        this._updateInputValue('delta-rot-y', this.state.deltaTransform.rotation.y);\r
        this._updateInputValue('delta-rot-z', this.state.deltaTransform.rotation.z);\r
        \r
        this._updateInputValue('delta-scale-x', this.state.deltaTransform.scale.x);\r
        this._updateInputValue('delta-scale-y', this.state.deltaTransform.scale.y);\r
        this._updateInputValue('delta-scale-z', this.state.deltaTransform.scale.z);\r
    }\r
    \r
    // _updateInputValue(id, value) {\r
    //     const input = document.getElementById(id);\r
    //     if (input && !input.dragHandler?.isTyping) {\r
    //         const newStr = (typeof value === 'number') ? value.toFixed(2) : String(value);\r
    //         if (input.value !== newStr) {\r
    //             input.value = newStr;\r
    //         }\r
    //     }\r
    // }\r
    _updateInputValue(id, value) {\r
        const input = document.getElementById(id);\r
        if (!input) return;\r
        \r
        // Skip update ONLY if user is actively typing in THIS specific input\r
        if (input.dragHandler?.isTyping) {\r
            // User is typing in this field, don't override\r
            return;\r
        }\r
        \r
        // Otherwise always update the value\r
        const newStr = (typeof value === 'number') ? value.toFixed(2) : String(value);\r
        if (input.value !== newStr) {\r
            input.value = newStr;\r
            this._dlog(\`[ObjectControls] \u{1F4DD} Updated \${id}: \${newStr}\`);\r
        }\r
    }\r
    \r
    _updateSelectValue(id, value) {\r
        const select = document.getElementById(id);\r
        if (select && select.value !== String(value)) {\r
            select.value = value;\r
        }\r
    }\r
    \r
    _updateCheckboxValue(id, value) {\r
        const checkbox = document.getElementById(id);\r
        if (checkbox && checkbox.checked !== !!value) {\r
            checkbox.checked = !!value;\r
        }\r
    }\r
    \r
    /**\r
     * Set complete state from parent - MUST UPDATE UI\r
     */\r
    setState(newState) {\r
        this._dlog('[ObjectControls] \u{1F4C4} setState called with:', newState);\r
        \r
        let changed = false;\r
        \r
        // Update transform if provided\r
        if (newState.transform) {\r
            const transformChanged = this._mergeTransformIfChanged(this.state.transform, newState.transform);\r
            changed = changed || transformChanged;\r
        }\r
        \r
        // Update delta transform if provided\r
        if (newState.deltaTransform) {\r
            const deltaChanged = this._mergeDeltaTransformIfChanged(this.state.deltaTransform, newState.deltaTransform);\r
            changed = changed || deltaChanged;\r
        }\r
        \r
        // Update other properties\r
        if (newState.wireframe !== undefined) {\r
            this.state.wireframe = newState.wireframe;\r
            changed = true;\r
        }\r
        \r
        // Update UI but DON'T emit events (this is from parent)\r
        if (changed) {\r
            this._dlog('[ObjectControls] \u2705 State changed from parent, updating UI only');\r
            this._scheduleUIUpdate();\r
            // DON'T call _emitTransformsChange() here\r
        }\r
    }\r
    \r
    setStateAndSync(newState) {\r
        this.setState(newState);\r
        // This one DOES emit to sync with worker\r
        this._emitTransformsChange();\r
    }\r
\r
    // Legacy compatibility methods\r
    setTransform(transform, opts = {}) {\r
        this._dlog('[ObjectControls] \u{1F527} setTransform called');\r
        if (!transform) return false;\r
        \r
        const changed = this._mergeTransformIfChanged(this.state.transform, transform);\r
        if (changed) {\r
            if (!opts.silent) {\r
                this._updateUI();\r
                this._emitTransformsChange();\r
            } else {\r
                this._needsUIUpdate = true;\r
            }\r
        }\r
        return changed;\r
    }\r
    \r
    setDeltaTransform(deltaTransform, opts = {}) {\r
        if (!deltaTransform) return false;\r
        \r
        const changed = this._mergeDeltaTransformIfChanged(this.state.deltaTransform, deltaTransform);\r
        if (changed) {\r
            if (!opts.silent) {\r
                this._updateUI();\r
                this._emitTransformsChange();\r
            } else {\r
                this._needsUIUpdate = true;\r
            }\r
        }\r
        return changed;\r
    }\r
    \r
    // Reset methods\r
    resetAllTransforms() {\r
        // Preserve current unitScale when resetting\r
        const currentUnitScale = this.state.transform.unitScale || this.config?.unitScale || 100;\r
        \r
        this.state.transform = {\r
            position: { x: 0, y: 0, z: 0 },\r
            rotation: { x: 0, y: 0, z: 0 },\r
            scale: { x: 1, y: 1, z: 1 },\r
            uniformScale: 1,\r
            unitScale: currentUnitScale,\r
            rotationOrder: 'ZXY'\r
        };\r
        \r
        this.state.deltaTransform = {\r
            position: { x: 0, y: 0, z: 0 },\r
            rotation: { x: 0, y: 0, z: 0 },\r
            scale: { x: 1, y: 1, z: 1 }\r
        };\r
        \r
        this._updateUI();\r
        this._emitTransformsChange();\r
        this._dlog('[ObjectControls] All transforms reset');\r
    }\r
    \r
    centerToOrigin() {\r
        this.state.transform.position = { x: 0, y: 0, z: 0 };\r
        this.state.deltaTransform.position = { x: 0, y: 0, z: 0 };\r
        \r
        this._updateUI();\r
        this._emitTransformsChange();\r
        this._dlog('[ObjectControls] Centered to origin');\r
    }\r
    \r
    randomizeAll() {\r
        this.state.transform = {\r
            ...this.state.transform,\r
            position: {\r
                x: (Math.random() - 0.5) * 20,\r
                y: (Math.random() - 0.5) * 20,\r
                z: (Math.random() - 0.5) * 20\r
            },\r
            rotation: {\r
                x: Math.random() * 360,\r
                y: Math.random() * 360,\r
                z: Math.random() * 360\r
            },\r
            uniformScale: 0.5 + Math.random() * 2,\r
            scale: {\r
                x: 0.5 + Math.random() * 2,\r
                y: 0.5 + Math.random() * 2,\r
                z: 0.5 + Math.random() * 2\r
            }\r
        };\r
        \r
        this.state.deltaTransform = {\r
            position: {\r
                x: (Math.random() - 0.5) * 10,\r
                y: (Math.random() - 0.5) * 10,\r
                z: (Math.random() - 0.5) * 10\r
            },\r
            rotation: {\r
                x: (Math.random() - 0.5) * 90,\r
                y: (Math.random() - 0.5) * 90,\r
                z: (Math.random() - 0.5) * 90\r
            },\r
            scale: {\r
                x: 0.8 + Math.random() * 0.4,\r
                y: 0.8 + Math.random() * 0.4,\r
                z: 0.8 + Math.random() * 0.4\r
            }\r
        };\r
        \r
        this._updateUI();\r
        this._emitTransformsChange();\r
        this._dlog('[ObjectControls] Randomized all transforms');\r
    }\r
    \r
    getState() {\r
        return {\r
            state: { ...this.state },\r
            collapsedSections: Array.from(this.collapsedSections)\r
        };\r
    }\r
    \r
    // Backward compatibility - keep for now\r
    updateFromParent(data) {\r
        this._dlog('[ObjectControls] \u{1F4C4} updateFromParent called');\r
        this.setState(data);\r
    }\r
    \r
    // Diff/merge utilities\r
    _approxEqual(a, b, eps = 1e-4) {\r
        if (typeof a === 'number' && typeof b === 'number') {\r
            return Math.abs(a - b) <= eps;\r
        }\r
        return a === b;\r
    }\r
    \r
    _mergeTransformIfChanged(target, patch) {\r
        let changed = false;\r
        \r
        if (patch.position) {\r
            const p = patch.position;\r
            if (typeof p.x === 'number' && !this._approxEqual(target.position.x, p.x)) {\r
                target.position.x = p.x;\r
                changed = true;\r
            }\r
            if (typeof p.y === 'number' && !this._approxEqual(target.position.y, p.y)) {\r
                target.position.y = p.y;\r
                changed = true;\r
            }\r
            if (typeof p.z === 'number' && !this._approxEqual(target.position.z, p.z)) {\r
                target.position.z = p.z;\r
                changed = true;\r
            }\r
        }\r
        \r
        if (patch.rotation) {\r
            const r = patch.rotation;\r
            if (typeof r.x === 'number' && !this._approxEqual(target.rotation.x, r.x)) {\r
                target.rotation.x = r.x;\r
                changed = true;\r
            }\r
            if (typeof r.y === 'number' && !this._approxEqual(target.rotation.y, r.y)) {\r
                target.rotation.y = r.y;\r
                changed = true;\r
            }\r
            if (typeof r.z === 'number' && !this._approxEqual(target.rotation.z, r.z)) {\r
                target.rotation.z = r.z;\r
                changed = true;\r
            }\r
        }\r
        \r
        if (patch.scale) {\r
            const s = patch.scale;\r
            if (typeof s.x === 'number' && !this._approxEqual(target.scale.x, s.x)) {\r
                target.scale.x = s.x;\r
                changed = true;\r
            }\r
            if (typeof s.y === 'number' && !this._approxEqual(target.scale.y, s.y)) {\r
                target.scale.y = s.y;\r
                changed = true;\r
            }\r
            if (typeof s.z === 'number' && !this._approxEqual(target.scale.z, s.z)) {\r
                target.scale.z = s.z;\r
                changed = true;\r
            }\r
        }\r
        \r
        if (patch.unitScale !== undefined && !this._approxEqual(target.unitScale, patch.unitScale)) {\r
            target.unitScale = patch.unitScale;\r
            changed = true;\r
        }\r
        \r
        if (patch.uniformScale !== undefined && !this._approxEqual(target.uniformScale, patch.uniformScale)) {\r
            target.uniformScale = patch.uniformScale;\r
            changed = true;\r
        }\r
        \r
        // Handle legacy scaleX/Y/Z format\r
        if (patch.scaleX !== undefined && !this._approxEqual(target.scale.x, patch.scaleX)) {\r
            target.scale.x = patch.scaleX;\r
            changed = true;\r
        }\r
        if (patch.scaleY !== undefined && !this._approxEqual(target.scale.y, patch.scaleY)) {\r
            target.scale.y = patch.scaleY;\r
            changed = true;\r
        }\r
        if (patch.scaleZ !== undefined && !this._approxEqual(target.scale.z, patch.scaleZ)) {\r
            target.scale.z = patch.scaleZ;\r
            changed = true;\r
        }\r
        \r
        if (patch.rotationOrder !== undefined && target.rotationOrder !== patch.rotationOrder) {\r
            target.rotationOrder = patch.rotationOrder;\r
            changed = true;\r
        }\r
        \r
        return changed;\r
    }\r
    \r
    _mergeDeltaTransformIfChanged(target, patch) {\r
        let changed = false;\r
        \r
        if (patch.position) {\r
            const p = patch.position;\r
            if (typeof p.x === 'number' && !this._approxEqual(target.position.x, p.x)) {\r
                target.position.x = p.x;\r
                changed = true;\r
            }\r
            if (typeof p.y === 'number' && !this._approxEqual(target.position.y, p.y)) {\r
                target.position.y = p.y;\r
                changed = true;\r
            }\r
            if (typeof p.z === 'number' && !this._approxEqual(target.position.z, p.z)) {\r
                target.position.z = p.z;\r
                changed = true;\r
            }\r
        }\r
        \r
        if (patch.rotation) {\r
            const r = patch.rotation;\r
            if (typeof r.x === 'number' && !this._approxEqual(target.rotation.x, r.x)) {\r
                target.rotation.x = r.x;\r
                changed = true;\r
            }\r
            if (typeof r.y === 'number' && !this._approxEqual(target.rotation.y, r.y)) {\r
                target.rotation.y = r.y;\r
                changed = true;\r
            }\r
            if (typeof r.z === 'number' && !this._approxEqual(target.rotation.z, r.z)) {\r
                target.rotation.z = r.z;\r
                changed = true;\r
            }\r
        }\r
        \r
        if (patch.scale) {\r
            const s = patch.scale;\r
            if (typeof s.x === 'number' && !this._approxEqual(target.scale.x, s.x)) {\r
                target.scale.x = s.x;\r
                changed = true;\r
            }\r
            if (typeof s.y === 'number' && !this._approxEqual(target.scale.y, s.y)) {\r
                target.scale.y = s.y;\r
                changed = true;\r
            }\r
            if (typeof s.z === 'number' && !this._approxEqual(target.scale.z, s.z)) {\r
                target.scale.z = s.z;\r
                changed = true;\r
            }\r
        }\r
        \r
        // Handle legacy scaleX/Y/Z format\r
        if (patch.scaleX !== undefined && !this._approxEqual(target.scale.x, patch.scaleX)) {\r
            target.scale.x = patch.scaleX;\r
            changed = true;\r
        }\r
        if (patch.scaleY !== undefined && !this._approxEqual(target.scale.y, patch.scaleY)) {\r
            target.scale.y = patch.scaleY;\r
            changed = true;\r
        }\r
        if (patch.scaleZ !== undefined && !this._approxEqual(target.scale.z, patch.scaleZ)) {\r
            target.scale.z = patch.scaleZ;\r
            changed = true;\r
        }\r
        \r
        return changed;\r
    }\r
    \r
    _beginBatch() {\r
        this._isBatching = true;\r
        this._needsUIUpdate = false;\r
    }\r
    \r
    _endBatch() {\r
        this._isBatching = false;\r
        if (this._needsUIUpdate) {\r
            this._needsUIUpdate = false;\r
            this._updateUI();\r
        }\r
    }\r
    \r
    dispose() {\r
        // Clean up drag handlers\r
        const dragInputs = document.querySelectorAll('.drag-input');\r
        dragInputs.forEach(input => {\r
            if (input.dragHandler) {\r
                input.dragHandler.dispose();\r
                delete input.dragHandler;\r
            }\r
        });\r
        \r
        this._dlog('[ObjectControls] Disposed');\r
    }\r
}\r
\r
// DragInputHandler class - KEEP EXACTLY AS IS\r
class DragInputHandler {\r
    constructor(input) {\r
        this.input = input;\r
        this.isDragging = false;\r
        this.startY = 0;\r
        this.startValue = 0;\r
        this.currentValue = 0;\r
        this.hasDraggedOutside = false;\r
        this.pendingValue = null;\r
        this.isTyping = false;\r
        this.hasMovedEnough = false;\r
        this.wasAlreadyFocused = false;\r
        \r
        // Get step value from input or default\r
        this.step = parseFloat(input.getAttribute('step')) || 0.1;\r
        \r
        // Drag sensitivity\r
        this.dragSensitivity = 0.5; // pixels per unit change\r
        \r
        // Bind methods\r
        this.handleMouseDown = this.handleMouseDown.bind(this);\r
        this.handleMouseMove = this.handleMouseMove.bind(this);\r
        this.handleMouseUp = this.handleMouseUp.bind(this);\r
        this.handleKeyDown = this.handleKeyDown.bind(this);\r
        this.handleInput = this.handleInput.bind(this);\r
        this.handleBlur = this.handleBlur.bind(this);\r
        this.handleFocus = this.handleFocus.bind(this);\r
        \r
        this.attachListeners();\r
    }\r
    \r
    attachListeners() {\r
        // Mouse events for dragging\r
        this.input.addEventListener('mousedown', this.handleMouseDown);\r
        \r
        // Keyboard events\r
        this.input.addEventListener('keydown', this.handleKeyDown);\r
        this.input.addEventListener('input', this.handleInput);\r
        this.input.addEventListener('blur', this.handleBlur);\r
        this.input.addEventListener('focus', this.handleFocus);\r
    }\r
    \r
    handleMouseDown(e) {\r
        // Store initial mouse position\r
        this.isDragging = false;\r
        this.hasDraggedOutside = false;\r
        this.startY = e.clientY;\r
        this.startValue = parseFloat(this.input.value) || 0;\r
        this.currentValue = this.startValue;\r
        this.hasMovedEnough = false;\r
        \r
        // If input is already focused, we might be starting a drag\r
        this.wasAlreadyFocused = (this.input === document.activeElement);\r
        \r
        // Add global listeners\r
        document.addEventListener('mousemove', this.handleMouseMove);\r
        document.addEventListener('mouseup', this.handleMouseUp);\r
        \r
        // Prevent text selection drag but allow focus\r
        if (this.wasAlreadyFocused) {\r
            e.preventDefault();\r
        }\r
        \r
        // Notify drag started\r
        window.dispatchEvent(new CustomEvent('z3d-drag-state', { \r
            detail: { dragging: true }, \r
            bubbles: true \r
        }));\r
    }\r
    \r
    handleMouseMove(e) {\r
        const deltaY = this.startY - e.clientY; // Inverted so up increases value\r
        const inputRect = this.input.getBoundingClientRect();\r
        const mouseY = e.clientY;\r
        \r
        // Check if mouse is outside input bounds\r
        const isOutside = mouseY < inputRect.top || mouseY > inputRect.bottom;\r
        \r
        // Only start dragging if we've moved enough\r
        if (!this.isDragging && (isOutside || Math.abs(deltaY) > 5)) {\r
            this.isDragging = true;\r
            this.hasMovedEnough = true;\r
            \r
            // Add dragging class and change cursor\r
            this.input.classList.add('dragging');\r
            document.body.style.cursor = 'ns-resize';\r
            \r
            // Prevent text selection\r
            e.preventDefault();\r
            \r
            // Keep the input focused during drag\r
            if (!this.wasAlreadyFocused) {\r
                this.input.focus();\r
            }\r
            this.input.select();\r
        }\r
        \r
        if (this.isDragging) {\r
            e.preventDefault();\r
            \r
            // Calculate value change based on drag distance\r
            let valueChange = deltaY * this.step * this.dragSensitivity;\r
            \r
            // Add acceleration for larger movements\r
            if (Math.abs(deltaY) > 50) {\r
                valueChange *= Math.abs(deltaY) / 50;\r
            }\r
            \r
            // Hold shift for fine control\r
            if (e.shiftKey) {\r
                valueChange *= 0.1;\r
            }\r
            \r
            // Hold ctrl/cmd for larger steps\r
            if (e.ctrlKey || e.metaKey) {\r
                valueChange *= 10;\r
            }\r
            \r
            // Calculate new value\r
            this.currentValue = this.startValue + valueChange;\r
            \r
            // Round to step precision\r
            const stepPrecision = this.getDecimalPlaces(this.step);\r
            this.currentValue = parseFloat(this.currentValue.toFixed(stepPrecision));\r
            \r
            // Update input display\r
            this.input.value = this.currentValue;\r
            \r
            // Keep selection during drag\r
            this.input.select();\r
            \r
            // Add visual feedback\r
            if (deltaY > 0) {\r
                this.input.classList.remove('drag-down');\r
                this.input.classList.add('drag-up');\r
            } else {\r
                this.input.classList.remove('drag-up');\r
                this.input.classList.add('drag-down');\r
            }\r
            \r
            // Keep pendingValue in sync\r
            this.pendingValue = this.input.value;\r
            \r
            // Trigger change event for live preview\r
            this.triggerChange();\r
        }\r
    }\r
    \r
    handleMouseUp(e) {\r
        if (this.isDragging) {\r
            this.isDragging = false;\r
            this.input.classList.remove('dragging', 'drag-up', 'drag-down');\r
            document.body.style.cursor = '';\r
            \r
            // Keep the input focused and selected after drag\r
            this.input.focus();\r
            this.input.select();\r
            \r
            // Final value update\r
            this.triggerChange(true);\r
            \r
            // Drag ended\r
            window.dispatchEvent(new CustomEvent('z3d-drag-state', { \r
                detail: { dragging: false }, \r
                bubbles: true \r
            }));\r
            \r
            // Ensure typing state is reset\r
            this.isTyping = false;\r
        } else if (!this.hasMovedEnough && !this.wasAlreadyFocused) {\r
            // It was just a click, not a drag - focus for typing\r
            this.input.focus();\r
            this.input.select();\r
        }\r
        \r
        // Reset flags\r
        this.wasAlreadyFocused = false;\r
        \r
        // Remove global listeners\r
        document.removeEventListener('mousemove', this.handleMouseMove);\r
        document.removeEventListener('mouseup', this.handleMouseUp);\r
    }\r
    \r
    handleFocus(e) {\r
        this.isTyping = true;\r
        this.pendingValue = this.input.value;\r
        this.currentValue = parseFloat(this.input.value) || 0;\r
    }\r
    \r
    handleInput(e) {\r
        // Store the pending value but don't apply it yet\r
        this.pendingValue = this.input.value;\r
    }\r
    \r
    handleKeyDown(e) {\r
        if (e.key === 'Enter') {\r
            e.preventDefault();\r
            this.applyPendingValue();\r
            this.input.blur();\r
            \r
            // Notify commit\r
            window.dispatchEvent(new CustomEvent('z3d-drag-state', { \r
                detail: { dragging: false }, \r
                bubbles: true \r
            }));\r
        } else if (e.key === 'Escape') {\r
            // Cancel editing and restore original value\r
            this.input.value = this.currentValue;\r
            this.pendingValue = null;\r
            this.input.blur();\r
        } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {\r
            e.preventDefault();\r
            const direction = e.key === 'ArrowUp' ? 1 : -1;\r
            const step = e.shiftKey ? this.step * 0.1 : this.step;\r
            const newValue = (parseFloat(this.input.value) || 0) + (direction * step);\r
            this.input.value = newValue.toFixed(this.getDecimalPlaces(this.step));\r
            this.pendingValue = this.input.value;\r
            this.applyPendingValue();\r
        }\r
    }\r
    \r
    handleBlur(e) {\r
        if (this.pendingValue !== null && this.pendingValue !== this.currentValue.toString()) {\r
            this.applyPendingValue();\r
        }\r
        // Always reset typing state on blur\r
        this.isTyping = false;\r
    }\r
    \r
    applyPendingValue() {\r
        const value = parseFloat(this.input.value);\r
        if (!isNaN(value)) {\r
            this.currentValue = value;\r
            this.input.value = value.toFixed(this.getDecimalPlaces(this.step));\r
            this.triggerChange(true);\r
        }\r
        this.pendingValue = null;\r
    }\r
    \r
    triggerChange(isFinal = false) {\r
        // Dispatch custom event with value\r
        const event = new CustomEvent('drag-value-change', {\r
            detail: {\r
                value: this.currentValue,\r
                property: this.input.dataset.prop,\r
                isFinal: isFinal\r
            },\r
            bubbles: true\r
        });\r
        this.input.dispatchEvent(event);\r
        \r
        // Also trigger standard change event for compatibility\r
        if (isFinal) {\r
            const changeEvent = new Event('change', { bubbles: true });\r
            this.input.dispatchEvent(changeEvent);\r
        }\r
    }\r
    \r
    getDecimalPlaces(num) {\r
        const str = num.toString();\r
        const decimal = str.indexOf('.');\r
        return decimal === -1 ? 0 : str.length - decimal - 1;\r
    }\r
    \r
    dispose() {\r
        this.input.removeEventListener('mousedown', this.handleMouseDown);\r
        this.input.removeEventListener('keydown', this.handleKeyDown);\r
        this.input.removeEventListener('input', this.handleInput);\r
        this.input.removeEventListener('blur', this.handleBlur);\r
        this.input.removeEventListener('focus', this.handleFocus);\r
        document.removeEventListener('mousemove', this.handleMouseMove);\r
        document.removeEventListener('mouseup', this.handleMouseUp);\r
    }\r
}\r
\r
// Initialize drag inputs helper\r
function initializeDragInputs() {\r
    const dragInputs = document.querySelectorAll('.drag-input');\r
    dragInputs.forEach(input => {\r
        // Skip if already initialized\r
        if (!input.dragHandler) {\r
            input.dragHandler = new DragInputHandler(input);\r
        }\r
    });\r
}\r
\r
// Make it globally available\r
if (typeof window.initializeDragInputs === 'undefined') {\r
    window.initializeDragInputs = initializeDragInputs;\r
}`,
        "viewportControls": `/* FILE: editor/z3d-object-editor/templates/scripts/components/viewport-controls.js */\r
class ViewportControls extends EventEmitter {\r
    async initialize() {\r
        const container = document.getElementById('viewport-controls');\r
        if (!container) {\r
            throw new Error('Viewport controls container not found');\r
        }\r
        container.innerHTML = this._generateHTML();\r
        this._setupEventListeners();\r
        this.isInitialized = true;\r
        // Ensure camera follow state is synced on init\r
        if (this.state.cameraFollow) {\r
            this.emit('camera-follow-changed', { enabled: true });\r
            if (window.worker) {\r
                window.worker.postMessage({\r
                    type: 'SET_CAMERA_FOLLOW_EDITOR',\r
                    data: { enabled: true }\r
                });\r
            }\r
        }\r
        console.log('[ViewportControls] \u2705 Initialized');\r
    }\r
    constructor(config) {\r
        super();\r
        this.config = config;\r
        this.isInitialized = false;\r
        this.state = {\r
            wireframe: false,\r
            worldGridCellPx: 64,\r
            localGridCellPx: 32,\r
            localGridPaddingPct: 25, // percent\r
            worldGridPaddingPct: 50, // percent\r
            snapAngleDeg: 15,\r
            snapScale: 0.1,\r
            cameraFollow: true,\r
            cameraPosition: { x: 0, y: 0, z: 0 }\r
        };\r
    // ...existing code...\r
        this.isInitialized = true;\r
        console.log('[ViewportControls] \u2705 Initialized');\r
    }\r
    \r
    _generateHTML() {\r
        return \`\r
            <div class="viewport-controls-panel">\r
                <div class="controls-row" style="max-width:380px; display:flex; gap:8px; align-items:center;">\r
                    <div class="vc-field"><label for="world-grid-cell">World(px)</label><input type="number" id="world-grid-cell" min="1" step="1" value="\${this.state.worldGridCellPx}"></div>\r
                    <div class="vc-field"><label for="world-grid-padding">Pad(%)</label><input type="number" id="world-grid-padding" min="0" step="1" value="\${this.state.worldGridPaddingPct}"></div>\r
                    <div class="vc-field"><label for="local-grid-cell">Local(px)</label><input type="number" id="local-grid-cell" min="1" step="1" value="\${this.state.localGridCellPx}"></div>\r
                    <div class="vc-field"><label for="local-grid-padding">Pad(%)</label><input type="number" id="local-grid-padding" min="0" step="1" value="\${this.state.localGridPaddingPct}"></div>\r
                    <div class="vc-field"><label for="snap-angle">Snap Angle (\xB0)</label><input type="number" id="snap-angle" min="1" step="1" value="\${this.state.snapAngleDeg}"></div>\r
                    <div class="vc-field"><label for="snap-scale">Snap Scale</label><input type="number" id="snap-scale" min="0.001" step="0.01" value="\${this.state.snapScale}"></div>\r
                    <div class="vc-field checkbox"><label for="camera-follow-checkbox">Follow</label><input type="checkbox" id="camera-follow-checkbox" \${this.state.cameraFollow ? 'checked' : ''}></div>\r
                </div>\r
            </div>\`;\r
    }\r
    \r
    _setupEventListeners() {\r
        // Camera follow checkbox\r
        const cameraFollowCheckbox = document.getElementById('camera-follow-checkbox');\r
        if (cameraFollowCheckbox) {\r
            cameraFollowCheckbox.addEventListener('change', (e) => {\r
                this.state.cameraFollow = !!e.target.checked;\r
                this.emit('camera-follow-changed', { enabled: this.state.cameraFollow });\r
                // Send message to worker to enable/disable camera follow for editor changes\r
                if (window.worker) {\r
                    window.worker.postMessage({\r
                        type: 'SET_CAMERA_FOLLOW_EDITOR',\r
                        data: { enabled: this.state.cameraFollow }\r
                    });\r
                }\r
            });\r
        }\r
        \r
        // World/local grid cell inputs\r
        const worldCell = document.getElementById('world-grid-cell');\r
        const localCell = document.getElementById('local-grid-cell');\r
    const worldPad = document.getElementById('world-grid-padding');\r
    const localPad = document.getElementById('local-grid-padding');\r
        if (worldCell) {\r
            worldCell.addEventListener('change', (e) => {\r
                const v = Math.max(1, parseInt(e.target.value, 10) || 1);\r
                this.state.worldGridCellPx = v;\r
                if (window.worker) window.worker.postMessage({ type: 'UPDATE_VIEWPORT_SETTING', data: { key: 'worldGridCellPx', value: v } });\r
            });\r
        }\r
        if (localCell) {\r
            localCell.addEventListener('change', (e) => {\r
                const v = Math.max(1, parseInt(e.target.value, 10) || 1);\r
                this.state.localGridCellPx = v;\r
                if (window.worker) window.worker.postMessage({ type: 'UPDATE_VIEWPORT_SETTING', data: { key: 'localGridCellPx', value: v } });\r
            });\r
        }\r
        if (worldPad) {\r
            worldPad.addEventListener('change', (e) => {\r
                const v = Math.max(0, parseFloat(e.target.value) || 0);\r
                this.state.worldGridPaddingPct = v;\r
                if (window.worker) window.worker.postMessage({ type: 'UPDATE_VIEWPORT_SETTING', data: { key: 'worldGridPaddingPct', value: v } });\r
            });\r
        }\r
        if (localPad) {\r
            localPad.addEventListener('change', (e) => {\r
                const v = Math.max(0, parseFloat(e.target.value) || 0);\r
                this.state.localGridPaddingPct = v;\r
                if (window.worker) window.worker.postMessage({ type: 'UPDATE_VIEWPORT_SETTING', data: { key: 'localGridPaddingPct', value: v } });\r
            });\r
        }\r
\r
        // Snap angle\r
        const snapAngle = document.getElementById('snap-angle');\r
        const snapScale = document.getElementById('snap-scale');\r
        if (snapAngle) {\r
            snapAngle.addEventListener('change', (e) => {\r
                const v = Math.max(1, parseInt(e.target.value, 10) || 1);\r
                this.state.snapAngleDeg = v;\r
                if (window.worker) window.worker.postMessage({ type: 'UPDATE_VIEWPORT_SETTING', data: { key: 'snapAngleDeg', value: v } });\r
            });\r
        }\r
        if (snapScale) {\r
            snapScale.addEventListener('change', (e) => {\r
                const v = Math.max(0.001, parseFloat(e.target.value) || 0.001);\r
                this.state.snapScale = v;\r
                if (window.worker) window.worker.postMessage({ type: 'UPDATE_VIEWPORT_SETTING', data: { key: 'snapScale', value: v } });\r
            });\r
        }\r
    /**\r
     * Integration note: In your main editor code, listen for 'camera-follow' events from object-controls\r
     * and call viewportControls.followCameraTo(position) to move the camera if camera follow is enabled.\r
     * Example:\r
     *   objectControls.on('camera-follow', ({ position }) => viewportControls.followCameraTo(position));\r
     */\r
        // Grid inputs -> emit viewport settings\r
    }\r
\r
    /**\r
     * Call this to move the camera if camera follow is enabled.\r
     * @param {object} position {x, y, z}\r
     */\r
    followCameraTo(position) {\r
        if (!this.state.cameraFollow) return;\r
        // Store last camera position (optional, for UI sync)\r
        this.state.cameraPosition = { ...position };\r
        \r
        // Emit event for the editor or 3D view to handle actual camera movement\r
        this.emit('camera-move-to', { position });\r
    }\r
    \r
    dispose() {\r
        console.log('[ViewportControls] Disposed');\r
    }\r
}`,
        "outlinerControls": `/* FILE: editor/z3d-object-editor/templates/scripts/components/outliner-controls.js */\r
/* Advanced Scene Explorer with Fixed Event Handling and Text Selection */\r
\r
class OutlinerControls extends EventEmitter {\r
    constructor(config) {\r
        super();\r
        this.config = config;\r
        this.isInitialized = false;\r
        \r
        // Complete scene data\r
        this.sceneData = {\r
            nodes: null,\r
            materials: [],\r
            textures: [],\r
            animations: [],\r
            skeletons: [],\r
            lights: [],\r
            cameras: [],\r
            geometries: []\r
        };\r
        \r
        // UI state\r
        this.expandedNodes = new Set();\r
        this.expandedCategories = new Set(['nodes']); // Start with nodes expanded\r
        this.expandedMetadata = new Set(); // NEW: Track which nodes have metadata expanded\r
        this.selectedItem = null;\r
        this.searchTerm = '';\r
        this.activeCategory = 'all'; // all, nodes, materials, textures, animations, etc.\r
        \r
        this._hoveredItem = null;\r
        this._debug = !!(this.config?.debugMode || (typeof window !== 'undefined' && window.Z3D_DEBUG));\r
    }\r
    \r
    async initialize() {\r
        const container = document.getElementById('node-tree');\r
        if (!container) {\r
            throw new Error('Node tree container not found');\r
        }\r
        \r
        // Set initial loading state\r
        container.innerHTML = this._generateLoadingHTML();\r
        \r
        // Listen for scene data from worker\r
        this._setupWorkerListener();\r
        \r
        // Listen for model loaded events\r
        this._setupModelLoadedListener();\r
        \r
        this.isInitialized = true;\r
        console.log('[OutlinerControls] \u2705 Initialized');\r
    }\r
    \r
    _generateLoadingHTML() {\r
        return \`\r
            <div class="outliner-container">\r
                <div class="outliner-toolbar">\r
                    <select id="outliner-category" class="outliner-category-select">\r
                        <option value="all">All Categories</option>\r
                        <option value="nodes">Scene Nodes</option>\r
                        <option value="materials">Materials</option>\r
                        <option value="textures">Textures</option>\r
                        <option value="animations">Animations</option>\r
                        <option value="skeletons">Skeletons</option>\r
                        <option value="lights">Lights</option>\r
                        <option value="cameras">Cameras</option>\r
                        <option value="geometries">Geometries</option>\r
                    </select>\r
                    <input type="text" \r
                           id="outliner-search" \r
                           class="outliner-search" \r
                           placeholder="Search..."\r
                           disabled>\r
                    <button id="outliner-expand-all" \r
                            class="btn btn-sm" \r
                            title="Expand All"\r
                            disabled>\u2795</button>\r
                    <button id="outliner-collapse-all" \r
                            class="btn btn-sm" \r
                            title="Collapse All"\r
                            disabled>\u2796</button>\r
                </div>\r
                <div class="outliner-tree" id="outliner-tree">\r
                    <div class="outliner-loading">\r
                        <div class="loading-spinner small"></div>\r
                        <span>Waiting for model...</span>\r
                    </div>\r
                </div>\r
                <div class="outliner-stats" id="outliner-stats">\r
                    <!-- Stats will be displayed here -->\r
                </div>\r
            </div>\`;\r
    }\r
    \r
    _setupWorkerListener() {\r
        if (window.worker) {\r
            window.worker.addEventListener('message', (event) => {\r
                // Listen for complete scene data\r
                if (event.data.type === 'SCENE_DATA') {\r
                    console.log('[OutlinerControls] Received scene data from worker:', event.data.data);\r
                    this._handleSceneData(event.data.data);\r
                }\r
                // Fallback to old node tree message\r
                else if (event.data.type === 'MODEL_NODE_TREE') {\r
                    console.log('[OutlinerControls] Received legacy node tree from worker');\r
                    this._handleLegacyNodeTree(event.data.data);\r
                }\r
            });\r
        }\r
    }\r
    \r
    _setupModelLoadedListener() {\r
        if (window.worker) {\r
            window.worker.addEventListener('message', (event) => {\r
                if (event.data.type === 'MODEL_LOADED' && event.data.data?.success) {\r
                    console.log('[OutlinerControls] Model loaded, waiting for scene data...');\r
                    // Request scene data if not received after a delay\r
                    setTimeout(() => {\r
                        if (!this.sceneData.nodes) {\r
                            console.log('[OutlinerControls] No scene data received, showing placeholder');\r
                            this._showNoModelState();\r
                        }\r
                    }, 2000);\r
                }\r
            });\r
        }\r
    }\r
    \r
    _handleSceneData(data) {\r
        if (!data || !data.sceneData) {\r
            console.warn('[OutlinerControls] Invalid scene data received');\r
            this._showNoModelState();\r
            return;\r
        }\r
        \r
        this.sceneData = data.sceneData;\r
        console.log('[OutlinerControls] Scene data structure:', this.sceneData);\r
        \r
        // Clear previous state\r
        this.expandedNodes.clear();\r
        this.expandedCategories.clear();\r
        this.expandedMetadata.clear();\r
        \r
        // Start with only nodes category expanded\r
        this.expandedCategories.add('nodes');\r
        \r
        // Auto-expand to show model structure\r
        if (this.sceneData.nodes) {\r
            // Expand root (Scene)\r
            this._expandNode(this.sceneData.nodes.id);\r
            \r
            // Find and expand ModelWrapper and LoadedModel\r
            if (this.sceneData.nodes.children) {\r
                this.sceneData.nodes.children.forEach(child => {\r
                    if (child.name === 'ModelWrapper') {\r
                        // Expand ModelWrapper\r
                        this._expandNode(child.id);\r
                        \r
                        // Find and expand LoadedModel within ModelWrapper\r
                        if (child.children) {\r
                            child.children.forEach(grandchild => {\r
                                if (grandchild.name === 'LoadedModel') {\r
                                    // Expand LoadedModel to show first level (e.g., Rig)\r
                                    this._expandNode(grandchild.id);\r
                                    // Don't expand further - we just want to see the first level\r
                                }\r
                            });\r
                        }\r
                    }\r
                });\r
            }\r
        }\r
        \r
        console.log('[OutlinerControls] Initial expanded categories:', Array.from(this.expandedCategories));\r
        console.log('[OutlinerControls] Initial expanded nodes:', Array.from(this.expandedNodes));\r
        \r
        // Apply initial node visibility if provided\r
        if (window.initialNodeVisibility) {\r
            console.log('[OutlinerControls] Applying initial node visibility:', window.initialNodeVisibility);\r
            this._applyInitialNodeVisibility(this.sceneData.nodes, window.initialNodeVisibility);\r
        }\r
        \r
        // Send initial node visibility state to parent\r
        this._sendAllNodeVisibilityToParent();\r
        \r
        // Enable controls and render\r
        this._enableToolbar();\r
        this._renderSceneExplorer();\r
        this._setupEventListeners();\r
        this._updateStats();\r
    }\r
    \r
    _handleLegacyNodeTree(data) {\r
        // Convert legacy node tree to scene data format\r
        if (!data || !data.nodeTree) {\r
            this._showNoModelState();\r
            return;\r
        }\r
        \r
        this.sceneData = {\r
            nodes: this._convertLegacyNode(data.nodeTree),\r
            materials: [],\r
            textures: [],\r
            animations: [],\r
            skeletons: [],\r
            lights: [],\r
            cameras: [],\r
            geometries: []\r
        };\r
        \r
        this._expandNode(this.sceneData.nodes.id);\r
        this._enableToolbar();\r
        this._renderSceneExplorer();\r
        this._setupEventListeners();\r
        this._updateStats();\r
    }\r
    \r
    _convertLegacyNode(node) {\r
        return {\r
            id: node.id,\r
            name: node.name,\r
            type: node.type,\r
            className: node.type,\r
            visible: true,\r
            userData: node.userData || {},\r
            children: node.children ? node.children.map(c => this._convertLegacyNode(c)) : []\r
        };\r
    }\r
    \r
    _showNoModelState() {\r
        const container = document.getElementById('outliner-tree');\r
        if (container) {\r
            container.innerHTML = \`\r
                <div class="outliner-empty">\r
                    <span class="empty-icon">\u{1F4E6}</span>\r
                    <span class="empty-text">No model loaded</span>\r
                </div>\`;\r
        }\r
    }\r
    \r
    _renderSceneExplorer() {\r
        const container = document.getElementById('outliner-tree');\r
        if (!container) return;\r
        \r
        let html = '<div class="scene-explorer">';\r
        \r
        // Filter categories based on active selection\r
        const categoriesToShow = this.activeCategory === 'all' \r
            ? ['nodes', 'skeletons', 'materials', 'textures', 'animations', 'lights', 'cameras', 'geometries']\r
            : [this.activeCategory];\r
        \r
        categoriesToShow.forEach(category => {\r
            html += this._renderCategory(category);\r
        });\r
        \r
        html += '</div>';\r
        container.innerHTML = html;\r
        \r
        // Apply search filter if any\r
        if (this.searchTerm) {\r
            this._applySearchFilter();\r
        }\r
    }\r
    \r
    _renderCategory(categoryName) {\r
        const categoryData = this.sceneData[categoryName];\r
        const isExpanded = this.expandedCategories.has(categoryName);\r
        const hasData = this._categoryHasData(categoryName, categoryData);\r
        \r
        console.log(\`[OutlinerControls] Rendering category: \${categoryName}, expanded: \${isExpanded}, hasData: \${hasData}\`);\r
        \r
        if (!hasData && this.activeCategory === 'all') {\r
            return ''; // Don't show empty categories in "all" view\r
        }\r
        \r
        const count = this._getCategoryCount(categoryName, categoryData);\r
        const icon = this._getCategoryIcon(categoryName);\r
        const displayName = this._getCategoryDisplayName(categoryName);\r
        \r
        let html = \`\r
            <div class="category-section" data-category="\${categoryName}">\r
                <div class="category-header \${!hasData ? 'empty' : ''}" data-category-toggle="\${categoryName}">\r
                    <span class="category-toggle \${isExpanded ? 'expanded' : ''}">\r
                        \${hasData ? (isExpanded ? '\u25BC' : '\u25B6') : '\u25CB'}\r
                    </span>\r
                    <span class="category-icon">\${icon}</span>\r
                    <span class="category-name">\${displayName}</span>\r
                    <span class="category-count">(\${count})</span>\r
                </div>\`;\r
        \r
        // ONLY render content if category is expanded\r
        if (hasData && isExpanded) {\r
            html += '<div class="category-content">';       \r
            \r
            switch (categoryName) {\r
                case 'nodes':\r
                    html += this._renderNode(categoryData, 0);\r
                    break;\r
                case 'materials':\r
                    html += this._renderMaterials(categoryData);\r
                    break;\r
                case 'textures':\r
                    html += this._renderTextures(categoryData);\r
                    break;\r
                case 'animations':\r
                    html += this._renderAnimations(categoryData);\r
                    break;\r
                case 'skeletons':\r
                    html += this._renderSkeletons(categoryData);\r
                    break;\r
                case 'lights':\r
                    html += this._renderLights(categoryData);\r
                    break;\r
                case 'cameras':\r
                    html += this._renderCameras(categoryData);\r
                    break;\r
                case 'geometries':\r
                    html += this._renderGeometries(categoryData);\r
                    break;\r
            }\r
            \r
            html += '</div>';\r
        }\r
        \r
        html += '</div>';\r
        return html;\r
    }\r
    \r
    _renderNode(node, depth = 0) {\r
        if (!node) return '';\r
        \r
        const hasChildren = node.children && node.children.length > 0;\r
        const isExpanded = this.expandedNodes.has(node.id);\r
        const isSelected = this.selectedItem === node.id;\r
        const isHovered = this._hoveredItem === node.id;\r
        const matchesSearch = this._itemMatchesSearch(node);\r
        const hasMetadata = this._hasMetadata(node);\r
        const isMetadataExpanded = this.expandedMetadata.has(node.id);\r
        \r
        const isVisible = !this.searchTerm || matchesSearch || this._hasMatchingDescendant(node);\r
        const displayStyle = isVisible ? '' : 'style="display: none;"';\r
        \r
        const icon = this._getNodeIcon(node);\r
        const classLabel = node.className !== node.type ? \` (\${node.className})\` : '';\r
        \r
        let html = \`\r
            <div class="outliner-node \${isSelected ? 'selected' : ''} \${isHovered ? 'hovered' : ''}" \r
                 data-node-id="\${node.id}" \r
                 data-item-type="node"\r
                 data-depth="\${depth}"\r
                 \${displayStyle}>\r
                <div class="node-row \${hasMetadata ? 'has-metadata' : ''}" style="padding-left: \${depth * 20}px;">\r
                    \${hasChildren ? \`\r
                        <span class="node-toggle \${isExpanded ? 'expanded' : ''}" data-toggle-for="\${node.id}">\r
                            \${isExpanded ? '\u25BC' : '\u25B6'}\r
                        </span>\` : \r
                        '<span class="node-toggle-spacer"></span>'\r
                    }\r
                    <span class="node-icon">\${icon}</span>\r
                    <span class="node-name \${matchesSearch ? 'search-match' : ''}">\${this._escapeHtml(node.name || 'Unnamed')}</span>\r
                    <span class="node-type">\${node.type}\${classLabel}</span>\r
                    <span class="visibility-toggle \${!node.visible ? 'hidden' : ''}" \r
                          data-visibility-toggle="\${node.id}"\r
                          title="\${node.visible ? 'Hide' : 'Show'}">\r
                        \u{1F441}\uFE0F\r
                    </span>\r
                    \${hasMetadata ? \`\r
                        <span class="metadata-toggle \${isMetadataExpanded ? 'expanded' : ''}" \r
                              data-metadata-toggle="\${node.id}"\r
                              title="Toggle metadata">\r
                            \${isMetadataExpanded ? '\u25BC' : '\u25B6'}\r
                        </span>\` : ''\r
                    }\r
                </div>\`;\r
        \r
        // Add metadata section only if expanded\r
        if (hasMetadata && isMetadataExpanded) {\r
            html += this._renderNodeMetadata(node, depth);\r
        }\r
        \r
        // Add children if expanded\r
        if (hasChildren && isExpanded) {\r
            html += '<div class="node-children">';\r
            node.children.forEach(child => {\r
                html += this._renderNode(child, depth + 1);\r
            });\r
            html += '</div>';\r
        }\r
        \r
        html += '</div>';\r
        return html;\r
    }\r
    \r
    _renderNodeMetadata(node, depth) {\r
        let html = '<div class="node-metadata" style="padding-left: ' + ((depth + 1) * 20 + 20) + 'px;">';\r
        \r
        // Transform data\r
        if (node.position || node.rotation || node.scale) {\r
            html += '<div class="metadata-group">';\r
            if (node.position) {\r
                html += \`<div class="metadata-item">\r
                    <span class="metadata-key">Position:</span>\r
                    <span class="metadata-value">(\${node.position.x.toFixed(2)}, \${node.position.y.toFixed(2)}, \${node.position.z.toFixed(2)})</span>\r
                </div>\`;\r
            }\r
            if (node.rotation) {\r
                html += \`<div class="metadata-item">\r
                    <span class="metadata-key">Rotation:</span>\r
                    <span class="metadata-value">(\${node.rotation.x.toFixed(1)}\xB0, \${node.rotation.y.toFixed(1)}\xB0, \${node.rotation.z.toFixed(1)}\xB0)</span>\r
                </div>\`;\r
            }\r
            if (node.scale) {\r
                html += \`<div class="metadata-item">\r
                    <span class="metadata-key">Scale:</span>\r
                    <span class="metadata-value">(\${node.scale.x.toFixed(2)}, \${node.scale.y.toFixed(2)}, \${node.scale.z.toFixed(2)})</span>\r
                </div>\`;\r
            }\r
            html += '</div>';\r
        }\r
        \r
        // Material/Geometry references\r
        if (node.materialId || node.geometryId || node.skeletonId) {\r
            html += '<div class="metadata-group">';\r
            if (node.materialId) {\r
                const matIds = Array.isArray(node.materialId) ? node.materialId : [node.materialId];\r
                matIds.forEach(id => {\r
                    const material = this.sceneData.materials.find(m => m.id === id);\r
                    if (material) {\r
                        html += \`<div class="metadata-item">\r
                            <span class="metadata-key">Material:</span>\r
                            <span class="metadata-value clickable" data-ref-id="\${id}" data-ref-type="material">\${material.name}</span>\r
                        </div>\`;\r
                    }\r
                });\r
            }\r
            if (node.geometryId) {\r
                const geometry = this.sceneData.geometries.find(g => g.id === node.geometryId);\r
                if (geometry) {\r
                    html += \`<div class="metadata-item">\r
                        <span class="metadata-key">Geometry:</span>\r
                        <span class="metadata-value clickable" data-ref-id="\${node.geometryId}" data-ref-type="geometry">\${geometry.name}</span>\r
                    </div>\`;\r
                }\r
            }\r
            if (node.skeletonId) {\r
                const skeleton = this.sceneData.skeletons.find(s => s.id === node.skeletonId);\r
                if (skeleton) {\r
                    html += \`<div class="metadata-item">\r
                        <span class="metadata-key">Skeleton:</span>\r
                        <span class="metadata-value clickable" data-ref-id="\${node.skeletonId}" data-ref-type="skeleton">\${skeleton.name}</span>\r
                    </div>\`;\r
                }\r
            }\r
            html += '</div>';\r
        }\r
        \r
        // User data\r
        if (node.userData && Object.keys(node.userData).length > 0) {\r
            html += '<div class="metadata-group">';\r
            for (const [key, value] of Object.entries(node.userData)) {\r
                html += \`<div class="metadata-item">\r
                    <span class="metadata-key">\${this._escapeHtml(key)}:</span>\r
                    <span class="metadata-value">\${this._escapeHtml(this._formatValue(value))}</span>\r
                </div>\`;\r
            }\r
            html += '</div>';\r
        }\r
        \r
        html += '</div>';\r
        return html;\r
    }\r
    \r
    _renderMaterials(materials) {\r
        let html = '<div class="items-list">';\r
        materials.forEach(material => {\r
            const isSelected = this.selectedItem === material.id;\r
            const icon = '\u{1F3A8}';\r
            \r
            html += \`\r
                <div class="list-item \${isSelected ? 'selected' : ''}" \r
                     data-item-id="\${material.id}" \r
                     data-item-type="material">\r
                    <span class="item-icon">\${icon}</span>\r
                    <span class="item-name">\${this._escapeHtml(material.name)}</span>\r
                    <span class="item-type">\${material.type}</span>\r
                </div>\`;\r
        });\r
        html += '</div>';\r
        return html;\r
    }\r
    \r
    _renderTextures(textures) {\r
        let html = '<div class="items-list">';\r
        textures.forEach(texture => {\r
            const isSelected = this.selectedItem === texture.id;\r
            const icon = '\u{1F5BC}\uFE0F';\r
            const dimensions = texture.image ? \`\${texture.image.width}\xD7\${texture.image.height}\` : 'Unknown';\r
            \r
            html += \`\r
                <div class="list-item \${isSelected ? 'selected' : ''}" \r
                     data-item-id="\${texture.id}" \r
                     data-item-type="texture">\r
                    <span class="item-icon">\${icon}</span>\r
                    <span class="item-name">\${this._escapeHtml(texture.name)}</span>\r
                    <span class="item-info">\${dimensions}</span>\r
                </div>\`;\r
        });\r
        html += '</div>';\r
        return html;\r
    }\r
    \r
    _renderAnimations(animations) {\r
        let html = '<div class="items-list expandable">';\r
        animations.forEach(animation => {\r
            const isExpanded = this.expandedNodes.has(animation.id);\r
            const isSelected = this.selectedItem === animation.id;\r
            const icon = '\u{1F3AC}';\r
            \r
            html += \`\r
                <div class="list-item \${isSelected ? 'selected' : ''}" \r
                     data-item-id="\${animation.id}" \r
                     data-item-type="animation">\r
                    \${animation.tracks && animation.tracks.length > 0 ? \`\r
                        <span class="item-toggle \${isExpanded ? 'expanded' : ''}" data-toggle-for="\${animation.id}">\r
                            \${isExpanded ? '\u25BC' : '\u25B6'}\r
                        </span>\` : \r
                        '<span class="node-toggle-spacer"></span>'\r
                    }\r
                    <span class="item-icon">\${icon}</span>\r
                    <span class="item-name">\${this._escapeHtml(animation.name)}</span>\r
                    <span class="item-info">\${animation.duration ? animation.duration.toFixed(2) : '0.00'}s</span>\r
                </div>\`;\r
            \r
            // Show tracks if expanded\r
            if (isExpanded && animation.tracks && animation.tracks.length > 0) {\r
                html += '<div class="sub-items">';\r
                animation.tracks.forEach(track => {\r
                    html += \`\r
                        <div class="sub-item">\r
                            <span class="sub-item-icon">\u{1F4C8}</span>\r
                            <span class="sub-item-name">\${this._escapeHtml(track.name)}</span>\r
                            <span class="sub-item-type">\${track.type}</span>\r
                        </div>\`;\r
                });\r
                html += '</div>';\r
            }\r
        });\r
        html += '</div>';\r
        return html;\r
    }\r
    \r
    _renderSkeletons(skeletons) {\r
        let html = '<div class="items-list expandable">';\r
        skeletons.forEach(skeleton => {\r
            const isExpanded = this.expandedNodes.has(skeleton.id);\r
            const isSelected = this.selectedItem === skeleton.id;\r
            const icon = '\u{1F9B4}';\r
            \r
            html += \`\r
                <div class="list-item \${isSelected ? 'selected' : ''}" \r
                     data-item-id="\${skeleton.id}" \r
                     data-item-type="skeleton">\r
                    \${skeleton.bones && skeleton.bones.length > 0 ? \`\r
                        <span class="item-toggle \${isExpanded ? 'expanded' : ''}" data-toggle-for="\${skeleton.id}">\r
                            \${isExpanded ? '\u25BC' : '\u25B6'}\r
                        </span>\` : \r
                        '<span class="node-toggle-spacer"></span>'\r
                    }\r
                    <span class="item-icon">\${icon}</span>\r
                    <span class="item-name">\${this._escapeHtml(skeleton.name)}</span>\r
                    <span class="item-info">\${skeleton.bones ? skeleton.bones.length : 0} bones</span>\r
                </div>\`;\r
            \r
            // Show bones if expanded\r
            if (isExpanded && skeleton.bones && skeleton.bones.length > 0) {\r
                html += '<div class="sub-items">';\r
                skeleton.bones.forEach(bone => {\r
                    html += \`\r
                        <div class="sub-item">\r
                            <span class="sub-item-icon">\u{1F9B4}</span>\r
                            <span class="sub-item-name">\${this._escapeHtml(bone.name)}</span>\r
                            \${bone.parent ? \`<span class="sub-item-info">\u2192 \${bone.parent}</span>\` : ''}\r
                        </div>\`;\r
                });\r
                html += '</div>';\r
            }\r
        });\r
        html += '</div>';\r
        return html;\r
    }\r
    \r
    _renderLights(lights) {\r
        let html = '<div class="items-list">';\r
        lights.forEach(light => {\r
            const isSelected = this.selectedItem === light.id;\r
            const icon = this._getLightIcon(light.type);\r
            \r
            html += \`\r
                <div class="list-item \${isSelected ? 'selected' : ''}" \r
                     data-item-id="\${light.id}" \r
                     data-item-type="light">\r
                    <span class="item-icon">\${icon}</span>\r
                    <span class="item-name">\${this._escapeHtml(light.name)}</span>\r
                    <span class="item-type">\${light.type}</span>\r
                    \${light.castShadow ? '<span class="item-badge" title="Casts Shadow">\u{1F311}</span>' : ''}\r
                </div>\`;\r
        });\r
        html += '</div>';\r
        return html;\r
    }\r
    \r
    _renderCameras(cameras) {\r
        let html = '<div class="items-list">';\r
        cameras.forEach(camera => {\r
            const isSelected = this.selectedItem === camera.id;\r
            const icon = camera.type === 'OrthographicCamera' ? '\u{1F4F9}' : '\u{1F4F7}';\r
            \r
            html += \`\r
                <div class="list-item \${isSelected ? 'selected' : ''}" \r
                     data-item-id="\${camera.id}" \r
                     data-item-type="camera">\r
                    <span class="item-icon">\${icon}</span>\r
                    <span class="item-name">\${this._escapeHtml(camera.name)}</span>\r
                    <span class="item-type">\${camera.type}</span>\r
                </div>\`;\r
        });\r
        html += '</div>';\r
        return html;\r
    }\r
    \r
    _renderGeometries(geometries) {\r
        let html = '<div class="items-list">';\r
        geometries.forEach(geometry => {\r
            const isSelected = this.selectedItem === geometry.id;\r
            const icon = '\u2B21';\r
            const vertCount = geometry.attributes.position ? geometry.attributes.position.count : 0;\r
            \r
            html += \`\r
                <div class="list-item \${isSelected ? 'selected' : ''}" \r
                     data-item-id="\${geometry.id}" \r
                     data-item-type="geometry">\r
                    <span class="item-icon">\${icon}</span>\r
                    <span class="item-name">\${this._escapeHtml(geometry.name)}</span>\r
                    <span class="item-info">\${vertCount} verts</span>\r
                </div>\`;\r
        });\r
        html += '</div>';\r
        return html;\r
    }\r
    \r
    // ... (Keep all the helper methods like _getNodeIcon, _getLightIcon, etc.)\r
    \r
    _enableToolbar() {\r
        const searchInput = document.getElementById('outliner-search');\r
        const expandBtn = document.getElementById('outliner-expand-all');\r
        const collapseBtn = document.getElementById('outliner-collapse-all');\r
        const categorySelect = document.getElementById('outliner-category');\r
        \r
        if (searchInput) {\r
            searchInput.disabled = false;\r
            searchInput.value = this.searchTerm;\r
        }\r
        if (expandBtn) expandBtn.disabled = false;\r
        if (collapseBtn) collapseBtn.disabled = false;\r
        if (categorySelect) categorySelect.disabled = false;\r
    }\r
    \r
    _setupEventListeners() {\r
        const container = document.getElementById('outliner-tree');\r
        if (!container) return;\r
        \r
        // Remove any existing listeners first\r
        if (this._clickHandler) {\r
            container.removeEventListener('click', this._clickHandler);\r
        }\r
        if (this._mousedownHandler) {\r
            container.removeEventListener('mousedown', this._mousedownHandler);\r
        }\r
        if (this._dblclickHandler) {\r
            container.removeEventListener('dblclick', this._dblclickHandler);\r
        }\r
        \r
        // Create bound handlers\r
        this._clickHandler = (e) => {\r
            console.log('[OutlinerControls] Click event on:', e.target.className);\r
            \r
            // Check for visibility toggle FIRST (highest priority)\r
            const visibilityToggle = e.target.closest('.visibility-toggle');\r
            if (visibilityToggle) {\r
                const nodeId = visibilityToggle.dataset.visibilityToggle;\r
                if (nodeId) {\r
                    console.log('[OutlinerControls] Visibility toggle clicked for:', nodeId);\r
                    this._toggleVisibility(nodeId);\r
                    e.preventDefault();\r
                    e.stopPropagation();\r
                    return;\r
                }\r
            }\r
            \r
            // Check for metadata toggle\r
            const metadataToggle = e.target.closest('.metadata-toggle');\r
            if (metadataToggle) {\r
                const nodeId = metadataToggle.dataset.metadataToggle;\r
                if (nodeId) {\r
                    console.log('[OutlinerControls] Metadata toggle clicked for:', nodeId);\r
                    this._toggleMetadata(nodeId);\r
                    e.preventDefault();\r
                    e.stopPropagation();\r
                    return;\r
                }\r
            }\r
            \r
            // Check if clicking directly on toggle text or its parent span\r
            let toggleEl = null;\r
            let toggleId = null;\r
            \r
            // First check if we clicked directly on a toggle or its child\r
            if (e.target.classList.contains('node-toggle') || e.target.classList.contains('item-toggle')) {\r
                toggleEl = e.target;\r
                toggleId = toggleEl.dataset.toggleFor;\r
            } else if (e.target.parentElement && \r
                      (e.target.parentElement.classList.contains('node-toggle') || \r
                       e.target.parentElement.classList.contains('item-toggle'))) {\r
                toggleEl = e.target.parentElement;\r
                toggleId = toggleEl.dataset.toggleFor;\r
            }\r
            \r
            // Handle toggle click\r
            if (toggleEl && toggleId && !toggleEl.classList.contains('node-toggle-spacer')) {\r
                console.log('[OutlinerControls] Toggle clicked for ID:', toggleId);\r
                this._toggleNode(toggleId);\r
                e.preventDefault();\r
                e.stopPropagation();\r
                return;\r
            }\r
            \r
            // Category header toggle\r
            const categoryToggle = e.target.closest('[data-category-toggle]');\r
            if (categoryToggle) {\r
                const category = categoryToggle.dataset.categoryToggle;\r
                console.log('[OutlinerControls] Category toggle clicked:', category);\r
                this._toggleCategory(category);\r
                e.preventDefault();\r
                return;\r
            }\r
            \r
            // Check if clicking on the node name specifically (for text selection)\r
            const nodeName = e.target.closest('.node-name, .item-name, .sub-item-name');\r
            if (nodeName) {\r
                // Allow text selection by not preventing default\r
                // But still handle row selection if not selecting text\r
                const selection = window.getSelection();\r
                if (!selection.toString()) {\r
                    // No text selected, handle row click\r
                    this._handleRowClick(e);\r
                }\r
                return;\r
            }\r
            \r
            // Handle row selection for other clicks\r
            this._handleRowClick(e);\r
        };\r
        \r
        // Add the click handler\r
        container.addEventListener('click', this._clickHandler);\r
        \r
        // Prevent text selection from being lost on row hover\r
        container.addEventListener('mousedown', (e) => {\r
            const nodeName = e.target.closest('.node-name, .item-name, .sub-item-name, .metadata-value');\r
            if (nodeName && !nodeName.classList.contains('clickable')) {\r
                // Allow text selection\r
                e.stopPropagation();\r
            }\r
        });\r
        \r
        // Double-click to expand/collapse\r
        container.addEventListener('dblclick', (e) => {\r
            const nodeRow = e.target.closest('.node-row');\r
            if (nodeRow) {\r
                const nodeEl = nodeRow.closest('.outliner-node');\r
                const nodeId = nodeEl?.dataset.nodeId;\r
                if (nodeId) {\r
                    const node = this._findNodeById(this.sceneData.nodes, nodeId);\r
                    if (node && node.children && node.children.length > 0) {\r
                        this._toggleNode(nodeId);\r
                        e.preventDefault();\r
                    }\r
                }\r
            }\r
        });\r
        \r
        // Category filter\r
        const categorySelect = document.getElementById('outliner-category');\r
        if (categorySelect) {\r
            categorySelect.addEventListener('change', (e) => {\r
                this.activeCategory = e.target.value;\r
                this._renderSceneExplorer();\r
            });\r
        }\r
        \r
        // Search functionality\r
        const searchInput = document.getElementById('outliner-search');\r
        if (searchInput) {\r
            let searchTimeout;\r
            searchInput.addEventListener('input', (e) => {\r
                clearTimeout(searchTimeout);\r
                searchTimeout = setTimeout(() => {\r
                    this.searchTerm = e.target.value.toLowerCase();\r
                    this._applySearchFilter();\r
                }, 300);\r
            });\r
        }\r
        \r
        // Expand/Collapse all buttons\r
        const expandBtn = document.getElementById('outliner-expand-all');\r
        if (expandBtn) {\r
            expandBtn.addEventListener('click', () => this._expandAll());\r
        }\r
        \r
        const collapseBtn = document.getElementById('outliner-collapse-all');\r
        if (collapseBtn) {\r
            collapseBtn.addEventListener('click', () => this._collapseAll());\r
        }\r
    }\r
    \r
    _handleRowClick(e) {\r
        // Node row click\r
        const nodeRow = e.target.closest('.node-row');\r
        if (nodeRow) {\r
            const nodeEl = nodeRow.closest('.outliner-node');\r
            const nodeId = nodeEl?.dataset.nodeId;\r
            if (nodeId) {\r
                this._selectItem(nodeId, 'node');\r
            }\r
        }\r
        \r
        // List item click\r
        const listItem = e.target.closest('.list-item');\r
        if (listItem) {\r
            const itemId = listItem.dataset.itemId;\r
            const itemType = listItem.dataset.itemType;\r
            if (itemId) {\r
                this._selectItem(itemId, itemType);\r
            }\r
        }\r
        \r
        // Reference click (material, geometry, skeleton links)\r
        const refEl = e.target.closest('[data-ref-id]');\r
        if (refEl && refEl.classList.contains('clickable')) {\r
            this._selectItemByReference(refEl.dataset.refId, refEl.dataset.refType);\r
            e.preventDefault();\r
        }\r
    }\r
    \r
    // ... (Keep all other methods unchanged)\r
    \r
    _getNodeIcon(node) {\r
        const iconMap = {\r
            'Scene': '\u{1F3AC}',\r
            'Group': '\u{1F4C1}',\r
            'TransformNode': '\u{1F504}',\r
            'Object3D': '\u{1F4E6}',\r
            'Mesh': '\u{1F537}',\r
            'SkinnedMesh': '\u{1F9B4}',\r
            'Bone': '\u{1F9B4}',\r
            'Light': '\u{1F4A1}',\r
            'DirectionalLight': '\u2600\uFE0F',\r
            'PointLight': '\u{1F4A1}',\r
            'SpotLight': '\u{1F526}',\r
            'AmbientLight': '\u{1F310}',\r
            'HemisphereLight': '\u{1F313}',\r
            'Camera': '\u{1F4F7}',\r
            'PerspectiveCamera': '\u{1F4F7}',\r
            'OrthographicCamera': '\u{1F4F9}',\r
            'Line': '\u{1F4CF}',\r
            'Points': '\u26AB',\r
            'Sprite': '\u{1F5BC}\uFE0F'\r
        };\r
        \r
        return iconMap[node.type] || iconMap[node.className] || '\u{1F4E6}';\r
    }\r
    \r
    _getLightIcon(type) {\r
        const iconMap = {\r
            'DirectionalLight': '\u2600\uFE0F',\r
            'PointLight': '\u{1F4A1}',\r
            'SpotLight': '\u{1F526}',\r
            'AmbientLight': '\u{1F310}',\r
            'HemisphereLight': '\u{1F313}'\r
        };\r
        return iconMap[type] || '\u{1F4A1}';\r
    }\r
    \r
    _getCategoryIcon(category) {\r
        const iconMap = {\r
            'nodes': '\u{1F333}',\r
            'materials': '\u{1F3A8}',\r
            'textures': '\u{1F5BC}\uFE0F',\r
            'animations': '\u{1F3AC}',\r
            'skeletons': '\u{1F9B4}',\r
            'lights': '\u{1F4A1}',\r
            'cameras': '\u{1F4F7}',\r
            'geometries': '\u2B21'\r
        };\r
        return iconMap[category] || '\u{1F4C1}';\r
    }\r
    \r
    _getCategoryDisplayName(category) {\r
        const nameMap = {\r
            'nodes': 'Scene',\r
            'materials': 'Materials',\r
            'textures': 'Textures',\r
            'animations': 'Animation Groups',\r
            'skeletons': 'Skeletons',\r
            'lights': 'Lights',\r
            'cameras': 'Cameras',\r
            'geometries': 'Geometries'\r
        };\r
        return nameMap[category] || category;\r
    }\r
    \r
    _categoryHasData(category, data) {\r
        if (!data) return false;\r
        if (category === 'nodes') return !!data;\r
        return Array.isArray(data) ? data.length > 0 : false;\r
    }\r
    \r
    _getCategoryCount(category, data) {\r
        if (!data) return 0;\r
        if (category === 'nodes') return this._countNodes(data);\r
        return Array.isArray(data) ? data.length : 0;\r
    }\r
    \r
    _countNodes(node) {\r
        if (!node) return 0;\r
        let count = 1;\r
        if (node.children) {\r
            node.children.forEach(child => {\r
                count += this._countNodes(child);\r
            });\r
        }\r
        return count;\r
    }\r
    \r
    _hasMetadata(node) {\r
        return !!(\r
            node.position || node.rotation || node.scale ||\r
            node.userData && Object.keys(node.userData).length > 0 ||\r
            node.materialId || node.geometryId || node.skeletonId ||\r
            node.meshInfo || node.lightInfo || node.cameraInfo\r
        );\r
    }\r
    \r
    _formatValue(value) {\r
        if (typeof value === 'object' && value !== null) {\r
            return JSON.stringify(value, null, 2);\r
        }\r
        if (typeof value === 'boolean') {\r
            return value ? '\u2713' : '\u2717';\r
        }\r
        if (typeof value === 'number') {\r
            return value.toFixed(3);\r
        }\r
        return String(value);\r
    }\r
    \r
    _toggleCategory(category) {\r
        console.log(\`[OutlinerControls] Toggling category: \${category}\`);\r
        console.log(\`[OutlinerControls] Currently expanded categories:\`, Array.from(this.expandedCategories));\r
        \r
        if (this.expandedCategories.has(category)) {\r
            this.expandedCategories.delete(category);\r
            console.log(\`[OutlinerControls] Category collapsed: \${category}\`);\r
        } else {\r
            this.expandedCategories.add(category);\r
            console.log(\`[OutlinerControls] Category expanded: \${category}\`);\r
        }\r
        \r
        console.log(\`[OutlinerControls] After toggle, expanded categories:\`, Array.from(this.expandedCategories));\r
        this._renderSceneExplorer();\r
    }\r
    \r
    _toggleNode(nodeId) {\r
        console.log('[OutlinerControls] Toggling node:', nodeId);\r
        console.log('[OutlinerControls] Currently expanded:', this.expandedNodes.has(nodeId));\r
        \r
        if (this.expandedNodes.has(nodeId)) {\r
            this.expandedNodes.delete(nodeId);\r
            console.log('[OutlinerControls] Node collapsed:', nodeId);\r
        } else {\r
            this.expandedNodes.add(nodeId);\r
            console.log('[OutlinerControls] Node expanded:', nodeId);\r
        }\r
        \r
        this._renderSceneExplorer();\r
    }\r
    \r
    _toggleMetadata(nodeId) {\r
        console.log('[OutlinerControls] Toggling metadata for node:', nodeId);\r
        \r
        if (this.expandedMetadata.has(nodeId)) {\r
            this.expandedMetadata.delete(nodeId);\r
            console.log('[OutlinerControls] Metadata collapsed:', nodeId);\r
        } else {\r
            this.expandedMetadata.add(nodeId);\r
            console.log('[OutlinerControls] Metadata expanded:', nodeId);\r
        }\r
        \r
        this._renderSceneExplorer();\r
    }\r
    \r
    _toggleVisibility(nodeId) {\r
        console.log('[OutlinerControls] Toggling visibility for node:', nodeId);\r
        \r
        // Find the node in the scene data\r
        const node = this._findNodeById(this.sceneData.nodes, nodeId);\r
        if (!node) {\r
            console.warn('[OutlinerControls] Node not found:', nodeId);\r
            return;\r
        }\r
        \r
        // Toggle the visibility in our data\r
        node.visible = !node.visible;\r
        console.log('[OutlinerControls] Node visibility set to:', node.visible);\r
        \r
        // Send message to worker to update Three.js scene\r
        if (window.worker) {\r
            window.worker.postMessage({\r
                type: 'TOGGLE_NODE_VISIBILITY',\r
                data: {\r
                    nodeId: nodeId,\r
                    visible: node.visible\r
                }\r
            });\r
        }\r
        \r
        // Notify parent of node visibility change\r
        if (window.opener && !window.opener.closed) {\r
            console.log('[OutlinerControls] Sending node visibility change to parent:', node.name, node.visible);\r
            window.opener.postMessage({\r
                type: 'NODE_VISIBILITY_CHANGE',\r
                data: {\r
                    nodeName: node.name,\r
                    visible: node.visible\r
                }\r
            }, '*');\r
        }\r
        \r
        // Update just the visibility toggle icon without re-rendering everything\r
        const visToggle = document.querySelector(\`[data-visibility-toggle="\${nodeId}"]\`);\r
        if (visToggle) {\r
            visToggle.classList.toggle('hidden', !node.visible);\r
            visToggle.title = node.visible ? 'Hide' : 'Show';\r
        }\r
    }\r
    \r
    _expandNode(nodeId) {\r
        this.expandedNodes.add(nodeId);\r
    }\r
    \r
    _applyInitialNodeVisibility(node, visibilityMap) {\r
        if (!node) return;\r
        \r
        // Apply visibility if this node is in the map\r
        if (visibilityMap[node.name] !== undefined) {\r
            node.visible = visibilityMap[node.name];\r
            console.log(\`[OutlinerControls] Set node \${node.name} visibility to \${node.visible}\`);\r
            \r
            // Send visibility update to worker to update Three.js scene\r
            if (window.worker) {\r
                window.worker.postMessage({\r
                    type: 'TOGGLE_NODE_VISIBILITY',\r
                    data: {\r
                        nodeId: node.id,\r
                        visible: node.visible\r
                    }\r
                });\r
            }\r
        }\r
        \r
        // Recursively apply to children\r
        if (node.children && node.children.length > 0) {\r
            node.children.forEach(child => {\r
                this._applyInitialNodeVisibility(child, visibilityMap);\r
            });\r
        }\r
    }\r
    \r
    _sendAllNodeVisibilityToParent() {\r
        if (!window.opener || window.opener.closed) return;\r
        \r
        const visibilityMap = {};\r
        this._collectNodeVisibility(this.sceneData.nodes, visibilityMap);\r
        \r
        // Only send if we have any nodes with non-default visibility\r
        const hasHiddenNodes = Object.values(visibilityMap).some(v => !v);\r
        if (hasHiddenNodes || Object.keys(visibilityMap).length === 0) {\r
            console.log('[OutlinerControls] Sending initial node visibility to parent:', visibilityMap);\r
            window.opener.postMessage({\r
                type: 'NODE_VISIBILITY_CHANGE',\r
                data: {\r
                    nodeVisibility: visibilityMap\r
                }\r
            }, '*');\r
        }\r
    }\r
    \r
    _collectNodeVisibility(node, visibilityMap) {\r
        if (!node) return;\r
        \r
        // Only track nodes that are explicitly hidden\r
        if (node.name && node.visible === false) {\r
            visibilityMap[node.name] = false;\r
        }\r
        \r
        // Recursively collect from children\r
        if (node.children && node.children.length > 0) {\r
            node.children.forEach(child => {\r
                this._collectNodeVisibility(child, visibilityMap);\r
            });\r
        }\r
    }\r
    \r
    _expandAll() {\r
        // Expand all categories\r
        ['nodes', 'materials', 'textures', 'animations', 'skeletons', 'lights', 'cameras', 'geometries']\r
            .forEach(cat => this.expandedCategories.add(cat));\r
        \r
        // Expand all nodes\r
        this._walkAllNodes((item) => {\r
            if (item.children && item.children.length > 0) {\r
                this.expandedNodes.add(item.id);\r
            }\r
            // Also expand metadata for nodes that have it\r
            if (this._hasMetadata(item)) {\r
                this.expandedMetadata.add(item.id);\r
            }\r
        });\r
        \r
        // Expand all animations and skeletons\r
        [...this.sceneData.animations, ...this.sceneData.skeletons].forEach(item => {\r
            if ((item.tracks && item.tracks.length > 0) || (item.bones && item.bones.length > 0)) {\r
                this.expandedNodes.add(item.id);\r
            }\r
        });\r
        \r
        this._renderSceneExplorer();\r
    }\r
    \r
    _collapseAll() {\r
        this.expandedCategories.clear();\r
        this.expandedCategories.add('nodes'); // Keep nodes category expanded\r
        this.expandedNodes.clear();\r
        this.expandedMetadata.clear(); // Also clear metadata\r
        this._renderSceneExplorer();\r
    }\r
    \r
    _selectItem(itemId, itemType) {\r
        this.selectedItem = itemId;\r
        \r
        // Update visual selection\r
        document.querySelectorAll('.outliner-node, .list-item').forEach(el => {\r
            el.classList.remove('selected');\r
        });\r
        \r
        const selector = itemType === 'node' \r
            ? \`[data-node-id="\${itemId}"]\`\r
            : \`[data-item-id="\${itemId}"]\`;\r
        \r
        const selectedEl = document.querySelector(selector);\r
        if (selectedEl) {\r
            selectedEl.classList.add('selected');\r
        }\r
        \r
        // Find the actual item data\r
        let item = null;\r
        switch (itemType) {\r
            case 'node':\r
                item = this._findNodeById(this.sceneData.nodes, itemId);\r
                break;\r
            case 'material':\r
                item = this.sceneData.materials.find(m => m.id === itemId);\r
                break;\r
            case 'texture':\r
                item = this.sceneData.textures.find(t => t.id === itemId);\r
                break;\r
            case 'animation':\r
                item = this.sceneData.animations.find(a => a.id === itemId);\r
                break;\r
            case 'skeleton':\r
                item = this.sceneData.skeletons.find(s => s.id === itemId);\r
                break;\r
            case 'light':\r
                item = this.sceneData.lights.find(l => l.id === itemId);\r
                break;\r
            case 'camera':\r
                item = this.sceneData.cameras.find(c => c.id === itemId);\r
                break;\r
            case 'geometry':\r
                item = this.sceneData.geometries.find(g => g.id === itemId);\r
                break;\r
        }\r
        \r
        if (item) {\r
            console.log(\`[OutlinerControls] \${itemType} selected:\`, item);\r
            \r
            // Emit selection event\r
            this.emit('item-selected', {\r
                itemId: itemId,\r
                itemType: itemType,\r
                item: item\r
            });\r
            \r
            // Send to worker for potential highlighting\r
            if (window.worker && itemType === 'node') {\r
                window.worker.postMessage({\r
                    type: 'HIGHLIGHT_NODE',\r
                    data: { nodeId: itemId }\r
                });\r
            }\r
        }\r
    }\r
    \r
    _selectItemByReference(refId, refType) {\r
        // Find the category and expand it\r
        const categoryMap = {\r
            'material': 'materials',\r
            'texture': 'textures',\r
            'skeleton': 'skeletons',\r
            'geometry': 'geometries'\r
        };\r
        \r
        const category = categoryMap[refType];\r
        if (category) {\r
            this.expandedCategories.add(category);\r
            this.activeCategory = category;\r
            this._renderSceneExplorer();\r
            \r
            // Select the item after render\r
            setTimeout(() => {\r
                this._selectItem(refId, refType);\r
            }, 10);\r
        }\r
    }\r
    \r
    _applySearchFilter() {\r
        if (!this.searchTerm) {\r
            // Show all items\r
            document.querySelectorAll('.outliner-node, .list-item, .category-section').forEach(el => {\r
                el.style.display = '';\r
            });\r
            document.querySelectorAll('.search-match').forEach(el => {\r
                el.classList.remove('search-match');\r
            });\r
            return;\r
        }\r
        \r
        // Hide non-matching items and highlight matches\r
        this._applySearchToNodes();\r
        this._applySearchToLists();\r
    }\r
    \r
    _applySearchToNodes() {\r
        if (!this.sceneData.nodes) return;\r
        \r
        this._walkAllNodes((node) => {\r
            const nodeEl = document.querySelector(\`[data-node-id="\${node.id}"]\`);\r
            if (!nodeEl) return;\r
            \r
            const matches = this._itemMatchesSearch(node);\r
            const hasMatchingDescendant = this._hasMatchingDescendant(node);\r
            \r
            nodeEl.style.display = (matches || hasMatchingDescendant) ? '' : 'none';\r
            \r
            const nameEl = nodeEl.querySelector('.node-name');\r
            if (nameEl) {\r
                nameEl.classList.toggle('search-match', matches);\r
            }\r
            \r
            // Auto-expand parents of matching nodes\r
            if (matches && !hasMatchingDescendant) {\r
                this._expandParentsOf(node.id);\r
            }\r
        });\r
    }\r
    \r
    _applySearchToLists() {\r
        const categories = ['materials', 'textures', 'animations', 'skeletons', 'lights', 'cameras', 'geometries'];\r
        \r
        categories.forEach(category => {\r
            const items = this.sceneData[category];\r
            if (!Array.isArray(items)) return;\r
            \r
            let hasMatch = false;\r
            items.forEach(item => {\r
                const itemEl = document.querySelector(\`[data-item-id="\${item.id}"]\`);\r
                if (!itemEl) return;\r
                \r
                const matches = this._itemMatchesSearch(item);\r
                itemEl.style.display = matches ? '' : 'none';\r
                \r
                const nameEl = itemEl.querySelector('.item-name');\r
                if (nameEl) {\r
                    nameEl.classList.toggle('search-match', matches);\r
                }\r
                \r
                if (matches) hasMatch = true;\r
            });\r
            \r
            // Hide/show category if no matches\r
            const categoryEl = document.querySelector(\`[data-category="\${category}"]\`);\r
            if (categoryEl) {\r
                categoryEl.style.display = hasMatch ? '' : 'none';\r
            }\r
        });\r
    }\r
    \r
    _itemMatchesSearch(item) {\r
        if (!this.searchTerm) return true;\r
        \r
        const searchLower = this.searchTerm.toLowerCase();\r
        \r
        // Check name\r
        if (item.name && item.name.toLowerCase().includes(searchLower)) {\r
            return true;\r
        }\r
        \r
        // Check type/className\r
        if (item.type && item.type.toLowerCase().includes(searchLower)) {\r
            return true;\r
        }\r
        if (item.className && item.className.toLowerCase().includes(searchLower)) {\r
            return true;\r
        }\r
        \r
        // Check user data\r
        if (item.userData) {\r
            for (const [key, value] of Object.entries(item.userData)) {\r
                if (key.toLowerCase().includes(searchLower) ||\r
                    String(value).toLowerCase().includes(searchLower)) {\r
                    return true;\r
                }\r
            }\r
        }\r
        \r
        return false;\r
    }\r
    \r
    _hasMatchingDescendant(node) {\r
        if (!node.children) return false;\r
        \r
        for (const child of node.children) {\r
            if (this._itemMatchesSearch(child) || this._hasMatchingDescendant(child)) {\r
                return true;\r
            }\r
        }\r
        return false;\r
    }\r
    \r
    _expandParentsOf(nodeId) {\r
        const path = this._findNodePath(this.sceneData.nodes, nodeId);\r
        if (path) {\r
            path.forEach(node => {\r
                if (node.children && node.children.length > 0) {\r
                    this.expandedNodes.add(node.id);\r
                }\r
            });\r
        }\r
    }\r
    \r
    _findNodeById(tree, nodeId) {\r
        if (!tree) return null;\r
        if (tree.id === nodeId) return tree;\r
        \r
        if (tree.children) {\r
            for (const child of tree.children) {\r
                const found = this._findNodeById(child, nodeId);\r
                if (found) return found;\r
            }\r
        }\r
        \r
        return null;\r
    }\r
    \r
    _findNodePath(tree, nodeId, path = []) {\r
        if (!tree) return null;\r
        \r
        path.push(tree);\r
        \r
        if (tree.id === nodeId) return path;\r
        \r
        if (tree.children) {\r
            for (const child of tree.children) {\r
                const foundPath = this._findNodePath(child, nodeId, [...path]);\r
                if (foundPath) return foundPath;\r
            }\r
        }\r
        \r
        return null;\r
    }\r
    \r
    _walkAllNodes(callback) {\r
        if (this.sceneData.nodes) {\r
            this._walkTree(this.sceneData.nodes, callback);\r
        }\r
    }\r
    \r
    _walkTree(tree, callback) {\r
        callback(tree);\r
        if (tree.children) {\r
            tree.children.forEach(child => this._walkTree(child, callback));\r
        }\r
    }\r
    \r
    _updateStats() {\r
        const statsEl = document.getElementById('outliner-stats');\r
        if (!statsEl || !this.sceneData.stats) return;\r
        \r
        const stats = this.sceneData.stats;\r
        statsEl.innerHTML = \`\r
            <div class="stats-row">\r
                <span class="stat-item">Nodes: \${stats.totalNodes || 0}</span>\r
                <span class="stat-item">Materials: \${stats.totalMaterials || 0}</span>\r
                <span class="stat-item">Textures: \${stats.totalTextures || 0}</span>\r
                <span class="stat-item">Animations: \${stats.totalAnimations || 0}</span>\r
            </div>\`;\r
    }\r
    \r
    _escapeHtml(text) {\r
        const div = document.createElement('div');\r
        div.textContent = text;\r
        return div.innerHTML;\r
    }\r
    \r
    dispose() {\r
        this.sceneData = {\r
            nodes: null,\r
            materials: [],\r
            textures: [],\r
            animations: [],\r
            skeletons: [],\r
            lights: [],\r
            cameras: [],\r
            geometries: []\r
        };\r
        this.expandedNodes.clear();\r
        this.expandedCategories.clear();\r
        this.selectedItem = null;\r
        console.log('[OutlinerControls] Disposed');\r
    }\r
}`,
        "animationControls": `/* FILE: editor/z3d-object-editor/templates/scripts/components/animation-controls.js */\r
/* Animation Viewer and Playback Controls */\r
\r
class AnimationControls extends EventEmitter {\r
    constructor(config) {\r
        super();\r
        this.config = config;\r
\r
        this.ANIMATION_DEBUG = !!(this.config?.debugAnimation || (typeof window !== 'undefined' && window.ANIMATION_DEBUG));\r
        console.log = (...args) => { if (this.ANIMATION_DEBUG) this._originalConsoleLog(...args); };\r
\r
        this.isInitialized = false;\r
        this.isDisposed = false;\r
\r
        // Animation state\r
        this.animations = [];\r
        this.currentAnimation = null;\r
        this.currentAnimationIndex = 0;\r
        this.isPlaying = false;\r
        this.isLooping = true;\r
        this.playbackSpeed = 1.0;\r
        this.currentTime = 0;\r
        this.duration = 0;\r
        \r
        // Scrubbing state\r
        this.isScrubbing = false;\r
        this.wasPlayingBeforeScrub = false;\r
        \r
        // Skinned mesh sync state\r
        this.skinnedMeshSync = {\r
            enabled: false,\r
            lastUpdateTime: 0,\r
            updateFrequency: 30, // Hz\r
            minUpdateInterval: 1000 / 30 // milliseconds\r
        };\r
        \r
        // UI elements\r
        this.container = null;\r
        this.animationSelect = null;\r
        this.playBtn = null;\r
        this.loopBtn = null;\r
        this.timeSlider = null;\r
        this.currentTimeDisplay = null;\r
        this.durationDisplay = null;\r
        this.speedControl = null;\r
        \r
        // Update interval\r
        this.updateInterval = null;\r
    }\r
    \r
    async initialize(container) {\r
        if (!container) {\r
            console.error('[AnimationControls] No container provided');\r
            return;\r
        }\r
        \r
        this.container = container;\r
        this._render();\r
        this._setupEventListeners();\r
        this._listenForAnimationData();\r
        \r
        this.isInitialized = true;\r
        console.log('[AnimationControls] \u2705 Initialized');\r
    }\r
    \r
    _render() {\r
        this.container.innerHTML = \`\r
            <div class="animation-controls">\r
                <!-- Animation Selection - Compact Layout -->\r
                <div class="animation-header-compact">\r
                    <div class="animation-select-row">\r
                        <select id="animation-select" class="animation-select" disabled>\r
                            <option value="">No animations</option>\r
                        </select>\r
                        <div class="animation-info-inline">\r
                            <span class="animation-name">No animation selected</span>\r
                            <span class="animation-duration">0:00</span>\r
                        </div>\r
                    </div>\r
                </div>\r
                \r
                <!-- Playback Controls -->\r
                <div class="playback-controls">\r
                    <div class="control-buttons">\r
                        <button id="anim-play-btn" class="control-btn play-btn" disabled title="Play/Pause">\r
                            \u25B6\uFE0F\r
                        </button>\r
                        <button id="anim-loop-btn" class="control-btn loop-btn active" disabled title="Toggle Loop">\r
                            \u{1F501}\r
                        </button>\r
                        <div class="speed-control">\r
                            <label>Speed:</label>\r
                            <select id="anim-speed-select" class="speed-select" disabled>\r
                                <option value="0.25">0.25x</option>\r
                                <option value="0.5">0.5x</option>\r
                                <option value="1" selected>1x</option>\r
                                <option value="1.5">1.5x</option>\r
                                <option value="2">2x</option>\r
                            </select>\r
                        </div>\r
                    </div>\r
                    \r
                    <!-- Timeline -->\r
                    <div class="timeline-container">\r
                        <div class="time-display">\r
                            <span id="current-time">0:00</span> / <span id="total-duration">0:00</span>\r
                        </div>\r
                        <div class="timeline">\r
                            <input type="range" \r
                                   id="time-slider" \r
                                   class="time-slider" \r
                                   min="0" \r
                                   max="100" \r
                                   value="0" \r
                                   step="0.1"\r
                                   disabled>\r
                            <div class="timeline-progress" id="timeline-progress"></div>\r
                        </div>\r
                    </div>\r
                </div>\r
                \r
                <!-- Animation List with Scrolling -->\r
                <div class="animation-list" id="animation-list">\r
                    <div class="list-header">Available Animations (\${this.animations.length})</div>\r
                    <div class="list-content scrollable" id="animation-list-content">\r
                        <div class="empty-state">No animations loaded</div>\r
                    </div>\r
                </div>\r
            </div>\`;\r
        \r
        // Cache UI elements\r
        this.animationSelect = document.getElementById('animation-select');\r
        this.playBtn = document.getElementById('anim-play-btn');\r
        this.loopBtn = document.getElementById('anim-loop-btn');\r
        this.timeSlider = document.getElementById('time-slider');\r
        this.currentTimeDisplay = document.getElementById('current-time');\r
        this.durationDisplay = document.getElementById('total-duration');\r
        this.speedControl = document.getElementById('anim-speed-select');\r
    }\r
    \r
    _setupEventListeners() {\r
        // Animation selection - ADD BLUR\r
        if (this.animationSelect) {\r
            this.animationSelect.addEventListener('change', (e) => {\r
                const index = parseInt(e.target.value);\r
                if (!isNaN(index)) {\r
                    this._selectAnimation(index, true);\r
                }\r
                e.target.blur(); // ADD THIS - remove focus after selection\r
            });\r
        }\r
        \r
        // Play/Pause button with focus management\r
        if (this.playBtn) {\r
            let isMouseDown = false;\r
            \r
            this.playBtn.addEventListener('mousedown', (e) => {\r
                isMouseDown = true;\r
            });\r
            \r
            this.playBtn.addEventListener('mouseup', (e) => {\r
                if (isMouseDown) {\r
                    this._togglePlayPause();\r
                    e.target.blur();\r
                }\r
                isMouseDown = false;\r
            });\r
            \r
            this.playBtn.addEventListener('mouseleave', (e) => {\r
                if (isMouseDown) {\r
                    e.target.blur(); // Remove focus if dragged outside\r
                }\r
                isMouseDown = false;\r
            });\r
            \r
            // Keep click handler as fallback\r
            this.playBtn.addEventListener('click', (e) => {\r
                e.target.blur();\r
            });\r
        }\r
        \r
        // Loop button with focus management\r
        if (this.loopBtn) {\r
            let isMouseDown = false;\r
            \r
            this.loopBtn.addEventListener('mousedown', (e) => {\r
                isMouseDown = true;\r
            });\r
            \r
            this.loopBtn.addEventListener('mouseup', (e) => {\r
                if (isMouseDown) {\r
                    this._toggleLoop();\r
                    e.target.blur();\r
                }\r
                isMouseDown = false;\r
            });\r
            \r
            this.loopBtn.addEventListener('mouseleave', (e) => {\r
                if (isMouseDown) {\r
                    e.target.blur(); // Remove focus if dragged outside\r
                }\r
                isMouseDown = false;\r
            });\r
            \r
            // Keep click handler as fallback\r
            this.loopBtn.addEventListener('click', (e) => {\r
                e.target.blur();\r
            });\r
        }\r
        \r
        // Timeline slider with FIXED alignment\r
        if (this.timeSlider) {\r
            let isDragging = false;\r
            \r
            // Calculate position from mouse event with thumb offset compensation\r
            const getSliderValueFromMouse = (e) => {\r
                const rect = this.timeSlider.getBoundingClientRect();\r
                const thumbWidth = 16; // Width of the slider thumb in pixels\r
                const trackWidth = rect.width - thumbWidth; // Usable track width\r
                const thumbOffset = thumbWidth / 2; // Half thumb width for centering\r
                \r
                // Adjust mouse position relative to the usable track\r
                const adjustedMouseX = e.clientX - rect.left - thumbOffset;\r
                const pos = adjustedMouseX / trackWidth;\r
                const clampedPos = Math.max(0, Math.min(1, pos));\r
                \r
                return clampedPos * 100;\r
            };\r
            \r
            // Mouse down - start scrubbing\r
            this.timeSlider.addEventListener('mousedown', (e) => {\r
                console.log('[AnimationControls] Scrubbing started');\r
                isDragging = true;\r
                this.isScrubbing = true;\r
                this.wasPlayingBeforeScrub = this.isPlaying;\r
                \r
                // Pause animation while scrubbing\r
                if (this.isPlaying) {\r
                    this._pauseForScrubbing();\r
                }\r
                \r
                // Calculate position from mouse click\r
                const sliderValue = getSliderValueFromMouse(e);\r
                this.timeSlider.value = sliderValue;\r
                \r
                console.log('[AnimationControls] Click position:', sliderValue);\r
                \r
                // Immediately seek to clicked position\r
                this._seekToPosition(sliderValue);\r
                \r
                e.preventDefault();\r
                e.stopPropagation();\r
            });\r
            \r
            // Mouse move - continue scrubbing\r
            const handleMouseMove = (e) => {\r
                if (this.isScrubbing && isDragging) {\r
                    const sliderValue = getSliderValueFromMouse(e);\r
                    this.timeSlider.value = sliderValue;\r
                    \r
                    console.log('[AnimationControls] Dragging to position:', sliderValue);\r
                    this._seekToPosition(sliderValue);\r
                    \r
                    e.preventDefault();\r
                }\r
            };\r
            \r
            document.addEventListener('mousemove', handleMouseMove);\r
            \r
            // Handle input event as fallback\r
            this.timeSlider.addEventListener('input', (e) => {\r
                if (this.isScrubbing) {\r
                    console.log('[AnimationControls] Input event scrubbing to:', e.target.value);\r
                    this._seekToPosition(parseFloat(e.target.value));\r
                }\r
            });\r
            \r
            // Global mouse up - end scrubbing\r
            const endScrubbing = (e) => {\r
                if (this.isScrubbing) {\r
                    console.log('[AnimationControls] Scrubbing ended, was playing:', this.wasPlayingBeforeScrub);\r
                    isDragging = false;\r
                    this.isScrubbing = false;\r
                    \r
                    // IMPORTANT: Clear any pending animation updates before resuming\r
                    // This prevents old updates from overriding the seek position\r
                    if (window.worker) {\r
                        // Send one final seek to ensure position is correct\r
                        const finalTime = (this.timeSlider.value / 100) * this.duration;\r
                        window.worker.postMessage({\r
                            type: 'SEEK_ANIMATION',\r
                            data: { time: finalTime }\r
                        });\r
                    }\r
                    \r
                    if (this.wasPlayingBeforeScrub) {\r
                        setTimeout(() => {\r
                            this._resumeFromScrubbing();\r
                        }, 50);\r
                    }\r
                }\r
            };\r
            \r
            document.addEventListener('mouseup', endScrubbing);\r
            \r
            this._cleanupFunctions = this._cleanupFunctions || [];\r
            this._cleanupFunctions.push(() => {\r
                document.removeEventListener('mousemove', handleMouseMove);\r
                document.removeEventListener('mouseup', endScrubbing);\r
            });\r
        }\r
        \r
        // Speed control\r
        if (this.speedControl) {\r
            this.speedControl.addEventListener('change', (e) => {\r
                this.playbackSpeed = parseFloat(e.target.value);\r
                this._updatePlaybackSpeed();\r
                e.target.blur(); // ADD THIS - remove focus after selection\r
            });\r
        }\r
    }\r
\r
    _togglePlayPause() {\r
        console.log('[AnimationControls] Toggle play/pause, currently playing:', this.isPlaying);\r
        \r
        if (this.isPlaying) {\r
            this._pause();\r
        } else {\r
            // If animation ended and not looping, restart from beginning\r
            if (this.currentTime >= this.duration && !this.isLooping) {\r
                console.log('[AnimationControls] Restarting animation from beginning');\r
                this.currentTime = 0; // Update local state immediately\r
                this._seekToPosition(0); // Seek to start\r
                \r
                // Wait for seek to complete, then play\r
                setTimeout(() => {\r
                    // Make sure we're not at the end anymore\r
                    if (this.currentTime < this.duration) {\r
                        this._play();\r
                    }\r
                }, 100); // Longer delay to ensure seek completes\r
            } else {\r
                this._play();\r
            }\r
        }\r
    }\r
\r
    _handleAnimationUpdate(data) {\r
        if (data.currentTime !== undefined && !this.isScrubbing) {\r
            const oldTime = this.currentTime;\r
            this.currentTime = data.currentTime;\r
            \r
            // Detect large time jumps\r
            if (Math.abs(this.currentTime - oldTime) > 0.5 && oldTime > 0) {\r
                console.log('[AnimationControls] WARNING: Large time jump detected!');\r
                console.log('[AnimationControls] Old time:', oldTime.toFixed(3), 'New time:', this.currentTime.toFixed(3));\r
            }\r
            \r
            // Calculate percentage correctly (0-100)\r
            const progress = (this.currentTime / this.duration) * 100;\r
            this.timeSlider.value = progress;\r
            \r
            console.log('[AnimationControls] Animation update - time:', this.currentTime.toFixed(3), 'progress:', progress.toFixed(1), 'ended:', data.ended);\r
            \r
            // Update progress bar\r
            const progressBar = document.getElementById('timeline-progress');\r
            if (progressBar) {\r
                progressBar.style.width = \`\${progress}%\`;\r
            }\r
            \r
            // Update time display\r
            this._updateTimeDisplay();\r
            \r
            // Check if animation ended\r
            if (data.ended && !this.isLooping) {\r
                console.log('[AnimationControls] ===== ANIMATION ENDED =====');\r
                console.log('[AnimationControls] Ending at time:', this.currentTime, 'duration:', this.duration);\r
                \r
                // IMMEDIATELY stop all UI updates\r
                this.isPlaying = false;\r
                this._updatePlayButton();\r
                this._stopUpdateLoop();\r
                \r
                // Wait before reset to ensure worker has stopped\r
                setTimeout(() => {\r
                    if (!this.isPlaying) { // Double-check we're still stopped\r
                        this._resetAnimationToStart();\r
                    }\r
                }, 200);\r
            }\r
        }\r
    }\r
    \r
    _listenForAnimationData() {\r
        if (window.worker) {\r
            window.worker.addEventListener('message', (event) => {\r
                if (event.data.type === 'SCENE_DATA') {\r
                    const sceneData = event.data.data?.sceneData;\r
                    if (sceneData && sceneData.animations) {\r
                        console.log('[AnimationControls] Received scene data with animations:', sceneData.animations);\r
                        this._handleAnimationData(sceneData.animations);\r
                    }\r
                }\r
                \r
                if (event.data.type === 'ANIMATION_UPDATE') {\r
                    this._handleAnimationUpdate(event.data.data);\r
                }\r
                \r
                if (event.data.type === 'ANIMATIONS_READY') {\r
                    console.log('[AnimationControls] Animations ready:', event.data.data);\r
                }\r
                \r
                if (event.data.type === 'ANIMATION_SELECTED') {\r
                    console.log('[AnimationControls] Animation selected in worker:', event.data.data);\r
                }\r
                \r
                if (event.data.type === 'ANIMATION_PLAYING') {\r
                    console.log('[AnimationControls] Animation playing:', event.data.data);\r
                    this.isPlaying = event.data.data.isPlaying;\r
                    this._updatePlayButton();\r
                }\r
                \r
                if (event.data.type === 'ANIMATION_PAUSED') {\r
                    console.log('[AnimationControls] Animation paused:', event.data.data);\r
                    this.isPlaying = event.data.data.isPlaying;\r
                    this._updatePlayButton();\r
                }\r
                \r
                if (event.data.type === 'SKINNED_MESH_UPDATE') {\r
                    // Forward skinned mesh data to parent window\r
                    console.log('[AnimationControls] Received skinned mesh update, vertices:', event.data.data?.vertexCount);\r
                    if (window.sendSkinnedMeshToParent && event.data.data) {\r
                        window.sendSkinnedMeshToParent(event.data.data);\r
                    }\r
                }\r
            });\r
        }\r
    }\r
\r
    _updatePlayButton() {\r
        if (this.playBtn) {\r
            if (this.isPlaying) {\r
                this.playBtn.textContent = '\u23F8\uFE0F';\r
                this.playBtn.title = 'Pause';\r
            } else {\r
                this.playBtn.textContent = '\u25B6\uFE0F';\r
                this.playBtn.title = 'Play';\r
            }\r
        }\r
    }\r
    \r
    _handleAnimationData(animations) {\r
        console.log('[AnimationControls] Received animations:', animations);\r
        \r
        let animationsArray = animations;\r
        if (animations && !Array.isArray(animations)) {\r
            console.log('[AnimationControls] Extracting animations from scene data');\r
            animationsArray = animations.animations || [];\r
        }\r
        \r
        if (!Array.isArray(animationsArray)) {\r
            console.warn('[AnimationControls] Invalid animations data format:', typeof animationsArray);\r
            this._showNoAnimations();\r
            return;\r
        }\r
        \r
        this.animations = animationsArray;\r
        \r
        if (this.animations.length === 0) {\r
            console.log('[AnimationControls] No animations found in data');\r
            this._showNoAnimations();\r
            return;\r
        }\r
        \r
        console.log('[AnimationControls] Processing ' + this.animations.length + ' animations');\r
        \r
        // Populate animation select\r
        this.animationSelect.innerHTML = '';\r
        this.animations.forEach((anim, index) => {\r
            const option = document.createElement('option');\r
            option.value = index;\r
            option.textContent = anim.name || \`Animation \${index + 1}\`;\r
            this.animationSelect.appendChild(option);\r
        });\r
        \r
        // Update list header with count\r
        const listHeader = this.container.querySelector('.list-header');\r
        if (listHeader) {\r
            listHeader.textContent = \`Available Animations (\${this.animations.length})\`;\r
        }\r
        \r
        // Populate animation list\r
        this._renderAnimationList();\r
        \r
        // Enable controls\r
        this._enableControls();\r
        \r
        // Load initial animation state from z3d-json or use defaults\r
        this._loadInitialAnimationState();\r
    }\r
    \r
    _loadInitialAnimationState() {\r
        // Check if we have initial state from parent (z3d-json)\r
        console.log('[AnimationControls] Checking for initial animation state...');\r
        console.log('[AnimationControls] window.initialAnimationState:', window.initialAnimationState);\r
        \r
        // Check if we have a valid initial state with actual animation data\r
        const hasValidState = window.initialAnimationState && \r
                            window.initialAnimationState.currentAnimation !== null &&\r
                            window.initialAnimationState.currentAnimation !== undefined;\r
        \r
        if (hasValidState) {\r
            const state = window.initialAnimationState;\r
            console.log('[AnimationControls] Loading initial animation state from z3d-json:', state);\r
            \r
            // Find animation by name\r
            let animIndex = 0;\r
            if (state.currentAnimation) {\r
                const foundIndex = this.animations.findIndex(a => a.name === state.currentAnimation);\r
                if (foundIndex >= 0) {\r
                    animIndex = foundIndex;\r
                }\r
            }\r
            \r
            // Select the animation (without auto-play and without resetting time)\r
            this._selectAnimation(animIndex, false, true);  // Third param = preserveTime\r
            \r
            // Apply the saved state\r
            if (state.currentTime !== undefined) {\r
                // Convert time to percentage for the seek position\r
                const percentage = (state.currentTime / (this.duration || 1)) * 100;\r
                this._seekToPosition(percentage);\r
            }\r
            \r
            if (state.isLooping !== undefined) {\r
                this.isLooping = state.isLooping;\r
                if (this.loopBtn) {\r
                    this.loopBtn.classList.toggle('active', this.isLooping);\r
                }\r
            }\r
            \r
            if (state.playbackSpeed !== undefined) {\r
                this.playbackSpeed = state.playbackSpeed;\r
                if (this.speedInput) {\r
                    this.speedInput.value = this.playbackSpeed;\r
                }\r
            }\r
            \r
            // Start playing if it was playing\r
            if (state.isPlaying) {\r
                this._play();\r
            }\r
            \r
            // Also check for node visibility\r
            if (window.initialNodeVisibility) {\r
                console.log('[AnimationControls] Applying initial node visibility:', window.initialNodeVisibility);\r
                Object.entries(window.initialNodeVisibility).forEach(([nodeName, visible]) => {\r
                    if (window.worker) {\r
                        window.worker.postMessage({\r
                            type: 'TOGGLE_NODE_VISIBILITY',\r
                            data: { nodeName, visible }\r
                        });\r
                    }\r
                });\r
            }\r
        } else {\r
            // Default: play first animation with all nodes visible\r
            console.log('[AnimationControls] No valid initial state found, using defaults (auto-play first animation)');\r
            this._selectAnimation(0, true); // Auto-play first animation\r
            \r
            // Note: _selectAnimation with autoPlay=true will call _play() which sends the state to parent\r
        }\r
    }\r
    \r
    _sendAnimationStateToParent() {\r
        if (window.opener && !window.opener.closed) {\r
            console.log('[AnimationControls] Sending animation state to parent');\r
            window.opener.postMessage({\r
                type: 'ANIMATION_STATE_CHANGE',\r
                data: {\r
                    currentAnimation: this.currentAnimation?.name,\r
                    currentTime: this.currentTime || 0,\r
                    isPlaying: this.isPlaying,\r
                    isLooping: this.isLooping,\r
                    playbackSpeed: this.playbackSpeed\r
                }\r
            }, '*');\r
        } else {\r
            console.warn('[AnimationControls] No opener window available to send state');\r
        }\r
    }\r
    \r
    _renderAnimationList() {\r
        const listContent = document.getElementById('animation-list-content');\r
        if (!listContent) return;\r
        \r
        if (this.animations.length === 0) {\r
            listContent.innerHTML = '<div class="empty-state">No animations loaded</div>';\r
            return;\r
        }\r
        \r
        let html = '';\r
        this.animations.forEach((anim, index) => {\r
            const isActive = index === this.currentAnimationIndex;\r
            html += \`\r
                <div class="animation-item \${isActive ? 'active' : ''}" data-index="\${index}">\r
                    <span class="anim-icon">\u{1F3AC}</span>\r
                    <span class="anim-name">\${this._escapeHtml(anim.name || \`Animation \${index + 1}\`)}</span>\r
                    <span class="anim-duration">\${this._formatTime(anim.duration)}</span>\r
                </div>\`;\r
        });\r
        \r
        listContent.innerHTML = html;\r
        \r
        // Add click handlers to list items\r
        listContent.querySelectorAll('.animation-item').forEach(item => {\r
            item.addEventListener('click', () => {\r
                const index = parseInt(item.dataset.index);\r
                if (!isNaN(index)) {\r
                    this._selectAnimation(index, true);\r
                }\r
            });\r
        });\r
    }\r
    \r
    _selectAnimation(index, autoPlay = false, preserveTime = false) {\r
        if (index < 0 || index >= this.animations.length) {\r
            console.log('[AnimationControls] Invalid animation index:', index, 'total:', this.animations.length);\r
            return;\r
        }\r
        \r
        console.log('[AnimationControls] Selecting animation:', index, 'autoPlay:', autoPlay, 'preserveTime:', preserveTime);\r
        \r
        this.currentAnimationIndex = index;\r
        this.currentAnimation = this.animations[index];\r
        this.duration = this.currentAnimation.duration || 0;\r
        \r
        // Only reset time if not preserving it\r
        if (!preserveTime) {\r
            this.currentTime = 0;\r
        }\r
        \r
        // Update UI\r
        this.animationSelect.value = index;\r
        \r
        // Update info display\r
        const nameEl = this.container.querySelector('.animation-name');\r
        const durationEl = this.container.querySelector('.animation-duration');\r
        if (nameEl) nameEl.textContent = this.currentAnimation.name || \`Animation \${index + 1}\`;\r
        if (durationEl) durationEl.textContent = this._formatTime(this.duration);\r
        \r
        // FIX: Set slider max to 100 (percentage), not duration * 100\r
        this.timeSlider.max = 100;\r
        this.timeSlider.value = 0;\r
        this._updateTimeDisplay();\r
        \r
        console.log('[AnimationControls] Slider setup - max:', this.timeSlider.max, 'duration:', this.duration);\r
        \r
        // Update list highlighting\r
        this.container.querySelectorAll('.animation-item').forEach(item => {\r
            item.classList.toggle('active', parseInt(item.dataset.index) === index);\r
        });\r
        \r
        // Send to worker\r
        if (window.worker) {\r
            window.worker.postMessage({\r
                type: 'SELECT_ANIMATION',\r
                data: {\r
                    animationId: this.currentAnimation.id,\r
                    animationIndex: index\r
                }\r
            });\r
        }\r
        \r
        console.log('[AnimationControls] Selected animation:', this.currentAnimation.name);\r
        \r
        // Auto-play if requested\r
        if (autoPlay) {\r
            setTimeout(() => {\r
                this._play();\r
            }, 50);\r
        } else {\r
            // If not auto-playing, still notify parent of selection\r
            if (window.opener && !window.opener.closed) {\r
                window.opener.postMessage({\r
                    type: 'ANIMATION_STATE_CHANGE',\r
                data: {\r
                    currentAnimation: this.currentAnimation?.name,\r
                    currentTime: 0,\r
                    isPlaying: false,\r
                    isLooping: this.isLooping,\r
                    playbackSpeed: this.playbackSpeed\r
                }\r
                }, '*');\r
            }\r
        }\r
    }\r
    \r
    _play() {\r
        if (!this.currentAnimation) return;\r
        \r
        console.log('[AnimationControls] ===== STARTING PLAY =====');\r
        console.log('[AnimationControls] Current time:', this.currentTime.toFixed(3));\r
        console.log('[AnimationControls] Duration:', this.duration);\r
        console.log('[AnimationControls] Loop:', this.isLooping);\r
        console.log('[AnimationControls] Worker available:', !!window.worker);\r
        \r
        // Set state immediately\r
        this.isPlaying = true;\r
        this._updatePlayButton();\r
        \r
        // Send play command to worker\r
        if (window.worker) {\r
            console.log('[AnimationControls] Sending PLAY_ANIMATION message to worker');\r
            const message = {\r
                type: 'PLAY_ANIMATION',\r
                data: {\r
                    animationId: this.currentAnimation.id,\r
                    loop: this.isLooping,\r
                    speed: this.playbackSpeed\r
                }\r
            };\r
            console.log('[AnimationControls] Message data:', message);\r
            window.worker.postMessage(message);\r
            console.log('[AnimationControls] PLAY_ANIMATION message sent');\r
        } else {\r
            console.error('[AnimationControls] No worker available for playing!');\r
        }\r
        \r
        // Start update loop\r
        this._startUpdateLoop();\r
        \r
        // Notify parent of state change\r
        if (window.opener && !window.opener.closed) {\r
            window.opener.postMessage({\r
            type: 'ANIMATION_STATE_CHANGE',\r
            data: {\r
                currentAnimation: this.currentAnimation?.name,\r
                currentTime: this.currentTime,\r
                isPlaying: true,\r
                isLooping: this.isLooping,\r
                playbackSpeed: this.playbackSpeed\r
            }\r
            }, '*');\r
        }\r
    }\r
    \r
    _pause() {\r
        console.log('[AnimationControls] Pausing at time:', this.currentTime.toFixed(3));\r
        \r
        this.isPlaying = false;\r
        this._updatePlayButton();\r
        \r
        // Send pause command to worker\r
        if (window.worker) {\r
            window.worker.postMessage({\r
                type: 'PAUSE_ANIMATION',\r
                data: {}\r
            });\r
        }\r
        \r
        this._stopUpdateLoop();\r
        \r
        // Notify parent of state change\r
        if (window.opener && !window.opener.closed) {\r
            window.opener.postMessage({\r
            type: 'ANIMATION_STATE_CHANGE',\r
            data: {\r
                currentAnimation: this.currentAnimation?.name,\r
                currentTime: this.currentTime,\r
                isPlaying: false,\r
                isLooping: this.isLooping,\r
                playbackSpeed: this.playbackSpeed\r
            }\r
            }, '*');\r
        }\r
    }\r
    \r
    _pauseForScrubbing() {\r
        // Pause without updating UI state (we'll resume automatically)\r
        if (window.worker) {\r
            window.worker.postMessage({\r
                type: 'PAUSE_ANIMATION',\r
                data: {}\r
            });\r
        }\r
    }\r
    \r
    _resumeFromScrubbing() {\r
        // Resume from current scrubbed position\r
        this.isPlaying = true;\r
        this._updatePlayButton();\r
        \r
        if (window.worker) {\r
            window.worker.postMessage({\r
                type: 'PLAY_ANIMATION',\r
                data: {\r
                    animationId: this.currentAnimation.id,\r
                    loop: this.isLooping,\r
                    speed: this.playbackSpeed\r
                }\r
            });\r
        }\r
        \r
        this._startUpdateLoop();\r
    }\r
    \r
    _togglePlayPause() {\r
        console.log('[AnimationControls] Toggle play/pause, currently playing:', this.isPlaying);\r
        \r
        if (this.isPlaying) {\r
            this._pause();\r
        } else {\r
            // Just play from current position (auto-reset handles going to start)\r
            this._play();\r
        }\r
    }\r
    \r
    _toggleLoop() {\r
        this.isLooping = !this.isLooping;\r
        this.loopBtn.classList.toggle('active', this.isLooping);\r
        \r
        console.log('[AnimationControls] Loop toggled to:', this.isLooping);\r
        \r
        // Send loop setting to worker\r
        if (window.worker) {\r
            window.worker.postMessage({\r
                type: 'SET_ANIMATION_LOOP',\r
                data: { loop: this.isLooping }\r
            });\r
        }\r
        \r
        // Notify parent of state change\r
        if (window.opener && !window.opener.closed) {\r
            window.opener.postMessage({\r
            type: 'ANIMATION_STATE_CHANGE',\r
            data: {\r
                currentAnimation: this.currentAnimation?.name,\r
                currentTime: this.currentTime,\r
                isPlaying: this.isPlaying,\r
                isLooping: this.isLooping,\r
                playbackSpeed: this.playbackSpeed\r
            }\r
            }, '*');\r
        }\r
    }\r
    \r
    _seekToPosition(value) {\r
        // Value is 0-100 percentage, convert to time\r
        const time = (value / 100) * this.duration;\r
        this.currentTime = time;\r
        \r
        console.log('[AnimationControls] ===== SEEKING =====');\r
        console.log('[AnimationControls] Percentage:', value.toFixed(1), 'Time:', time.toFixed(3), 'Duration:', this.duration);\r
        console.log('[AnimationControls] Worker available:', !!window.worker);\r
        \r
        // Update display immediately\r
        this._updateTimeDisplay();\r
        \r
        // Update progress bar immediately\r
        const progressBar = document.getElementById('timeline-progress');\r
        if (progressBar) {\r
            progressBar.style.width = \`\${value}%\`;\r
        }\r
        \r
        // Send seek command to worker\r
        if (window.worker) {\r
            console.log('[AnimationControls] Sending SEEK_ANIMATION message to worker');\r
            window.worker.postMessage({\r
                type: 'SEEK_ANIMATION',\r
                data: { time: time }\r
            });\r
            console.log('[AnimationControls] SEEK_ANIMATION message sent');\r
        } else {\r
            console.error('[AnimationControls] No worker available for seeking!');\r
        }\r
        \r
        // Notify parent of state change\r
        if (window.opener && !window.opener.closed) {\r
            window.opener.postMessage({\r
            type: 'ANIMATION_STATE_CHANGE',\r
            data: {\r
                currentAnimation: this.currentAnimation?.name,\r
                currentTime: time,\r
                isPlaying: this.isPlaying,\r
                isLooping: this.isLooping,\r
                playbackSpeed: this.playbackSpeed\r
            }\r
            }, '*');\r
        }\r
    }\r
    \r
    _updatePlaybackSpeed() {\r
        // Send speed update to worker\r
        if (window.worker) {\r
            window.worker.postMessage({\r
                type: 'SET_ANIMATION_SPEED',\r
                data: { speed: this.playbackSpeed }\r
            });\r
        }\r
    }\r
    \r
    _startUpdateLoop() {\r
        this._stopUpdateLoop();\r
        \r
        this.updateInterval = setInterval(() => {\r
            // CRITICAL: Don't request updates while scrubbing!\r
            if (!this.isScrubbing && this.isPlaying) {\r
                // Request current time from worker\r
                if (window.worker) {\r
                    window.worker.postMessage({\r
                        type: 'GET_ANIMATION_TIME',\r
                        data: {}\r
                    });\r
                }\r
            }\r
        }, 50);\r
    }\r
    \r
    _stopUpdateLoop() {\r
        if (this.updateInterval) {\r
            clearInterval(this.updateInterval);\r
            this.updateInterval = null;\r
        }\r
    }\r
    \r
    _handleAnimationUpdate(data) {\r
        // CRITICAL: Ignore updates while scrubbing\r
        if (this.isScrubbing) {\r
            console.log('[AnimationControls] Ignoring animation update while scrubbing');\r
            return;\r
        }\r
        \r
        if (data.currentTime !== undefined) {\r
            const oldTime = this.currentTime;\r
            this.currentTime = data.currentTime;\r
            \r
            // Detect large time jumps\r
            if (Math.abs(this.currentTime - oldTime) > 0.5 && oldTime > 0) {\r
                console.warn('[AnimationControls] WARNING: Large time jump detected!');\r
                console.log('[AnimationControls] Old time:', oldTime.toFixed(3), 'New time:', this.currentTime.toFixed(3));\r
            }\r
            \r
            // Calculate percentage correctly (0-100)\r
            const progress = (this.currentTime / this.duration) * 100;\r
            this.timeSlider.value = progress;\r
            \r
            console.log('[AnimationControls] Animation update - time:', this.currentTime.toFixed(3), 'duration:', this.duration, 'progress:', progress.toFixed(1));\r
            \r
            // Update progress bar\r
            const progressBar = document.getElementById('timeline-progress');\r
            if (progressBar) {\r
                progressBar.style.width = \`\${progress}%\`;\r
            }\r
            \r
            // Update time display\r
            this._updateTimeDisplay();\r
            \r
            // Check if animation ended\r
            if (data.ended && !this.isLooping) {\r
                console.log('[AnimationControls] Animation ended (no loop), stopping and resetting');\r
                \r
                // IMMEDIATELY stop playing state to prevent extra updates\r
                this.isPlaying = false;\r
                this._updatePlayButton();\r
                this._stopUpdateLoop();\r
                \r
                // Reset to start after a short delay to avoid timing conflicts\r
                setTimeout(() => {\r
                    this._resetAnimationToStart();\r
                }, 100);\r
            }\r
        }\r
    }\r
\r
    _resetAnimationToStart() {\r
        console.log('[AnimationControls] ===== RESETTING TO START =====');\r
        console.log('[AnimationControls] Current state - playing:', this.isPlaying, 'time:', this.currentTime);\r
        \r
        // Ensure we're definitely stopped\r
        this.isPlaying = false;\r
        this._updatePlayButton();\r
        this._stopUpdateLoop();\r
        \r
        // Update UI to show start position\r
        this.currentTime = 0;\r
        this.timeSlider.value = 0;\r
        \r
        // Update progress bar to start\r
        const progressBar = document.getElementById('timeline-progress');\r
        if (progressBar) {\r
            progressBar.style.width = '0%';\r
        }\r
        \r
        // Update time display\r
        this._updateTimeDisplay();\r
        \r
        // Tell worker to seek to beginning\r
        if (window.worker) {\r
            console.log('[AnimationControls] Sending reset SEEK_ANIMATION to worker');\r
            window.worker.postMessage({\r
                type: 'SEEK_ANIMATION',\r
                data: { time: 0 }\r
            });\r
            console.log('[AnimationControls] Reset SEEK_ANIMATION sent');\r
        } else {\r
            console.error('[AnimationControls] No worker available for reset!');\r
        }\r
        \r
        console.log('[AnimationControls] Reset complete - ready for next play');\r
    }\r
    \r
    _updateTimeDisplay() {\r
        if (this.currentTimeDisplay) {\r
            this.currentTimeDisplay.textContent = this._formatTime(this.currentTime);\r
        }\r
        if (this.durationDisplay) {\r
            this.durationDisplay.textContent = this._formatTime(this.duration);\r
        }\r
    }\r
    \r
    _formatTime(seconds) {\r
        if (!seconds || isNaN(seconds)) return '0:00';\r
        \r
        const mins = Math.floor(seconds / 60);\r
        const secs = Math.floor(seconds % 60);\r
        const ms = Math.floor((seconds % 1) * 100);\r
        \r
        return \`\${mins}:\${secs.toString().padStart(2, '0')}.\${ms.toString().padStart(2, '0')}\`;\r
    }\r
    \r
    _enableControls() {\r
        this.animationSelect.disabled = false;\r
        this.playBtn.disabled = false;\r
        this.loopBtn.disabled = false;\r
        this.timeSlider.disabled = false;\r
        this.speedControl.disabled = false;\r
    }\r
    \r
    _showNoAnimations() {\r
        this.animationSelect.innerHTML = '<option value="">No animations</option>';\r
        this.animationSelect.disabled = true;\r
        this.playBtn.disabled = true;\r
        this.loopBtn.disabled = true;\r
        this.timeSlider.disabled = true;\r
        this.speedControl.disabled = true;\r
        \r
        const nameEl = this.container.querySelector('.animation-name');\r
        const durationEl = this.container.querySelector('.animation-duration');\r
        if (nameEl) nameEl.textContent = 'No animations';\r
        if (durationEl) durationEl.textContent = '0:00';\r
    }\r
    \r
    _escapeHtml(text) {\r
        const div = document.createElement('div');\r
        div.textContent = text;\r
        return div.innerHTML;\r
    }\r
    \r
    dispose() {\r
        this._stopUpdateLoop();\r
        \r
        // Clean up global event listeners\r
        if (this._cleanupFunctions) {\r
            this._cleanupFunctions.forEach(cleanup => cleanup());\r
            this._cleanupFunctions = [];\r
        }\r
        \r
        if (this.container) {\r
            this.container.innerHTML = '';\r
        }\r
        this.isInitialized = false;\r
        this.isDisposed = true;\r
        console.log('[AnimationControls] Disposed');\r
    }\r
}`,
        "textureControls": `/* FILE: editor/z3d-object-editor/templates/scripts/components/texture-controls.js */\r
/* Texture Viewer and Controls */\r
\r
class TextureControls extends EventEmitter {\r
    constructor(config) {\r
        super();\r
        this.config = config;\r
        this.isInitialized = false;\r
        \r
        // Texture state\r
        this.textures = [];\r
        this.currentTexture = null;\r
        this.currentTextureIndex = 0;\r
        \r
        // Zoom state\r
        this.zoomLevel = 1;\r
        this.minZoom = 0.1;\r
        this.maxZoom = 10;\r
        this.panX = 0;\r
        this.panY = 0;\r
        this.isPanning = false;\r
        \r
        // UI elements\r
        this.container = null;\r
        this.textureSelect = null;\r
        this.canvas = null;\r
        this.ctx = null;\r
        this.imageElement = null;\r
    }\r
    \r
    async initialize(container) {\r
        if (!container) {\r
            console.error('[TextureControls] No container provided');\r
            return;\r
        }\r
        \r
        this.container = container;\r
        this._render();\r
        this._setupEventListeners();\r
        this._listenForTextureData();\r
        this._setupResizeObserver(); // Add this\r
        \r
        this.isInitialized = true;\r
        console.log('[TextureControls] \u2705 Initialized');\r
    }\r
    \r
    _render() {\r
        this.container.innerHTML = \`\r
            <div class="texture-controls">\r
                <!-- Texture Selection -->\r
                <div class="texture-header">\r
                    <select id="texture-select" class="texture-select" disabled>\r
                        <option value="">No textures</option>\r
                    </select>\r
                    <div class="texture-info">\r
                        <span class="texture-name">No texture selected</span>\r
                        <div class="texture-stats">\r
                            <span class="texture-format">-</span>\r
                            <span class="texture-dimensions">-</span>\r
                            <span class="texture-size">-</span>\r
                        </div>\r
                    </div>\r
                </div>\r
                \r
                <!-- Texture Viewer -->\r
                <div class="texture-viewer">\r
                    <div class="viewer-controls">\r
                        <button id="zoom-in-btn" class="zoom-btn" title="Zoom In">\u{1F50D}</button>\r
                        <button id="zoom-out-btn" class="zoom-btn" title="Zoom Out">\u{1F50D}</button>\r
                        <button id="zoom-reset-btn" class="zoom-btn" title="Reset View">\u{1F504}</button>\r
                        <button id="pixel-mode-btn" class="zoom-btn" title="Toggle Pixel Art Mode">\u26A1</button>\r
                        <span class="zoom-level">100%</span>\r
                    </div>\r
                    <div class="canvas-container" id="texture-canvas-container">\r
                        <canvas id="texture-canvas" class="texture-canvas"></canvas>\r
                        <div class="texture-placeholder">\r
                            <span>\u{1F5BC}\uFE0F</span>\r
                            <span>No texture loaded</span>\r
                        </div>\r
                    </div>\r
                </div>\r
                \r
                <!-- Texture List -->\r
                <div class="texture-list" id="texture-list">\r
                    <div class="list-header">Available Textures</div>\r
                    <div class="list-content" id="texture-list-content">\r
                        <div class="empty-state">No textures loaded</div>\r
                    </div>\r
                </div>\r
            </div>\`;\r
        \r
        // Cache UI elements\r
        this.textureSelect = document.getElementById('texture-select');\r
        this.canvas = document.getElementById('texture-canvas');\r
        this.ctx = this.canvas.getContext('2d');\r
        \r
        // Hide canvas initially\r
        this.canvas.style.display = 'none';\r
        \r
        // Initialize pixel mode state\r
        this.pixelMode = false;\r
    }\r
    \r
    _setupEventListeners() {\r
        // Texture selection\r
        if (this.textureSelect) {\r
            this.textureSelect.addEventListener('change', (e) => {\r
                const index = parseInt(e.target.value);\r
                if (!isNaN(index)) {\r
                    this._selectTexture(index);\r
                }\r
            });\r
        }\r
        \r
        // Zoom buttons\r
        const zoomInBtn = document.getElementById('zoom-in-btn');\r
        const zoomOutBtn = document.getElementById('zoom-out-btn');\r
        const zoomResetBtn = document.getElementById('zoom-reset-btn');\r
        const pixelModeBtn = document.getElementById('pixel-mode-btn');\r
        \r
        if (zoomInBtn) {\r
            zoomInBtn.addEventListener('click', () => this._zoomIn());\r
        }\r
        if (zoomOutBtn) {\r
            zoomOutBtn.addEventListener('click', () => this._zoomOut());\r
        }\r
        if (zoomResetBtn) {\r
            zoomResetBtn.addEventListener('click', () => this._resetView());\r
        }\r
        \r
        // ADD: Pixel mode toggle\r
        if (pixelModeBtn) {\r
            pixelModeBtn.addEventListener('click', () => this._togglePixelMode());\r
        }\r
        \r
        // Canvas mouse events for pan and zoom\r
        if (this.canvas) {\r
            this.canvas.addEventListener('wheel', (e) => {\r
                e.preventDefault();\r
                \r
                // Get mouse position relative to canvas\r
                const rect = this.canvas.getBoundingClientRect();\r
                const mouseX = e.clientX - rect.left;\r
                const mouseY = e.clientY - rect.top;\r
                \r
                // Convert mouse position to canvas coordinates\r
                const canvasX = mouseX - this.canvas.width / 2;\r
                const canvasY = mouseY - this.canvas.height / 2;\r
                \r
                // Calculate world position before zoom\r
                const worldX = (canvasX - this.panX) / this.zoomLevel;\r
                const worldY = (canvasY - this.panY) / this.zoomLevel;\r
                \r
                // Apply zoom\r
                const delta = e.deltaY > 0 ? 0.9 : 1.1;\r
                const newZoom = Math.max(0.1, Math.min(10, this.zoomLevel * delta));\r
                \r
                // Calculate new pan to keep the same world point under the cursor\r
                this.panX = canvasX - worldX * newZoom;\r
                this.panY = canvasY - worldY * newZoom;\r
                \r
                this.zoomLevel = newZoom;\r
                this._redrawCanvas();\r
            });\r
            \r
            // Pan with mouse drag\r
            let lastX = 0;\r
            let lastY = 0;\r
            \r
            this.canvas.addEventListener('mousedown', (e) => {\r
                this.isPanning = true;\r
                lastX = e.clientX;\r
                lastY = e.clientY;\r
                this.canvas.style.cursor = 'grabbing';\r
            });\r
            \r
            window.addEventListener('mousemove', (e) => {\r
                if (!this.isPanning) return;\r
                \r
                const deltaX = e.clientX - lastX;\r
                const deltaY = e.clientY - lastY;\r
                \r
                this.panX += deltaX;\r
                this.panY += deltaY;\r
                \r
                lastX = e.clientX;\r
                lastY = e.clientY;\r
                \r
                this._redrawCanvas();\r
            });\r
            \r
            window.addEventListener('mouseup', () => {\r
                this.isPanning = false;\r
                this.canvas.style.cursor = 'grab';\r
            });\r
            \r
            // Double-click to reset\r
            this.canvas.addEventListener('dblclick', () => {\r
                this._resetView();\r
            });\r
        }\r
    }\r
    \r
    _listenForTextureData() {\r
        // Listen for scene data from worker\r
        if (window.worker) {\r
            window.worker.addEventListener('message', (event) => {\r
                if (event.data.type === 'SCENE_DATA') {\r
                    const sceneData = event.data.data?.sceneData;\r
                    if (sceneData && sceneData.textures) {\r
                        this._handleTextureData(sceneData.textures);\r
                    }\r
                }\r
                \r
                // Listen for texture image data\r
                if (event.data.type === 'TEXTURE_IMAGE_DATA') {\r
                    this._handleTextureImageData(event.data.data);\r
                }\r
            });\r
        }\r
    }\r
    // Public method for external use\r
    setTextureData(textures) {\r
        this._handleTextureData(textures);\r
    }\r
    \r
    _handleTextureData(textures) {\r
        console.log('[TextureControls] Received textures:', textures);\r
        this.textures = textures;\r
        \r
        if (textures.length === 0) {\r
            this._showNoTextures();\r
            return;\r
        }\r
        \r
        // Populate texture select\r
        this.textureSelect.innerHTML = '';\r
        textures.forEach((texture, index) => {\r
            const option = document.createElement('option');\r
            option.value = index;\r
            option.textContent = texture.name || \`Texture \${index + 1}\`;\r
            this.textureSelect.appendChild(option);\r
        });\r
        \r
        // Populate texture list\r
        this._renderTextureList();\r
        \r
        // Enable controls\r
        this._enableControls();\r
        \r
        // Auto-select first texture with a small delay to ensure worker is ready\r
        if (textures.length > 0) {\r
            console.log('[TextureControls] Auto-selecting first texture');\r
            this.textureSelect.value = 0;\r
            \r
            // Add a small delay to ensure worker is available\r
            setTimeout(() => {\r
                console.log('[TextureControls] Delayed auto-select executing');\r
                this._selectTexture(0);\r
            }, 100);\r
        }\r
    }\r
    \r
    _renderTextureList() {\r
        const listContent = document.getElementById('texture-list-content');\r
        if (!listContent) return;\r
        \r
        if (this.textures.length === 0) {\r
            listContent.innerHTML = '<div class="empty-state">No textures loaded</div>';\r
            return;\r
        }\r
        \r
        let html = '';\r
        this.textures.forEach((texture, index) => {\r
            const isActive = index === this.currentTextureIndex;\r
            const dimensions = texture.image ? \`\${texture.image.width}\xD7\${texture.image.height}\` : 'Unknown';\r
            \r
            html += \`\r
                <div class="texture-item \${isActive ? 'active' : ''}" data-index="\${index}">\r
                    <span class="tex-icon">\u{1F5BC}\uFE0F</span>\r
                    <span class="tex-name">\${this._escapeHtml(texture.name || \`Texture \${index + 1}\`)}</span>\r
                    <span class="tex-info">\${dimensions}</span>\r
                    <span class="tex-type">\${texture.type || 'map'}</span>\r
                </div>\`;\r
        });\r
        \r
        listContent.innerHTML = html;\r
        \r
        // Add click handlers to list items\r
        listContent.querySelectorAll('.texture-item').forEach(item => {\r
            item.addEventListener('click', () => {\r
                const index = parseInt(item.dataset.index);\r
                if (!isNaN(index)) {\r
                    this._selectTexture(index);\r
                }\r
            });\r
        });\r
    }\r
    \r
    _selectTexture(index) {\r
        if (index < 0 || index >= this.textures.length) return;\r
        \r
        this.currentTextureIndex = index;\r
        this.currentTexture = this.textures[index];\r
        \r
        // Update UI\r
        this.textureSelect.value = index;\r
        \r
        // Update info display\r
        const nameEl = this.container.querySelector('.texture-name');\r
        const formatEl = this.container.querySelector('.texture-format');\r
        const dimensionsEl = this.container.querySelector('.texture-dimensions');\r
        const sizeEl = this.container.querySelector('.texture-size');\r
        \r
        if (nameEl) nameEl.textContent = this.currentTexture.name || \`Texture \${index + 1}\`;\r
        if (formatEl) formatEl.textContent = this._getTextureFormat(this.currentTexture);\r
        if (dimensionsEl) {\r
            const dims = this.currentTexture.image \r
                ? \`\${this.currentTexture.image.width}\xD7\${this.currentTexture.image.height}px\`\r
                : 'Unknown';\r
            dimensionsEl.textContent = dims;\r
        }\r
        if (sizeEl) {\r
            sizeEl.textContent = this._estimateTextureSize(this.currentTexture);\r
        }\r
        \r
        // Update list highlighting\r
        this.container.querySelectorAll('.texture-item').forEach(item => {\r
            item.classList.toggle('active', parseInt(item.dataset.index) === index);\r
        });\r
        \r
        // Request texture image from worker - FIXED\r
        if (window.worker && this.currentTexture) {\r
            const textureId = this.currentTexture.id || this.currentTexture.uuid;\r
            \r
            console.log('[TextureControls] Requesting texture image:', {\r
                textureId: textureId,\r
                textureName: this.currentTexture.name,\r
                textureType: this.currentTexture.type\r
            });\r
            \r
            window.worker.postMessage({\r
                type: 'GET_TEXTURE_IMAGE',\r
                data: {\r
                    textureId: textureId  // Use the UUID as the ID\r
                }\r
            });\r
        }\r
        \r
        // Show loading state\r
        this._showTextureLoading();\r
        \r
        console.log('[TextureControls] Selected texture:', this.currentTexture.name);\r
    }\r
    \r
    _handleTextureImageData(data) {\r
        console.log('[TextureControls] Received texture image data:', {\r
            hasData: !!data,\r
            hasImageData: !!(data && data.imageData),\r
            hasError: !!(data && data.error)\r
        });\r
        \r
        if (!data) {\r
            console.warn('[TextureControls] No data received');\r
            this._showTextureError('No data received');\r
            return;\r
        }\r
        \r
        if (data.error) {\r
            console.error('[TextureControls] Error loading texture:', data.error);\r
            this._showTextureError(data.error);\r
            return;\r
        }\r
        \r
        if (!data.imageData) {\r
            console.warn('[TextureControls] No image data in response');\r
            this._showTextureError('No image data available');\r
            return;\r
        }\r
        \r
        // Create image from data URL\r
        this.imageElement = new Image();\r
        this.imageElement.onload = () => {\r
            console.log('[TextureControls] Image loaded successfully:', \r
                this.imageElement.width, 'x', this.imageElement.height);\r
            this._displayTexture();\r
        };\r
        this.imageElement.onerror = (error) => {\r
            console.error('[TextureControls] Failed to load image:', error);\r
            this._showTextureError('Failed to load image');\r
        };\r
        \r
        // Set the image source\r
        this.imageElement.src = data.imageData;\r
    }\r
    \r
    _displayTexture() {\r
        console.log('[TextureControls] _displayTexture called');\r
        \r
        if (!this.imageElement || !this.canvas) {\r
            console.error('[TextureControls] Missing imageElement or canvas:', {\r
                hasImageElement: !!this.imageElement,\r
                hasCanvas: !!this.canvas\r
            });\r
            return;\r
        }\r
        \r
        // Show canvas, hide placeholder\r
        console.log('[TextureControls] Showing canvas, hiding placeholder');\r
        this.canvas.style.display = 'block';\r
        \r
        const placeholder = this.container.querySelector('.texture-placeholder');\r
        if (placeholder) {\r
            console.log('[TextureControls] Hiding placeholder');\r
            placeholder.style.display = 'none';\r
        }\r
        \r
        // Update canvas size when displaying\r
        this._updateCanvasSize();\r
        \r
        console.log('[TextureControls] Canvas display complete');\r
    }\r
\r
    _updateCanvasSize() {\r
        const container = document.getElementById('texture-canvas-container');\r
        if (!container) return;\r
        \r
        let width = container.clientWidth;\r
        let height = container.clientHeight;\r
        \r
        // If height is 0, try again after a delay\r
        if (height === 0) {\r
            console.warn('[TextureControls] Container has 0 height, retrying...');\r
            setTimeout(() => {\r
                this._updateCanvasSize();\r
            }, 100);\r
            return;\r
        }\r
        \r
        // Only update if size actually changed\r
        if (this.canvas.width !== width || this.canvas.height !== height) {\r
            this.canvas.width = width;\r
            this.canvas.height = height;\r
            console.log('[TextureControls] Canvas sized to:', width, 'x', height);\r
            \r
            // Recalculate zoom to maintain aspect ratio\r
            this._resetView();\r
        }\r
    }\r
\r
    _togglePixelMode() {\r
        this.pixelMode = !this.pixelMode;\r
        \r
        const pixelModeBtn = document.getElementById('pixel-mode-btn');\r
        \r
        if (this.pixelMode) {\r
            this.canvas.classList.add('pixel-art');\r
            pixelModeBtn.classList.add('active');\r
            pixelModeBtn.title = 'Disable Pixel Art Mode';\r
            console.log('[TextureControls] Pixel art mode enabled');\r
        } else {\r
            this.canvas.classList.remove('pixel-art');\r
            pixelModeBtn.classList.remove('active');\r
            pixelModeBtn.title = 'Enable Pixel Art Mode';\r
            console.log('[TextureControls] Pixel art mode disabled');\r
        }\r
        \r
        // Update the canvas rendering context\r
        if (this.ctx) {\r
            this.ctx.imageSmoothingEnabled = !this.pixelMode;\r
            this.ctx.mozImageSmoothingEnabled = !this.pixelMode;\r
            this.ctx.webkitImageSmoothingEnabled = !this.pixelMode;\r
            this.ctx.msImageSmoothingEnabled = !this.pixelMode;\r
        }\r
        \r
        // Redraw the canvas with new settings\r
        if (this.imageElement) {\r
            this._redrawCanvas();\r
        }\r
    }\r
\r
    // Add a resize observer to handle container size changes\r
    _setupResizeObserver() {\r
        const container = document.getElementById('texture-canvas-container');\r
        if (!container) return;\r
        \r
        // Use ResizeObserver if available\r
        if (window.ResizeObserver) {\r
            this.resizeObserver = new ResizeObserver(() => {\r
                if (this.canvas && this.imageElement) {\r
                    this._updateCanvasSize();\r
                }\r
            });\r
            this.resizeObserver.observe(container);\r
        } else {\r
            // Fallback to window resize event\r
            this._handleResize = () => {\r
                if (this.canvas && this.imageElement) {\r
                    this._updateCanvasSize();\r
                }\r
            };\r
            window.addEventListener('resize', this._handleResize);\r
        }\r
    }\r
\r
    _resetView() {\r
        console.log('[TextureControls] _resetView called');\r
        \r
        this.zoomLevel = 1;\r
        this.panX = 0;\r
        this.panY = 0;\r
        \r
        // Fit image to canvas while preserving aspect ratio\r
        if (this.imageElement && this.canvas) {\r
            const canvasWidth = this.canvas.width;\r
            const canvasHeight = this.canvas.height;\r
            const imageWidth = this.imageElement.width;\r
            const imageHeight = this.imageElement.height;\r
            \r
            // Calculate scale to fit image within canvas\r
            const scaleX = canvasWidth / imageWidth;\r
            const scaleY = canvasHeight / imageHeight;\r
            \r
            // Use the smaller scale to ensure entire image fits\r
            this.zoomLevel = Math.min(scaleX, scaleY) * 0.9; // 90% to add padding\r
            \r
            console.log('[TextureControls] Calculated zoom level:', this.zoomLevel, {\r
                canvasSize: \`\${canvasWidth}x\${canvasHeight}\`,\r
                imageSize: \`\${imageWidth}x\${imageHeight}\`,\r
                scaleX,\r
                scaleY\r
            });\r
        }\r
        \r
        this._redrawCanvas();\r
    }\r
\r
    _redrawCanvas() {\r
        console.log('[TextureControls] _redrawCanvas called');\r
        \r
        if (!this.ctx || !this.imageElement) {\r
            console.error('[TextureControls] Missing ctx or imageElement:', {\r
                hasCtx: !!this.ctx,\r
                hasImageElement: !!this.imageElement\r
            });\r
            return;\r
        }\r
        \r
        // Set image smoothing based on pixel mode\r
        this.ctx.imageSmoothingEnabled = !this.pixelMode;\r
        this.ctx.mozImageSmoothingEnabled = !this.pixelMode;\r
        this.ctx.webkitImageSmoothingEnabled = !this.pixelMode;\r
        this.ctx.msImageSmoothingEnabled = !this.pixelMode;\r
        \r
        // Clear entire canvas with background\r
        this.ctx.fillStyle = '#1a1a1a';\r
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r
        \r
        // Draw checkerboard pattern for transparency visualization\r
        this._drawCheckerboard();\r
        \r
        // Save context state\r
        this.ctx.save();\r
        \r
        // Center the image in the canvas\r
        this.ctx.translate(this.canvas.width / 2 + this.panX, this.canvas.height / 2 + this.panY);\r
        this.ctx.scale(this.zoomLevel, this.zoomLevel);\r
        \r
        // Draw image centered at origin\r
        this.ctx.drawImage(\r
            this.imageElement,\r
            -this.imageElement.width / 2,\r
            -this.imageElement.height / 2\r
        );\r
        \r
        console.log('[TextureControls] Drew image at zoom:', this.zoomLevel, 'pixelMode:', this.pixelMode);\r
        \r
        // Restore context state\r
        this.ctx.restore();\r
        \r
        // Update zoom level display\r
        const zoomDisplay = this.container.querySelector('.zoom-level');\r
        if (zoomDisplay) {\r
            zoomDisplay.textContent = \`\${Math.round(this.zoomLevel * 100)}%\`;\r
        }\r
    }\r
\r
    _drawCheckerboard() {\r
        // Draw a subtle checkerboard pattern for transparency\r
        const size = 20;\r
        const cols = Math.ceil(this.canvas.width / size);\r
        const rows = Math.ceil(this.canvas.height / size);\r
        \r
        this.ctx.fillStyle = '#242424';\r
        for (let row = 0; row < rows; row++) {\r
            for (let col = 0; col < cols; col++) {\r
                if ((row + col) % 2 === 0) {\r
                    this.ctx.fillRect(col * size, row * size, size, size);\r
                }\r
            }\r
        }\r
    }\r
    \r
    _zoom(factor, centerX, centerY) {\r
        const newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoomLevel * factor));\r
        \r
        if (centerX !== undefined && centerY !== undefined) {\r
            // Zoom toward mouse position\r
            const scale = newZoom / this.zoomLevel;\r
            this.panX = centerX - (centerX - this.panX) * scale;\r
            this.panY = centerY - (centerY - this.panY) * scale;\r
        }\r
        \r
        this.zoomLevel = newZoom;\r
        this._redrawCanvas();\r
    }\r
    \r
    _zoomIn() {\r
        const centerX = this.canvas.width / 2;\r
        const centerY = this.canvas.height / 2;\r
        this._zoomToPoint(centerX, centerY, 1.2);\r
    }\r
\r
    _zoomOut() {\r
        const centerX = this.canvas.width / 2;\r
        const centerY = this.canvas.height / 2;\r
        this._zoomToPoint(centerX, centerY, 0.8);\r
    }\r
\r
    // Add a helper method for zooming to a specific point:\r
    _zoomToPoint(screenX, screenY, multiplier) {\r
        // Convert screen position to canvas coordinates\r
        const canvasX = screenX - this.canvas.width / 2;\r
        const canvasY = screenY - this.canvas.height / 2;\r
        \r
        // Calculate world position before zoom\r
        const worldX = (canvasX - this.panX) / this.zoomLevel;\r
        const worldY = (canvasY - this.panY) / this.zoomLevel;\r
        \r
        // Apply zoom\r
        const newZoom = Math.max(0.1, Math.min(10, this.zoomLevel * multiplier));\r
        \r
        // Calculate new pan to keep the same world point at the screen position\r
        this.panX = canvasX - worldX * newZoom;\r
        this.panY = canvasY - worldY * newZoom;\r
        \r
        this.zoomLevel = newZoom;\r
        this._redrawCanvas();\r
    }\r
    \r
    _getTextureFormat(texture) {\r
        // Try to determine format from various properties\r
        if (texture.format) {\r
            const formatMap = {\r
                1023: 'RGBA',           // RGBAFormat - 4 channels (most common)\r
                1022: 'RGB',            // RGBFormat - 3 channels (no transparency)\r
                1024: 'Alpha',          // AlphaFormat - 1 channel (grayscale for transparency)\r
                1025: 'Luminance',      // LuminanceFormat - 1 channel (grayscale)\r
                1026: 'LuminanceAlpha', // LuminanceAlphaFormat - 2 channels\r
                1020: 'Depth',          // DepthFormat\r
                1021: 'DepthStencil',   // DepthStencilFormat\r
                1027: 'Red',            // RedFormat - 1 channel\r
                1028: 'RG',             // RGFormat - 2 channels\r
                1030: 'RedInteger',     // RedIntegerFormat\r
                1031: 'RGInteger',      // RGIntegerFormat\r
                1032: 'RGBAInteger'     // RGBAIntegerFormat\r
            };\r
            return formatMap[texture.format] || 'Unknown';\r
        }\r
        \r
        if (texture.image && texture.image.src) {\r
            const ext = texture.image.src.split('.').pop().toLowerCase();\r
            return ext.toUpperCase();\r
        }\r
        \r
        return 'Unknown';\r
    }\r
    \r
    _estimateTextureSize(texture) {\r
        if (!texture.image || !texture.image.width || !texture.image.height) {\r
            return 'Unknown';\r
        }\r
        \r
        // Estimate uncompressed size (4 bytes per pixel for RGBA)\r
        const pixels = texture.image.width * texture.image.height;\r
        const bytes = pixels * 4;\r
        \r
        if (bytes < 1024) {\r
            return \`\${bytes} B\`;\r
        } else if (bytes < 1024 * 1024) {\r
            return \`\${(bytes / 1024).toFixed(1)} KB\`;\r
        } else {\r
            return \`\${(bytes / (1024 * 1024)).toFixed(1)} MB\`;\r
        }\r
    }\r
    \r
    _showTextureLoading() {\r
        if (this.canvas) {\r
            this.canvas.style.display = 'none';\r
        }\r
        const placeholder = this.container.querySelector('.texture-placeholder');\r
        if (placeholder) {\r
            placeholder.style.display = 'flex';\r
            placeholder.innerHTML = '<span>\u23F3</span><span>Loading texture...</span>';\r
        }\r
    }\r
    \r
    _showNoTextures() {\r
        this.textureSelect.innerHTML = '<option value="">No textures</option>';\r
        this.textureSelect.disabled = true;\r
        \r
        const nameEl = this.container.querySelector('.texture-name');\r
        const formatEl = this.container.querySelector('.texture-format');\r
        const dimensionsEl = this.container.querySelector('.texture-dimensions');\r
        const sizeEl = this.container.querySelector('.texture-size');\r
        \r
        if (nameEl) nameEl.textContent = 'No textures';\r
        if (formatEl) formatEl.textContent = '-';\r
        if (dimensionsEl) dimensionsEl.textContent = '-';\r
        if (sizeEl) sizeEl.textContent = '-';\r
        \r
        if (this.canvas) {\r
            this.canvas.style.display = 'none';\r
        }\r
        const placeholder = this.container.querySelector('.texture-placeholder');\r
        if (placeholder) {\r
            placeholder.style.display = 'flex';\r
            placeholder.innerHTML = '<span>\u{1F5BC}\uFE0F</span><span>No textures loaded</span>';\r
        }\r
    }\r
    \r
    _enableControls() {\r
        this.textureSelect.disabled = false;\r
    }\r
    \r
    _escapeHtml(text) {\r
        const div = document.createElement('div');\r
        div.textContent = text;\r
        return div.innerHTML;\r
    }\r
    \r
    dispose() {\r
        if (this.resizeObserver) {\r
            this.resizeObserver.disconnect();\r
            this.resizeObserver = null;\r
        }\r
        if (this._handleResize) {\r
            window.removeEventListener('resize', this._handleResize);\r
            this._handleResize = null;\r
        }\r
        if (this.container) {\r
            this.container.innerHTML = '';\r
        }\r
        this.isInitialized = false;\r
        console.log('[TextureControls] Disposed');\r
    }\r
}`,
        "viewerManager": "/* FILE: editor/z3d-object-editor/templates/scripts/components/viewer-manager.js */\r\n/* Manages switching between Animation and Texture viewers */\r\n\r\nclass ViewerManager {\r\n    constructor() {\r\n        this.currentViewer = null;\r\n        this.animationControls = null;\r\n        this.textureControls = null;\r\n        this.hasAnimations = false;\r\n        this.hasTextures = false;\r\n        this.isInitialized = false;\r\n        this.workerReady = false;\r\n        this.cachedAnimationData = null;\r\n        this.cachedTextureData = null;\r\n    }\r\n    \r\n    async initialize() {\r\n        console.log('[ViewerManager] Initializing...');\r\n        \r\n        // Get viewer elements\r\n        this.viewerSelect = document.getElementById('viewer-type');\r\n        this.viewerContent = document.getElementById('viewer-content');\r\n        \r\n        if (!this.viewerSelect || !this.viewerContent) {\r\n            console.error('[ViewerManager] Required elements not found');\r\n            return;\r\n        }\r\n        \r\n        // Setup event listeners\r\n        this.viewerSelect.addEventListener('change', (e) => {\r\n            this.switchViewer(e.target.value);\r\n            e.target.blur();\r\n        });\r\n        \r\n        this.isInitialized = true;\r\n        console.log('[ViewerManager] \u2705 Initialized (waiting for worker)');\r\n    }\r\n    \r\n    // Called by the main editor when worker is ready\r\n    attachToWorker() {\r\n        if (!window.worker) {\r\n            console.error('[ViewerManager] attachToWorker called but no worker available');\r\n            return;\r\n        }\r\n        \r\n        if (this.workerReady) {\r\n            console.log('[ViewerManager] Worker already attached');\r\n            return;\r\n        }\r\n        \r\n        console.log('[ViewerManager] \u{1F517} Attaching to worker...');\r\n        \r\n        window.worker.addEventListener('message', (event) => {\r\n            this._handleWorkerMessage(event);\r\n        });\r\n        \r\n        this.workerReady = true;\r\n        console.log('[ViewerManager] \u2705 Worker listeners attached');\r\n    }\r\n    \r\n    _handleWorkerMessage(event) {\r\n        const { type, data } = event.data;\r\n        \r\n        switch (type) {\r\n            case 'SCENE_DATA':\r\n                this._handleSceneData(data?.sceneData);\r\n                break;\r\n                \r\n            case 'ANIMATIONS_READY':\r\n                console.log('[ViewerManager] ANIMATIONS_READY:', data);\r\n                this.hasAnimations = data.hasAnimations;\r\n                this._autoSelectViewer();\r\n                break;\r\n                \r\n            case 'ANIMATION_SELECTED':\r\n                console.log('[ViewerManager] ANIMATION_SELECTED:', data);\r\n                this.hasAnimations = true;\r\n                this._autoSelectViewer();\r\n                break;\r\n        }\r\n    }\r\n    \r\n    _handleSceneData(sceneData) {\r\n        if (!sceneData) return;\r\n        \r\n        console.log('[ViewerManager] Processing scene data:', {\r\n            animationCount: sceneData.animations?.length || 0,\r\n            textureCount: sceneData.textures?.length || 0\r\n        });\r\n        \r\n        this.hasAnimations = Array.isArray(sceneData.animations) && sceneData.animations.length > 0;\r\n        this.hasTextures = Array.isArray(sceneData.textures) && sceneData.textures.length > 0;\r\n        \r\n        // Cache animation data for re-use\r\n        if (this.hasAnimations) {\r\n            this.cachedAnimationData = sceneData.animations;\r\n            console.log('[ViewerManager] Cached animation data:', this.cachedAnimationData.length, 'animations');\r\n        }\r\n        \r\n        // ADD: Cache texture data for re-use\r\n        if (this.hasTextures) {\r\n            this.cachedTextureData = sceneData.textures;\r\n            console.log('[ViewerManager] Cached texture data:', this.cachedTextureData.length, 'textures');\r\n        }\r\n        \r\n        console.log('[ViewerManager] Content detected:', {\r\n            hasAnimations: this.hasAnimations,\r\n            hasTextures: this.hasTextures\r\n        });\r\n        \r\n        if (this.hasAnimations) {\r\n            console.log('[ViewerManager] First animation:', sceneData.animations[0]);\r\n        }\r\n        \r\n        this._autoSelectViewer();\r\n    }\r\n    \r\n    _autoSelectViewer() {\r\n        if (!this.isInitialized || !this.workerReady) {\r\n            console.log('[ViewerManager] Not ready for auto-select');\r\n            return;\r\n        }\r\n        \r\n        const targetViewer = this.hasAnimations ? 'animation' : 'texture';\r\n        \r\n        console.log(`[ViewerManager] ${this.hasAnimations ? '\u{1F3AC}' : '\u{1F5BC}\uFE0F'} Auto-selecting ${targetViewer} viewer`);\r\n        \r\n        if (this.currentViewer !== targetViewer) {\r\n            this.viewerSelect.value = targetViewer;\r\n            this.switchViewer(targetViewer);\r\n        }\r\n    }\r\n    \r\n    async switchViewer(type) {\r\n        console.log('[ViewerManager] Switching to viewer:', type);\r\n        \r\n        // Don't dispose if switching to the same viewer\r\n        if (this.currentViewer === type) {\r\n            return;\r\n        }\r\n        \r\n        // Dispose current viewer\r\n        if (this.currentViewer) {\r\n            if (this.currentViewer === 'animation' && this.animationControls) {\r\n                // Don't fully dispose - just hide it\r\n                // this.animationControls.dispose();  // REMOVE THIS LINE\r\n                this.animationControls = null;  // Just clear reference, don't dispose\r\n            } else if (this.currentViewer === 'texture' && this.textureControls) {\r\n                // this.textureControls.dispose();  // REMOVE THIS LINE if texture controls exist\r\n                this.textureControls = null;\r\n            }\r\n        }\r\n        \r\n        // Clear content\r\n        this.viewerContent.innerHTML = '';\r\n        this.currentViewer = type;\r\n        \r\n        if (type === 'animation') {\r\n            await this._initAnimationViewer();\r\n        } else if (type === 'texture') {\r\n            await this._initTextureViewer();\r\n        }\r\n    }\r\n    \r\n    async _initAnimationViewer() {\r\n        try {\r\n            if (typeof AnimationControls === 'undefined') {\r\n                throw new Error('AnimationControls class not found');\r\n            }\r\n            \r\n            // Check if we already have animation data cached\r\n            const reuseExisting = this.animationControls && !this.animationControls.isDisposed;\r\n            \r\n            if (!reuseExisting) {\r\n                this.animationControls = new AnimationControls({});\r\n                await this.animationControls.initialize(this.viewerContent);\r\n                \r\n                // If we already have animation data, re-send it\r\n                if (this.hasAnimations && this.cachedAnimationData) {\r\n                    this.animationControls._handleAnimationData(this.cachedAnimationData);\r\n                }\r\n            } else {\r\n                // Re-initialize with existing data\r\n                await this.animationControls.initialize(this.viewerContent);\r\n            }\r\n            \r\n            console.log('[ViewerManager] \u2705 Animation viewer ready');\r\n        } catch (error) {\r\n            console.error('[ViewerManager] \u274C Animation viewer failed:', error);\r\n            this.viewerContent.innerHTML = `\r\n                <div class=\"placeholder\">\r\n                    Animation viewer error: ${error.message}\r\n                </div>`;\r\n        }\r\n    }\r\n    \r\n    async _initTextureViewer() {\r\n        try {\r\n            if (typeof TextureControls === 'undefined') {\r\n                throw new Error('TextureControls class not found');\r\n            }\r\n            \r\n            this.textureControls = new TextureControls({});\r\n            await this.textureControls.initialize(this.viewerContent);\r\n            \r\n            // Use the public method\r\n            if (this.hasTextures && this.cachedTextureData) {\r\n                console.log('[ViewerManager] Sending cached texture data to viewer');\r\n                this.textureControls.setTextureData(this.cachedTextureData);  // Use public method\r\n            }\r\n            \r\n            console.log('[ViewerManager] \u2705 Texture viewer ready');\r\n        } catch (error) {\r\n            console.error('[ViewerManager] \u274C Texture viewer failed:', error);\r\n            this.viewerContent.innerHTML = `\r\n                <div class=\"placeholder\">\r\n                    Texture viewer error: ${error.message}\r\n                </div>`;\r\n        }\r\n    }\r\n    \r\n    dispose() {\r\n        if (this.animationControls) {\r\n            this.animationControls.dispose();\r\n            this.animationControls = null;\r\n        }\r\n        if (this.textureControls) {\r\n            this.textureControls.dispose();\r\n            this.textureControls = null;\r\n        }\r\n        this.currentViewer = null;\r\n        this.isInitialized = false;\r\n        this.workerReady = false;\r\n        console.log('[ViewerManager] Disposed');\r\n    }\r\n}\r\n\r\n// Clean initialization - no polling!\r\nif (typeof window !== 'undefined') {\r\n    window.viewerManager = null;\r\n    \r\n    function initViewerManager() {\r\n        if (!window.viewerManager) {\r\n            console.log('[ViewerManager] Creating ViewerManager...');\r\n            window.viewerManager = new ViewerManager();\r\n            window.viewerManager.initialize();\r\n        }\r\n    }\r\n    \r\n    // Initialize when DOM is ready\r\n    if (document.readyState === 'loading') {\r\n        document.addEventListener('DOMContentLoaded', initViewerManager);\r\n    } else {\r\n        initViewerManager();\r\n    }\r\n}",
        "resizer": "/* FILE: editor/z3d-object-editor/templates/scripts/components/resizer.js */\r\n/* COMPLETE FIXED VERSION - No snapping on vertical resizer */\r\n\r\nclass Resizer extends EventEmitter {\r\n    constructor(config) {\r\n        super();\r\n        this.config = config;\r\n        this.resizers = [];\r\n        this.isInitialized = false;\r\n    this._leftRatio = null; // Persist left:total ratio set by user drag\r\n    this._horizontalNodeTreeRatio = null; // Persist nodeTree:(nodeTree+sideTabs) ratio\r\n    this.MIN_STATUS_BAR_HEIGHT = 28; // enforce status bar minimum height\r\n        \r\n        // Scene minimum sizes to avoid collapse\r\n        this.MIN_VIEWPORT_WIDTH = 400;\r\n        this.MIN_VIEWPORT_HEIGHT = 300;\r\n        this.MIN_RIGHT_PANEL_WIDTH = 250;\r\n        this.MIN_VIEWER_HEIGHT = 100;\r\n    }\r\n    \r\n    async initialize() {\r\n        // Setup vertical resizer (between left and right regions)\r\n        this.setupVerticalResizer();\r\n        \r\n        // Setup horizontal resizer (in right region between node tree and tabs)\r\n        this.setupHorizontalResizer();\r\n        \r\n        // Setup left horizontal resizer (between viewport and viewer areas)\r\n        this.setupLeftHorizontalResizer();\r\n\r\n        // Handle window resize (maximize/restore/manual drag) so right-region always fills width\r\n        this._handleWindowResize = this._handleWindowResize.bind(this);\r\n        window.addEventListener('resize', this._handleWindowResize);\r\n\r\n        // Establish initial ratio from DOM after initial layout\r\n        requestAnimationFrame(() => {\r\n            const leftRegion = document.querySelector('.left-region');\r\n            const rightRegion = document.querySelector('.right-region');\r\n            const mainContent = document.querySelector('.main-content');\r\n            if (leftRegion && rightRegion && mainContent) {\r\n                const mainRect = mainContent.getBoundingClientRect();\r\n                const resizer = document.querySelector('.vertical-resizer');\r\n                const resizerWidth = resizer ? (resizer.getBoundingClientRect().width || 4) : 4;\r\n                const totalWidth = Math.max(1, mainRect.width - resizerWidth);\r\n                const leftWidth = leftRegion.getBoundingClientRect().width;\r\n                this._leftRatio = Math.min(0.95, Math.max(0.05, leftWidth / totalWidth));\r\n            }\r\n        });\r\n        \r\n        this.isInitialized = true;\r\n        console.log('[Resizer] \u2705 Initialized successfully');\r\n    }\r\n    \r\n    /**\r\n     * Sync canvas size using CanvasManager\r\n     */\r\n    syncCanvasSize() {\r\n        // Use the global canvas manager if available\r\n        if (window.canvasManager) {\r\n            window.canvasManager.forceResize();\r\n        } else {\r\n            // Fallback: just notify worker about size change\r\n            const viewport = document.getElementById('viewport-area');\r\n            if (viewport && window.worker) {\r\n                const rect = viewport.getBoundingClientRect();\r\n                const width = Math.max(1, Math.floor(rect.width));\r\n                const height = Math.max(1, Math.floor(rect.height));\r\n                \r\n                window.worker.postMessage({\r\n                    type: 'UPDATE_RENDER_SIZE',\r\n                    data: { width, height }\r\n                });\r\n            }\r\n        }\r\n    }\r\n    \r\n    setupVerticalResizer() {\r\n        const resizer = document.querySelector('.vertical-resizer');\r\n        const leftRegion = document.querySelector('.left-region');\r\n        const rightRegion = document.querySelector('.right-region');\r\n        const mainContent = document.querySelector('.main-content');\r\n        \r\n        if (!resizer || !leftRegion || !rightRegion || !mainContent) {\r\n            console.warn('[Resizer] Vertical resizer elements not found');\r\n            return;\r\n        }\r\n        \r\n        let isResizing = false;\r\n        let startX = 0;\r\n        let startLeftWidth = 0;\r\n        let startRightWidth = 0;\r\n        let rafId = null;\r\n        \r\n        const startResize = (e) => {\r\n            isResizing = true;\r\n            startX = e.clientX;\r\n            \r\n            // FIX: Get the actual current widths from computed styles or flex values\r\n            const leftRect = leftRegion.getBoundingClientRect();\r\n            const rightRect = rightRegion.getBoundingClientRect();\r\n            \r\n            // Store actual current widths\r\n            startLeftWidth = leftRect.width;\r\n            startRightWidth = rightRect.width;\r\n            \r\n            // If flex values are set, use those as they're more accurate\r\n            const leftFlex = leftRegion.style.flex;\r\n            const rightFlex = rightRegion.style.flex;\r\n            \r\n            if (leftFlex && leftFlex.includes('px')) {\r\n                const match = leftFlex.match(/0 0 (\\d+(?:\\.\\d+)?)px/);\r\n                if (match) {\r\n                    startLeftWidth = parseFloat(match[1]);\r\n                }\r\n            }\r\n            \r\n            if (rightFlex && rightFlex.includes('px')) {\r\n                const match = rightFlex.match(/0 0 (\\d+(?:\\.\\d+)?)px/);\r\n                if (match) {\r\n                    startRightWidth = parseFloat(match[1]);\r\n                }\r\n            }\r\n            \r\n            console.log('[Resizer] Starting vertical resize:', {\r\n                startLeftWidth,\r\n                startRightWidth,\r\n                startX: e.clientX\r\n            });\r\n            \r\n            resizer.classList.add('resizing');\r\n            document.body.style.cursor = 'ew-resize';\r\n            document.body.style.userSelect = 'none';\r\n            \r\n            // Add overlay to prevent iframe interference\r\n            const overlay = document.createElement('div');\r\n            overlay.id = 'resize-overlay';\r\n            overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;z-index:9999;cursor:ew-resize;';\r\n            document.body.appendChild(overlay);\r\n            \r\n            e.preventDefault();\r\n        };\r\n        \r\n        const resize = (e) => {\r\n            if (!isResizing) return;\r\n            \r\n            // Cancel previous RAF\r\n            if (rafId) cancelAnimationFrame(rafId);\r\n            \r\n            rafId = requestAnimationFrame(() => {\r\n                const deltaX = e.clientX - startX;\r\n                const mainRect = mainContent.getBoundingClientRect();\r\n                const resizerWidth = 4;\r\n                const totalWidth = mainRect.width - resizerWidth;\r\n                // Compute new left width from drag delta\r\n                let newLeftWidth = startLeftWidth + deltaX;\r\n                // Constrain left width within min/max bounds (leaving at least MIN_RIGHT_PANEL_WIDTH for right)\r\n                const maxLeft = totalWidth - this.MIN_RIGHT_PANEL_WIDTH;\r\n                newLeftWidth = Math.max(this.MIN_VIEWPORT_WIDTH, Math.min(maxLeft, newLeftWidth));\r\n                // Derive right width so that sum exactly fills totalWidth (eliminates trailing gap)\r\n                let newRightWidth = totalWidth - newLeftWidth;\r\n                // Enforce right min; if violated, adjust left accordingly and recalc right\r\n                if (newRightWidth < this.MIN_RIGHT_PANEL_WIDTH) {\r\n                    newRightWidth = this.MIN_RIGHT_PANEL_WIDTH;\r\n                    newLeftWidth = totalWidth - newRightWidth;\r\n                    if (newLeftWidth < this.MIN_VIEWPORT_WIDTH) {\r\n                        // Final clamp compromise: prioritize mins\r\n                        newLeftWidth = this.MIN_VIEWPORT_WIDTH;\r\n                        newRightWidth = totalWidth - newLeftWidth;\r\n                    }\r\n                }\r\n                // Safety: if rounding causes a pixel shortfall, assign the remainder to right panel\r\n                const remainder = totalWidth - (newLeftWidth + newRightWidth);\r\n                if (Math.abs(remainder) >= 1) {\r\n                    newRightWidth += remainder; // keep fill exact\r\n                }\r\n                \r\n                // Apply new sizes using flex-basis\r\n                leftRegion.style.flex = `0 0 ${newLeftWidth}px`;\r\n                rightRegion.style.flex = `0 0 ${newRightWidth}px`;\r\n\r\n                // Persist ratio for future window resizes\r\n                const effectiveTotal = newLeftWidth + newRightWidth;\r\n                if (effectiveTotal > 0) {\r\n                    this._leftRatio = newLeftWidth / effectiveTotal;\r\n                }\r\n                \r\n                // Sync canvas size\r\n                this.syncCanvasSize();\r\n                \r\n                this.emit('vertical-resize', { leftWidth: newLeftWidth, rightWidth: newRightWidth });\r\n            });\r\n            \r\n            e.preventDefault();\r\n        };\r\n        \r\n        const stopResize = () => {\r\n            if (!isResizing) return;\r\n            \r\n            isResizing = false;\r\n            resizer.classList.remove('resizing');\r\n            document.body.style.cursor = '';\r\n            document.body.style.userSelect = '';\r\n            \r\n            const overlay = document.getElementById('resize-overlay');\r\n            if (overlay) overlay.remove();\r\n            \r\n            // Cancel any pending RAF\r\n            if (rafId) {\r\n                cancelAnimationFrame(rafId);\r\n                rafId = null;\r\n            }\r\n            \r\n            // Final canvas sync\r\n            this.syncCanvasSize();\r\n            \r\n            console.log('[Resizer] Vertical resize complete');\r\n        };\r\n        \r\n        resizer.addEventListener('mousedown', startResize);\r\n        document.addEventListener('mousemove', resize);\r\n        document.addEventListener('mouseup', stopResize);\r\n        \r\n        this.resizers.push({\r\n            type: 'vertical',\r\n            cleanup: () => {\r\n                resizer.removeEventListener('mousedown', startResize);\r\n                document.removeEventListener('mousemove', resize);\r\n                document.removeEventListener('mouseup', stopResize);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Window resize handler: preserve current left width (within constraints) and expand right to fill.\r\n     */\r\n    _handleWindowResize() {\r\n        const leftRegion = document.querySelector('.left-region');\r\n        const rightRegion = document.querySelector('.right-region');\r\n        const mainContent = document.querySelector('.main-content');\r\n        const resizer = document.querySelector('.vertical-resizer');\r\n        if (!leftRegion || !rightRegion || !mainContent || !resizer) return;\r\n\r\n        const mainRect = mainContent.getBoundingClientRect();\r\n        const resizerWidth = resizer.getBoundingClientRect().width || 4;\r\n        const totalWidth = mainRect.width - resizerWidth;\r\n        // Desired left width based on stored ratio (fallback to current DOM width if null)\r\n        let desiredLeft = this._leftRatio != null\r\n            ? this._leftRatio * totalWidth\r\n            : leftRegion.getBoundingClientRect().width;\r\n        // Clamp desired left width\r\n        const maxLeft = totalWidth - this.MIN_RIGHT_PANEL_WIDTH;\r\n        let leftWidth = Math.max(this.MIN_VIEWPORT_WIDTH, Math.min(maxLeft, desiredLeft));\r\n        let rightWidth = totalWidth - leftWidth;\r\n        // If right min violated after clamp, adjust again\r\n        if (rightWidth < this.MIN_RIGHT_PANEL_WIDTH) {\r\n            rightWidth = this.MIN_RIGHT_PANEL_WIDTH;\r\n            leftWidth = totalWidth - rightWidth;\r\n        }\r\n        // Update ratio to actual applied ratio\r\n        if (totalWidth > 0) {\r\n            this._leftRatio = leftWidth / totalWidth;\r\n        }\r\n        leftRegion.style.flex = `0 0 ${leftWidth}px`;\r\n        rightRegion.style.flex = `0 0 ${rightWidth}px`;\r\n        requestAnimationFrame(() => this.syncCanvasSize());\r\n    }\r\n\r\n    /** Cleanup listeners */\r\n    dispose() {\r\n        window.removeEventListener('resize', this._handleWindowResize);\r\n        this.resizers.forEach(r => r.cleanup && r.cleanup());\r\n        this.resizers = [];\r\n    }\r\n    \r\n    setupHorizontalResizer() {\r\n        const resizer = document.querySelector('.horizontal-resizer');\r\n        const nodeTreeSection = document.querySelector('.node-tree-section');\r\n        const sideTabsSection = document.querySelector('.side-tabs-section');\r\n        const rightRegion = document.querySelector('.right-region');\r\n        const statusBar = rightRegion ? rightRegion.querySelector('.status-bar') : null;\r\n        \r\n        if (!resizer || !nodeTreeSection || !sideTabsSection) {\r\n            console.warn('[Resizer] Horizontal resizer elements not found');\r\n            return;\r\n        }\r\n        \r\n        let isResizing = false;\r\n        let startY = 0;\r\n        let startNodeTreeHeight = 0;\r\n        let startSideTabsHeight = 0;\r\n        \r\n        const startResize = (e) => {\r\n            isResizing = true;\r\n            startY = e.clientY;\r\n            \r\n            const nodeTreeRect = nodeTreeSection.getBoundingClientRect();\r\n            const sideTabsRect = sideTabsSection.getBoundingClientRect();\r\n            \r\n            startNodeTreeHeight = nodeTreeRect.height;\r\n            startSideTabsHeight = sideTabsRect.height;\r\n            \r\n            resizer.classList.add('resizing');\r\n            document.body.style.cursor = 'ns-resize';\r\n            document.body.style.userSelect = 'none';\r\n            \r\n            e.preventDefault();\r\n        };\r\n        \r\n        const MIN_NODE_TREE = 100;\r\n        const MIN_SIDE_TABS = 110;\r\n\r\n        const fitHorizontalHeights = (nodeTreeH, sideTabsH) => {\r\n            if (!rightRegion) return { nodeTreeH, sideTabsH };\r\n            const totalRegionHeight = rightRegion.getBoundingClientRect().height;\r\n            const resizerHeight = resizer.getBoundingClientRect().height || 4;\r\n            const statusBarHeightRaw = statusBar ? statusBar.getBoundingClientRect().height : 0;\r\n            const statusBarHeight = Math.max(this.MIN_STATUS_BAR_HEIGHT, statusBarHeightRaw);\r\n            const available = totalRegionHeight - statusBarHeight - resizerHeight;\r\n            // Enforce mins\r\n            nodeTreeH = Math.max(MIN_NODE_TREE, nodeTreeH);\r\n            sideTabsH = Math.max(MIN_SIDE_TABS, sideTabsH);\r\n            // If overflow, reduce node tree first, then side tabs\r\n            let overflow = (nodeTreeH + sideTabsH) - available;\r\n            if (overflow > 0) {\r\n                const reducibleNode = nodeTreeH - MIN_NODE_TREE;\r\n                const takeFromNode = Math.min(reducibleNode, overflow);\r\n                nodeTreeH -= takeFromNode;\r\n                overflow -= takeFromNode;\r\n            }\r\n            if (overflow > 0) {\r\n                const reducibleSide = sideTabsH - MIN_SIDE_TABS;\r\n                const takeFromSide = Math.min(reducibleSide, overflow);\r\n                sideTabsH -= takeFromSide;\r\n                overflow -= takeFromSide;\r\n            }\r\n            // Final guard: if still overflow (extreme small window) proportionally scale\r\n            if (overflow > 0 && (nodeTreeH + sideTabsH) > 0) {\r\n                const scale = (available) / (nodeTreeH + sideTabsH);\r\n                nodeTreeH = Math.max(MIN_NODE_TREE, Math.floor(nodeTreeH * scale));\r\n                sideTabsH = Math.max(MIN_SIDE_TABS, Math.floor(sideTabsH * scale));\r\n            }\r\n            return { nodeTreeH, sideTabsH };\r\n        };\r\n\r\n        const applyHeights = (nodeTreeH, sideTabsH, updateRatio=true) => {\r\n            // Node tree fixed height; side tabs can flex to absorb extra / release space\r\n            nodeTreeSection.style.flex = `0 0 ${nodeTreeH}px`;\r\n            sideTabsSection.style.flex = `1 1 ${sideTabsH}px`;\r\n            if (updateRatio && rightRegion) {\r\n                const totalRegionHeight = rightRegion.getBoundingClientRect().height;\r\n                const resizerHeight = resizer.getBoundingClientRect().height || 4;\r\n                const statusBarHeightRaw = statusBar ? statusBar.getBoundingClientRect().height : 0;\r\n                const statusBarHeight = Math.max(this.MIN_STATUS_BAR_HEIGHT, statusBarHeightRaw);\r\n                const available = totalRegionHeight - statusBarHeight - resizerHeight;\r\n                if (available > 0) {\r\n                    this._horizontalNodeTreeRatio = Math.min(0.95, Math.max(0.05, nodeTreeH / available));\r\n                }\r\n            }\r\n        };\r\n\r\n        const resize = (e) => {\r\n            if (!isResizing) return;\r\n            const deltaY = e.clientY - startY;\r\n            let tentativeNode = startNodeTreeHeight + deltaY;\r\n            let tentativeSide = startSideTabsHeight - deltaY;\r\n            let { nodeTreeH, sideTabsH } = fitHorizontalHeights(tentativeNode, tentativeSide);\r\n            applyHeights(nodeTreeH, sideTabsH);\r\n            this.emit('horizontal-resize', { nodeTreeHeight: nodeTreeH, sideTabsHeight: sideTabsH });\r\n            e.preventDefault();\r\n        };\r\n        \r\n        const stopResize = () => {\r\n            if (!isResizing) return;\r\n            \r\n            isResizing = false;\r\n            resizer.classList.remove('resizing');\r\n            document.body.style.cursor = '';\r\n            document.body.style.userSelect = '';\r\n        };\r\n        \r\n        resizer.addEventListener('mousedown', startResize);\r\n        document.addEventListener('mousemove', resize);\r\n        document.addEventListener('mouseup', stopResize);\r\n        \r\n        this.resizers.push({\r\n            type: 'horizontal',\r\n            cleanup: () => {\r\n                resizer.removeEventListener('mousedown', startResize);\r\n                document.removeEventListener('mousemove', resize);\r\n                document.removeEventListener('mouseup', stopResize);\r\n            }\r\n        });\r\n\r\n        // Adjust on window resize so status bar never disappears\r\n        const handleSectionFit = () => {\r\n            if (!rightRegion) return;\r\n            const totalRegionHeight = rightRegion.getBoundingClientRect().height;\r\n            const resizerHeight = resizer.getBoundingClientRect().height || 4;\r\n            const statusBarHeightRaw = statusBar ? statusBar.getBoundingClientRect().height : 0;\r\n            const statusBarHeight = Math.max(this.MIN_STATUS_BAR_HEIGHT, statusBarHeightRaw);\r\n            const available = totalRegionHeight - statusBarHeight - resizerHeight;\r\n            let desiredNode = this._horizontalNodeTreeRatio != null ? this._horizontalNodeTreeRatio * available : nodeTreeSection.getBoundingClientRect().height;\r\n            let desiredSide = available - desiredNode;\r\n            let fitted = fitHorizontalHeights(desiredNode, desiredSide);\r\n            applyHeights(fitted.nodeTreeH, fitted.sideTabsH);\r\n            // Post-apply guard: ensure status bar remains visible by shrinking side tabs if overflow occurred\r\n            requestAnimationFrame(() => {\r\n                const nodeTreeH = nodeTreeSection.getBoundingClientRect().height;\r\n                const sideTabsH = sideTabsSection.getBoundingClientRect().height;\r\n                const used = nodeTreeH + sideTabsH + statusBarHeight + resizerHeight;\r\n                if (used > totalRegionHeight) {\r\n                    const overflow = used - totalRegionHeight;\r\n                    const newSide = Math.max(MIN_SIDE_TABS, sideTabsH - overflow);\r\n                    if (newSide !== sideTabsH) {\r\n                        applyHeights(nodeTreeH, newSide, false);\r\n                    }\r\n                }\r\n            });\r\n        };\r\n        window.addEventListener('resize', handleSectionFit);\r\n        this.resizers.push({\r\n            type: 'horizontal-fit-listener',\r\n            cleanup: () => window.removeEventListener('resize', handleSectionFit)\r\n        });\r\n\r\n        // Initial ratio capture after first layout paint (avoid snap)\r\n        requestAnimationFrame(() => handleSectionFit());\r\n    }\r\n    \r\n    setupLeftHorizontalResizer() {\r\n        const resizer = document.querySelector('.left-horizontal-resizer');\r\n        const viewportArea = document.querySelector('.viewport-area');\r\n        const viewerArea = document.querySelector('.viewer-area');\r\n        const leftRegion = document.querySelector('.left-region');\r\n        \r\n        if (!resizer || !viewportArea || !viewerArea || !leftRegion) {\r\n            console.warn('[Resizer] Left horizontal resizer elements not found');\r\n            return;\r\n        }\r\n        \r\n        let isResizing = false;\r\n        let startY = 0;\r\n        let startViewportHeight = 0;\r\n        let startViewerHeight = 0;\r\n        let rafId = null;\r\n        \r\n        const startResize = (e) => {\r\n            isResizing = true;\r\n            startY = e.clientY;\r\n            \r\n            const viewportRect = viewportArea.getBoundingClientRect();\r\n            const viewerRect = viewerArea.getBoundingClientRect();\r\n            \r\n            startViewportHeight = viewportRect.height;\r\n            startViewerHeight = viewerRect.height;\r\n            \r\n            resizer.classList.add('resizing');\r\n            document.body.style.cursor = 'ns-resize';\r\n            document.body.style.userSelect = 'none';\r\n            \r\n            // Add overlay\r\n            const overlay = document.createElement('div');\r\n            overlay.id = 'resize-overlay';\r\n            overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;z-index:9999;cursor:ns-resize;';\r\n            document.body.appendChild(overlay);\r\n            \r\n            e.preventDefault();\r\n        };\r\n        \r\n        const resize = (e) => {\r\n            if (!isResizing) return;\r\n            \r\n            // Cancel previous RAF\r\n            if (rafId) cancelAnimationFrame(rafId);\r\n            \r\n            rafId = requestAnimationFrame(() => {\r\n                const deltaY = e.clientY - startY;\r\n                const leftRect = leftRegion.getBoundingClientRect();\r\n                const totalHeight = leftRect.height;\r\n                const resizerHeight = 4;\r\n                \r\n                // Calculate new heights with constraints\r\n                let newViewportHeight = Math.max(this.MIN_VIEWPORT_HEIGHT, startViewportHeight + deltaY);\r\n                let newViewerHeight = Math.max(this.MIN_VIEWER_HEIGHT, startViewerHeight - deltaY);\r\n                \r\n                // Ensure they don't exceed total\r\n                const maxViewportHeight = totalHeight - resizerHeight - this.MIN_VIEWER_HEIGHT;\r\n                const maxViewerHeight = totalHeight - resizerHeight - this.MIN_VIEWPORT_HEIGHT;\r\n                \r\n                newViewportHeight = Math.min(newViewportHeight, maxViewportHeight);\r\n                newViewerHeight = Math.min(newViewerHeight, maxViewerHeight);\r\n                \r\n                // Apply sizes\r\n                viewportArea.style.flex = `0 0 ${newViewportHeight}px`;\r\n                viewerArea.style.flex = `0 0 ${newViewerHeight}px`;\r\n                \r\n                // Sync canvas size\r\n                this.syncCanvasSize();\r\n                \r\n                this.emit('left-horizontal-resize', { \r\n                    viewportHeight: newViewportHeight, \r\n                    viewerHeight: newViewerHeight \r\n                });\r\n            });\r\n            \r\n            e.preventDefault();\r\n        };\r\n        \r\n        const stopResize = () => {\r\n            if (!isResizing) return;\r\n            \r\n            isResizing = false;\r\n            resizer.classList.remove('resizing');\r\n            document.body.style.cursor = '';\r\n            document.body.style.userSelect = '';\r\n            \r\n            const overlay = document.getElementById('resize-overlay');\r\n            if (overlay) overlay.remove();\r\n            \r\n            // Cancel any pending RAF\r\n            if (rafId) {\r\n                cancelAnimationFrame(rafId);\r\n                rafId = null;\r\n            }\r\n            \r\n            // Final canvas sync\r\n            this.syncCanvasSize();\r\n        };\r\n        \r\n        resizer.addEventListener('mousedown', startResize);\r\n        document.addEventListener('mousemove', resize);\r\n        document.addEventListener('mouseup', stopResize);\r\n        \r\n        this.resizers.push({\r\n            type: 'left-horizontal',\r\n            cleanup: () => {\r\n                resizer.removeEventListener('mousedown', startResize);\r\n                document.removeEventListener('mousemove', resize);\r\n                document.removeEventListener('mouseup', stopResize);\r\n            }\r\n        });\r\n\r\n        // Set initial split to 70/30 instead of 80/20\r\n        requestAnimationFrame(() => {\r\n            const leftRect = leftRegion.getBoundingClientRect();\r\n            const totalHeight = leftRect.height - 4; // minus resizer height\r\n            const viewportHeight = totalHeight * 0.7; // 70%\r\n            const viewerHeight = totalHeight * 0.3; // 30%\r\n            \r\n            viewportArea.style.flex = `0 0 ${viewportHeight}px`;\r\n            viewerArea.style.flex = `1 1 ${viewerHeight}px`; // Change to flex-grow: 1\r\n            \r\n            // Initial canvas size sync\r\n            this.syncCanvasSize();\r\n            \r\n            // IMPORTANT: Trigger a resize event after a small delay to ensure texture canvas gets sized\r\n            setTimeout(() => {\r\n                window.dispatchEvent(new Event('resize'));\r\n            }, 100);\r\n        });\r\n\r\n    }\r\n    \r\n    dispose() {\r\n        this.resizers.forEach(resizer => {\r\n            if (resizer.cleanup) {\r\n                resizer.cleanup();\r\n            }\r\n        });\r\n        this.resizers = [];\r\n        console.log('[Resizer] Disposed');\r\n    }\r\n}",
        "gizmoController": "// FILE: templates/scripts/components/gizmo-controller.js\r\n// Main thread gizmo controller - handles viewport gizmo UI and transform gizmo communication\r\n\r\nclass GizmoController {\r\n    constructor() {\r\n        console.log('[GizmoController] \u{1F3AF} Constructor called!');\r\n        console.error('[GizmoController] CONSTRUCTOR STACK TRACE:', new Error().stack);\r\n        \r\n        this.canvas = null;\r\n        this.worker = null;\r\n        this.isInitialized = false;\r\n        \r\n        // Viewport gizmo state\r\n        this.viewportGizmoCanvas = null;\r\n        this.viewportGizmoRenderer = null;\r\n        this.viewportGizmoScene = null;\r\n        this.viewportGizmoCamera = null;\r\n        this.viewportGizmoGroup = null;\r\n        \r\n        // Camera state from worker\r\n        this.cameraQuaternion = new THREE.Quaternion();\r\n        \r\n        console.log('[GizmoController] \u2705 Controller created successfully');\r\n        console.log('[GizmoController] THREE available?', typeof THREE !== 'undefined');\r\n    }\r\n    \r\n    /**\r\n     * Initialize the gizmo controller with canvas and worker\r\n     */\r\n    initialize(canvas, worker) {\r\n        console.log('[GizmoController] \u{1F3AF} Initialize called!');\r\n        console.log('[GizmoController] Canvas:', canvas);\r\n        console.log('[GizmoController] Worker:', worker);\r\n        console.log('[GizmoController] Already initialized?', this.isInitialized);\r\n        \r\n        if (this.isInitialized) {\r\n            console.warn('[GizmoController] Already initialized, skipping');\r\n            return;\r\n        }\r\n        \r\n        this.canvas = canvas;\r\n        this.worker = worker;\r\n        \r\n        console.log('[GizmoController] Starting initialization...');\r\n        \r\n        try {\r\n            // Create viewport gizmo UI\r\n            console.log('[GizmoController] Creating viewport gizmo UI...');\r\n            this.createViewportGizmoUI();\r\n            \r\n            // Setup mouse event listeners for transform gizmo\r\n            console.log('[GizmoController] Setting up transform gizmo listeners...');\r\n            this.setupTransformGizmoListeners();\r\n            \r\n            // Listen for worker messages\r\n            console.log('[GizmoController] Setting up worker message listener...');\r\n            this.setupWorkerMessageListener();\r\n            \r\n            // Initialize transform gizmo in worker\r\n            console.log('[GizmoController] Initializing worker gizmos...');\r\n            this.initializeWorkerGizmos();\r\n            \r\n            this.isInitialized = true;\r\n            console.log('[GizmoController] \u2705 Gizmo controller initialized successfully!');\r\n        } catch (error) {\r\n            console.error('[GizmoController] \u274C Initialization failed:', error);\r\n            console.error('[GizmoController] Stack trace:', error.stack);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Create the viewport gizmo UI element (rendered in main thread)\r\n     */\r\n    createViewportGizmoUI() {\r\n        console.log('[GizmoController] Creating viewport gizmo container...');\r\n        \r\n        // Check if container already exists\r\n        let container = document.getElementById('viewport-gizmo-container');\r\n        if (container) {\r\n            console.log('[GizmoController] Container already exists, removing old one');\r\n            container.remove();\r\n        }\r\n        \r\n        // Create container for viewport gizmo\r\n        container = document.createElement('div');\r\n        container.id = 'viewport-gizmo-container';\r\n        container.style.cssText = `\r\n            position: absolute;\r\n            top: 46px;\r\n            right: 10px;\r\n            width: 196px;\r\n            height: 196px;\r\n            z-index: 90;\r\n            pointer-events: auto;\r\n            cursor: pointer;\r\n            user-select: none;\r\n            background: transparent;\r\n            border: none;\r\n            border-radius: 0;\r\n            overflow: visible;\r\n        `;\r\n        \r\n        // Create canvas for viewport gizmo\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = 196;\r\n        canvas.height = 196;\r\n        canvas.style.width = '196px';\r\n        canvas.style.height = '196px';\r\n        container.appendChild(canvas);\r\n        \r\n        // Add to viewport\r\n        const viewportArea = document.getElementById('viewport-area');\r\n        if (viewportArea) {\r\n            console.log('[GizmoController] Adding container to viewport-area');\r\n            viewportArea.appendChild(container);\r\n            this.viewportGizmoCanvas = canvas;\r\n            \r\n            // Setup viewport gizmo renderer\r\n            this.setupViewportGizmoRenderer(canvas);\r\n            \r\n            // Setup viewport gizmo mouse events\r\n            this.setupViewportGizmoEvents(container, canvas);\r\n        } else {\r\n            console.error('[GizmoController] viewport-area element not found!');\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Setup Three.js renderer for viewport gizmo (main thread)\r\n     */\r\n    setupViewportGizmoRenderer(canvas) {\r\n        // Create renderer\r\n        this.viewportGizmoRenderer = new THREE.WebGLRenderer({\r\n            canvas: canvas,\r\n            alpha: true,\r\n            antialias: true\r\n        });\r\n        this.viewportGizmoRenderer.setSize(196, 196);\r\n        this.viewportGizmoRenderer.setClearColor(0x000000, 0);\r\n        \r\n        // Create scene\r\n        this.viewportGizmoScene = new THREE.Scene();\r\n        \r\n        // Create camera\r\n        this.viewportGizmoCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);\r\n        this.viewportGizmoCamera.position.set(3, -3, 3);\r\n        this.viewportGizmoCamera.up.set(0, 0, 1);\r\n        this.viewportGizmoCamera.lookAt(0, 0, 0);\r\n        \r\n        // Create the gizmo geometry\r\n        this.createViewportGizmoGeometry();\r\n        \r\n        // Start render loop for viewport gizmo\r\n        this.startViewportGizmoRenderLoop();\r\n    }\r\n    \r\n    /**\r\n     * Create viewport gizmo geometry\r\n     */\r\n    createViewportGizmoGeometry() {\r\n        const group = new THREE.Group();\r\n        \r\n        // Face definitions\r\n        const faces = {\r\n            front: { normal: [0, -1, 0], color: 0x4CAF50, label: 'Front' },\r\n            back: { normal: [0, 1, 0], color: 0x2196F3, label: 'Back' },\r\n            left: { normal: [-1, 0, 0], color: 0xFF9800, label: 'Left' },\r\n            right: { normal: [1, 0, 0], color: 0xE91E63, label: 'Right' },\r\n            top: { normal: [0, 0, 1], color: 0x9C27B0, label: 'Top' },\r\n            bottom: { normal: [0, 0, -1], color: 0x795548, label: 'Bottom' }\r\n        };\r\n        \r\n        // Create cube faces\r\n        const faceSize = 0.8;\r\n        const faceGeometry = new THREE.BoxGeometry(faceSize, 0.05, faceSize);\r\n        \r\n        Object.entries(faces).forEach(([key, face]) => {\r\n            const material = new THREE.MeshBasicMaterial({\r\n                color: face.color,\r\n                opacity: 0.8,\r\n                transparent: true\r\n            });\r\n            \r\n            const mesh = new THREE.Mesh(faceGeometry, material);\r\n            mesh.userData = { type: 'face', faceKey: key, ...face };\r\n            \r\n            // Position based on normal\r\n            if (face.normal[0] !== 0) {\r\n                mesh.rotation.z = Math.PI / 2;\r\n                mesh.position.x = face.normal[0] * 0.5;\r\n            } else if (face.normal[1] !== 0) {\r\n                mesh.position.y = face.normal[1] * 0.5;\r\n            } else if (face.normal[2] !== 0) {\r\n                mesh.rotation.x = Math.PI / 2;\r\n                mesh.position.z = face.normal[2] * 0.5;\r\n            }\r\n            \r\n            group.add(mesh);\r\n        });\r\n        \r\n        // Create axes\r\n        const axisLength = 1.2;\r\n        const axisRadius = 0.02;\r\n        \r\n        // X axis - Red\r\n        const xGeometry = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8);\r\n        const xMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });\r\n        const xAxis = new THREE.Mesh(xGeometry, xMaterial);\r\n        xAxis.rotation.z = -Math.PI / 2;\r\n        xAxis.position.x = axisLength / 2;\r\n        group.add(xAxis);\r\n        \r\n        // Y axis - Green (negative for C3)\r\n        const yGeometry = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8);\r\n        const yMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\r\n        const yAxis = new THREE.Mesh(yGeometry, yMaterial);\r\n        yAxis.position.y = -axisLength / 2;\r\n        group.add(yAxis);\r\n        \r\n        // Z axis - Blue\r\n        const zGeometry = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8);\r\n        const zMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });\r\n        const zAxis = new THREE.Mesh(zGeometry, zMaterial);\r\n        zAxis.rotation.x = Math.PI / 2;\r\n        zAxis.position.z = axisLength / 2;\r\n        group.add(zAxis);\r\n        \r\n        // Add axis labels\r\n        this.createAxisLabels(group);\r\n        \r\n        // No lighting needed - viewport gizmo uses unlit materials\r\n        \r\n        this.viewportGizmoGroup = group;\r\n        this.viewportGizmoScene.add(group);\r\n    }\r\n    \r\n    /**\r\n     * Create axis labels for viewport gizmo\r\n     */\r\n    createAxisLabels(group) {\r\n        // Create text sprites without FontLoader (deprecated in Three.js r147+)\r\n        const createTextSprite = (text, color, position) => {\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = 64;\r\n            canvas.height = 64;\r\n            const ctx = canvas.getContext('2d');\r\n            \r\n            ctx.fillStyle = color;\r\n            ctx.font = 'bold 48px Arial';\r\n            ctx.textAlign = 'center';\r\n            ctx.textBaseline = 'middle';\r\n            ctx.fillText(text, 32, 32);\r\n            \r\n            const texture = new THREE.CanvasTexture(canvas);\r\n            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });\r\n            const sprite = new THREE.Sprite(spriteMaterial);\r\n            sprite.scale.set(0.3, 0.3, 1);\r\n            sprite.position.copy(position);\r\n            \r\n            return sprite;\r\n        };\r\n        \r\n        group.add(createTextSprite('X', '#ff0000', new THREE.Vector3(1.5, 0, 0)));\r\n        group.add(createTextSprite('Y', '#00ff00', new THREE.Vector3(0, -1.5, 0)));\r\n        group.add(createTextSprite('Z', '#0000ff', new THREE.Vector3(0, 0, 1.5)));\r\n    }\r\n    \r\n    /**\r\n     * Start render loop for viewport gizmo\r\n     */\r\n    // Fix startViewportGizmoRenderLoop to keep gizmo aligned with world axes:\r\n    startViewportGizmoRenderLoop() {\r\n        const animate = () => {\r\n            requestAnimationFrame(animate);\r\n            \r\n            // FIXED: Don't rotate the gizmo group - it should stay aligned with world axes\r\n            // The camera position relative to the gizmo will show the correct orientation\r\n            if (this.viewportGizmoGroup) {\r\n                // Keep the gizmo aligned with world axes (no rotation)\r\n                this.viewportGizmoGroup.quaternion.identity();\r\n            }\r\n            \r\n            // Update the camera to match the main camera's viewing angle\r\n            if (this.viewportGizmoCamera && window.camera) {\r\n                // Get the main camera's position relative to its target\r\n                const target = window.orbitControls ? window.orbitControls.target : new THREE.Vector3(0, 0, 0);\r\n                const relativePos = window.camera.position.clone().sub(target).normalize();\r\n                \r\n                // Set viewport gizmo camera to match this viewing angle\r\n                const distance = 5;\r\n                this.viewportGizmoCamera.position.copy(relativePos.multiplyScalar(distance));\r\n                this.viewportGizmoCamera.up.copy(window.camera.up);\r\n                this.viewportGizmoCamera.lookAt(0, 0, 0);\r\n            }\r\n            \r\n            // Render\r\n            if (this.viewportGizmoRenderer && this.viewportGizmoScene && this.viewportGizmoCamera) {\r\n                this.viewportGizmoRenderer.render(this.viewportGizmoScene, this.viewportGizmoCamera);\r\n            }\r\n        };\r\n        animate();\r\n    }\r\n    \r\n    /**\r\n     * Setup mouse events for viewport gizmo\r\n     */\r\n    setupViewportGizmoEvents(container, canvas) {\r\n        const raycaster = new THREE.Raycaster();\r\n        const mouse = new THREE.Vector2();\r\n        \r\n        // Click handler\r\n        canvas.addEventListener('click', (event) => {\r\n            const rect = canvas.getBoundingClientRect();\r\n            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\r\n            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\r\n            \r\n            raycaster.setFromCamera(mouse, this.viewportGizmoCamera);\r\n            const intersects = raycaster.intersectObjects(this.viewportGizmoGroup.children);\r\n            \r\n            if (intersects.length > 0) {\r\n                const object = intersects[0].object;\r\n                if (object.userData.type === 'face') {\r\n                    this.handleViewportGizmoClick(object.userData);\r\n                }\r\n            }\r\n        });\r\n        \r\n        // Hover effect\r\n        canvas.addEventListener('mousemove', (event) => {\r\n            const rect = canvas.getBoundingClientRect();\r\n            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\r\n            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\r\n            \r\n            raycaster.setFromCamera(mouse, this.viewportGizmoCamera);\r\n            const intersects = raycaster.intersectObjects(this.viewportGizmoGroup.children);\r\n            \r\n            // Reset all materials\r\n            this.viewportGizmoGroup.children.forEach(child => {\r\n                if (child.material && child.userData.type === 'face') {\r\n                    child.material.opacity = 0.8;\r\n                }\r\n            });\r\n            \r\n            // Highlight hovered\r\n            if (intersects.length > 0) {\r\n                const object = intersects[0].object;\r\n                if (object.material && object.userData.type === 'face') {\r\n                    object.material.opacity = 1.0;\r\n                    canvas.style.cursor = 'pointer';\r\n                }\r\n            } else {\r\n                canvas.style.cursor = 'grab';\r\n            }\r\n        });\r\n        \r\n        // Drag to rotate viewport gizmo\r\n        let isDragging = false;\r\n        let lastMousePos = { x: 0, y: 0 };\r\n        \r\n        canvas.addEventListener('mousedown', (event) => {\r\n            if (event.button === 0) {\r\n                isDragging = true;\r\n                lastMousePos = { x: event.clientX, y: event.clientY };\r\n                canvas.style.cursor = 'grabbing';\r\n            }\r\n        });\r\n        \r\n        canvas.addEventListener('mousemove', (event) => {\r\n            if (isDragging) {\r\n                const deltaX = event.clientX - lastMousePos.x;\r\n                const deltaY = event.clientY - lastMousePos.y;\r\n                \r\n                // Rotate the viewport gizmo group\r\n                this.viewportGizmoGroup.rotation.z += deltaX * 0.01;\r\n                this.viewportGizmoGroup.rotation.x += deltaY * 0.01;\r\n                \r\n                lastMousePos = { x: event.clientX, y: event.clientY };\r\n            }\r\n        });\r\n        \r\n        canvas.addEventListener('mouseup', () => {\r\n            isDragging = false;\r\n            canvas.style.cursor = 'grab';\r\n        });\r\n        \r\n        canvas.addEventListener('mouseleave', () => {\r\n            isDragging = false;\r\n            canvas.style.cursor = 'grab';\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Handle viewport gizmo clicks\r\n     */\r\n    handleViewportGizmoClick(faceData) {\r\n        console.log(`[GizmoController] Viewport gizmo clicked: ${faceData.label}`);\r\n        \r\n        // Get current target from OrbitControls\r\n        const currentTarget = window.orbitControls ? \r\n            [window.orbitControls.target.x, window.orbitControls.target.y, window.orbitControls.target.z] : \r\n            [0, 0, 0];\r\n        \r\n        // Calculate camera position based on face, relative to current target\r\n        // Keep the same camera distance (radius) from the target as before the snap\r\n        const targetVec = new THREE.Vector3(currentTarget[0], currentTarget[1], currentTarget[2]);\r\n        const currentRadius = (window.camera && window.orbitControls)\r\n            ? window.camera.position.distanceTo(targetVec)\r\n            : 15; // fallback\r\n        const normal = new THREE.Vector3(...faceData.normal);\r\n        const offset = normal.multiplyScalar(currentRadius);\r\n        \r\n        // Position is target + offset\r\n        const position = [\r\n            currentTarget[0] + offset.x,\r\n            currentTarget[1] + offset.y,\r\n            currentTarget[2] + offset.z\r\n        ];\r\n        \r\n        // Determine the up vector for each face\r\n        let upVector = [0, 0, 1]; // Default up is Z for most views\r\n        \r\n        // Special handling for top/bottom views\r\n        // Top view: screen-up should be +Y\r\n        if (faceData.label === 'Top') {\r\n            upVector = [0, 1, 0];\r\n        } else if (faceData.label === 'Bottom') {\r\n            // Bottom view: screen-up should be -Y\r\n            upVector = [0, -1, 0];\r\n        }\r\n        \r\n        // Send to worker - explicitly maintain the current target\r\n        if (this.worker) {\r\n            this.worker.postMessage({\r\n                type: 'CAMERA_ANIMATE_TO',\r\n                data: {\r\n                    position: position,\r\n                    target: currentTarget,  // Explicitly pass current target\r\n                    upVector: upVector,\r\n                    duration: 500,\r\n                    viewName: faceData.label\r\n                }\r\n            });\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Setup mouse listeners for transform gizmo on main canvas\r\n     */\r\n    setupTransformGizmoListeners() {\r\n        if (!this.canvas) return;\r\n        \r\n        let normalizedMouse = { x: 0, y: 0 };\r\n        let isDragging = false;\r\n        \r\n        // Track mouse position\r\n        this.canvas.addEventListener('mousemove', (event) => {\r\n            const rect = this.canvas.getBoundingClientRect();\r\n            normalizedMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\r\n            normalizedMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\r\n            \r\n            // Send to worker for transform gizmo\r\n            if (this.worker) {\r\n                this.worker.postMessage({\r\n                    type: 'GIZMO_MOUSE_MOVE',\r\n                    data: {\r\n                        x: normalizedMouse.x,\r\n                        y: normalizedMouse.y,\r\n                        isDragging: isDragging\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        \r\n        // Mouse down\r\n        this.canvas.addEventListener('mousedown', (event) => {\r\n            if (event.button !== 0) return; // Only left click\r\n            \r\n            const rect = this.canvas.getBoundingClientRect();\r\n            normalizedMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\r\n            normalizedMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\r\n            \r\n            // Send to worker to check if gizmo was hit\r\n            if (this.worker) {\r\n                this.worker.postMessage({\r\n                    type: 'GIZMO_MOUSE_DOWN',\r\n                    data: {\r\n                        x: normalizedMouse.x,\r\n                        y: normalizedMouse.y\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        \r\n        // Mouse up\r\n        this.canvas.addEventListener('mouseup', (event) => {\r\n            isDragging = false;\r\n            \r\n            if (this.worker) {\r\n                this.worker.postMessage({\r\n                    type: 'GIZMO_MOUSE_UP',\r\n                    data: {}\r\n                });\r\n            }\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Setup listener for worker messages\r\n     */\r\n    setupWorkerMessageListener() {\r\n        // Listen for messages from worker via window events\r\n        window.addEventListener('worker-message', (event) => {\r\n            const { type, data } = event.detail;\r\n            this.handleWorkerMessage(type, data);\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Initialize gizmos in worker\r\n     */\r\n    initializeWorkerGizmos() {\r\n        if (!this.worker) return;\r\n        \r\n        console.log('[GizmoController] Initializing worker transform gizmo...');\r\n        \r\n        this.worker.postMessage({\r\n            type: 'INIT_GIZMOS',\r\n            data: {\r\n                transformGizmoSize: 3.0 // Larger size as requested\r\n            }\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Handle messages from worker\r\n     */\r\n    handleWorkerMessage(type, data) {\r\n        switch (type) {\r\n            case 'CAMERA_UPDATE':\r\n            case 'CAMERA_QUATERNION_UPDATE':\r\n                // Update camera quaternion for viewport gizmo\r\n                if (data.quaternion) {\r\n                    this.cameraQuaternion.fromArray(data.quaternion);\r\n                }\r\n                break;\r\n                \r\n            case 'GIZMO_ACTIVE':\r\n                if (data.active) {\r\n                    // Disable orbit controls while dragging\r\n                    if (window.orbitControls) {\r\n                        window.orbitControls.enabled = false;\r\n                    }\r\n                    this.canvas.style.cursor = 'move';\r\n                } else {\r\n                    // Re-enable orbit controls\r\n                    if (window.orbitControls) {\r\n                        window.orbitControls.enabled = true;\r\n                    }\r\n                    this.canvas.style.cursor = 'grab';\r\n                }\r\n                break;\r\n                \r\n            case 'GIZMO_HOVER':\r\n                if (data.hovering) {\r\n                    this.canvas.style.cursor = 'pointer';\r\n                } else {\r\n                    this.canvas.style.cursor = 'grab';\r\n                }\r\n                break;\r\n                \r\n            case 'UPDATE_CAMERA_TARGET':\r\n                // Update OrbitControls target in main thread\r\n                if (window.orbitControls && data.target) {\r\n                    // Only update the target if Follow is enabled\r\n                    if (window.viewportControls && window.viewportControls.state && !window.viewportControls.state.cameraFollow) {\r\n                        break;\r\n                    }\r\n                    console.log('[GizmoController] Updating camera target:', data.target);\r\n                    window.orbitControls.target.set(data.target.x, data.target.y, data.target.z);\r\n                    window.orbitControls.update();\r\n                }\r\n                break;\r\n                \r\n            case 'UPDATE_CAMERA_FOLLOW':\r\n                // Update both camera position and target to maintain relative view\r\n                if (window.camera && window.orbitControls && data) {\r\n                    // Only follow when Follow checkbox is enabled\r\n                    if (window.viewportControls && window.viewportControls.state && !window.viewportControls.state.cameraFollow) {\r\n                        break;\r\n                    }\r\n                    // Prefer provided delta; if missing, infer from current target -> new target\r\n                    let inferredDelta = null;\r\n                    if (!data.delta && data.target && window.orbitControls?.target) {\r\n                        inferredDelta = {\r\n                            x: data.target.x - window.orbitControls.target.x,\r\n                            y: data.target.y - window.orbitControls.target.y,\r\n                            z: data.target.z - window.orbitControls.target.z\r\n                        };\r\n                    }\r\n\r\n                    const delta = data.delta || inferredDelta;\r\n                    console.log('[GizmoController] Camera follow - applying delta:', delta, 'target:', data.target);\r\n\r\n                    // Move camera by delta to maintain the same relative view\r\n                    if (delta) {\r\n                        window.camera.position.x += delta.x;\r\n                        window.camera.position.y += delta.y;\r\n                        window.camera.position.z += delta.z;\r\n                    }\r\n\r\n                    // Always update the target if provided\r\n                    if (data.target) {\r\n                        window.orbitControls.target.set(data.target.x, data.target.y, data.target.z);\r\n                    }\r\n\r\n                    window.orbitControls.update();\r\n                }\r\n                break;\r\n                \r\n            case 'CAMERA_SNAP_TO_VIEW':\r\n                // Snap camera to a specific view orientation\r\n                if (window.camera && window.orbitControls && data) {\r\n                    console.log('[GizmoController] Snapping camera to view:', data.viewName);\r\n\r\n                    // Disable orbit controls temporarily\r\n                    window.orbitControls.enabled = false;\r\n\r\n                    // Set camera position\r\n                    if (data.position) {\r\n                        window.camera.position.set(data.position[0], data.position[1], data.position[2]);\r\n                    }\r\n\r\n                    // Set orbit controls target and look\r\n                    if (data.target) {\r\n                        window.orbitControls.target.set(data.target[0], data.target[1], data.target[2]);\r\n                        window.camera.lookAt(window.orbitControls.target);\r\n                    }\r\n\r\n                    // Force world Z-up to avoid roll in OrbitControls\r\n                    window.camera.up.set(0, 0, 1);\r\n\r\n                    window.camera.updateMatrixWorld();\r\n                    window.orbitControls.update();\r\n\r\n                    // Re-enable orbit controls after a short delay\r\n                    setTimeout(() => {\r\n                        window.orbitControls.enabled = true;\r\n                    }, 100);\r\n                }\r\n                break;\r\n                \r\n            case 'UPDATE_DELTA_LABEL':\r\n                // Handle delta label display in scene-topbar\r\n                const topbar = document.querySelector('.scene-topbar');\r\n                const topbarControls = document.querySelector('.topbar-controls-wrapper');\r\n                \r\n                if (!window.deltaLabel && topbar) {\r\n                    // Create delta label element in the topbar\r\n                    const deltaLabel = document.createElement('div');\r\n                    deltaLabel.id = 'transform-delta-label';\r\n                    deltaLabel.style.cssText = `\r\n                        padding: 0 12px;\r\n                        color: rgba(255, 255, 255, 0.9);\r\n                        font-family: 'Consolas', 'Monaco', monospace;\r\n                        font-size: 12px;\r\n                        white-space: nowrap;\r\n                        display: none;\r\n                        align-items: center;\r\n                        height: 100%;\r\n                    `;\r\n                    // Insert at the beginning of the topbar\r\n                    topbar.insertBefore(deltaLabel, topbar.firstChild);\r\n                    window.deltaLabel = deltaLabel;\r\n                }\r\n                \r\n                if (data && data.visible && window.deltaLabel) {\r\n                    window.deltaLabel.textContent = data.text;\r\n                    window.deltaLabel.style.display = 'flex'; // Use flex to center vertically\r\n                    \r\n                    // Hide the topbar controls while showing delta\r\n                    if (topbarControls) {\r\n                        topbarControls.style.display = 'none';\r\n                    }\r\n                } else if (window.deltaLabel) {\r\n                    window.deltaLabel.style.display = 'none';\r\n                    \r\n                    // Show the topbar controls again\r\n                    if (topbarControls) {\r\n                        topbarControls.style.display = 'flex';\r\n                    }\r\n                }\r\n                break;\r\n                \r\n            case 'GIZMO_TRANSFORM_UPDATE':\r\n                // Handle transform updates from gizmo\r\n                if (data.position || data.rotation || data.scale) {\r\n                    this.handleTransformUpdate(data);\r\n                }\r\n                break;\r\n            case 'POSITION_DRAG_ENDED':\r\n                // Maintain view relative to the object after position drag ends\r\n                if (data && data.position && window.camera && window.orbitControls) {\r\n                    // Only follow when Follow checkbox is enabled\r\n                    if (window.viewportControls && window.viewportControls.state && !window.viewportControls.state.cameraFollow) {\r\n                        break;\r\n                    }\r\n                    const delta = data.delta || { x: 0, y: 0, z: 0 };\r\n\r\n                    // Move camera by the object's movement delta\r\n                    window.camera.position.x += delta.x;\r\n                    window.camera.position.y += delta.y;\r\n                    window.camera.position.z += delta.z;\r\n\r\n                    // Snap orbit target to the new object position\r\n                    window.orbitControls.target.set(\r\n                        data.position.x,\r\n                        data.position.y,\r\n                        data.position.z\r\n                    );\r\n\r\n                    window.orbitControls.update();\r\n                    console.log('[GizmoController] Position drag ended - camera and target updated. Delta:', delta);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Handle transform updates from gizmo\r\n     */\r\n    handleTransformUpdate(data) {\r\n        console.log('[GizmoController] Handling transform update:', data);\r\n        \r\n        // Update object controls UI by setting state and triggering events\r\n        if (window.objectControls && window.objectControls.state) {\r\n            const state = window.objectControls.state;\r\n            let changed = false;\r\n            \r\n            // Update position (pos-x, pos-y, pos-z)\r\n            if (data.position) {\r\n                state.transform.position.x = data.position.x;\r\n                state.transform.position.y = data.position.y;\r\n                state.transform.position.z = data.position.z;\r\n                changed = true;\r\n            }\r\n            \r\n            // Update rotation (rot-x, rot-y, rot-z)\r\n            if (data.rotation) {\r\n                state.transform.rotation.x = data.rotation.x;\r\n                state.transform.rotation.y = data.rotation.y;\r\n                state.transform.rotation.z = data.rotation.z;\r\n                changed = true;\r\n            }\r\n            \r\n            // Update scale (scale-x, scale-y, scale-z) - independent values\r\n            if (data.scale) {\r\n                state.transform.scale.x = data.scale.x;\r\n                state.transform.scale.y = data.scale.y;\r\n                state.transform.scale.z = data.scale.z;\r\n                changed = true;\r\n            }\r\n            \r\n            // Update uniform scale (master-scale) - ONLY when donut is dragged\r\n            if (data.uniformScale !== undefined) {\r\n                state.transform.uniformScale = data.uniformScale;\r\n                // DO NOT update individual scale components - keep them independent\r\n                // The visual scale should be uniformScale * scale.x/y/z\r\n                changed = true;\r\n            }\r\n            \r\n            if (changed) {\r\n                // Update the UI inputs using _renderUI\r\n                if (window.objectControls._renderUI) {\r\n                    window.objectControls._renderUI();\r\n                }\r\n                \r\n                // Emit transform change event for C3\r\n                if (window.objectControls.emit) {\r\n                    window.objectControls.emit('transforms-changed', {\r\n                        transform: state.transform,\r\n                        deltaTransform: state.deltaTransform,\r\n                        source: 'gizmo' // Mark as from gizmo\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Also send directly to parent (C3) if available\r\n        if (window.sendTransformsToParent) {\r\n            // Get the current unitScale from object controls state\r\n            const currentUnitScale = window.objectControls && window.objectControls.state \r\n                ? window.objectControls.state.transform.unitScale: 64;\r\n            \r\n            const transform = {\r\n                position: data.position || { x: 0, y: 0, z: 0 },\r\n                rotation: data.rotation || { x: 0, y: 0, z: 0 },\r\n                scale: data.scale || { x: 1, y: 1, z: 1 },\r\n                uniformScale: 1,\r\n                unitScale: currentUnitScale,\r\n                rotationOrder: 'ZXY'\r\n            };\r\n            \r\n            // Only send uniform scale if it was explicitly updated (yellow sphere dragged)\r\n            // DO NOT calculate uniform scale from individual axes\r\n            if (data.uniformScale !== undefined) {\r\n                transform.uniformScale = data.uniformScale;\r\n            }\r\n            \r\n            window.sendTransformsToParent(transform, {});\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Public methods for external control\r\n     */\r\n    setMode(mode) {\r\n        if (this.worker) {\r\n            this.worker.postMessage({\r\n                type: 'SET_GIZMO_MODE',\r\n                data: { mode }\r\n            });\r\n        }\r\n    }\r\n    \r\n    setSpace(space) {\r\n        if (this.worker) {\r\n            this.worker.postMessage({\r\n                type: 'SET_GIZMO_SPACE',\r\n                data: { space }\r\n            });\r\n        }\r\n    }\r\n    \r\n    setVisible(visible) {\r\n        if (this.worker) {\r\n            this.worker.postMessage({\r\n                type: 'SET_GIZMO_VISIBLE',\r\n                data: { visible }\r\n            });\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Cleanup\r\n     */\r\n    dispose() {\r\n        // Remove viewport gizmo container\r\n        const container = document.getElementById('viewport-gizmo-container');\r\n        if (container) {\r\n            container.remove();\r\n        }\r\n        \r\n        // Cleanup Three.js resources\r\n        if (this.viewportGizmoRenderer) {\r\n            this.viewportGizmoRenderer.dispose();\r\n        }\r\n        \r\n        this.isInitialized = false;\r\n    }\r\n}\r\n\r\n// Debug: Check if script is loading\r\nconsole.log('[GizmoController] \u{1F680} Script loaded!');\r\nconsole.log('[GizmoController] Current window.gizmoController:', window.gizmoController);\r\n\r\n// Create global instance\r\ntry {\r\n    console.log('[GizmoController] Creating global instance...');\r\n    window.gizmoController = new GizmoController();\r\n    console.log('[GizmoController] Global instance created:', window.gizmoController);\r\n} catch (error) {\r\n    console.error('[GizmoController] Failed to create instance:', error);\r\n}\r\n\r\n// Auto-initialize when worker is ready\r\nif (document.readyState === 'loading') {\r\n    console.log('[GizmoController] Document still loading, adding DOMContentLoaded listener');\r\n    document.addEventListener('DOMContentLoaded', () => {\r\n        console.log('[GizmoController] DOMContentLoaded fired!');\r\n        initializeGizmoWhenReady();\r\n    });\r\n} else {\r\n    console.log('[GizmoController] Document already loaded, initializing now');\r\n    initializeGizmoWhenReady();\r\n}\r\n\r\nfunction initializeGizmoWhenReady() {\r\n    console.log('[GizmoController] Waiting for worker...');\r\n    let checkCount = 0;\r\n    const checkWorker = setInterval(() => {\r\n        checkCount++;\r\n        console.log(`[GizmoController] Check #${checkCount}: worker=${!!window.worker}, canvas=${!!document.getElementById('three-canvas')}`);\r\n        \r\n        if (window.worker) {\r\n            clearInterval(checkWorker);\r\n            const canvas = document.getElementById('three-canvas');\r\n            console.log('[GizmoController] Worker found! Canvas:', canvas);\r\n            \r\n            if (canvas) {\r\n                console.log('[GizmoController] Initializing with canvas and worker');\r\n                window.gizmoController.initialize(canvas, window.worker);\r\n                \r\n                // Initialize Scene Topbar Controls\r\n                if (window.SceneTopbarControls) {\r\n                    console.log('[GizmoController] Initializing Scene Topbar Controls');\r\n                    window.sceneTopbarControls = new SceneTopbarControls();\r\n                    window.sceneTopbarControls.initialize();\r\n                } else {\r\n                    console.warn('[GizmoController] SceneTopbarControls not available');\r\n                }\r\n                \r\n                // Initialize Viewport Buttons\r\n                if (window.ViewportButtons) {\r\n                    console.log('[GizmoController] Initializing Viewport Buttons');\r\n                    window.viewportButtons = new ViewportButtons();\r\n                    window.viewportButtons.initialize(window.worker);\r\n                    \r\n                    // Connect to scene topbar controls if available\r\n                    if (window.sceneTopbarControls) {\r\n                        // The scene topbar controls will handle visibility toggling\r\n                        console.log('[GizmoController] Viewport Buttons connected to Scene Topbar Controls');\r\n                    }\r\n                } else {\r\n                    console.warn('[GizmoController] ViewportButtons not available');\r\n                }\r\n            } else {\r\n                console.error('[GizmoController] Canvas not found!');\r\n            }\r\n        }\r\n        \r\n        if (checkCount > 50) { // Stop after 5 seconds\r\n            clearInterval(checkWorker);\r\n            console.error('[GizmoController] Timeout waiting for worker!');\r\n        }\r\n    }, 100);\r\n}\r\n\r\n// Forward worker messages to gizmo controller\r\nif (!window._workerMessageForwarder) {\r\n    window._workerMessageForwarder = true;\r\n    \r\n    // Listen for worker messages properly\r\n    const setupWorkerForwarding = () => {\r\n        if (window.worker) {\r\n            console.log('[GizmoController] Setting up worker message forwarding');\r\n            window.worker.addEventListener('message', (event) => {\r\n                if (event.data && event.data.type) {\r\n                    // Debug specific gizmo messages\r\n                    if (event.data.type.includes('GIZMO') || event.data.type.includes('CAMERA_QUATERNION')) {\r\n                        console.log('[GizmoController] Worker message:', event.data.type, event.data.data);\r\n                    }\r\n                    \r\n                    // Dispatch custom event for gizmo controller\r\n                    window.dispatchEvent(new CustomEvent('worker-message', {\r\n                        detail: event.data\r\n                    }));\r\n                }\r\n            });\r\n        } else {\r\n            // Retry if worker not ready\r\n            setTimeout(setupWorkerForwarding, 100);\r\n        }\r\n    };\r\n    setupWorkerForwarding();\r\n}",
        "statsOverlay": `/* FILE: editor/z3d-object-editor/templates/scripts/components/stats-overlay.js */\r
/* Stats Overlay Component - Shows real-time rendering statistics */\r
\r
class StatsOverlay {\r
    constructor() {\r
        this.isVisible = false;\r
        this.container = null;\r
        this.updateInterval = null;\r
        \r
        // Stats tracking\r
        this.stats = {\r
            fps: 60,\r
            frameTime: 0,\r
            vertices: 0,\r
            triangles: 0,\r
            drawCalls: 0,\r
            textures: 0,\r
            geometries: 0,\r
            programs: 0,\r
            memory: 0\r
        };\r
        \r
        // FPS calculation\r
        this.frameCount = 0;\r
        this.lastTime = performance.now();\r
        this.fps = 60;\r
        \r
        console.log('[StatsOverlay] Created');\r
    }\r
    \r
    initialize() {\r
        // Find or create the stats overlay container\r
        this.container = document.getElementById('stats-overlay');\r
        \r
        if (!this.container) {\r
            console.error('[StatsOverlay] Container element not found');\r
            return;\r
        }\r
        \r
        // Setup the stats content structure\r
        this.setupStatsContent();\r
        \r
        // Start hidden by default\r
        this.hide();\r
        \r
        // Listen for scene updates from worker\r
        this.setupWorkerListener();\r
        \r
        console.log('[StatsOverlay] Initialized');\r
    }\r
    \r
    setupStatsContent() {\r
        // Create a more comprehensive stats display\r
        this.container.innerHTML = \`\r
            <div class="stats-header">Render Stats</div>\r
            <div class="stats-content">\r
                <div class="stats-section">\r
                    <div class="stat-row">\r
                        <span class="stat-label">FPS:</span>\r
                        <span class="stat-value" id="stat-fps">60</span>\r
                    </div>\r
                    <div class="stat-row">\r
                        <span class="stat-label">Frame Time:</span>\r
                        <span class="stat-value" id="stat-frametime">16.7ms</span>\r
                    </div>\r
                </div>\r
                \r
                <div class="stats-section">\r
                    <div class="stat-row">\r
                        <span class="stat-label">Vertices:</span>\r
                        <span class="stat-value" id="stat-vertices">0</span>\r
                    </div>\r
                    <div class="stat-row">\r
                        <span class="stat-label">Triangles:</span>\r
                        <span class="stat-value" id="stat-triangles">0</span>\r
                    </div>\r
                    <div class="stat-row">\r
                        <span class="stat-label">Draw Calls:</span>\r
                        <span class="stat-value" id="stat-drawcalls">0</span>\r
                    </div>\r
                </div>\r
                \r
                <div class="stats-section">\r
                    <div class="stat-row">\r
                        <span class="stat-label">Textures:</span>\r
                        <span class="stat-value" id="stat-textures">0</span>\r
                    </div>\r
                    <div class="stat-row">\r
                        <span class="stat-label">Geometries:</span>\r
                        <span class="stat-value" id="stat-geometries">0</span>\r
                    </div>\r
                    <div class="stat-row">\r
                        <span class="stat-label">Programs:</span>\r
                        <span class="stat-value" id="stat-programs">0</span>\r
                    </div>\r
                </div>\r
                \r
                <div class="stats-section">\r
                    <div class="stat-row">\r
                        <span class="stat-label">Memory:</span>\r
                        <span class="stat-value" id="stat-memory">0 MB</span>\r
                    </div>\r
                </div>\r
            </div>\r
        \`;\r
        \r
        // Cache DOM elements for performance\r
        this.elements = {\r
            fps: document.getElementById('stat-fps'),\r
            frameTime: document.getElementById('stat-frametime'),\r
            vertices: document.getElementById('stat-vertices'),\r
            triangles: document.getElementById('stat-triangles'),\r
            drawCalls: document.getElementById('stat-drawcalls'),\r
            textures: document.getElementById('stat-textures'),\r
            geometries: document.getElementById('stat-geometries'),\r
            programs: document.getElementById('stat-programs'),\r
            memory: document.getElementById('stat-memory')\r
        };\r
    }\r
    \r
    setupWorkerListener() {\r
        if (!window.worker) {\r
            console.warn('[StatsOverlay] Worker not available yet');\r
            return;\r
        }\r
        \r
        // Listen for stats updates from the worker\r
        window.worker.addEventListener('message', (event) => {\r
            const { type, data } = event.data;\r
            \r
            switch (type) {\r
                case 'RENDER_STATS':\r
                    this.updateStats(data);\r
                    break;\r
                    \r
                case 'SCENE_STATS':\r
                    this.updateSceneStats(data);\r
                    break;\r
            }\r
        });\r
        \r
        // Request initial stats\r
        window.worker.postMessage({ type: 'REQUEST_STATS' });\r
    }\r
    \r
    updateStats(data) {\r
        if (!this.isVisible) return;\r
        \r
        // Update stored stats\r
        if (data.vertices !== undefined) this.stats.vertices = data.vertices;\r
        if (data.triangles !== undefined) this.stats.triangles = data.triangles;\r
        if (data.drawCalls !== undefined) this.stats.drawCalls = data.drawCalls;\r
        \r
        // Update display\r
        this.updateDisplay();\r
    }\r
    \r
    updateSceneStats(data) {\r
        if (!this.isVisible) return;\r
        \r
        // Update renderer info\r
        if (data.memory) {\r
            this.stats.geometries = data.memory.geometries || 0;\r
            this.stats.textures = data.memory.textures || 0;\r
            this.stats.programs = data.memory.programs || 0;\r
        }\r
        \r
        // Update display\r
        this.updateDisplay();\r
    }\r
    \r
    updateDisplay() {\r
        if (!this.elements || !this.isVisible) return;\r
        \r
        // Update all stat displays\r
        if (this.elements.fps) {\r
            this.elements.fps.textContent = Math.round(this.fps);\r
        }\r
        \r
        if (this.elements.frameTime) {\r
            const frameTime = this.fps > 0 ? (1000 / this.fps).toFixed(1) : '0';\r
            this.elements.frameTime.textContent = \`\${frameTime}ms\`;\r
        }\r
        \r
        if (this.elements.vertices) {\r
            this.elements.vertices.textContent = this.formatNumber(this.stats.vertices);\r
        }\r
        \r
        if (this.elements.triangles) {\r
            this.elements.triangles.textContent = this.formatNumber(this.stats.triangles);\r
        }\r
        \r
        if (this.elements.drawCalls) {\r
            this.elements.drawCalls.textContent = this.stats.drawCalls;\r
        }\r
        \r
        if (this.elements.textures) {\r
            this.elements.textures.textContent = this.stats.textures;\r
        }\r
        \r
        if (this.elements.geometries) {\r
            this.elements.geometries.textContent = this.stats.geometries;\r
        }\r
        \r
        if (this.elements.programs) {\r
            this.elements.programs.textContent = this.stats.programs;\r
        }\r
        \r
        if (this.elements.memory && performance.memory) {\r
            const usedMB = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);\r
            this.elements.memory.textContent = \`\${usedMB} MB\`;\r
        }\r
    }\r
    \r
    formatNumber(num) {\r
        if (num >= 1000000) {\r
            return (num / 1000000).toFixed(1) + 'M';\r
        } else if (num >= 1000) {\r
            return (num / 1000).toFixed(1) + 'K';\r
        }\r
        return num.toString();\r
    }\r
    \r
    startFPSTracking() {\r
        // Track FPS using requestAnimationFrame\r
        const trackFrame = () => {\r
            if (!this.isVisible) return;\r
            \r
            this.frameCount++;\r
            const currentTime = performance.now();\r
            const delta = currentTime - this.lastTime;\r
            \r
            // Update FPS every 500ms\r
            if (delta >= 500) {\r
                this.fps = (this.frameCount * 1000) / delta;\r
                this.frameCount = 0;\r
                this.lastTime = currentTime;\r
                this.updateDisplay();\r
            }\r
            \r
            requestAnimationFrame(trackFrame);\r
        };\r
        \r
        requestAnimationFrame(trackFrame);\r
    }\r
    \r
    show() {\r
        if (this.container) {\r
            this.container.style.display = 'block';\r
            this.isVisible = true;\r
            \r
            // Start FPS tracking\r
            this.frameCount = 0;\r
            this.lastTime = performance.now();\r
            this.startFPSTracking();\r
            \r
            // Request fresh stats from worker\r
            if (window.worker) {\r
                window.worker.postMessage({ type: 'REQUEST_STATS' });\r
            }\r
            \r
            console.log('[StatsOverlay] Shown');\r
        }\r
    }\r
    \r
    hide() {\r
        if (this.container) {\r
            this.container.style.display = 'none';\r
            this.isVisible = false;\r
            console.log('[StatsOverlay] Hidden');\r
        }\r
    }\r
    \r
    toggle() {\r
        if (this.isVisible) {\r
            this.hide();\r
        } else {\r
            this.show();\r
        }\r
        return this.isVisible;\r
    }\r
    \r
    dispose() {\r
        this.hide();\r
        if (this.updateInterval) {\r
            clearInterval(this.updateInterval);\r
            this.updateInterval = null;\r
        }\r
        this.container = null;\r
        this.elements = null;\r
        console.log('[StatsOverlay] Disposed');\r
    }\r
}\r
\r
// Make it globally available\r
window.StatsOverlay = StatsOverlay;`,
        "sceneTopbarControls": `/* FILE: editor/z3d-object-editor/templates/scripts/components/scene-topbar-controls.js */\r
/* Scene Topbar Controls - Manages the scene topbar buttons and functionality */\r
\r
class SceneTopbarControls {\r
    constructor() {\r
        this.container = null;\r
        this.statsOverlay = null;\r
        this.gizmoController = null;\r
        \r
        // Toggle states\r
        this.showOverlays = false;\r
        this.showGizmos = true;\r
    this.snapEnabled = false;\r
        \r
        console.log('[SceneTopbarControls] Created');\r
    }\r
    \r
    initialize() {\r
        // Find or create the scene topbar\r
        this.container = document.querySelector('.scene-topbar');\r
        \r
        if (!this.container) {\r
            console.error('[SceneTopbarControls] Scene topbar not found');\r
            return;\r
        }\r
        \r
        // Ensure the topbar has proper styling for visibility and full width\r
        this.container.style.zIndex = '1000';\r
        this.container.style.position = 'absolute';\r
        this.container.style.pointerEvents = 'auto';\r
        this.container.style.top = '0';\r
        this.container.style.left = '0';\r
        this.container.style.right = '0';\r
        this.container.style.width = '100%';\r
        this.container.style.height = '36px';\r
        this.container.style.background = 'rgba(37, 37, 37, 0.95)';\r
        this.container.style.backdropFilter = 'blur(10px)';\r
        this.container.style.borderBottom = '1px solid rgba(255, 255, 255, 0.1)';\r
        \r
        // Restructure the topbar with three containers\r
        this.restructureTopbar();\r
        \r
        // Initialize stats overlay\r
        this.initializeStatsOverlay();\r
        \r
        // Setup button handlers\r
        this.setupButtonHandlers();\r
        \r
        // Ensure initial states are correct\r
        this.updateButtonStates();\r
        \r
        console.log('[SceneTopbarControls] Initialized with gizmos:', this.showGizmos, 'overlays:', this.showOverlays);\r
    }\r
    \r
    restructureTopbar() {\r
        // Clear existing content\r
        this.container.innerHTML = '';\r
        \r
        // Create wrapper for all controls (can be hidden/shown as a group)\r
        const controlsWrapper = document.createElement('div');\r
        controlsWrapper.className = 'topbar-controls-wrapper';\r
        controlsWrapper.style.width = '100%';\r
        controlsWrapper.style.height = '100%';\r
        controlsWrapper.style.display = 'flex';\r
        controlsWrapper.style.alignItems = 'center';\r
        controlsWrapper.style.justifyContent = 'space-between';\r
        controlsWrapper.style.padding = '0 12px';\r
        controlsWrapper.style.boxSizing = 'border-box';\r
        controlsWrapper.innerHTML = \`\r
            <!-- Left Container -->\r
            <div class="topbar-left" style="flex: 0 0 auto;">\r
                <!-- Future buttons go here -->\r
            </div>\r
            \r
            <!-- Center Container -->\r
            <div class="topbar-center" style="flex: 1 1 auto; display: flex; align-items: center; justify-content: center; gap: 6px;">\r
                <button id="toggle-snap" class="btn btn-sm topbar-btn" title="Toggle Snap (position/rotation)">\r
                    <span class="btn-icon">\u{1F512}</span>\r
                    <span class="btn-text">Snap</span>\r
                </button>\r
            </div>\r
            \r
            <!-- Right Container -->\r
            <div class="topbar-right" style="flex: 0 0 auto; margin-left: auto; display: flex; gap: 4px;">\r
                <button id="toggle-gizmos" class="btn btn-sm topbar-btn active" title="Toggle Gizmos" style="margin-right: 4px;">\r
                    <span class="btn-icon">\u{1F3AF}</span>\r
                    <span class="btn-text">Gizmos</span>\r
                </button>\r
                <button id="toggle-overlays" class="btn btn-sm topbar-btn" title="Toggle Overlays">\r
                    <span class="btn-icon">\u{1F4CA}</span>\r
                    <span class="btn-text">Overlays</span>\r
                </button>\r
            </div>\r
        \`;\r
        \r
        this.container.appendChild(controlsWrapper);\r
        \r
        // Cache references\r
        this.controlsWrapper = controlsWrapper;\r
        this.leftContainer = controlsWrapper.querySelector('.topbar-left');\r
        this.centerContainer = controlsWrapper.querySelector('.topbar-center');\r
        this.rightContainer = controlsWrapper.querySelector('.topbar-right');\r
        \r
        // Cache button references\r
        this.gizmosButton = document.getElementById('toggle-gizmos');\r
        this.overlaysButton = document.getElementById('toggle-overlays');\r
    this.snapButton = document.getElementById('toggle-snap');\r
        \r
        // Set initial button states\r
        this.updateButtonStates();\r
    }\r
    \r
    initializeStatsOverlay() {\r
        // Create and initialize the stats overlay\r
        if (!window.StatsOverlay) {\r
            console.warn('[SceneTopbarControls] StatsOverlay class not available');\r
            return;\r
        }\r
        \r
        this.statsOverlay = new StatsOverlay();\r
        this.statsOverlay.initialize();\r
    }\r
    \r
    setupButtonHandlers() {\r
        // Toggle Overlays button\r
        if (this.overlaysButton) {\r
            this.overlaysButton.addEventListener('click', (e) => {\r
                this.handleButtonClick(e.currentTarget);\r
                this.toggleOverlays();\r
            });\r
        }\r
        \r
        // Toggle Gizmos button\r
        if (this.gizmosButton) {\r
            this.gizmosButton.addEventListener('click', (e) => {\r
                this.handleButtonClick(e.currentTarget);\r
                this.toggleGizmos();\r
            });\r
        }\r
\r
        // Toggle Snap button\r
        if (this.snapButton) {\r
            this.snapButton.addEventListener('click', (e) => {\r
                this.handleButtonClick(e.currentTarget);\r
                this.toggleSnap();\r
            });\r
        }\r
    }\r
    \r
    handleButtonClick(button) {\r
        // Add clicked class for animation\r
        button.classList.add('clicked');\r
        \r
        // Force button to lose focus\r
        button.blur();\r
        \r
        // Remove the class after animation completes\r
        setTimeout(() => {\r
            button.classList.remove('clicked');\r
        }, 300);\r
    }\r
    \r
    toggleOverlays() {\r
        this.showOverlays = !this.showOverlays;\r
        \r
        // Toggle stats overlay\r
        if (this.statsOverlay) {\r
            if (this.showOverlays) {\r
                this.statsOverlay.show();\r
            } else {\r
                this.statsOverlay.hide();\r
            }\r
        }\r
        \r
        // Update button state\r
        this.updateButtonStates();\r
        \r
        console.log('[SceneTopbarControls] Overlays toggled:', this.showOverlays);\r
    }\r
    \r
    toggleGizmos() {\r
        this.showGizmos = !this.showGizmos;\r
        \r
        // Send message to worker to toggle transform gizmo\r
        if (window.worker) {\r
            window.worker.postMessage({\r
                type: 'TOGGLE_GIZMOS',\r
                data: { visible: this.showGizmos }\r
            });\r
        }\r
        \r
        // Toggle viewport buttons visibility\r
        if (window.viewportButtons) {\r
            window.viewportButtons.setVisible(this.showGizmos);\r
        }\r
        \r
        // Toggle viewport gizmo\r
        const viewportGizmoContainer = document.getElementById('viewport-gizmo-container');\r
        if (viewportGizmoContainer) {\r
            viewportGizmoContainer.style.display = this.showGizmos ? 'block' : 'none';\r
        }\r
        \r
        // Update button state\r
        this.updateButtonStates();\r
        \r
        console.log('[SceneTopbarControls] Gizmos toggled:', this.showGizmos);\r
    }\r
    \r
    updateButtonStates() {\r
        // Update overlays button\r
        if (this.overlaysButton) {\r
            if (this.showOverlays) {\r
                this.overlaysButton.classList.add('active');\r
                // Apply inline styles as fallback\r
                this.overlaysButton.style.background = 'rgba(76, 175, 80, 0.2)';\r
                this.overlaysButton.style.borderColor = '#4CAF50';\r
                this.overlaysButton.style.color = '#4CAF50';\r
                this.overlaysButton.style.boxShadow = '0 0 0 1px #4CAF50';\r
                console.log('[SceneTopbarControls] Overlays button set to active');\r
            } else {\r
                this.overlaysButton.classList.remove('active');\r
                // Remove inline styles\r
                this.overlaysButton.style.background = '';\r
                this.overlaysButton.style.borderColor = '';\r
                this.overlaysButton.style.color = '';\r
                this.overlaysButton.style.boxShadow = '';\r
                console.log('[SceneTopbarControls] Overlays button set to inactive');\r
            }\r
        }\r
        \r
        // Update gizmos button\r
        if (this.gizmosButton) {\r
            if (this.showGizmos) {\r
                this.gizmosButton.classList.add('active');\r
                // Apply inline styles as fallback\r
                this.gizmosButton.style.background = 'rgba(76, 175, 80, 0.2)';\r
                this.gizmosButton.style.borderColor = '#4CAF50';\r
                this.gizmosButton.style.color = '#4CAF50';\r
                this.gizmosButton.style.boxShadow = '0 0 0 1px #4CAF50';\r
                console.log('[SceneTopbarControls] Gizmos button set to active, classes:', this.gizmosButton.className);\r
            } else {\r
                this.gizmosButton.classList.remove('active');\r
                // Remove inline styles\r
                this.gizmosButton.style.background = '';\r
                this.gizmosButton.style.borderColor = '';\r
                this.gizmosButton.style.color = '';\r
                this.gizmosButton.style.boxShadow = '';\r
                console.log('[SceneTopbarControls] Gizmos button set to inactive, classes:', this.gizmosButton.className);\r
            }\r
        }\r
\r
        // Update snap button\r
        if (this.snapButton) {\r
            if (this.snapEnabled) {\r
                this.snapButton.classList.add('active');\r
                this.snapButton.style.background = 'rgba(76, 175, 80, 0.2)';\r
                this.snapButton.style.borderColor = '#4CAF50';\r
                this.snapButton.style.color = '#4CAF50';\r
                this.snapButton.style.boxShadow = '0 0 0 1px #4CAF50';\r
            } else {\r
                this.snapButton.classList.remove('active');\r
                this.snapButton.style.background = '';\r
                this.snapButton.style.borderColor = '';\r
                this.snapButton.style.color = '';\r
                this.snapButton.style.boxShadow = '';\r
            }\r
        }\r
    }\r
\r
    toggleSnap() {\r
        this.snapEnabled = !this.snapEnabled;\r
\r
        // Inform worker\r
        if (window.worker) {\r
            window.worker.postMessage({\r
                type: 'SET_SNAP_ENABLED',\r
                data: { enabled: this.snapEnabled }\r
            });\r
        }\r
\r
        this.updateButtonStates();\r
        console.log('[SceneTopbarControls] Snap toggled:', this.snapEnabled);\r
    }\r
    \r
    // Method to show/hide the entire controls wrapper\r
    showControls() {\r
        if (this.controlsWrapper) {\r
            this.controlsWrapper.style.display = 'flex';\r
        }\r
    }\r
    \r
    hideControls() {\r
        if (this.controlsWrapper) {\r
            this.controlsWrapper.style.display = 'none';\r
        }\r
    }\r
    \r
    // Method to set custom content in the center container\r
    setCenterContent(content) {\r
        if (this.centerContainer) {\r
            if (typeof content === 'string') {\r
                this.centerContainer.innerHTML = content;\r
            } else if (content instanceof HTMLElement) {\r
                this.centerContainer.innerHTML = '';\r
                this.centerContainer.appendChild(content);\r
            }\r
        }\r
    }\r
    \r
    // Method to add buttons to left container\r
    addLeftButton(button) {\r
        if (this.leftContainer && button instanceof HTMLElement) {\r
            this.leftContainer.appendChild(button);\r
        }\r
    }\r
    \r
    dispose() {\r
        // Dispose stats overlay\r
        if (this.statsOverlay) {\r
            this.statsOverlay.dispose();\r
            this.statsOverlay = null;\r
        }\r
        \r
        // Clear references\r
        this.container = null;\r
        this.controlsWrapper = null;\r
        this.leftContainer = null;\r
        this.centerContainer = null;\r
        this.rightContainer = null;\r
        this.gizmosButton = null;\r
        this.overlaysButton = null;\r
        \r
        console.log('[SceneTopbarControls] Disposed');\r
    }\r
}\r
\r
// Make it globally available\r
window.SceneTopbarControls = SceneTopbarControls;`,
        "viewportButtons": "/* FILE: templates/scripts/components/viewport-buttons.js */\r\n/* Viewport action buttons - circular buttons for camera controls */\r\n\r\nclass ViewportButtons {\r\n    constructor() {\r\n        this.container = null;\r\n        this.buttons = {};\r\n        this.isVisible = true;\r\n        this.worker = null;\r\n    // Padding multiplier for framing (distance buffer around the object)\r\n    this.focusPadding = 1.75; // increase as requested; can be overridden via window.Z3D_FOCUS_PADDING\r\n    }\r\n    \r\n    initialize(worker) {\r\n        this.worker = worker;\r\n        this.createContainer();\r\n        this.createButtons();\r\n        this.setupEventListeners();\r\n        \r\n        // Start visible (will be controlled by gizmos toggle)\r\n        this.setVisible(true);\r\n        \r\n        console.log('[ViewportButtons] Initialized');\r\n    }\r\n    \r\n    createContainer() {\r\n        // Create container for circular buttons\r\n        this.container = document.createElement('div');\r\n        this.container.className = 'viewport-buttons-container';\r\n        this.container.style.cssText = `\r\n            position: absolute;\r\n            top: 260px;  /* Below viewport gizmo */\r\n            right: 10px;\r\n            width: 48px;\r\n            display: flex;\r\n            flex-direction: column;\r\n            gap: 10px;\r\n            z-index: 85;\r\n            pointer-events: auto;\r\n        `;\r\n        \r\n        // Add to viewport area\r\n        const viewportArea = document.getElementById('viewport-area');\r\n        if (viewportArea) {\r\n            viewportArea.appendChild(this.container);\r\n        }\r\n    }\r\n    \r\n    createButtons() {\r\n        // Create focus/refocus button\r\n        const focusButton = this.createButton({\r\n            id: 'focus-camera',\r\n            icon: '\u{1F50D}',  // Alternative: \u{1F3AF}, \u{1F441}\uFE0F, or we can use SVG\r\n            tooltip: 'Focus on Model',\r\n            onClick: () => this.handleFocusCamera()\r\n        });\r\n        \r\n        this.buttons.focus = focusButton;\r\n        this.container.appendChild(focusButton);\r\n    }\r\n    \r\n    createButton(config) {\r\n        const button = document.createElement('button');\r\n        button.id = config.id;\r\n        button.className = 'viewport-button';\r\n        button.title = config.tooltip;\r\n        button.innerHTML = `<span class=\"button-icon\">${config.icon}</span>`;\r\n        \r\n        // Style the button\r\n        button.style.cssText = `\r\n            width: 48px;\r\n            height: 48px;\r\n            border-radius: 50%;\r\n            background: rgba(37, 37, 37, 0.9);\r\n            backdrop-filter: blur(10px);\r\n            border: 1px solid rgba(255, 255, 255, 0.1);\r\n            color: rgba(255, 255, 255, 0.7);\r\n            font-size: 20px;\r\n            cursor: pointer;\r\n            display: flex;\r\n            align-items: center;\r\n            justify-content: center;\r\n            transition: all 0.2s ease;\r\n            outline: none;\r\n            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\r\n            pointer-events: auto;\r\n        `;\r\n        \r\n        // Add hover effects\r\n        button.addEventListener('mouseenter', () => {\r\n            button.style.background = 'rgba(37, 37, 37, 0.95)';\r\n            button.style.borderColor = 'rgba(255, 255, 255, 0.2)';\r\n            button.style.color = 'rgba(255, 255, 255, 0.9)';\r\n            button.style.transform = 'scale(1.05)';\r\n        });\r\n        \r\n        button.addEventListener('mouseleave', () => {\r\n            button.style.background = 'rgba(37, 37, 37, 0.9)';\r\n            button.style.borderColor = 'rgba(255, 255, 255, 0.1)';\r\n            button.style.color = 'rgba(255, 255, 255, 0.7)';\r\n            button.style.transform = 'scale(1)';\r\n        });\r\n        \r\n        button.addEventListener('mousedown', () => {\r\n            button.style.transform = 'scale(0.95)';\r\n        });\r\n        \r\n        button.addEventListener('mouseup', () => {\r\n            button.style.transform = 'scale(1)';\r\n        });\r\n        \r\n        if (config.onClick) {\r\n            button.addEventListener('click', config.onClick);\r\n        }\r\n        \r\n        return button;\r\n    }\r\n    \r\n    handleFocusCamera() {\r\n        console.log('[ViewportButtons] Focus camera on model');\r\n        \r\n        // Get camera and controls\r\n        const camera = window.camera;\r\n        const controls = window.orbitControls;\r\n        \r\n        if (!camera || !controls) {\r\n            console.warn('[ViewportButtons] Camera or controls not available');\r\n            return;\r\n        }\r\n        \r\n        // Send message to worker to get model bounds\r\n        if (this.worker) {\r\n            this.worker.postMessage({\r\n                type: 'GET_MODEL_BOUNDS'\r\n            });\r\n        }\r\n        \r\n        // Wait for MODEL_BOUNDS to arrive; refocus occurs in onmessage handler\r\n    }\r\n    \r\n    refocusCamera() {\r\n        const camera = window.camera;\r\n        const controls = window.orbitControls;\r\n        \r\n        if (!camera || !controls) return;\r\n        \r\n        // Determine target center (object origin) and radius for framing\r\n        let targetPosition = new THREE.Vector3(0, 0, 0);\r\n        let sphereRadius = 2;\r\n        let box = null;\r\n\r\n        if (window.currentModelBounds) {\r\n            box = window.currentModelBounds.box || window.currentModelBounds;\r\n            // Prefer origin from metadata if available\r\n            if (window.currentModelBounds.origin) {\r\n                targetPosition = new THREE.Vector3(\r\n                    window.currentModelBounds.origin.x,\r\n                    window.currentModelBounds.origin.y,\r\n                    window.currentModelBounds.origin.z\r\n                );\r\n            } else if (box && typeof box.getCenter === 'function') {\r\n                // Fallback: center of bounds\r\n                targetPosition = box.getCenter(new THREE.Vector3());\r\n            }\r\n\r\n            if (window.currentModelBounds.sphereRadius) {\r\n                sphereRadius = Math.max(1e-4, window.currentModelBounds.sphereRadius);\r\n            } else if (box && typeof box.getBoundingSphere === 'function') {\r\n                const sphere = box.getBoundingSphere(new THREE.Sphere());\r\n                sphereRadius = Math.max(1e-4, sphere.radius);\r\n            }\r\n        }\r\n\r\n        // Keep current view direction\r\n        const viewDirection = new THREE.Vector3();\r\n        camera.getWorldDirection(viewDirection);\r\n\r\n        // Compute distance to frame sphere using vertical and horizontal FOVs\r\n        const vFov = camera.fov * (Math.PI / 180);\r\n        const aspect = camera.aspect || 1;\r\n        const hFov = 2 * Math.atan(Math.tan(vFov / 2) * aspect);\r\n        const pad = (typeof window !== 'undefined' && typeof window.Z3D_FOCUS_PADDING === 'number')\r\n            ? window.Z3D_FOCUS_PADDING\r\n            : this.focusPadding; // padding factor\r\n        const distV = sphereRadius / Math.sin(vFov / 2);\r\n        const distH = sphereRadius / Math.sin(hFov / 2);\r\n        const distance = Math.max(distV, distH) * pad;\r\n\r\n        // New camera pos maintaining view direction\r\n        const newPosition = targetPosition.clone().sub(viewDirection.multiplyScalar(distance));\r\n        \r\n        // Animate camera to new position\r\n        if (window.gsap) {\r\n            // Smooth animation if GSAP is available\r\n            window.gsap.to(camera.position, {\r\n                duration: 0.8,\r\n                x: newPosition.x,\r\n                y: newPosition.y,\r\n                z: newPosition.z,\r\n                ease: \"power2.inOut\",\r\n                onUpdate: () => {\r\n                    controls.target.copy(targetPosition);\r\n                    controls.update();\r\n                }\r\n            });\r\n        } else {\r\n            // Direct update\r\n            camera.position.copy(newPosition);\r\n            controls.target.copy(targetPosition);\r\n            controls.update();\r\n        }\r\n        \r\n        console.log('[ViewportButtons] Camera refocused on model');\r\n    }\r\n    \r\n    setupEventListeners() {\r\n        // Listen for worker messages\r\n        if (this.worker) {\r\n            const originalListener = this.worker.onmessage;\r\n            this.worker.onmessage = (event) => {\r\n                if (originalListener) originalListener(event);\r\n                \r\n                const { type, data } = event.data;\r\n                \r\n                if (type === 'MODEL_BOUNDS') {\r\n                    // Store bounds and metadata for refocus calculation\r\n                    const box = new THREE.Box3(\r\n                        new THREE.Vector3(data.min.x, data.min.y, data.min.z),\r\n                        new THREE.Vector3(data.max.x, data.max.y, data.max.z)\r\n                    );\r\n                    window.currentModelBounds = {\r\n                        box,\r\n                        center: data.center ? { ...data.center } : undefined,\r\n                        sphereRadius: data.sphereRadius,\r\n                        origin: data.origin ? { ...data.origin } : undefined\r\n                    };\r\n\r\n                    // Now refocus with correct bounds\r\n                    this.refocusCamera();\r\n                }\r\n            };\r\n        }\r\n    }\r\n    \r\n    setVisible(visible) {\r\n        this.isVisible = visible;\r\n        if (this.container) {\r\n            this.container.style.display = visible ? 'flex' : 'none';\r\n        }\r\n    }\r\n    \r\n    dispose() {\r\n        if (this.container && this.container.parentNode) {\r\n            this.container.parentNode.removeChild(this.container);\r\n        }\r\n        this.container = null;\r\n        this.buttons = {};\r\n    }\r\n}\r\n\r\n// Make the class globally available\r\nwindow.ViewportButtons = ViewportButtons;\r\n\r\n// Note: Instance will be created by gizmo-controller.js when ready"
      },
      "workers": {
        "threeWorker": "/* FILE: editor/z3d-object-editor/templates/scripts/workers/three-worker.js */\r\n/* CLEANED VERSION - Unified message handling, all features preserved */\r\n\r\n// Import scene data collector functions\r\n// Scene data collector will be embedded separately\r\n// Transform gizmo will be embedded separately\r\n\r\n// Debug gate\r\nconst __originalConsoleLog = console.log.bind(console);\r\n// let WORKER_DEBUG = !!(typeof self !== 'undefined' && self.WORKER_DEBUG);\r\nlet WORKER_DEBUG = true;\r\nconsole.log = (...args) => { if (WORKER_DEBUG) __originalConsoleLog(...args); };\r\n\r\nconsole.log('[Z3D Worker] Starting Three.js worker with coordinate conversion...');\r\n\r\n// Worker state\r\nlet scene = null;\r\nlet camera = null;\r\nlet renderer = null;\r\nlet canvas = null;\r\nlet currentModel = null;\r\nlet animationId = null;\r\nlet orbitControls = null;\r\nlet orbitTarget = new THREE.Vector3(0, 0, 0);\r\nlet isCameraAnimating = false;  // Flag to prevent OrbitControls fighting\r\n// Overlay (HUD) rendering\r\nlet overlayScene = null;\r\nlet overlayCamera = null;\r\nlet overlayRoot = null;\r\nlet viewportWidth = 1;\r\nlet viewportHeight = 1;\r\n// Gizmo instances\r\nlet viewportGizmo = null;\r\nlet transformGizmo = null;\r\nlet gizmoEnabled = true;\r\nlet gizmoMode = 'all'; // 'position', 'rotation', 'scale', 'all'\r\nlet gizmoSpace = 'world'; // 'world' or 'local'\r\nlet snapEnabled = false;\r\nlet snapAngleDeg = 5;\r\nlet snapScale = 0.1;\r\n\r\n// Camera state management\r\nlet cameraFollowState = {\r\n    lastModelPosition: { x: 0, y: 0, z: 0 }, // C3 pixels\r\n    isEnabledForEditorChanges: false,\r\n    isEnabledForC3Changes: true,\r\n    updateThrottle: 0\r\n};\r\n\r\n// Hysteresis to avoid flicker\r\nconst cameraFollowHysteresis = {\r\n    lastSignX: 0,\r\n    lastSignY: 0,\r\n    lastSignZ: 0\r\n};\r\n\r\n// Grid helpers\r\nlet worldGrid = null;\r\nlet localGrid = null;\r\nlet localGridGroup = null;\r\nlet lastWorldGridRebuildTs = 0;\r\n\r\n// Grid config\r\nconst q = 64; // 64 px == 1 world unit\r\nlet worldGridCellPx = 64;\r\nlet localGridCellPx = 32;\r\nlet worldGridPaddingPct = 0.5;\r\nlet localGridPaddingPct = 0.25;\r\n\r\n// Model state - store in C3 coordinates\r\nlet modelPosition = { x: 0, y: 0, z: 0 }; // C3 position in pixels\r\nlet modelRotation = { x: 0, y: 0, z: 0 }; // C3 rotation in degrees\r\nlet modelScale = { x: 1, y: 1, z: 1 }; // C3 scale values\r\nlet modelDeltaTransform = {\r\n    position: { x: 0, y: 0, z: 0 },\r\n    rotation: { x: 0, y: 0, z: 0 },\r\n    scale: { x: 1, y: 1, z: 1 }\r\n};\r\nlet uniformScale = 1;\r\nlet modelRotationOrder = 'ZXY';\r\nlet unitScale = 64;\r\nlet wireframeMode = false;\r\n\r\n// Animation state\r\nlet animationMixer = null;\r\nlet currentAnimationAction = null;\r\nlet animations = [];\r\nlet animationClock = new THREE.Clock();\r\nlet isAnimationPlaying = false;\r\nlet animationSpeed = 1.0;\r\nlet animationLoop = true;\r\n\r\n// Skinned mesh sync state\r\nlet skinnedMeshSyncEnabled = true;\r\nlet lastSkinnedMeshUpdate = 0;\r\nlet skinnedMeshUpdateFrequency = 30; // Hz - configurable (15/30/60)\r\nlet skinnedMeshUpdateInterval = 1000 / 30; // milliseconds\r\nlet lastSkinnedVertices = null; // Cache last computed vertices for pause state\r\nlet currentNodeVisibility = {}; // Track node visibility state from outliner\r\n\r\n// Layout info\r\nlet layoutInfo = null;\r\n\r\n// Message handler\r\nself.addEventListener('message', function(event) {\r\n    const { type, data } = event.data;\r\n    console.log(`[Z3D Worker] \u{1F528} Processing message: ${type}`);\r\n    \r\n    try {\r\n        switch (type) {\r\n            case 'SET_DEBUG':\r\n                WORKER_DEBUG = !!(data && data.enabled);\r\n                __originalConsoleLog('[Z3D Worker] Debug mode set to:', WORKER_DEBUG);\r\n                break;\r\n                \r\n            case 'PING':\r\n                handlePing(data);\r\n                break;\r\n                \r\n            case 'SETUP_CANVAS':\r\n                setupCanvas(data);\r\n                break;\r\n                \r\n            case 'SETUP_CANVAS_FALLBACK':\r\n                setupCanvasFallback(data);\r\n                break;\r\n                \r\n            case 'LOAD_MODEL':\r\n                loadModel(data);\r\n                break;\r\n                \r\n            // UNIFIED STATE UPDATE HANDLER\r\n            case 'UPDATE_STATE':\r\n                updateState(data);\r\n                break;\r\n                \r\n            // Legacy handlers for backward compatibility\r\n            case 'UPDATE_TRANSFORM':\r\n                updateTransform(data);\r\n                break;\r\n                \r\n            case 'UPDATE_UNIT_SCALE':\r\n                updateUnitScale(data);\r\n                break;\r\n                \r\n            case 'UPDATE_VIEWPORT_SETTING':\r\n                updateViewportSetting(data);\r\n                break;\r\n            case 'SET_SNAP_ENABLED':\r\n                setSnapEnabled(data);\r\n                break;\r\n                \r\n            case 'CAMERA_UPDATE':\r\n                console.log('[Z3D Worker] Camera update data:', data);\r\n                updateCamera(data);\r\n                break;\r\n                \r\n            case 'CAMERA_TARGET_UPDATE':\r\n                console.log('[Z3D Worker] Camera target update data:', data);\r\n                handleCameraTargetUpdate(data);\r\n                break;\r\n                \r\n            case 'SET_CAMERA_FOLLOW_EDITOR':\r\n                setCameraFollowForEditor(data.enabled);\r\n                break;\r\n                \r\n            case 'SET_CAMERA_FOLLOW_C3':\r\n                setCameraFollowForC3(data.enabled);\r\n                break;\r\n                \r\n            case 'RESET_VIEW':\r\n                resetView();\r\n                break;\r\n                \r\n            case 'CENTER_OBJECT':\r\n                centerObject();\r\n                break;\r\n                \r\n            case 'FIT_VIEW':\r\n                fitCameraToModelAndGrids();\r\n                break;\r\n                \r\n            case 'UPDATE_RENDER_SIZE':\r\n                updateRenderSize(data);\r\n                break;\r\n                \r\n            case 'TOGGLE_NODE_VISIBILITY':\r\n                toggleNodeVisibility(data);\r\n                break;\r\n                \r\n            // Animation messages\r\n            case 'SELECT_ANIMATION':\r\n                selectAnimation(data);\r\n                break;\r\n                \r\n            case 'PLAY_ANIMATION':\r\n                playAnimation(data);\r\n                break;\r\n                \r\n            case 'PAUSE_ANIMATION':\r\n                pauseAnimation();\r\n                break;\r\n                \r\n            case 'SET_ANIMATION_LOOP':\r\n                setAnimationLoop(data);\r\n                break;\r\n                \r\n            case 'SET_ANIMATION_SPEED':\r\n                setAnimationSpeed(data);\r\n                break;\r\n                \r\n            case 'SEEK_ANIMATION':\r\n                seekAnimation(data);\r\n                break;\r\n                \r\n            case 'SET_SKINNED_MESH_FREQUENCY':\r\n                setSkinnedMeshUpdateFrequency(data);\r\n                break;\r\n                \r\n            case 'GET_ANIMATION_TIME':\r\n                getAnimationTime();\r\n                break;\r\n                \r\n            case 'GET_TEXTURE_IMAGE':\r\n                getTextureImage(data);\r\n                break;\r\n\r\n            case 'INIT_GIZMOS':\r\n                initializeGizmos(data);\r\n                break;\r\n\r\n            case 'SET_GIZMO_MODE':\r\n                setGizmoMode(data);\r\n                break;\r\n\r\n            case 'SET_GIZMO_SPACE':\r\n                setGizmoSpace(data);\r\n                break;\r\n\r\n            case 'SET_GIZMO_VISIBLE':\r\n                setGizmoVisible(data);\r\n                break;\r\n                \r\n            case 'TOGGLE_GIZMOS':\r\n                toggleGizmos(data);\r\n                break;\r\n                \r\n            case 'GET_MODEL_BOUNDS':\r\n                getModelBounds();\r\n                break;\r\n\r\n            case 'GIZMO_MOUSE_DOWN':\r\n                handleGizmoMouseDown(data);\r\n                break;\r\n\r\n            case 'GIZMO_MOUSE_MOVE':\r\n                handleGizmoMouseMove(data);\r\n                break;\r\n\r\n            case 'GIZMO_MOUSE_UP':\r\n                handleGizmoMouseUp(data);\r\n                break;\r\n\r\n            case 'CAMERA_ANIMATE_TO':\r\n                animateCameraTo(data);\r\n                break;\r\n                \r\n            case 'POSITION_DRAG_ENDED':\r\n                handlePositionDragEnded(data);\r\n                break;\r\n                \r\n            case 'REQUEST_STATS':\r\n                sendRenderStats();\r\n                break;\r\n                \r\n            default:\r\n                console.warn(`[Z3D Worker] Unknown message type: ${type}`);\r\n        }\r\n    } catch (error) {\r\n        console.error(`[Z3D Worker] Error handling ${type}:`, error);\r\n        self.postMessage({\r\n            type: 'ERROR',\r\n            data: { error: error.message, messageType: type }\r\n        });\r\n    }\r\n});\r\n\r\n/**\r\n * NEW: Unified state update handler\r\n */\r\nfunction updateState(data) {\r\n    console.log('[Z3D Worker] \u{1F4CA} UPDATE_STATE received');\r\n    \r\n    if (!data) return;\r\n    \r\n    // Handle transform updates\r\n    if (data.transform || data.deltaTransform) {\r\n        updateTransform({\r\n            transform: data.transform,\r\n            deltaTransform: data.deltaTransform,\r\n            source: data.source || 'editor'\r\n        });\r\n    }\r\n    \r\n    // Handle wireframe\r\n    if (data.wireframe !== undefined) {\r\n        wireframeMode = data.wireframe;\r\n        if (currentModel) {\r\n            currentModel.traverse((child) => {\r\n                if (child.isMesh && child.material) {\r\n                    child.material.wireframe = wireframeMode;\r\n                    child.material.needsUpdate = true;\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Coordinate System Conversion\r\n */\r\nfunction convertC3ToThree(c3Transform) {\r\n    const result = {\r\n        position: { x: 0, y: 0, z: 0 },\r\n        rotation: { x: 0, y: 0, z: 0 },\r\n        scale: { x: 1, y: 1, z: 1 }\r\n    };\r\n    \r\n    // Position conversion: Flip Y axis and convert to units\r\n    if (c3Transform.position) {\r\n        result.position.x = c3Transform.position.x / unitScale;\r\n        result.position.y = -(c3Transform.position.y / unitScale);\r\n        result.position.z = c3Transform.position.z / unitScale;\r\n    }\r\n    \r\n    // Rotation conversion: C3 left-handed to Three.js right-handed\r\n    // C3: positive rotation is clockwise when viewing from +axis toward origin\r\n    // Three.js: positive rotation is counter-clockwise when viewing from +axis\r\n    // \r\n    // Based on testing - Three.js currently shows:\r\n    // X: CW (correct) - keep negation\r\n    // Y: CCW (wrong) - don't negate to get CW\r\n    // Z: CCW (wrong) - negate to get CW\r\n    if (c3Transform.rotation) {\r\n        result.rotation.x = -c3Transform.rotation.x;    // X inverted (currently correct)\r\n        result.rotation.y = c3Transform.rotation.y;     // Y not inverted \r\n        result.rotation.z = -c3Transform.rotation.z;    // Z inverted to get CW\r\n    }\r\n    \r\n    // Scale: No conversion needed\r\n    if (c3Transform.scale) {\r\n        result.scale.x = c3Transform.scale.x;\r\n        result.scale.y = c3Transform.scale.y;\r\n        result.scale.z = c3Transform.scale.z;\r\n    }\r\n    \r\n    return result;\r\n}\r\n\r\n/**\r\n * Extract skinned vertices from the animated model\r\n */\r\n/**\r\n * Extract skinned vertices using proper Three.js skinning formula\r\n * Returns vertices in object space (not world space) for C3 to transform\r\n */\r\nfunction extractSkinnedVertices() {\r\n    if (!currentModel) return null;\r\n    \r\n    const allVertices = [];\r\n    const meshVisibilityMap = {}; // Track which meshes are visible by name\r\n    let meshIndex = 0;\r\n    let foundAnyMesh = false;\r\n    \r\n    // Ensure the model's world matrix is up to date\r\n    currentModel.updateMatrixWorld(true);\r\n    \r\n    // Process ALL meshes regardless of visibility to maintain vertex buffer consistency\r\n    // This ensures indices remain valid\r\n    currentModel.traverse((child) => {\r\n        if (!child.isMesh || !child.geometry) return;\r\n        \r\n        foundAnyMesh = true;\r\n        const geometry = child.geometry;\r\n        const posAttr = geometry.attributes.position;\r\n        \r\n        if (!posAttr) return;\r\n        \r\n        // Build visibility map to pass along with vertices\r\n        // Use name if available, otherwise use a generated ID\r\n        const meshId = child.name || `mesh_${meshIndex++}`;\r\n        meshVisibilityMap[meshId] = child.visible;\r\n        \r\n        // ALWAYS process vertices regardless of visibility\r\n        // This maintains index alignment\r\n        \r\n        if (child.isSkinnedMesh && child.skeleton) {\r\n            // Extract skinned vertices for this mesh\r\n            const vertices = extractSkinnedVerticesForMesh(child);\r\n            if (vertices) {\r\n                for (let i = 0; i < vertices.length; i++) {\r\n                    allVertices.push(vertices[i]);\r\n                }\r\n            }\r\n        } else {\r\n            // For non-skinned meshes, apply the animated world transform\r\n            child.updateMatrixWorld(true);\r\n            \r\n            const vertexCount = posAttr.count;\r\n            const vertex = new THREE.Vector3();\r\n            \r\n            // Get the world matrix of the mesh (includes all parent transforms and animations)\r\n            const worldMatrix = child.matrixWorld;\r\n            \r\n            for (let i = 0; i < vertexCount; i++) {\r\n                // Get vertex in local space\r\n                vertex.fromBufferAttribute(posAttr, i);\r\n                \r\n                // Transform to world space (includes animation transforms)\r\n                vertex.applyMatrix4(worldMatrix);\r\n                \r\n                // Convert back to model space (remove root transform)\r\n                const modelWorldInverse = new THREE.Matrix4().copy(currentModel.matrixWorld).invert();\r\n                vertex.applyMatrix4(modelWorldInverse);\r\n                \r\n                // Convert from Three.js Y-up to C3 Y-down coordinate system\r\n                allVertices.push(vertex.x);\r\n                allVertices.push(-vertex.y);  // Flip Y for C3\r\n                allVertices.push(vertex.z);\r\n            }\r\n        }\r\n    });\r\n    \r\n    if (!foundAnyMesh) {\r\n        return { vertices: lastSkinnedVertices, visibility: {} };\r\n    }\r\n    \r\n    // Convert to Float32Array and cache\r\n    const result = new Float32Array(allVertices);\r\n    lastSkinnedVertices = result;\r\n    \r\n    console.log(`[Z3D Worker] Extracted ${result.length / 3} vertices (ALL for index consistency), visibility map:`, meshVisibilityMap);\r\n    \r\n    // Return both vertices and visibility map\r\n    return { vertices: result, visibility: meshVisibilityMap };\r\n}\r\n\r\n/**\r\n * Helper function to extract skinned vertices for a single mesh\r\n */\r\nfunction extractSkinnedVerticesForMesh(skinnedMesh) {\r\n    if (!skinnedMesh || !skinnedMesh.skeleton) return null;\r\n    \r\n    // Ensure matrices are up to date\r\n    skinnedMesh.updateMatrixWorld(true);\r\n    skinnedMesh.skeleton.update();\r\n    \r\n    const geometry = skinnedMesh.geometry;\r\n    const posAttr = geometry.attributes.position;\r\n    const skinIndexAttr = geometry.attributes.skinIndex;\r\n    const skinWeightAttr = geometry.attributes.skinWeight;\r\n    \r\n    if (!posAttr || !skinIndexAttr || !skinWeightAttr) {\r\n        console.warn('[Z3D Worker] Missing skinning attributes');\r\n        return null;\r\n    }\r\n    \r\n    const vertexCount = posAttr.count;\r\n    const output = new Float32Array(vertexCount * 3);\r\n    \r\n    // Get skinning matrices\r\n    const bindMatrix = skinnedMesh.bindMatrix;\r\n    const bindMatrixInverse = skinnedMesh.bindMatrixInverse || new THREE.Matrix4().copy(bindMatrix).invert();\r\n    const boneMatrices = skinnedMesh.skeleton.boneMatrices; // Float32Array\r\n    \r\n    // Temp objects (reused for performance)\r\n    const vertex = new THREE.Vector3();\r\n    const temp = new THREE.Vector4();\r\n    const skinned = new THREE.Vector4();\r\n    const boneMatrix = new THREE.Matrix4();\r\n    \r\n    // Process each vertex\r\n    for (let i = 0; i < vertexCount; i++) {\r\n        // Get bind pose position\r\n        vertex.fromBufferAttribute(posAttr, i);\r\n        \r\n        // Transform to bind space: p_bind = bindMatrix * position\r\n        temp.set(vertex.x, vertex.y, vertex.z, 1.0);\r\n        temp.applyMatrix4(bindMatrix);\r\n        \r\n        // Initialize skinned position\r\n        skinned.set(0, 0, 0, 0);\r\n        \r\n        // Get bone influences (up to 4 bones per vertex)\r\n        const boneIndex0 = skinIndexAttr.getX(i);\r\n        const boneIndex1 = skinIndexAttr.getY(i);\r\n        const boneIndex2 = skinIndexAttr.getZ(i);\r\n        const boneIndex3 = skinIndexAttr.getW(i);\r\n        \r\n        const weight0 = skinWeightAttr.getX(i);\r\n        const weight1 = skinWeightAttr.getY(i);\r\n        const weight2 = skinWeightAttr.getZ(i);\r\n        const weight3 = skinWeightAttr.getW(i);\r\n        \r\n        // Apply bone transforms weighted by influence\r\n        // p_skinned = \u03A3 weight[i] * (boneMatrix[i] * p_bind)\r\n        if (weight0 > 0) {\r\n            const offset = boneIndex0 * 16;\r\n            boneMatrix.fromArray(boneMatrices, offset);\r\n            const v = new THREE.Vector4().copy(temp).applyMatrix4(boneMatrix).multiplyScalar(weight0);\r\n            skinned.add(v);\r\n        }\r\n        \r\n        if (weight1 > 0) {\r\n            const offset = boneIndex1 * 16;\r\n            boneMatrix.fromArray(boneMatrices, offset);\r\n            const v = new THREE.Vector4().copy(temp).applyMatrix4(boneMatrix).multiplyScalar(weight1);\r\n            skinned.add(v);\r\n        }\r\n        \r\n        if (weight2 > 0) {\r\n            const offset = boneIndex2 * 16;\r\n            boneMatrix.fromArray(boneMatrices, offset);\r\n            const v = new THREE.Vector4().copy(temp).applyMatrix4(boneMatrix).multiplyScalar(weight2);\r\n            skinned.add(v);\r\n        }\r\n        \r\n        if (weight3 > 0) {\r\n            const offset = boneIndex3 * 16;\r\n            boneMatrix.fromArray(boneMatrices, offset);\r\n            const v = new THREE.Vector4().copy(temp).applyMatrix4(boneMatrix).multiplyScalar(weight3);\r\n            skinned.add(v);\r\n        }\r\n        \r\n        // Transform back to object space: p_object = bindMatrixInverse * p_skinned\r\n        skinned.applyMatrix4(bindMatrixInverse);\r\n        \r\n        // Three.js (RH):  x,y,z\r\n        // \u2192 C3: +X right, +Y down, +Z out\r\n        const idx = i * 3;\r\n        output[idx]     =  skinned.x / unitScale;   // X <-  X\r\n        output[idx + 1] =  skinned.z / unitScale;   // Y <-  Z\r\n        output[idx + 2] =  skinned.y / unitScale;   // Z <-  Y\r\n    }\r\n    \r\n    // Cache the result\r\n    lastSkinnedVertices = output;\r\n    return output;\r\n}\r\n\r\n/**\r\n * Compress vertices to base64 for transmission\r\n */\r\nfunction compressVertices(vertices) {\r\n    if (!vertices || vertices.length === 0) return null;\r\n    \r\n    // Convert Float32Array to base64\r\n    const bytes = new Uint8Array(vertices.buffer, vertices.byteOffset, vertices.byteLength);\r\n    \r\n    // Convert to base64 in chunks to avoid stack overflow\r\n    let binary = '';\r\n    const chunkSize = 8192;\r\n    for (let i = 0; i < bytes.length; i += chunkSize) {\r\n        const chunk = bytes.subarray(i, Math.min(i + chunkSize, bytes.length));\r\n        binary += String.fromCharCode.apply(null, Array.from(chunk));\r\n    }\r\n    \r\n    return btoa(binary);\r\n}\r\n\r\n/**\r\n * Send skinned mesh update to the editor\r\n */\r\nfunction sendSkinnedMeshUpdate() {\r\n    const now = performance.now();\r\n    \r\n    // Check if we should throttle updates\r\n    if (now - lastSkinnedMeshUpdate < skinnedMeshUpdateInterval) {\r\n        return;\r\n    }\r\n    \r\n    // Extract skinned vertices and visibility map\r\n    const extractResult = extractSkinnedVertices();\r\n    if (!extractResult || !extractResult.vertices) return;\r\n    \r\n    const { vertices, visibility } = extractResult;\r\n    \r\n    // Compress for transmission\r\n    const compressed = compressVertices(vertices);\r\n    if (!compressed) return;\r\n    \r\n    lastSkinnedMeshUpdate = now;\r\n    \r\n    // Use Date.now() for timestamp to ensure uniqueness across different contexts\r\n    const timestamp = Date.now() + Math.random(); // Add random to ensure uniqueness\r\n    \r\n    // Send to parent window with visibility map\r\n    self.postMessage({\r\n        type: 'SKINNED_MESH_UPDATE',\r\n        data: {\r\n            timestamp: timestamp,\r\n            verticesCompressed: compressed,\r\n            visibility: visibility, // Include mesh visibility map\r\n            updateFrequency: skinnedMeshUpdateFrequency,\r\n            vertexCount: vertices.length / 3\r\n        }\r\n    });\r\n    \r\n    console.log(`[Z3D Worker] Sent skinned mesh update: ${vertices.length / 3} vertices, timestamp: ${timestamp}`);\r\n}\r\n\r\nfunction setSkinnedMeshUpdateFrequency(data) {\r\n    const frequency = data.frequency || 30;\r\n    skinnedMeshUpdateFrequency = Math.max(1, Math.min(60, frequency)); // Clamp 1-60 Hz\r\n    skinnedMeshUpdateInterval = 1000 / skinnedMeshUpdateFrequency;\r\n    \r\n    console.log(`[Z3D Worker] Skinned mesh update frequency set to ${skinnedMeshUpdateFrequency}Hz`);\r\n    \r\n    // Also update enabled state if provided\r\n    if (data.enabled !== undefined) {\r\n        skinnedMeshSyncEnabled = data.enabled;\r\n        console.log(`[Z3D Worker] Skinned mesh sync ${skinnedMeshSyncEnabled ? 'enabled' : 'disabled'}`);\r\n    }\r\n}\r\n\r\nfunction handlePing(data) {\r\n    self.postMessage({\r\n        type: 'WORKER_READY',\r\n        data: { timestamp: Date.now(), originalTimestamp: data?.timestamp }\r\n    });\r\n}\r\n\r\nfunction setupCanvas(data) {\r\n    console.log('[Z3D Worker] Setting up canvas with initial state...');\r\n    \r\n    try {\r\n        canvas = data.canvas;\r\n        \r\n        // Extract initial state\r\n        if (data.initialState) {\r\n            const state = data.initialState;\r\n\r\n            // \u2705 VERIFY these are actually being set\r\n            console.log('[Z3D Worker] Storing initial state:', {\r\n                position: state.transform?.position,\r\n                rotation: state.transform?.rotation,\r\n                scale: state.transform?.scale,\r\n                deltaTransform: state.deltaTransform\r\n            });\r\n            \r\n            // Set model position\r\n            if (state.transform?.position) {\r\n                modelPosition = {\r\n                    x: state.transform.position.x || 0,\r\n                    y: state.transform.position.y || 0,\r\n                    z: state.transform.position.z || 0\r\n                };\r\n            }\r\n            \r\n            // Set rotation\r\n            if (state.transform?.rotation) {\r\n                modelRotation = state.transform.rotation;\r\n            }\r\n            \r\n            // Set scale\r\n            if (state.transform?.scale) {\r\n                modelScale = state.transform.scale;\r\n            }\r\n            \r\n            // Set uniform scale\r\n            if (state.transform?.uniformScale !== undefined) {\r\n                uniformScale = state.transform.uniformScale;\r\n            }\r\n            \r\n            // Set unit scale\r\n            if (state.transform?.unitScale) {\r\n                unitScale = state.transform.unitScale;\r\n            }\r\n            \r\n            // Set rotation order\r\n            if (state.transform?.rotationOrder) {\r\n                modelRotationOrder = state.transform.rotationOrder;\r\n            }\r\n            \r\n            // Set delta transforms\r\n            if (state.deltaTransform) {\r\n                modelDeltaTransform = {\r\n                    position: state.deltaTransform.position || { x: 0, y: 0, z: 0 },\r\n                    rotation: state.deltaTransform.rotation || { x: 0, y: 0, z: 0 },\r\n                    scale: state.deltaTransform.scale || { x: 1, y: 1, z: 1 }\r\n                };\r\n            }\r\n            \r\n            // Set wireframe\r\n            if (state.wireframe !== undefined) {\r\n                wireframeMode = state.wireframe;\r\n            }\r\n        }\r\n        \r\n        return initializeThreeJS(data);\r\n        \r\n    } catch (error) {\r\n        console.error('[Z3D Worker] Canvas setup failed:', error);\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction setupCanvasFallback(data) {\r\n    console.log('[Z3D Worker] Setting up fallback canvas...');\r\n    \r\n    try {\r\n        console.log('[Z3D Worker] Fallback mode - limited rendering capabilities');\r\n        return initializeThreeJS(data, true);\r\n    } catch (error) {\r\n        console.error('[Z3D Worker] Fallback canvas setup failed:', error);\r\n        self.postMessage({\r\n            type: 'ERROR',\r\n            data: { error: error.message, context: 'fallback_canvas_setup' }\r\n        });\r\n    }\r\n}\r\n\r\nfunction initializeThreeJS(data, isFallback = false) {\r\n    if (typeof THREE === 'undefined') {\r\n        throw new Error('THREE.js not available in worker');\r\n    }\r\n    \r\n    const width = data.width || 800;\r\n    const height = data.height || 600;\r\n    \r\n    if (data.isFallback || !data.canvas) {\r\n        console.log('[Z3D Worker] Fallback mode - creating virtual canvas');\r\n        isFallback = true;\r\n    }\r\n    \r\n    if (!isFallback) {\r\n        canvas = data.canvas;\r\n        if (!canvas) {\r\n            throw new Error('No valid canvas provided to worker');\r\n        }\r\n        \r\n        renderer = new THREE.WebGLRenderer({\r\n            canvas: canvas,\r\n            antialias: true,\r\n            alpha: true,\r\n            preserveDrawingBuffer: true\r\n        });\r\n        \r\n        renderer.setSize(width, height, false);\r\n        renderer.setClearColor(0x2a2a2a, 1);\r\n        renderer.shadowMap.enabled = true;\r\n        renderer.shadowMap.type = THREE.PCFSoftShadowMap;\r\n    }\r\n    \r\n    // Create scene\r\n    scene = new THREE.Scene();\r\n    scene.name = 'Main Scene';\r\n    scene.background = new THREE.Color(0x2a2a2a);\r\n    \r\n    // Create camera (Z up)\r\n    const aspect = width / height;\r\n    camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);\r\n    \r\n    const camPos = data.cameraParams?.position || [5, -5, 5];\r\n    const camTarget = data.cameraParams?.target || [0, 0, 0];\r\n    \r\n    camera.position.set(camPos[0], camPos[1], camPos[2]);\r\n    camera.lookAt(camTarget[0], camTarget[1], camTarget[2]);\r\n    camera.up.set(0, 0, 1);\r\n    \r\n    if (!isFallback) {\r\n        initializeCameraState();\r\n    }\r\n    \r\n    // Process initial state\r\n    if (data.initialState) {\r\n        processInitialState(data.initialState);\r\n    }\r\n    \r\n    setupLighting();\r\n    setupGridSystem();\r\n    \r\n    if (renderer) {\r\n        startRenderLoop();\r\n    }\r\n    \r\n    console.log('[Z3D Worker] \u2705 Three.js initialized');\r\n    \r\n    self.postMessage({\r\n        type: 'CANVAS_READY',\r\n        data: { \r\n            success: true,\r\n            canvasSize: { width, height },\r\n            threeVersion: THREE.REVISION,\r\n            fallbackMode: isFallback\r\n        }\r\n    });\r\n}\r\n\r\nfunction processInitialState(initialState) {\r\n    // Set transforms\r\n    if (initialState.transform) {\r\n        if (initialState.transform.position) {\r\n            modelPosition = { ...initialState.transform.position };\r\n        }\r\n        if (initialState.transform.rotation) {\r\n            modelRotation = { ...initialState.transform.rotation };\r\n        }\r\n        if (initialState.transform.scale) {\r\n            modelScale = { ...initialState.transform.scale };\r\n        }\r\n        if (initialState.transform.uniformScale !== undefined) {\r\n            uniformScale = initialState.transform.uniformScale;\r\n        }\r\n        if (initialState.transform.unitScale !== undefined) {\r\n            unitScale = initialState.transform.unitScale;\r\n        }\r\n        if (initialState.transform.rotationOrder) {\r\n            modelRotationOrder = initialState.transform.rotationOrder;\r\n        }\r\n    }\r\n    \r\n    // Set delta transforms\r\n    if (initialState.deltaTransform) {\r\n        modelDeltaTransform = {\r\n            position: initialState.deltaTransform.position || { x: 0, y: 0, z: 0 },\r\n            rotation: initialState.deltaTransform.rotation || { x: 0, y: 0, z: 0 },\r\n            scale: initialState.deltaTransform.scale || { x: 1, y: 1, z: 1 }\r\n        };\r\n    }\r\n    \r\n    // Set other properties\r\n    if (initialState.wireframe !== undefined) {\r\n        wireframeMode = initialState.wireframe;\r\n    }\r\n    \r\n    if (initialState.layoutInfo) {\r\n        layoutInfo = initialState.layoutInfo;\r\n    }\r\n    \r\n    console.log('[Z3D Worker] Initial state processed');\r\n}\r\n\r\nfunction setupLighting() {\r\n    const ambientLight = new THREE.AmbientLight(0x404040, Math.PI);\r\n    ambientLight.name = 'Ambient Light';\r\n    scene.add(ambientLight);\r\n    \r\n    const directionalLight = new THREE.DirectionalLight(0xffffff, 1 * Math.PI * 2);\r\n    directionalLight.name = 'Sun Light';\r\n    directionalLight.position.set(5, 10, 5);\r\n    directionalLight.castShadow = true;\r\n    directionalLight.shadow.mapSize.width = 2048;\r\n    directionalLight.shadow.mapSize.height = 2048;\r\n    scene.add(directionalLight);\r\n    \r\n    const fillLight = new THREE.DirectionalLight(0x87CEEB, 1 * Math.PI);\r\n    fillLight.name = 'Fill Light';\r\n    fillLight.position.set(-5, 2, -5);\r\n    scene.add(fillLight);\r\n}\r\n\r\nfunction setupGridSystem() {\r\n    console.log('[Z3D Worker] Setting up grid system...');\r\n    \r\n    rebuildWorldGrid();\r\n    rebuildLocalGrid();\r\n    \r\n    // World axes\r\n    const axesGroup = new THREE.Group();\r\n    axesGroup.name = 'World Axes';\r\n    axesGroup.position.z = 0.01;\r\n    \r\n    const axisRadius = 0.02;\r\n    const axisLength = 3;\r\n    const coneRadius = 0.05;\r\n    const coneHeight = 0.15;\r\n    \r\n    // X axis - Red\r\n    const xGeometry = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8);\r\n    const xMaterial = new THREE.MeshBasicMaterial({ color: 0xff3333 });\r\n    const xAxis = new THREE.Mesh(xGeometry, xMaterial);\r\n    xAxis.name = 'X-Axis';\r\n    xAxis.rotation.z = -Math.PI / 2;\r\n    xAxis.position.x = axisLength / 2;\r\n    axesGroup.add(xAxis);\r\n    \r\n    // X axis cone\r\n    const xConeGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 8);\r\n    const xCone = new THREE.Mesh(xConeGeometry, xMaterial);\r\n    xCone.rotation.z = -Math.PI / 2;\r\n    xCone.position.x = axisLength + coneHeight / 2;\r\n    axesGroup.add(xCone);\r\n    \r\n    // Y axis - Green (negative Y for C3)\r\n    const yGeometry = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8);\r\n    const yMaterial = new THREE.MeshBasicMaterial({ color: 0x33ff33 });\r\n    const yAxis = new THREE.Mesh(yGeometry, yMaterial);\r\n    yAxis.name = 'Y-Axis';\r\n    yAxis.position.y = -axisLength / 2;\r\n    axesGroup.add(yAxis);\r\n    \r\n    // Y axis cone\r\n    const yConeGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 8);\r\n    const yCone = new THREE.Mesh(yConeGeometry, yMaterial);\r\n    yCone.rotation.z = Math.PI;\r\n    yCone.position.y = -axisLength - coneHeight / 2;\r\n    axesGroup.add(yCone);\r\n    \r\n    // Z axis - Blue\r\n    const zGeometry = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8);\r\n    const zMaterial = new THREE.MeshBasicMaterial({ color: 0x3333ff });\r\n    const zAxis = new THREE.Mesh(zGeometry, zMaterial);\r\n    zAxis.name = 'Z-Axis';\r\n    zAxis.rotation.x = Math.PI / 2;\r\n    zAxis.position.z = axisLength / 2;\r\n    axesGroup.add(zAxis);\r\n    \r\n    // Z axis cone\r\n    const zConeGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 8);\r\n    const zCone = new THREE.Mesh(zConeGeometry, zMaterial);\r\n    zCone.rotation.x = Math.PI / 2;  // Flipped to point in positive Z direction\r\n    zCone.position.z = axisLength + coneHeight / 2;\r\n    axesGroup.add(zCone);\r\n    \r\n    scene.add(axesGroup);\r\n    \r\n    // Local axes\r\n    if (localGridGroup) {\r\n        const localAxesGroup = new THREE.Group();\r\n        localAxesGroup.name = 'Local Axes';\r\n        localAxesGroup.position.z = 0.01;\r\n        \r\n        const localAxisRadius = 0.015;\r\n        const localAxisLength = 1.5;\r\n        const localConeRadius = 0.04;\r\n        const localConeHeight = 0.12;\r\n        \r\n        // Local X axis - Red\r\n        const localXGeometry = new THREE.CylinderGeometry(localAxisRadius, localAxisRadius, localAxisLength, 8);\r\n        const localXMaterial = new THREE.MeshBasicMaterial({ color: 0xff6666 });\r\n        const localXAxis = new THREE.Mesh(localXGeometry, localXMaterial);\r\n        localXAxis.name = 'Local-X-Axis';\r\n        localXAxis.rotation.z = -Math.PI / 2;\r\n        localXAxis.position.x = localAxisLength / 2;\r\n        localAxesGroup.add(localXAxis);\r\n        \r\n        // Local X axis cone\r\n        const localXConeGeometry = new THREE.ConeGeometry(localConeRadius, localConeHeight, 8);\r\n        const localXCone = new THREE.Mesh(localXConeGeometry, localXMaterial);\r\n        localXCone.rotation.z = -Math.PI / 2;\r\n        localXCone.position.x = localAxisLength + localConeHeight / 2;\r\n        localAxesGroup.add(localXCone);\r\n        \r\n        // Local Y axis - Green (negative Y for C3)\r\n        const localYGeometry = new THREE.CylinderGeometry(localAxisRadius, localAxisRadius, localAxisLength, 8);\r\n        const localYMaterial = new THREE.MeshBasicMaterial({ color: 0x66ff66 });\r\n        const localYAxis = new THREE.Mesh(localYGeometry, localYMaterial);\r\n        localYAxis.name = 'Local-Y-Axis';\r\n        localYAxis.position.y = -localAxisLength / 2;\r\n        localAxesGroup.add(localYAxis);\r\n        \r\n        // Local Y axis cone\r\n        const localYConeGeometry = new THREE.ConeGeometry(localConeRadius, localConeHeight, 8);\r\n        const localYCone = new THREE.Mesh(localYConeGeometry, localYMaterial);\r\n        localYCone.rotation.z = Math.PI;\r\n        localYCone.position.y = -localAxisLength - localConeHeight / 2;\r\n        localAxesGroup.add(localYCone);\r\n        \r\n        // Local Z axis - Blue\r\n        const localZGeometry = new THREE.CylinderGeometry(localAxisRadius, localAxisRadius, localAxisLength, 8);\r\n        const localZMaterial = new THREE.MeshBasicMaterial({ color: 0x6666ff });\r\n        const localZAxis = new THREE.Mesh(localZGeometry, localZMaterial);\r\n        localZAxis.name = 'Local-Z-Axis';\r\n        localZAxis.rotation.x = Math.PI / 2;\r\n        localZAxis.position.z = localAxisLength / 2;\r\n        localAxesGroup.add(localZAxis);\r\n        \r\n        // Local Z axis cone\r\n        const localZConeGeometry = new THREE.ConeGeometry(localConeRadius, localConeHeight, 8);\r\n        const localZCone = new THREE.Mesh(localZConeGeometry, localZMaterial);\r\n        localZCone.rotation.x = Math.PI / 2;  // Flipped to point in positive Z direction\r\n        localZCone.position.z = localAxisLength + localConeHeight / 2;\r\n        localAxesGroup.add(localZCone);\r\n        \r\n        localGridGroup.add(localAxesGroup);\r\n    }\r\n    \r\n    console.log('[Z3D Worker] \u2705 Grid system setup complete');\r\n}\r\n\r\n// Grid rebuild functions\r\nfunction unitsPerCell(px) {\r\n    return Math.max(1e-6, px / unitScale);\r\n}\r\n\r\nfunction rebuildWorldGrid() {\r\n    if (worldGrid) {\r\n        if (worldGrid.geometry) worldGrid.geometry.dispose();\r\n        if (worldGrid.material) worldGrid.material.dispose();\r\n        if (scene && worldGrid.parent === scene) scene.remove(worldGrid);\r\n        worldGrid = null;\r\n    }\r\n    \r\n    const cellUnits = unitsPerCell(worldGridCellPx);\r\n    // Compute half-size needed to cover the model's extents from world origin with padding\r\n    let halfSize = cellUnits * 4; // sensible default\r\n    if (currentModel) {\r\n        const box = new THREE.Box3().setFromObject(currentModel);\r\n        const size = box.getSize(new THREE.Vector3());\r\n        const paddingX = Math.max(0, worldGridPaddingPct) * size.x;\r\n        const paddingY = Math.max(0, worldGridPaddingPct) * size.y;\r\n        const min = box.min; const max = box.max;\r\n        const halfX = Math.max(Math.abs(min.x) + paddingX, Math.abs(max.x) + paddingX);\r\n        const halfY = Math.max(Math.abs(min.y) + paddingY, Math.abs(max.y) + paddingY);\r\n        halfSize = Math.max(halfX, halfY, cellUnits);\r\n    }\r\n    // Snap total size to whole cell counts so lines align\r\n    const halfCells = Math.max(1, Math.ceil(halfSize / cellUnits));\r\n    const totalSize = halfCells * cellUnits * 2;\r\n    const divisions = Math.max(1, halfCells * 2);\r\n    \r\n    worldGrid = new THREE.GridHelper(totalSize, divisions, 0x444444, 0x333333);\r\n    worldGrid.rotateX(Math.PI / 2);\r\n    worldGrid.name = 'World Grid';\r\n    \r\n    scene.add(worldGrid);\r\n}\r\n\r\nfunction rebuildLocalGrid() {\r\n    if (!localGridGroup) {\r\n        localGridGroup = new THREE.Group();\r\n        localGridGroup.name = 'Local Grid Group';\r\n        scene.add(localGridGroup);\r\n    }\r\n    \r\n    if (localGrid) {\r\n        localGridGroup.remove(localGrid);\r\n        if (localGrid.geometry) localGrid.geometry.dispose();\r\n        if (localGrid.material) localGrid.material.dispose();\r\n        localGrid = null;\r\n    }\r\n    \r\n    let sizeX = 5, sizeY = 5;\r\n    \r\n    if (currentModel) {\r\n        const box = new THREE.Box3().setFromObject(currentModel);\r\n        const size = box.getSize(new THREE.Vector3());\r\n        sizeX = Math.max(size.x, 0.001);\r\n        sizeY = Math.max(size.y, 0.001);\r\n    }\r\n    \r\n    const cellUnits = unitsPerCell(localGridCellPx);\r\n    const factor = 1 + (2 * localGridPaddingPct);\r\n    const halfMax = Math.max(sizeX, sizeY) * factor * 0.5;\r\n    const halfSnapped = Math.ceil(halfMax / cellUnits) * cellUnits;\r\n    const total = Math.max(cellUnits, halfSnapped * 2);\r\n    const divisions = Math.max(1, Math.round(total / cellUnits));\r\n    \r\n    localGrid = new THREE.GridHelper(1, divisions, 0x888888, 0x666666);\r\n    localGrid.scale.set(total, 1, total);\r\n    localGrid.rotateX(Math.PI / 2);\r\n    localGrid.name = 'Local Grid';\r\n    localGridGroup.add(localGrid);\r\n    \r\n    if (currentModel) {\r\n        setLocalGridPosition(currentModel.position);\r\n    }\r\n}\r\n\r\n// Ensure local grid avoids z-fighting with world grid: if z is effectively 0, lift slightly\r\nfunction setLocalGridPosition(posVec3) {\r\n    if (!localGridGroup || !posVec3) return;\r\n    localGridGroup.position.set(posVec3.x, posVec3.y, (Math.abs(posVec3.z) < 1e-6 ? 0.05 : posVec3.z));\r\n}\r\n\r\n// Model loading\r\nfunction loadModel(data) {\r\n    console.log('[Z3D Worker] Loading 3D model...');\r\n    \r\n    try {\r\n        const GLTFLoader = THREE.GLTFLoader || self.GLTFLoader;\r\n        if (!GLTFLoader) {\r\n            throw new Error('GLTFLoader not available');\r\n        }\r\n        \r\n        const loader = new GLTFLoader();\r\n        \r\n        if (data.modelUrl) {\r\n            loader.load(\r\n                data.modelUrl,\r\n                (gltf) => handleModelLoaded(gltf, data),\r\n                (progress) => handleModelProgress(progress),\r\n                (error) => handleModelError(error, data)\r\n            );\r\n        } else if (data.modelData) {\r\n            loader.parse(\r\n                data.modelData,\r\n                '',\r\n                (gltf) => handleModelLoaded(gltf, data),\r\n                (error) => handleModelError(error, data)\r\n            );\r\n        } else {\r\n            throw new Error('No model URL or data provided');\r\n        }\r\n    } catch (error) {\r\n        handleModelError(error, data);\r\n    }\r\n}\r\n\r\nfunction handleModelLoaded(gltf, data) {\r\n    console.log('[Z3D Worker] \u2705 Model loaded successfully');\r\n    \r\n    try {\r\n        // Remove previous model\r\n        if (currentModel) {\r\n            scene.remove(currentModel);\r\n            currentModel = null;\r\n        }\r\n        \r\n        // Get the model\r\n        const originalModel = gltf.scene;\r\n        originalModel.name = 'LoadedModel';\r\n        \r\n        // Configure model\r\n        originalModel.traverse((child) => {\r\n            if (child.isMesh) {\r\n                child.castShadow = true;\r\n                child.receiveShadow = true;\r\n                if (child.material) {\r\n                    child.material.needsUpdate = true;\r\n                }\r\n            }\r\n        });\r\n        \r\n        // Create wrapper\r\n        const modelWrapper = new THREE.Group();\r\n        modelWrapper.name = 'ModelWrapper';\r\n        modelWrapper.add(originalModel);\r\n        \r\n        currentModel = modelWrapper;\r\n        \r\n        // Set rotation order\r\n        if (currentModel.rotation) {\r\n            currentModel.rotation.order = modelRotationOrder || 'ZXY';\r\n        }\r\n        \r\n        // // Apply all transforms\r\n        // applyAllTransforms();\r\n\r\n        // Add to scene\r\n        scene.add(currentModel);\r\n\r\n        // Initialize transform gizmo for the new model\r\n        if (typeof TransformGizmo !== 'undefined' && !transformGizmo) {\r\n            transformGizmo = new TransformGizmo();\r\n            transformGizmo.initialize(scene, camera, currentModel);\r\n            // Initialize overlay for HUD\r\n            if (overlayScene && overlayCamera) {\r\n                transformGizmo.setOverlay(overlayScene, overlayCamera, () => ({ width: viewportWidth, height: viewportHeight }), overlayRoot);\r\n            }\r\n            transformGizmo.setMode(gizmoMode);\r\n            transformGizmo.setSpace(gizmoSpace);\r\n            // Push snap config for WORLD grid snapping (origin 0,0,0)\r\n            const units = unitsPerCell(worldGridCellPx);\r\n                if (transformGizmo.setSnapConfig) transformGizmo.setSnapConfig({ enabled: snapEnabled, angleDeg: snapAngleDeg, snapScale: snapScale, localGridCellPx, unitsPerCell: units, origin: { x: 0, y: 0, z: 0 } });\r\n            console.log('[Z3D Worker] \u2705 Transform gizmo initialized for loaded model');\r\n        } else if (transformGizmo && currentModel) {\r\n            // Update existing gizmo with new model\r\n            if (overlayScene && overlayCamera && transformGizmo.setOverlay) {\r\n                transformGizmo.setOverlay(overlayScene, overlayCamera, () => ({ width: viewportWidth, height: viewportHeight }), overlayRoot);\r\n            }\r\n            transformGizmo.setTarget(currentModel);\r\n            // Update snap config on re-target too\r\n            const units = unitsPerCell(worldGridCellPx);\r\n                if (transformGizmo.setSnapConfig) transformGizmo.setSnapConfig({ enabled: snapEnabled, angleDeg: snapAngleDeg, snapScale: snapScale, localGridCellPx, unitsPerCell: units, origin: { x: 0, y: 0, z: 0 } });\r\n            console.log('[Z3D Worker] \u2705 Transform gizmo target updated');\r\n        }\r\n\r\n        // \u2705 ADD THIS: Apply the initial transforms that were already set\r\n        console.log('[Z3D Worker] Applying initial transforms to loaded model:', {\r\n            position: modelPosition,\r\n            rotation: modelRotation,\r\n            scale: modelScale,\r\n            deltaTransform: modelDeltaTransform\r\n        });\r\n        \r\n        // Apply all transforms immediately\r\n        applyAllTransforms();\r\n        \r\n        // Initialize scene data\r\n        if (typeof SceneDataCollector !== 'undefined') {\r\n            SceneDataCollector.setLoadedGLTF(gltf);\r\n            \r\n            setTimeout(() => {\r\n                try {\r\n                    const sceneData = SceneDataCollector.collectSceneData(scene, currentModel);\r\n                    \r\n                    // ADD DEBUGGING HERE\r\n                    console.log('[Z3D Worker] Scene data collected:', {\r\n                        textureCount: sceneData.textures ? sceneData.textures.length : 0,\r\n                        materialCount: sceneData.materials ? sceneData.materials.length : 0,\r\n                        textures: sceneData.textures\r\n                    });\r\n                    \r\n                    // Check if textures have IDs\r\n                    if (sceneData.textures && sceneData.textures.length > 0) {\r\n                        sceneData.textures.forEach((texture, index) => {\r\n                            console.log(`[Z3D Worker] Texture ${index}:`, {\r\n                                id: texture.id,\r\n                                uuid: texture.uuid,\r\n                                name: texture.name,\r\n                                type: texture.type,\r\n                                hasImage: !!texture.image\r\n                            });\r\n                        });\r\n                    } else {\r\n                        console.warn('[Z3D Worker] No textures found in scene data');\r\n                    }\r\n                    \r\n                    self.postMessage({\r\n                        type: 'SCENE_DATA',\r\n                        data: { sceneData, timestamp: Date.now() }\r\n                    });\r\n                } catch (error) {\r\n                    console.error('[Z3D Worker] Error collecting scene data:', error);\r\n                }\r\n            }, 100);\r\n        }\r\n        \r\n        // Initialize animations\r\n        if (gltf.animations && gltf.animations.length > 0) {\r\n            initializeAnimations(gltf);\r\n            \r\n            // Restore animation state if provided in data\r\n            if (data.animationState) {\r\n                console.log('[Z3D Worker] Restoring animation state:', data.animationState);\r\n                restoreAnimationState(data.animationState);\r\n            }\r\n        }\r\n        \r\n        // Update grids\r\n        rebuildWorldGrid();\r\n        rebuildLocalGrid();\r\n        \r\n        // Fit camera\r\n        fitCameraToModelAndGrids();\r\n        \r\n        // Initialize camera following\r\n        initializeCameraFollowing();\r\n        \r\n        // Send success message\r\n        const modelInfo = getModelInfo(gltf);\r\n        self.postMessage({\r\n            type: 'MODEL_LOADED',\r\n            data: {\r\n                success: true,\r\n                modelInfo,\r\n                hasAnimations: gltf.animations && gltf.animations.length > 0\r\n            }\r\n        });\r\n        \r\n    } catch (error) {\r\n        handleModelError(error, data);\r\n    }\r\n}\r\n\r\nfunction handleModelProgress(progress) {\r\n    const percent = progress.total > 0 ? (progress.loaded / progress.total) * 100 : 0;\r\n    console.log(`[Z3D Worker] Loading progress: ${percent.toFixed(1)}%`);\r\n}\r\n\r\nfunction handleModelError(error, data) {\r\n    console.error('[Z3D Worker] Model loading failed:', error);\r\n    self.postMessage({\r\n        type: 'MODEL_ERROR',\r\n        data: {\r\n            success: false,\r\n            error: error.message || 'Unknown error',\r\n            modelPath: data?.modelPath || 'unknown'\r\n        }\r\n    });\r\n}\r\n\r\nfunction getModelInfo(gltf) {\r\n    let vertexCount = 0;\r\n    let triangleCount = 0;\r\n    let materialCount = 0;\r\n    \r\n    gltf.scene.traverse((child) => {\r\n        if (child.isMesh && child.geometry) {\r\n            const positions = child.geometry.attributes.position;\r\n            if (positions) vertexCount += positions.count;\r\n            \r\n            const indices = child.geometry.index;\r\n            if (indices) {\r\n                triangleCount += indices.count / 3;\r\n            } else if (positions) {\r\n                triangleCount += positions.count / 3;\r\n            }\r\n            \r\n            if (child.material) materialCount++;\r\n        }\r\n    });\r\n    \r\n    return {\r\n        vertexCount: Math.floor(vertexCount),\r\n        triangleCount: Math.floor(triangleCount),\r\n        materialCount,\r\n        hasAnimations: gltf.animations && gltf.animations.length > 0\r\n    };\r\n}\r\n\r\n// Transform handling\r\nfunction updateTransform(data) {\r\n    console.log('[Z3D Worker] \u{1F4C4} UPDATE_TRANSFORM received');\r\n    \r\n    if (!data.transform && !data.deltaTransform) return;\r\n    \r\n    const source = data.source || 'unknown';\r\n    let transformsChanged = false;\r\n    \r\n    // Update delta transforms\r\n    if (data.deltaTransform) {\r\n        const dt = data.deltaTransform;\r\n        modelDeltaTransform = {\r\n            position: dt.position || { x: 0, y: 0, z: 0 },\r\n            rotation: dt.rotation || { x: 0, y: 0, z: 0 },\r\n            scale: dt.scale || { x: 1, y: 1, z: 1 }\r\n        };\r\n        transformsChanged = true;\r\n    }\r\n    \r\n    // Update base transforms\r\n    if (data.transform) {\r\n        const t = data.transform;\r\n        let positionChanged = false;\r\n        \r\n        // Position\r\n        if (t.position) {\r\n            if (typeof t.position.x === 'number') {\r\n                modelPosition.x = t.position.x;\r\n                positionChanged = true;\r\n            }\r\n            if (typeof t.position.y === 'number') {\r\n                modelPosition.y = t.position.y;\r\n                positionChanged = true;\r\n            }\r\n            if (typeof t.position.z === 'number') {\r\n                modelPosition.z = t.position.z;\r\n                positionChanged = true;\r\n            }\r\n        }\r\n        \r\n        // Rotation\r\n        if (t.rotation) {\r\n            if (typeof t.rotation.x === 'number') modelRotation.x = t.rotation.x;\r\n            if (typeof t.rotation.y === 'number') modelRotation.y = t.rotation.y;\r\n            if (typeof t.rotation.z === 'number') modelRotation.z = t.rotation.z;\r\n            transformsChanged = true;\r\n        }\r\n        \r\n        // Scale\r\n        if (t.scale) {\r\n            if (typeof t.scale.x === 'number') modelScale.x = t.scale.x;\r\n            if (typeof t.scale.y === 'number') modelScale.y = t.scale.y;\r\n            if (typeof t.scale.z === 'number') modelScale.z = t.scale.z;\r\n            transformsChanged = true;\r\n        }\r\n        \r\n        // Uniform scale\r\n        if (typeof t.uniformScale === 'number') {\r\n            uniformScale = t.uniformScale;\r\n            transformsChanged = true;\r\n        }\r\n        \r\n        // Unit scale\r\n        if (typeof t.unitScale === 'number') {\r\n            unitScale = t.unitScale;\r\n            transformsChanged = true;\r\n        }\r\n        \r\n        // Rotation order\r\n        if (t.rotationOrder) {\r\n            modelRotationOrder = t.rotationOrder;\r\n            if (currentModel && currentModel.rotation) {\r\n                currentModel.rotation.order = modelRotationOrder;\r\n            }\r\n        }\r\n        \r\n        // Handle position changes and camera following\r\n        if (positionChanged) {\r\n            updateModelPosition();\r\n            handleCameraFollowing(source);\r\n        }\r\n    }\r\n    \r\n     // Apply transforms if changed\r\n    if (transformsChanged && currentModel) {\r\n        applyAllTransforms();\r\n        \r\n        // Update gizmo position\r\n        if (transformGizmo && currentModel) {\r\n            transformGizmo.updateGizmoTransform();\r\n        }\r\n    }\r\n}\r\n\r\nfunction applyAllTransforms() {\r\n    if (!currentModel) return;\r\n    \r\n    // Calculate final position (base + delta)\r\n    const finalPosition = {\r\n        x: modelPosition.x + modelDeltaTransform.position.x,\r\n        y: modelPosition.y + modelDeltaTransform.position.y,\r\n        z: modelPosition.z + modelDeltaTransform.position.z\r\n    };\r\n    \r\n    // Apply position\r\n    const worldPos = convertC3ToThree({ position: finalPosition });\r\n    currentModel.position.set(worldPos.position.x, worldPos.position.y, worldPos.position.z);\r\n    \r\n    // Calculate final rotation (base + delta)\r\n    const finalRotation = {\r\n        x: modelRotation.x + modelDeltaTransform.rotation.x,\r\n        y: modelRotation.y + modelDeltaTransform.rotation.y,\r\n        z: modelRotation.z + modelDeltaTransform.rotation.z\r\n    };\r\n    \r\n    // Apply rotation\r\n    const worldRot = convertC3ToThree({ rotation: finalRotation });\r\n    currentModel.rotation.x = (worldRot.rotation.x * Math.PI) / 180;\r\n    currentModel.rotation.y = (worldRot.rotation.y * Math.PI) / 180;\r\n    currentModel.rotation.z = (worldRot.rotation.z * Math.PI) / 180;\r\n    \r\n    // Calculate final scale\r\n    // Since positions are divided by unitScale in convertC3ToThree,\r\n    // we DON'T apply unitScale to the model scale in Three.js\r\n    // This keeps the model in \"world units\" consistently\r\n    const finalScale = {\r\n        x: uniformScale * modelScale.x * modelDeltaTransform.scale.x,\r\n        y: uniformScale * modelScale.y * modelDeltaTransform.scale.y,\r\n        z: uniformScale * modelScale.z * modelDeltaTransform.scale.z\r\n    };\r\n    \r\n    // Apply scale\r\n    currentModel.scale.set(finalScale.x, finalScale.y, finalScale.z);\r\n    \r\n    // Apply wireframe if needed\r\n    if (wireframeMode) {\r\n        currentModel.traverse((child) => {\r\n            if (child.isMesh && child.material) {\r\n                child.material.wireframe = true;\r\n                child.material.needsUpdate = true;\r\n            }\r\n        });\r\n    }\r\n    \r\n    // Update matrix\r\n    currentModel.updateMatrixWorld(true);\r\n    \r\n    // Update local grid position\r\n    if (localGridGroup) {\r\n        const baseWorldPos = convertC3ToThree({ position: modelPosition });\r\n        localGridGroup.position.set(\r\n            baseWorldPos.position.x,\r\n            baseWorldPos.position.y,\r\n            baseWorldPos.position.z\r\n        );\r\n    }\r\n}\r\n\r\nfunction updateModelPosition() {\r\n    if (!currentModel) return;\r\n    \r\n    const finalPosition = {\r\n        x: modelPosition.x + modelDeltaTransform.position.x,\r\n        y: modelPosition.y + modelDeltaTransform.position.y,\r\n        z: modelPosition.z + modelDeltaTransform.position.z\r\n    };\r\n    \r\n    const worldPos = convertC3ToThree({ position: finalPosition });\r\n    currentModel.position.set(worldPos.position.x, worldPos.position.y, worldPos.position.z);\r\n\r\n    // Update OrbitControls target to follow model\r\n    if (orbitControls) {\r\n        orbitControls.target.copy(currentModel.position);\r\n        orbitControls.update();\r\n    }\r\n    \r\n    if (localGridGroup) {\r\n        const baseWorldPos = convertC3ToThree({ position: modelPosition });\r\n        setLocalGridPosition(new THREE.Vector3(baseWorldPos.position.x, baseWorldPos.position.y, baseWorldPos.position.z));\r\n    }\r\n}\r\n\r\nfunction updateUnitScale(data) {\r\n    if (typeof data.unitScale === 'number') {\r\n        unitScale = data.unitScale;\r\n        if (currentModel) {\r\n            applyAllTransforms();\r\n        }\r\n    }\r\n}\r\n\r\n// Camera handling\r\nfunction initializeCameraState() {\r\n    if (camera) {\r\n        cameraFollowState.lastModelPosition = { ...modelPosition };\r\n    }\r\n}\r\n\r\nfunction initializeCameraFollowing() {\r\n    cameraFollowState.lastModelPosition = { ...modelPosition };\r\n}\r\n\r\nfunction handleCameraFollowing(source) {\r\n    const deltaC3 = {\r\n        x: modelPosition.x - cameraFollowState.lastModelPosition.x,\r\n        y: modelPosition.y - cameraFollowState.lastModelPosition.y,\r\n        z: modelPosition.z - cameraFollowState.lastModelPosition.z\r\n    };\r\n    \r\n    const DEADZONE_PX = 1;\r\n    const movementMagnitude = Math.sqrt(deltaC3.x * deltaC3.x + deltaC3.y * deltaC3.y + deltaC3.z * deltaC3.z);\r\n    \r\n    let shouldFollow = false;\r\n    if (source === 'c3') {\r\n        shouldFollow = cameraFollowState.isEnabledForC3Changes;\r\n    } else if (source === 'editor') {\r\n        shouldFollow = cameraFollowState.isEnabledForEditorChanges;\r\n    }\r\n    \r\n    if (!shouldFollow) {\r\n        cameraFollowState.lastModelPosition = { ...modelPosition };\r\n        return;\r\n    }\r\n    \r\n    if (movementMagnitude < DEADZONE_PX) return;\r\n    \r\n    const now = Date.now();\r\n    if (now - cameraFollowState.updateThrottle < 50) return;\r\n    \r\n    cameraFollowState.updateThrottle = now;\r\n    \r\n    const deltaThree = convertC3ToThree({ position: deltaC3 });\r\n    \r\n    self.postMessage({\r\n        type: 'CAMERA_FOLLOW_REQUEST',\r\n        data: {\r\n            deltaPosition: deltaThree.position,\r\n            source,\r\n            modelPositionC3: { ...modelPosition },\r\n            timestamp: now\r\n        }\r\n    });\r\n    \r\n    cameraFollowState.lastModelPosition = { ...modelPosition };\r\n}\r\n\r\nfunction setCameraFollowForEditor(enabled) {\r\n    cameraFollowState.isEnabledForEditorChanges = enabled;\r\n}\r\n\r\nfunction setCameraFollowForC3(enabled) {\r\n    cameraFollowState.isEnabledForC3Changes = enabled;\r\n}\r\n\r\nfunction updateCamera(data) {\r\n    if (!camera) return;\r\n    \r\n    try {\r\n        camera.position.fromArray(data.position);\r\n        camera.quaternion.fromArray(data.quaternion);\r\n        camera.updateMatrixWorld();\r\n        \r\n        if (data.target) {\r\n            const targetPos = new THREE.Vector3().fromArray(data.target);\r\n            camera.lookAt(targetPos);\r\n        }\r\n    } catch (error) {\r\n        console.error(\"[Z3D Worker] Camera update failed:\", error);\r\n    }\r\n}\r\n\r\nfunction handleCameraTargetUpdate(data) {\r\n    if (!camera || !data.target) return;\r\n    \r\n    const newTarget = new THREE.Vector3(data.target[0], data.target[1], data.target[2]);\r\n    camera.lookAt(newTarget);\r\n    if (orbitTarget) {\r\n        orbitTarget.copy(newTarget);\r\n    }\r\n}\r\n\r\nfunction fitCameraToModelAndGrids() {\r\n    if (!camera) return;\r\n    \r\n    let targetPosition = new THREE.Vector3(0, 0, 0);\r\n    let cameraDistance = 10;\r\n    \r\n    if (currentModel) {\r\n        targetPosition.copy(currentModel.position);\r\n        \r\n        const box = new THREE.Box3().setFromObject(currentModel);\r\n        const size = box.getSize(new THREE.Vector3());\r\n        const maxDim = Math.max(size.x, size.y, size.z);\r\n        \r\n        const fov = camera.fov * (Math.PI / 180);\r\n        const distance = (maxDim / 0.75) / (2 * Math.tan(fov / 2));\r\n        cameraDistance = Math.max(distance * 1.2, maxDim * 2);\r\n    }\r\n    \r\n    const elevation45 = Math.PI / 4;\r\n    const offsetX = 0;\r\n    const offsetY = -cameraDistance * Math.cos(elevation45);\r\n    const offsetZ = cameraDistance * Math.sin(elevation45);\r\n    \r\n    camera.position.set(\r\n        targetPosition.x + offsetX,\r\n        targetPosition.y + offsetY,\r\n        targetPosition.z + offsetZ\r\n    );\r\n    \r\n    camera.up.set(0, 0, 1);\r\n    camera.lookAt(targetPosition);\r\n    \r\n    self.postMessage({\r\n        type: 'INITIAL_CAMERA_STATE',\r\n        data: {\r\n            position: [camera.position.x, camera.position.y, camera.position.z],\r\n            target: [targetPosition.x, targetPosition.y, targetPosition.z],\r\n            up: [0, 0, 1]\r\n        }\r\n    });\r\n    \r\n    if (orbitTarget) {\r\n        orbitTarget.copy(targetPosition);\r\n    }\r\n}\r\n\r\nfunction resetView() {\r\n    if (camera) {\r\n        if (currentModel) {\r\n            fitCameraToModelAndGrids();\r\n        } else {\r\n            camera.position.set(5, -5, 5);\r\n            camera.up.set(0, 0, 1);\r\n            camera.lookAt(0, 0, 0);\r\n        }\r\n    }\r\n}\r\n\r\nfunction centerObject() {\r\n    modelPosition = { x: 0, y: 0, z: 0 };\r\n    updateModelPosition();\r\n}\r\n\r\nfunction updateRenderSize(data) {\r\n    try {\r\n        if (!renderer || !camera) return;\r\n        \r\n        const width = Math.max(1, Math.floor(data.width || 1));\r\n        const height = Math.max(1, Math.floor(data.height || 1));\r\n        // Track viewport size for overlay\r\n        viewportWidth = width;\r\n        viewportHeight = height;\r\n        \r\n        // Update renderer size (this is for the offscreen canvas)\r\n        renderer.setSize(width, height, false);\r\n        \r\n        // CRITICAL: Update camera aspect ratio to prevent skewing\r\n        camera.aspect = width / height;\r\n        camera.updateProjectionMatrix();\r\n\r\n        // Update overlay ortho camera to match new pixel size\r\n        if (overlayCamera) {\r\n            overlayCamera.left = 0;\r\n            overlayCamera.right = Math.max(1, viewportWidth);\r\n            overlayCamera.top = Math.max(1, viewportHeight);\r\n            overlayCamera.bottom = 0;\r\n            overlayCamera.updateProjectionMatrix();\r\n        }\r\n        \r\n        // The FOV remains constant - this is key to preventing distortion\r\n        console.log(`[Z3D Worker] Render size updated: ${width}x${height}, aspect: ${camera.aspect.toFixed(2)}, FOV: ${camera.fov}\xB0`);\r\n        \r\n    } catch (err) {\r\n        console.error('[Z3D Worker] Failed to update render size:', err);\r\n    }\r\n}\r\n\r\n// Viewport settings\r\nfunction updateViewportSetting(data) {\r\n    // Accept legacy shape { setting: {name,value} } and new shape { key, value }\r\n    let name, value;\r\n    if (data && data.setting) ({ name, value } = data.setting);\r\n    else if (data && data.key) { name = data.key; value = data.value; }\r\n    else return;\r\n    \r\n    switch (name) {\r\n        case 'background':\r\n            if (scene) scene.background = new THREE.Color(value);\r\n            break;\r\n            \r\n        case 'wireframe':\r\n            wireframeMode = value;\r\n            if (currentModel) {\r\n                currentModel.traverse((child) => {\r\n                    if (child.isMesh && child.material) {\r\n                        child.material.wireframe = value;\r\n                        child.material.needsUpdate = true;\r\n                    }\r\n                });\r\n            }\r\n            break;\r\n            \r\n        case 'showWorldGrid':\r\n            if (worldGrid) worldGrid.visible = value;\r\n            break;\r\n            \r\n        case 'showLocalGrid':\r\n            if (localGridGroup) localGridGroup.visible = value;\r\n            break;\r\n            \r\n        case 'worldGridCellPx':\r\n            worldGridCellPx = Math.max(1, +value || 1);\r\n            rebuildWorldGrid();\r\n            // Snap settings use WORLD grid\r\n            if (transformGizmo && transformGizmo.setSnapConfig) {\r\n                    transformGizmo.setSnapConfig({ enabled: snapEnabled, angleDeg: snapAngleDeg, snapScale: snapScale, localGridCellPx, unitsPerCell: unitsPerCell(worldGridCellPx), origin: { x: 0, y: 0, z: 0 } });\r\n            }\r\n            break;\r\n            \r\n        case 'localGridCellPx':\r\n            localGridCellPx = Math.max(1, +value || 1);\r\n            rebuildLocalGrid();\r\n            // Snapping adheres to world grid; no change\r\n            break;\r\n        case 'worldGridPaddingPct': {\r\n            let pct = +value || 0;\r\n            if (pct > 1) pct = pct / 100;\r\n            worldGridPaddingPct = Math.max(0, pct);\r\n            rebuildWorldGrid();\r\n            break;\r\n        }\r\n        case 'localGridPaddingPct': {\r\n            let pct = +value || 0;\r\n            if (pct > 1) pct = pct / 100;\r\n            localGridPaddingPct = Math.max(0, pct);\r\n            rebuildLocalGrid();\r\n            break;\r\n        }\r\n        case 'snapAngleDeg':\r\n            snapAngleDeg = Math.max(1, +value || 1);\r\n            if (transformGizmo && transformGizmo.setSnapConfig) {\r\n                transformGizmo.setSnapConfig({ enabled: snapEnabled, angleDeg: snapAngleDeg, snapScale: snapScale, localGridCellPx, unitsPerCell: unitsPerCell(worldGridCellPx), origin: { x: 0, y: 0, z: 0 } });\r\n            }\r\n            break;\r\n        case 'snapScale':\r\n            snapScale = Math.max(0.000001, +value || 0.000001);\r\n            if (transformGizmo && transformGizmo.setSnapConfig) {\r\n                transformGizmo.setSnapConfig({ enabled: snapEnabled, angleDeg: snapAngleDeg, snapScale: snapScale, localGridCellPx, unitsPerCell: unitsPerCell(worldGridCellPx), origin: { x: 0, y: 0, z: 0 } });\r\n            }\r\n            break;\r\n    }\r\n}\r\n\r\nfunction setSnapEnabled(data) {\r\n    snapEnabled = !!(data && data.enabled);\r\n    // Inform gizmo if present\r\n    if (transformGizmo && transformGizmo.setSnapConfig) {\r\n    transformGizmo.setSnapConfig({ enabled: snapEnabled, angleDeg: snapAngleDeg, localGridCellPx, unitsPerCell: unitsPerCell(worldGridCellPx), origin: { x: 0, y: 0, z: 0 } });\r\n    }\r\n}\r\n\r\n// Node visibility\r\nfunction toggleNodeVisibility(data) {\r\n    if (!scene || !data.nodeId) return;\r\n    \r\n    const object = scene.getObjectByProperty('uuid', data.nodeId);\r\n    \r\n    if (object) {\r\n        object.visible = data.visible;\r\n        \r\n        if (object.traverse) {\r\n            object.traverse((child) => {\r\n                if (child.isMesh || child.isLight) {\r\n                    child.visible = data.visible;\r\n                }\r\n            });\r\n        }\r\n        \r\n        // Trigger skinned mesh update to reflect visibility change\r\n        if (skinnedMeshSyncEnabled) {\r\n            sendSkinnedMeshUpdate();\r\n        }\r\n        \r\n        self.postMessage({\r\n            type: 'NODE_VISIBILITY_UPDATED',\r\n            data: {\r\n                nodeId: data.nodeId,\r\n                visible: data.visible,\r\n                success: true\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n// Animation handling\r\nfunction initializeAnimations(gltf) {\r\n    if (!gltf.animations || gltf.animations.length === 0) return;\r\n    \r\n    animations = gltf.animations;\r\n    \r\n    if (currentModel) {\r\n        animationMixer = new THREE.AnimationMixer(currentModel);\r\n        \r\n        if (animations.length > 0) {\r\n            selectAnimationByIndex(0);\r\n        }\r\n        \r\n        self.postMessage({\r\n            type: 'ANIMATIONS_READY',\r\n            data: {\r\n                count: animations.length,\r\n                hasAnimations: true\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nfunction selectAnimation(data) {\r\n    if (!animations || animations.length === 0) return;\r\n    \r\n    let animIndex = -1;\r\n    \r\n    if (data.animationId) {\r\n        animIndex = animations.findIndex(anim => \r\n            (anim.uuid || `anim_${animations.indexOf(anim)}`) === data.animationId\r\n        );\r\n    } else if (typeof data.animationIndex === 'number') {\r\n        animIndex = data.animationIndex;\r\n    }\r\n    \r\n    if (animIndex >= 0 && animIndex < animations.length) {\r\n        selectAnimationByIndex(animIndex);\r\n    }\r\n}\r\n\r\nfunction selectAnimationByIndex(index) {\r\n    if (!animationMixer || !animations || index < 0 || index >= animations.length) return;\r\n    \r\n    if (currentAnimationAction) {\r\n        currentAnimationAction.stop();\r\n        currentAnimationAction = null;\r\n    }\r\n    \r\n    const animation = animations[index];\r\n    currentAnimationAction = animationMixer.clipAction(animation);\r\n    currentAnimationAction.loop = animationLoop ? THREE.LoopRepeat : THREE.LoopOnce;\r\n    currentAnimationAction.timeScale = animationSpeed;\r\n    \r\n    self.postMessage({\r\n        type: 'ANIMATION_SELECTED',\r\n        data: {\r\n            animationId: animation.uuid || `anim_${index}`,\r\n            animationIndex: index,\r\n            name: animation.name || `Animation ${index + 1}`,\r\n            duration: animation.duration\r\n        }\r\n    });\r\n}\r\n\r\nfunction restoreAnimationState(animationState) {\r\n    if (!animationMixer || !animations || !animationState) return;\r\n    \r\n    console.log('[Z3D Worker] Restoring animation state:', animationState);\r\n    \r\n    // Restore animation selection\r\n    if (animationState.selectedIndex !== undefined && animationState.selectedIndex >= 0) {\r\n        selectAnimationByIndex(animationState.selectedIndex);\r\n        \r\n        // Restore animation time\r\n        if (currentAnimationAction && animationState.currentTime !== undefined) {\r\n            currentAnimationAction.enabled = true;\r\n            currentAnimationAction.setEffectiveWeight(1.0);\r\n            currentAnimationAction.setEffectiveTimeScale(animationSpeed);\r\n            currentAnimationAction.play();\r\n            currentAnimationAction.paused = true; // Start paused\r\n            \r\n            // Set the time\r\n            animationMixer.setTime(animationState.currentTime);\r\n            animationMixer.update(0);\r\n            \r\n            // Update model world matrix\r\n            if (currentModel) {\r\n                currentModel.updateMatrixWorld(true);\r\n            }\r\n            \r\n            // Send skinned mesh update with restored pose\r\n            if (skinnedMeshSyncEnabled) {\r\n                lastSkinnedMeshUpdate = 0;\r\n                sendSkinnedMeshUpdate();\r\n            }\r\n            \r\n            console.log(`[Z3D Worker] Restored animation to time ${animationState.currentTime}`);\r\n        }\r\n    }\r\n    \r\n    // Restore animation settings\r\n    if (animationState.loop !== undefined) {\r\n        animationLoop = animationState.loop;\r\n        if (currentAnimationAction) {\r\n            currentAnimationAction.loop = animationLoop ? THREE.LoopRepeat : THREE.LoopOnce;\r\n        }\r\n    }\r\n    \r\n    if (animationState.speed !== undefined) {\r\n        animationSpeed = animationState.speed;\r\n        if (currentAnimationAction) {\r\n            currentAnimationAction.timeScale = animationSpeed;\r\n        }\r\n    }\r\n    \r\n    // Note: We start paused - the animation controls will handle play state\r\n    isAnimationPlaying = false;\r\n}\r\n\r\nfunction playAnimation(data) {\r\n    if (!currentAnimationAction) return;\r\n    \r\n    if (data.loop !== undefined) {\r\n        animationLoop = data.loop;\r\n        currentAnimationAction.loop = animationLoop ? THREE.LoopRepeat : THREE.LoopOnce;\r\n        currentAnimationAction.clampWhenFinished = !animationLoop;\r\n    }\r\n    \r\n    if (data.speed !== undefined) {\r\n        animationSpeed = data.speed;\r\n        currentAnimationAction.timeScale = animationSpeed;\r\n    }\r\n    \r\n    if (currentAnimationAction.paused) {\r\n        currentAnimationAction.paused = false;\r\n    } else {\r\n        const duration = currentAnimationAction.getClip().duration;\r\n        const currentTime = currentAnimationAction.time;\r\n        \r\n        if (currentTime >= duration - 0.001 && !animationLoop) {\r\n            currentAnimationAction.stop();\r\n            currentAnimationAction.reset();\r\n            currentAnimationAction.time = 0;\r\n        }\r\n        \r\n        currentAnimationAction.enabled = true;\r\n        currentAnimationAction.setEffectiveWeight(1.0);\r\n        currentAnimationAction.setEffectiveTimeScale(animationSpeed);\r\n        currentAnimationAction.play();\r\n    }\r\n    \r\n    isAnimationPlaying = true;\r\n    animationClock.start();\r\n    \r\n    self.postMessage({\r\n        type: 'ANIMATION_PLAYING',\r\n        data: {\r\n            isPlaying: true,\r\n            loop: animationLoop,\r\n            speed: animationSpeed\r\n        }\r\n    });\r\n}\r\n\r\nfunction pauseAnimation() {\r\n    if (!currentAnimationAction) return;\r\n    \r\n    currentAnimationAction.paused = true;\r\n    isAnimationPlaying = false;\r\n    \r\n    // Send one final skinned mesh update to preserve the paused pose\r\n    if (skinnedMeshSyncEnabled) {\r\n        // Force immediate update regardless of throttling\r\n        lastSkinnedMeshUpdate = 0;\r\n        sendSkinnedMeshUpdate();\r\n    }\r\n    \r\n    self.postMessage({\r\n        type: 'ANIMATION_PAUSED',\r\n        data: { isPlaying: false }\r\n    });\r\n}\r\n\r\nfunction setAnimationLoop(data) {\r\n    animationLoop = data.loop;\r\n    if (currentAnimationAction) {\r\n        currentAnimationAction.loop = animationLoop ? THREE.LoopRepeat : THREE.LoopOnce;\r\n    }\r\n}\r\n\r\nfunction setAnimationSpeed(data) {\r\n    animationSpeed = data.speed;\r\n    if (currentAnimationAction) {\r\n        currentAnimationAction.timeScale = animationSpeed;\r\n    }\r\n}\r\n\r\nfunction seekAnimation(data) {\r\n    if (!currentAnimationAction || !animationMixer) return;\r\n    \r\n    const clip = currentAnimationAction.getClip();\r\n    const duration = clip.duration;\r\n    const targetTime = Math.max(0, Math.min(data.time, duration));\r\n    \r\n    const wasPlaying = isAnimationPlaying;\r\n    const wasPaused = currentAnimationAction.paused;\r\n    \r\n    if (!currentAnimationAction.isRunning()) {\r\n        currentAnimationAction.enabled = true;\r\n        currentAnimationAction.setEffectiveWeight(1.0);\r\n        currentAnimationAction.setEffectiveTimeScale(1.0);\r\n        currentAnimationAction.play();\r\n        currentAnimationAction.paused = true;\r\n    }\r\n    \r\n    const originalPaused = currentAnimationAction.paused;\r\n    currentAnimationAction.paused = false;\r\n    \r\n    animationMixer.setTime(targetTime);\r\n    animationMixer.update(0);\r\n    \r\n    currentAnimationAction.paused = originalPaused || !wasPlaying;\r\n    \r\n    if (currentModel) {\r\n        currentModel.updateMatrixWorld(true);\r\n    }\r\n    \r\n    if (renderer && scene && camera) {\r\n        renderer.render(scene, camera);\r\n    }\r\n    \r\n    if (wasPlaying && !wasPaused) {\r\n        currentAnimationAction.paused = false;\r\n        isAnimationPlaying = true;\r\n    } else {\r\n        currentAnimationAction.paused = true;\r\n        isAnimationPlaying = false;\r\n    }\r\n    \r\n    // Send skinned mesh update for scrubbing position\r\n    if (skinnedMeshSyncEnabled) {\r\n        // Force immediate update regardless of throttling\r\n        lastSkinnedMeshUpdate = 0;\r\n        sendSkinnedMeshUpdate();\r\n    }\r\n    \r\n    self.postMessage({\r\n        type: 'ANIMATION_UPDATE',\r\n        data: {\r\n            currentTime: targetTime,\r\n            duration: duration,\r\n            ended: targetTime >= duration && !animationLoop\r\n        }\r\n    });\r\n}\r\n\r\nfunction getAnimationTime() {\r\n    if (!currentAnimationAction) {\r\n        self.postMessage({\r\n            type: 'ANIMATION_UPDATE',\r\n            data: { currentTime: 0, ended: false }\r\n        });\r\n        return;\r\n    }\r\n    \r\n    const currentTime = currentAnimationAction.time;\r\n    const duration = currentAnimationAction.getClip().duration;\r\n    const ended = !animationLoop && currentTime >= duration;\r\n    \r\n    self.postMessage({\r\n        type: 'ANIMATION_UPDATE',\r\n        data: { currentTime, duration, ended }\r\n    });\r\n}\r\n\r\n// Texture handling\r\nfunction getTextureImage(data) {\r\n    console.log('[Z3D Worker] Getting texture image for ID:', data.textureId);\r\n    \r\n    if (!scene || !data.textureId) {\r\n        console.warn('[Z3D Worker] No scene or texture ID');\r\n        self.postMessage({\r\n            type: 'TEXTURE_IMAGE_DATA',\r\n            data: { \r\n                textureId: data.textureId, \r\n                imageData: null,\r\n                error: 'No scene or texture ID'\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    \r\n    let foundTexture = null;\r\n    let foundLocation = null;\r\n    \r\n    // Search through all meshes in the scene\r\n    scene.traverse((object) => {\r\n        if (object.isMesh && object.material) {\r\n            const materials = Array.isArray(object.material) ? object.material : [object.material];\r\n            \r\n            materials.forEach(material => {\r\n                const textureProps = [\r\n                    'map', 'normalMap', 'roughnessMap', 'metalnessMap',\r\n                    'emissiveMap', 'aoMap', 'bumpMap', 'displacementMap',\r\n                    'alphaMap', 'envMap', 'lightMap'\r\n                ];\r\n                \r\n                textureProps.forEach(prop => {\r\n                    if (material[prop] && material[prop].uuid === data.textureId) {\r\n                        foundTexture = material[prop];\r\n                        foundLocation = `${material.name || 'Material'}.${prop}`;\r\n                        console.log('[Z3D Worker] Found texture at:', foundLocation);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    });\r\n    \r\n    if (!foundTexture) {\r\n        console.warn('[Z3D Worker] Texture not found for ID:', data.textureId);\r\n        self.postMessage({\r\n            type: 'TEXTURE_IMAGE_DATA',\r\n            data: { \r\n                textureId: data.textureId, \r\n                imageData: null,\r\n                error: 'Texture not found'\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    \r\n    if (!foundTexture.image) {\r\n        console.warn('[Z3D Worker] Texture has no image data');\r\n        self.postMessage({\r\n            type: 'TEXTURE_IMAGE_DATA',\r\n            data: { \r\n                textureId: data.textureId, \r\n                imageData: null,\r\n                error: 'Texture has no image data'\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    \r\n    try {\r\n        console.log('[Z3D Worker] Texture image type:', foundTexture.image.constructor.name);\r\n        \r\n        // Create canvas to extract image data\r\n        const canvas = new OffscreenCanvas(\r\n            foundTexture.image.width || 512,\r\n            foundTexture.image.height || 512\r\n        );\r\n        const ctx = canvas.getContext('2d');\r\n        \r\n        // Draw the image\r\n        ctx.drawImage(foundTexture.image, 0, 0);\r\n        \r\n        // Convert to blob then to data URL\r\n        canvas.convertToBlob({ type: 'image/png' }).then(blob => {\r\n            const reader = new FileReader();\r\n            reader.onloadend = () => {\r\n                console.log('[Z3D Worker] Sending texture image data');\r\n                self.postMessage({\r\n                    type: 'TEXTURE_IMAGE_DATA',\r\n                    data: {\r\n                        textureId: data.textureId,\r\n                        imageData: reader.result,\r\n                        width: canvas.width,\r\n                        height: canvas.height\r\n                    }\r\n                });\r\n            };\r\n            reader.readAsDataURL(blob);\r\n        }).catch(error => {\r\n            console.error('[Z3D Worker] Error converting texture:', error);\r\n            self.postMessage({\r\n                type: 'TEXTURE_IMAGE_DATA',\r\n                data: { \r\n                    textureId: data.textureId, \r\n                    imageData: null,\r\n                    error: error.message\r\n                }\r\n            });\r\n        });\r\n        \r\n    } catch (error) {\r\n        console.error('[Z3D Worker] Error extracting texture image:', error);\r\n        self.postMessage({\r\n            type: 'TEXTURE_IMAGE_DATA',\r\n            data: { \r\n                textureId: data.textureId, \r\n                imageData: null,\r\n                error: error.message\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Gizmo Initialization and Management\r\n */\r\nfunction initializeGizmos(data) {\r\n    console.log('[Z3D Worker] Initializing gizmos...');\r\n    \r\n    if (!scene || !camera || !renderer) {\r\n        console.warn('[Z3D Worker] Scene not ready for gizmos');\r\n        return;\r\n    }\r\n    \r\n    try {\r\n        // Viewport gizmo is handled in main thread as UI overlay\r\n        // Only initialize transform gizmo in worker\r\n\r\n        // Ensure overlay (HUD) exists for 2D screen-space indicators\r\n        if (!overlayScene) {\r\n            overlayScene = new THREE.Scene();\r\n            overlayRoot = new THREE.Group();\r\n            overlayRoot.name = 'OverlayRoot';\r\n            overlayScene.add(overlayRoot);\r\n            // Orthographic camera in pixel space (origin at center by default; we will use 0..w and 0..h)\r\n            overlayCamera = new THREE.OrthographicCamera(0, Math.max(1, viewportWidth), Math.max(1, viewportHeight), 0, -10, 10);\r\n            overlayCamera.position.set(0, 0, 10);\r\n            overlayCamera.lookAt(0, 0, 0);\r\n        }\r\n        \r\n        // Initialize transform gizmo only if it doesn't exist\r\n        if (typeof TransformGizmo !== 'undefined' && currentModel && !transformGizmo) {\r\n            transformGizmo = new TransformGizmo();\r\n            transformGizmo.initialize(scene, camera, currentModel);\r\n            if (overlayScene && overlayCamera) {\r\n                transformGizmo.setOverlay(overlayScene, overlayCamera, () => ({ width: viewportWidth, height: viewportHeight }), overlayRoot);\r\n            }\r\n            transformGizmo.setMode(gizmoMode);\r\n            transformGizmo.setSpace(gizmoSpace);\r\n            console.log('[Z3D Worker] \u2705 Transform gizmo initialized');\r\n        } else if (transformGizmo && currentModel) {\r\n            // If gizmo exists but we have a new model, update the target\r\n            if (overlayScene && overlayCamera && transformGizmo.setOverlay) {\r\n                transformGizmo.setOverlay(overlayScene, overlayCamera, () => ({ width: viewportWidth, height: viewportHeight }), overlayRoot);\r\n            }\r\n            transformGizmo.setTarget(currentModel);\r\n            console.log('[Z3D Worker] \u2705 Transform gizmo target updated');\r\n        }\r\n        \r\n        self.postMessage({\r\n            type: 'GIZMOS_READY',\r\n            data: { \r\n                transformGizmo: !!transformGizmo\r\n            }\r\n        });\r\n    } catch (error) {\r\n        console.error('[Z3D Worker] Failed to initialize gizmos:', error);\r\n        self.postMessage({\r\n            type: 'ERROR',\r\n            data: { error: error.message, context: 'gizmo_initialization' }\r\n        });\r\n    }\r\n}\r\n\r\nfunction setGizmoMode(data) {\r\n    if (!transformGizmo) return;\r\n    \r\n    gizmoMode = data.mode || 'all';\r\n    transformGizmo.setMode(gizmoMode);\r\n    \r\n    console.log('[Z3D Worker] Gizmo mode set to:', gizmoMode);\r\n}\r\n\r\nfunction setGizmoSpace(data) {\r\n    if (!transformGizmo) return;\r\n    \r\n    gizmoSpace = data.space || 'world';\r\n    transformGizmo.setSpace(gizmoSpace);\r\n    \r\n    console.log('[Z3D Worker] Gizmo space set to:', gizmoSpace);\r\n}\r\n\r\nfunction setGizmoVisible(data) {\r\n    gizmoEnabled = data.visible;\r\n    \r\n    if (transformGizmo) {\r\n        transformGizmo.setVisible(gizmoEnabled);\r\n    }\r\n    \r\n    console.log('[Z3D Worker] Gizmo visibility:', gizmoEnabled);\r\n}\r\n\r\nfunction toggleGizmos(data) {\r\n    // Toggle gizmo visibility\r\n    gizmoEnabled = data.visible !== undefined ? data.visible : !gizmoEnabled;\r\n    \r\n    if (transformGizmo) {\r\n        transformGizmo.setVisible(gizmoEnabled);\r\n    }\r\n    \r\n    console.log('[Z3D Worker] Gizmos toggled:', gizmoEnabled);\r\n}\r\n\r\nfunction getModelBounds() {\r\n    // Use currentModel (wrapper group) as the target object to bound\r\n    if (!currentModel) {\r\n        self.postMessage({\r\n            type: 'MODEL_BOUNDS',\r\n            data: {\r\n                min: { x: -1, y: -1, z: -1 },\r\n                max: { x: 1, y: 1, z: 1 },\r\n                center: { x: 0, y: 0, z: 0 },\r\n                sphereRadius: Math.sqrt(3),\r\n                origin: { x: 0, y: 0, z: 0 }\r\n            }\r\n        });\r\n        return;\r\n    }\r\n\r\n    // Ensure matrices are up to date before measuring\r\n    currentModel.updateMatrixWorld(true);\r\n\r\n    // Compute bounding box and sphere for the whole model\r\n    const box = new THREE.Box3().setFromObject(currentModel);\r\n    const center = new THREE.Vector3();\r\n    box.getCenter(center);\r\n    const sphere = new THREE.Sphere();\r\n    box.getBoundingSphere(sphere);\r\n\r\n    // Compute object's world origin\r\n    const origin = new THREE.Vector3();\r\n    currentModel.getWorldPosition(origin);\r\n\r\n    // Fallback if box ended up empty (e.g., no meshes)\r\n    if (box.isEmpty()) {\r\n        box.set(\r\n            new THREE.Vector3(-1, -1, -1),\r\n            new THREE.Vector3(1, 1, 1)\r\n        );\r\n        center.set(0, 0, 0);\r\n        sphere.center.set(0, 0, 0);\r\n        sphere.radius = Math.sqrt(3);\r\n    }\r\n\r\n    // Send bounds and helpful metadata back to main thread\r\n    self.postMessage({\r\n        type: 'MODEL_BOUNDS',\r\n        data: {\r\n            min: { x: box.min.x, y: box.min.y, z: box.min.z },\r\n            max: { x: box.max.x, y: box.max.y, z: box.max.z },\r\n            center: { x: center.x, y: center.y, z: center.z },\r\n            sphereRadius: sphere.radius,\r\n            origin: { x: origin.x, y: origin.y, z: origin.z }\r\n        }\r\n    });\r\n}\r\n\r\nfunction sendRenderStats() {\r\n    if (!scene || !renderer) return;\r\n    \r\n    // Calculate scene statistics\r\n    let vertices = 0;\r\n    let triangles = 0;\r\n    \r\n    scene.traverse((object) => {\r\n        if (object.isMesh && object.geometry) {\r\n            const geom = object.geometry;\r\n            if (geom.index) {\r\n                triangles += geom.index.count / 3;\r\n            } else if (geom.attributes.position) {\r\n                triangles += geom.attributes.position.count / 3;\r\n            }\r\n            if (geom.attributes.position) {\r\n                vertices += geom.attributes.position.count;\r\n            }\r\n        }\r\n    });\r\n    \r\n    // Send render stats\r\n    self.postMessage({\r\n        type: 'RENDER_STATS',\r\n        data: {\r\n            vertices: vertices,\r\n            triangles: triangles,\r\n            drawCalls: renderer.info.render.calls || 0\r\n        }\r\n    });\r\n    \r\n    // Send scene stats\r\n    if (renderer.info && renderer.info.memory) {\r\n        self.postMessage({\r\n            type: 'SCENE_STATS',\r\n            data: {\r\n                memory: {\r\n                    geometries: renderer.info.memory.geometries || 0,\r\n                    textures: renderer.info.memory.textures || 0,\r\n                    programs: renderer.info.programs ? renderer.info.programs.length : 0\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n// Store initial positions for camera follow\r\nlet initialModelPosition = null;\r\nlet initialCameraOffset = null;\r\n\r\nfunction handleGizmoMouseDown(data) {\r\n    console.log('[Z3D Worker] handleGizmoMouseDown:', {\r\n        hasTransformGizmo: !!transformGizmo,\r\n        gizmoEnabled: gizmoEnabled,\r\n        hasCamera: !!camera,\r\n        mouseData: data\r\n    });\r\n    \r\n    if (!transformGizmo || !gizmoEnabled || !camera) {\r\n        console.warn('[Z3D Worker] Cannot handle gizmo mouse down - missing:', {\r\n            transformGizmo: !!transformGizmo,\r\n            gizmoEnabled: gizmoEnabled,\r\n            camera: !!camera\r\n        });\r\n        return;\r\n    }\r\n    \r\n    const mouse = new THREE.Vector2(data.x, data.y);\r\n    const isActive = transformGizmo.handleMouseDown(mouse, camera);\r\n    \r\n    // Store initial positions when starting a position drag\r\n    if (isActive && currentModel && transformGizmo.activeHandle?.type === 'position') {\r\n        initialModelPosition = currentModel.position.clone();\r\n        // Calculate camera offset from model\r\n        initialCameraOffset = camera.position.clone().sub(currentModel.position);\r\n        console.log('[Z3D Worker] Stored initial positions for camera follow');\r\n    // Hide only the local grid during position drag (keep axes visible)\r\n    if (localGrid) localGrid.visible = false;\r\n    }\r\n    \r\n    // Refresh snap config at drag start (WORLD grid: origin 0, step from worldGridCellPx)\r\n    if (isActive && transformGizmo && transformGizmo.setSnapConfig) {\r\n        transformGizmo.setSnapConfig({ enabled: snapEnabled, angleDeg: snapAngleDeg, localGridCellPx, unitsPerCell: unitsPerCell(worldGridCellPx), origin: { x: 0, y: 0, z: 0 } });\r\n    }\r\n    console.log('[Z3D Worker] Gizmo active after mouse down:', isActive);\r\n    \r\n    self.postMessage({\r\n        type: 'GIZMO_ACTIVE',\r\n        data: { active: isActive }\r\n    });\r\n}\r\n\r\nfunction handleGizmoMouseMove(data) {\r\n    if (!transformGizmo) return;\r\n    \r\n    const mouse = new THREE.Vector2(data.x, data.y);\r\n    const isActive = transformGizmo.handleMouseMove(mouse, camera);\r\n    \r\n    if (isActive) {\r\n        // If dragging position, keep the world grid updated to include the object + padding\r\n        if (transformGizmo.activeHandle && transformGizmo.activeHandle.type === 'position') {\r\n            const now = Date.now();\r\n            if (now - lastWorldGridRebuildTs > 100) { // throttle\r\n                rebuildWorldGrid();\r\n                lastWorldGridRebuildTs = now;\r\n            }\r\n        }\r\n        // Transform gizmo will send its own updates via postMessage\r\n        // We just need to update our local state\r\n        if (currentModel) {\r\n            // Convert Three.js position back to C3 coordinates\r\n            modelPosition.x = currentModel.position.x * unitScale;\r\n            modelPosition.y = -currentModel.position.y * unitScale;\r\n            modelPosition.z = currentModel.position.z * unitScale;\r\n            \r\n            // Convert rotation back to degrees\r\n            modelRotation.x = currentModel.rotation.x * 180 / Math.PI;\r\n            modelRotation.y = currentModel.rotation.y * 180 / Math.PI;\r\n            modelRotation.z = currentModel.rotation.z * 180 / Math.PI;\r\n            \r\n            // Update scale\r\n            // Reverse the scale calculation to get model scale from Three.js scale\r\n            modelScale.x = currentModel.scale.x / uniformScale;\r\n            modelScale.y = currentModel.scale.y / uniformScale;\r\n            modelScale.z = currentModel.scale.z / uniformScale;\r\n        }\r\n    }\r\n}\r\n\r\nfunction handleGizmoMouseUp(data) {\r\n    if (!transformGizmo) return;\r\n    \r\n    // Check if position was being dragged before releasing\r\n    const wasPositionDragged = transformGizmo.activeHandle && transformGizmo.activeHandle.type === 'position';\r\n    const currentPosition = currentModel ? currentModel.position.clone() : null;\r\n    \r\n    const wasActive = transformGizmo.handleMouseUp();\r\n\r\n    // Force final snap-to-grid on release (WORLD grid)\r\n    if (wasPositionDragged && currentModel && snapEnabled) {\r\n        const step = unitsPerCell(worldGridCellPx);\r\n        if (step > 0) {\r\n            currentModel.position.x = Math.round(currentModel.position.x / step) * step;\r\n            currentModel.position.y = Math.round(currentModel.position.y / step) * step;\r\n            currentModel.position.z = Math.round(currentModel.position.z / step) * step;\r\n            // Update internal state mirrors\r\n            modelPosition.x = currentModel.position.x * unitScale;\r\n            modelPosition.y = -currentModel.position.y * unitScale;\r\n            modelPosition.z = currentModel.position.z * unitScale;\r\n        }\r\n    }\r\n    \r\n    self.postMessage({\r\n        type: 'GIZMO_ACTIVE',\r\n        data: { active: false }\r\n    });\r\n    \r\n    // If position was dragged, update local grid and camera\r\n    if (wasPositionDragged && currentModel) {\r\n        // Update local grid position and show it again\r\n        if (localGridGroup) {\r\n            setLocalGridPosition(currentModel.position);\r\n            if (localGrid) localGrid.visible = true;\r\n        }\r\n        \r\n        // Update camera to maintain same view if follow is enabled\r\n        if (cameraFollowState.isEnabledForEditorChanges && initialModelPosition && initialCameraOffset) {\r\n            console.log('[Z3D Worker] Camera follow enabled, maintaining view');\r\n            \r\n            // Update camera position to maintain same offset\r\n            const newCameraPosition = currentModel.position.clone().add(initialCameraOffset);\r\n            camera.position.copy(newCameraPosition);\r\n            \r\n            // Update orbit target to model position\r\n            if (orbitTarget) {\r\n                orbitTarget.copy(currentModel.position);\r\n            }\r\n            \r\n            // Update camera to look at new target\r\n            camera.lookAt(currentModel.position);\r\n            \r\n            // Update orbit controls if they exist\r\n            if (orbitControls) {\r\n                orbitControls.target.copy(currentModel.position);\r\n                orbitControls.update();\r\n            }\r\n            \r\n            // Send message to main thread\r\n            self.postMessage({\r\n                type: 'UPDATE_CAMERA_FOLLOW',\r\n                data: {\r\n                    position: {\r\n                        x: camera.position.x,\r\n                        y: camera.position.y,\r\n                        z: camera.position.z\r\n                    },\r\n                    target: {\r\n                        x: currentModel.position.x,\r\n                        y: currentModel.position.y,\r\n                        z: currentModel.position.z\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        \r\n        // Clear stored positions\r\n        initialModelPosition = null;\r\n        initialCameraOffset = null;\r\n    }\r\n}\r\n\r\nfunction handlePositionDragEnded(data) {\r\n    if (!data || !data.position) return;\r\n    \r\n    // Update local grid position to match the new object position\r\n    if (localGridGroup) {\r\n        localGridGroup.position.set(\r\n            data.position.x,\r\n            data.position.y,\r\n            data.position.z\r\n        );\r\n    }\r\n    \r\n    // If camera follow is enabled and we have a delta, update camera\r\n    if (data.delta && cameraFollowState.isEnabledForEditorChanges && camera) {\r\n        console.log('[Z3D Worker] Camera follow enabled, moving camera by delta:', data.delta);\r\n        \r\n        // Move the camera by the same delta to maintain the view\r\n        camera.position.x += data.delta.x;\r\n        camera.position.y += data.delta.y;\r\n        camera.position.z += data.delta.z;\r\n        \r\n        // Update orbit target to the new object position\r\n        if (orbitTarget) {\r\n            orbitTarget.set(data.position.x, data.position.y, data.position.z);\r\n        }\r\n        \r\n        // Update orbit controls\r\n        if (orbitControls) {\r\n            orbitControls.target.set(data.position.x, data.position.y, data.position.z);\r\n            orbitControls.update();\r\n        }\r\n        \r\n        // Send the updated camera state to main thread\r\n        self.postMessage({\r\n            type: 'UPDATE_CAMERA_FOLLOW',\r\n            data: {\r\n                delta: data.delta,\r\n                target: data.position,\r\n                cameraPosition: {\r\n                    x: camera.position.x,\r\n                    y: camera.position.y,\r\n                    z: camera.position.z\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nfunction animateCameraTo(data) {\r\n    if (!camera || !data) {\r\n        console.error('[Z3D Worker] Cannot animate camera - camera:', !!camera, 'data:', !!data);\r\n        return;\r\n    }\r\n    \r\n    const { position, target, upVector, duration, viewName } = data;\r\n    \r\n    // IMPORTANT: Use provided target, or current orbit target, or current model position\r\n    let cameraTarget;\r\n    if (target) {\r\n        // Explicit target provided (e.g., from viewport gizmo maintaining current target)\r\n        cameraTarget = target;\r\n    } else if (currentModel) {\r\n        // Use current model position as target\r\n        cameraTarget = [\r\n            currentModel.position.x,\r\n            currentModel.position.y,\r\n            currentModel.position.z\r\n        ];\r\n    } else if (orbitTarget) {\r\n        // Fall back to orbit target\r\n        cameraTarget = orbitTarget.toArray();\r\n    } else {\r\n        // Last resort: origin\r\n        cameraTarget = [0, 0, 0];\r\n    }\r\n    \r\n    console.log(`[Z3D Worker] Animating camera to ${viewName} view:`, {\r\n        position: position,\r\n        target: cameraTarget,\r\n        upVector: upVector\r\n    });\r\n    \r\n    // Set the camera up vector if provided (aligns screen-up for specific views like Top/Bottom)\r\n    if (upVector) {\r\n        camera.up.set(upVector[0], upVector[1], upVector[2]);\r\n    } else {\r\n        // Default up vector for C3 coordinate system\r\n        camera.up.set(0, 0, 1);\r\n    }\r\n    \r\n    // Set the new camera position (distance preserved by the caller)\r\n    if (position) {\r\n        camera.position.set(position[0], position[1], position[2]);\r\n    }\r\n    \r\n    // Update orbit target and camera look-at\r\n    const targetVec = new THREE.Vector3(cameraTarget[0], cameraTarget[1], cameraTarget[2]);\r\n    \r\n    if (orbitTarget) {\r\n        orbitTarget.copy(targetVec);\r\n    }\r\n    \r\n    // Make camera look at target\r\n    camera.lookAt(targetVec);\r\n    \r\n    // Update orbit controls if they exist\r\n    if (orbitControls) {\r\n        orbitControls.target.copy(targetVec);\r\n        orbitControls.update();\r\n    }\r\n    \r\n    camera.updateMatrixWorld();\r\n    \r\n    // Send message to main thread to update OrbitControls\r\n    self.postMessage({\r\n        type: 'CAMERA_SNAP_TO_VIEW',\r\n        data: {\r\n            position: position,\r\n            target: cameraTarget,  // Send the actual target used\r\n            upVector: upVector,\r\n            viewName: viewName\r\n        }\r\n    });\r\n    \r\n    // IMPORTANT: restore world Z-up after establishing the snapped orientation\r\n    camera.up.set(0, 0, 1);\r\n    if (orbitControls) {\r\n        orbitControls.object.up.set(0, 0, 1);\r\n        orbitControls.update();\r\n    }\r\n\r\n    self.postMessage({\r\n        type: 'CAMERA_ANIMATION_COMPLETE',\r\n        data: { viewName }\r\n    });\r\n}\r\n\r\n// Render loop\r\nfunction startRenderLoop() {\r\n    if (!renderer || !scene || !camera) return;\r\n    \r\n    let statsUpdateCounter = 0;\r\n    \r\n    function animate() {\r\n        animationId = requestAnimationFrame(animate);\r\n        \r\n        try {\r\n            // Update orbit controls FIRST (unless camera is animating)\r\n            if (orbitControls && !isCameraAnimating) {\r\n                orbitControls.update();\r\n            }\r\n\r\n            // Send camera quaternion to main thread for viewport gizmo\r\n            if (camera && !this._lastQuaternionUpdate || Date.now() - this._lastQuaternionUpdate > 16) {\r\n                this._lastQuaternionUpdate = Date.now();\r\n                self.postMessage({\r\n                    type: 'CAMERA_QUATERNION_UPDATE',\r\n                    data: { quaternion: camera.quaternion.toArray() }\r\n                });\r\n            }\r\n            \r\n            // Send render stats periodically (every 30 frames)\r\n            statsUpdateCounter++;\r\n            if (statsUpdateCounter >= 30) {\r\n                statsUpdateCounter = 0;\r\n                sendRenderStats();\r\n            }\r\n\r\n            // Update transform gizmo\r\n            if (transformGizmo) {\r\n                transformGizmo.update();\r\n            }\r\n\r\n            // Update animations\r\n            if (animationMixer && currentAnimationAction && isAnimationPlaying && !currentAnimationAction.paused) {\r\n                const delta = animationClock.getDelta();\r\n                const prevTime = currentAnimationAction.time;\r\n                const duration = currentAnimationAction.getClip().duration;\r\n                \r\n                animationMixer.update(delta);\r\n                \r\n                // Send skinned mesh update if enabled\r\n                if (skinnedMeshSyncEnabled) {\r\n                    sendSkinnedMeshUpdate();\r\n                }\r\n                \r\n                const newTime = currentAnimationAction.time;\r\n                \r\n                self.postMessage({\r\n                    type: 'ANIMATION_UPDATE',\r\n                    data: {\r\n                        currentTime: newTime,\r\n                        duration: duration,\r\n                        ended: false\r\n                    }\r\n                });\r\n                \r\n                if (!animationLoop && prevTime < duration && newTime >= duration - 0.001) {\r\n                    isAnimationPlaying = false;\r\n                    currentAnimationAction.paused = true;\r\n                    currentAnimationAction.time = duration;\r\n                    \r\n                    animationMixer.setTime(duration);\r\n                    animationMixer.update(0);\r\n                    \r\n                    self.postMessage({\r\n                        type: 'ANIMATION_UPDATE',\r\n                        data: {\r\n                            currentTime: duration,\r\n                            duration: duration,\r\n                            ended: true\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n\r\n            \r\n            \r\n            // Render scene\r\n            renderer.render(scene, camera);\r\n\r\n            // Render overlay HUD on top\r\n            if (overlayScene && overlayCamera) {\r\n                // Ensure depth buffer does not occlude overlay and avoid clearing color on second pass\r\n                const prevAutoClear = renderer.autoClear;\r\n                renderer.autoClear = false;\r\n                renderer.clearDepth();\r\n                renderer.render(overlayScene, overlayCamera);\r\n                renderer.autoClear = prevAutoClear;\r\n            }\r\n            \r\n        } catch (error) {\r\n            console.error('[Z3D Worker] Render error:', error);\r\n        }\r\n    }\r\n    \r\n    animate();\r\n}\r\n\r\nfunction stopRenderLoop() {\r\n    if (animationId) {\r\n        cancelAnimationFrame(animationId);\r\n        animationId = null;\r\n    }\r\n}\r\n\r\n// Cleanup\r\n// Cleanup\r\nself.addEventListener('beforeunload', () => {\r\n    stopRenderLoop();\r\n    \r\n    // Cleanup transform gizmo only (viewport gizmo is in main thread)\r\n    \r\n    if (transformGizmo) {\r\n        transformGizmo.dispose();\r\n        transformGizmo = null;\r\n    }\r\n    \r\n    if (renderer) {\r\n        renderer.dispose();\r\n    }\r\n});\r\n\r\nconsole.log('[Z3D Worker] \u2705 Worker ready');\r\nself.postMessage({\r\n    type: 'WORKER_READY',\r\n    data: { timestamp: Date.now(), version: 'cleaned-unified' }\r\n});",
        "sceneDataCollector": "/* FILE: editor/z3d-object-editor/templates/scripts/workers/scene-data-collector.js */\r\n/* Scene Data Collection for Three.js - Fixed version with proper error handling */\r\n\r\n// Store the loaded GLTF data globally within this module\r\nlet loadedGLTF = null;\r\n\r\n/**\r\n * Set the GLTF data for collection\r\n */\r\nfunction setLoadedGLTF(gltf) {\r\n    loadedGLTF = gltf;\r\n    console.log('[SceneDataCollector] GLTF data stored');\r\n}\r\n\r\n/**\r\n * Collect complete scene data aligned with Three.js concepts\r\n * Removes Babylon.js specific concepts and adds Three.js specific ones\r\n */\r\n/**\r\n * Collect complete scene data aligned with Three.js concepts\r\n */\r\nfunction collectSceneData(scene, currentModel) {\r\n    console.log('[SceneDataCollector] Collecting complete scene data...');\r\n    \r\n    const data = {\r\n        nodes: null,\r\n        materials: new Map(),\r\n        textures: new Map(),\r\n        animations: [],\r\n        skeletons: [],\r\n        lights: [],\r\n        cameras: [],\r\n        geometries: new Map(),\r\n        meshes: [],\r\n        groups: [],\r\n        helpers: [],\r\n        fog: null,\r\n        environment: null,\r\n        postProcessing: [],\r\n    };\r\n    \r\n    try {\r\n        // Collect the main scene hierarchy\r\n        if (scene) {\r\n            data.nodes = collectNodeHierarchy(scene);\r\n            \r\n            // Collect scene-level properties\r\n            if (scene.fog) {\r\n                data.fog = {\r\n                    type: scene.fog.isFog ? 'Fog' : scene.fog.isFogExp2 ? 'FogExp2' : 'Unknown',\r\n                    color: scene.fog.color ? scene.fog.color.getHex() : null,\r\n                    near: scene.fog.near,\r\n                    far: scene.fog.far,\r\n                    density: scene.fog.density\r\n                };\r\n            }\r\n            \r\n            if (scene.environment) {\r\n                data.environment = {\r\n                    texture: scene.environment ? scene.environment.uuid : null,\r\n                    mapping: scene.environment ? scene.environment.mapping : null\r\n                };\r\n            }\r\n        }\r\n        \r\n        // Collect animations from GLTF\r\n        if (loadedGLTF && loadedGLTF.animations) {\r\n            data.animations = collectAnimations(loadedGLTF.animations);\r\n            console.log(`[SceneDataCollector] Found ${data.animations.length} animations`);\r\n        }\r\n        \r\n        // Also check for animations in the scene mixer\r\n        if (loadedGLTF && loadedGLTF.mixer) {\r\n            data.animationMixer = {\r\n                timeScale: loadedGLTF.mixer.timeScale,\r\n                clipCount: loadedGLTF.mixer._actions ? loadedGLTF.mixer._actions.length : 0\r\n            };\r\n        }\r\n        \r\n        // FIRST: Collect actual texture objects from the scene\r\n        const actualTextures = new Map();\r\n        \r\n        scene.traverse((object) => {\r\n            if (object.isMesh && object.material) {\r\n                const materials = Array.isArray(object.material) ? object.material : [object.material];\r\n                \r\n                materials.forEach(material => {\r\n                    // Check for actual texture objects\r\n                    const textureProps = [\r\n                        'map', 'normalMap', 'roughnessMap', 'metalnessMap',\r\n                        'emissiveMap', 'aoMap', 'bumpMap', 'displacementMap',\r\n                        'alphaMap', 'envMap', 'lightMap', 'specularMap',\r\n                        'clearcoatMap', 'clearcoatNormalMap', 'clearcoatRoughnessMap'\r\n                    ];\r\n                    \r\n                    textureProps.forEach(prop => {\r\n                        const texture = material[prop];\r\n                        // Check if it's an actual texture object (not a string UUID)\r\n                        if (texture && typeof texture === 'object' && texture.isTexture) {\r\n                            if (!actualTextures.has(texture.uuid)) {\r\n                                actualTextures.set(texture.uuid, {\r\n                                    texture: texture,\r\n                                    materialName: material.name,\r\n                                    property: prop\r\n                                });\r\n                                console.log(`[SceneDataCollector] Found actual texture: ${prop} from ${material.name}, UUID: ${texture.uuid}`);\r\n                            }\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n        });\r\n        \r\n        // Convert actual textures to serializable data\r\n        actualTextures.forEach(({texture, materialName, property}, uuid) => {\r\n            try {\r\n                const textureData = {\r\n                    id: uuid,\r\n                    uuid: uuid,\r\n                    name: texture.name || `${materialName || 'Material'} - ${property}`,\r\n                    type: property,\r\n                    materialName: materialName || 'Unnamed Material',\r\n                    className: texture.constructor.name,\r\n                    image: null,\r\n                    // Texture properties\r\n                    wrapS: texture.wrapS || 1001,\r\n                    wrapT: texture.wrapT || 1001,\r\n                    repeat: texture.repeat ? {\r\n                        x: texture.repeat.x || 1,\r\n                        y: texture.repeat.y || 1\r\n                    } : { x: 1, y: 1 },\r\n                    offset: texture.offset ? {\r\n                        x: texture.offset.x || 0,\r\n                        y: texture.offset.y || 0\r\n                    } : { x: 0, y: 0 },\r\n                    center: texture.center ? {\r\n                        x: texture.center.x || 0,\r\n                        y: texture.center.y || 0\r\n                    } : { x: 0, y: 0 },\r\n                    rotation: texture.rotation || 0,\r\n                    magFilter: texture.magFilter || 1006,\r\n                    minFilter: texture.minFilter || 1008,\r\n                    anisotropy: texture.anisotropy || 1,\r\n                    format: texture.format || 1023,\r\n                    encoding: texture.encoding || 3000,\r\n                    generateMipmaps: texture.generateMipmaps !== undefined ? texture.generateMipmaps : true,\r\n                    flipY: texture.flipY !== undefined ? texture.flipY : true\r\n                };\r\n                \r\n                // Check for image data\r\n                if (texture.image) {\r\n                    textureData.image = {\r\n                        width: texture.image.width || 0,\r\n                        height: texture.image.height || 0,\r\n                        hasData: true\r\n                    };\r\n                    console.log(`[SceneDataCollector] Texture has image: ${textureData.image.width}x${textureData.image.height}`);\r\n                }\r\n                \r\n                data.textures.set(uuid, textureData);\r\n                console.log(`[SceneDataCollector] Added texture: ${textureData.name} (ID: ${uuid})`);\r\n                \r\n            } catch (err) {\r\n                console.error('[SceneDataCollector] Error processing texture:', err);\r\n            }\r\n        });\r\n        \r\n        // Traverse scene to collect other objects\r\n        scene.traverse((object) => {\r\n            try {\r\n                // Collect materials\r\n                if (object.isMesh && object.material) {\r\n                    const materials = Array.isArray(object.material) ? object.material : [object.material];\r\n                    materials.forEach(mat => {\r\n                        if (!data.materials.has(mat.uuid)) {\r\n                            data.materials.set(mat.uuid, collectMaterialData(mat));\r\n                        }\r\n                    });\r\n                    \r\n                    // Add to meshes array\r\n                    data.meshes.push({\r\n                        id: object.uuid,\r\n                        name: object.name,\r\n                        vertexCount: object.geometry ? \r\n                            (object.geometry.attributes.position ? object.geometry.attributes.position.count : 0) : 0,\r\n                        materialCount: materials.length\r\n                    });\r\n                }\r\n                \r\n                // Collect geometries\r\n                if (object.isMesh && object.geometry) {\r\n                    if (!data.geometries.has(object.geometry.uuid)) {\r\n                        data.geometries.set(object.geometry.uuid, collectGeometryData(object.geometry));\r\n                    }\r\n                }\r\n                \r\n                // Collect groups\r\n                if (object.isGroup && !object.isMesh && !object.isLight && !object.isCamera) {\r\n                    data.groups.push({\r\n                        id: object.uuid,\r\n                        name: object.name || 'Group',\r\n                        childCount: object.children.length\r\n                    });\r\n                }\r\n                \r\n                // Collect lights\r\n                if (object.isLight) {\r\n                    data.lights.push(collectLightData(object));\r\n                }\r\n                \r\n                // Collect cameras\r\n                if (object.isCamera) {\r\n                    data.cameras.push(collectCameraData(object));\r\n                }\r\n                \r\n                // Collect skeletons\r\n                if (object.isSkinnedMesh && object.skeleton) {\r\n                    const skeletonData = collectSkeletonData(object.skeleton);\r\n                    const exists = data.skeletons.some(s => s.id === skeletonData.id);\r\n                    if (!exists) {\r\n                        data.skeletons.push(skeletonData);\r\n                    }\r\n                }\r\n                \r\n                // Collect helpers\r\n                if (object.type && (\r\n                    object.type.includes('Helper') || \r\n                    object.type === 'GridHelper' || \r\n                    object.type === 'AxesHelper' ||\r\n                    object.type === 'BoxHelper' ||\r\n                    object.type === 'PlaneHelper' ||\r\n                    object.type === 'ArrowHelper'\r\n                )) {\r\n                    data.helpers.push({\r\n                        id: object.uuid,\r\n                        name: object.name || object.type,\r\n                        type: object.type,\r\n                        visible: object.visible\r\n                    });\r\n                }\r\n            } catch (err) {\r\n                console.warn(`[SceneDataCollector] Error processing object ${object.name}:`, err);\r\n            }\r\n        });\r\n        \r\n        // DON'T collect textures from materials anymore since they only have UUID strings\r\n        // Comment out or remove this:\r\n        /*\r\n        data.materials.forEach(material => {\r\n            console.log('[SceneDataCollector] Processing material:', {\r\n                name: material.name,\r\n                type: material.type,\r\n                hasMap: 'map' in material,\r\n                mapValue: material.map,\r\n                hasNormalMap: 'normalMap' in material,\r\n                normalMapValue: material.normalMap\r\n            });\r\n            collectTexturesFromMaterial(material, data.textures);\r\n        });\r\n        */\r\n        \r\n        // Add LOD information if present\r\n        const lodObjects = [];\r\n        scene.traverse((object) => {\r\n            if (object.isLOD) {\r\n                lodObjects.push({\r\n                    id: object.uuid,\r\n                    name: object.name || 'LOD',\r\n                    levels: object.levels.length\r\n                });\r\n            }\r\n        });\r\n        \r\n        if (lodObjects.length > 0) {\r\n            data.lods = lodObjects;\r\n        }\r\n        \r\n    } catch (error) {\r\n        console.error('[SceneDataCollector] Error during scene traversal:', error);\r\n    }\r\n    \r\n    // Convert Maps to Arrays for serialization\r\n    const serializedData = {\r\n        nodes: data.nodes,\r\n        materials: Array.from(data.materials.values()),\r\n        textures: Array.from(data.textures.values()),\r\n        animations: data.animations,\r\n        skeletons: data.skeletons,\r\n        lights: data.lights,\r\n        cameras: data.cameras,\r\n        geometries: Array.from(data.geometries.values()),\r\n        meshes: data.meshes,\r\n        groups: data.groups,\r\n        helpers: data.helpers,\r\n        lods: data.lods || [],\r\n        fog: data.fog,\r\n        environment: data.environment,\r\n        animationMixer: data.animationMixer,\r\n        stats: {\r\n            totalNodes: countNodes(data.nodes),\r\n            totalMaterials: data.materials.size,\r\n            totalTextures: data.textures.size,\r\n            totalAnimations: data.animations.length,\r\n            totalSkeletons: data.skeletons.length,\r\n            totalLights: data.lights.length,\r\n            totalCameras: data.cameras.length,\r\n            totalGeometries: data.geometries.size,\r\n            totalMeshes: data.meshes.length,\r\n            totalGroups: data.groups.length,\r\n            totalHelpers: data.helpers.length,\r\n            totalLODs: data.lods ? data.lods.length : 0,\r\n            totalVertices: calculateTotalVertices(data.geometries),\r\n            totalTriangles: calculateTotalTriangles(data.geometries)\r\n        }\r\n    };\r\n    \r\n    console.log('[SceneDataCollector] Scene data collected:', serializedData.stats);\r\n    return serializedData;\r\n}\r\n\r\n/**\r\n * Collect node hierarchy with proper classification\r\n */\r\nfunction collectNodeHierarchy(node, depth = 0) {\r\n    const nodeData = {\r\n        id: node.uuid,\r\n        name: node.name || 'Unnamed',\r\n        type: getNodeType(node),\r\n        className: node.constructor.name, // Actual Three.js class name\r\n        visible: node.visible,\r\n        castShadow: node.castShadow,\r\n        receiveShadow: node.receiveShadow,\r\n        frustumCulled: node.frustumCulled,\r\n        renderOrder: node.renderOrder,\r\n        layers: node.layers.mask, // Layer mask for selective rendering\r\n        position: {\r\n            x: node.position.x,\r\n            y: node.position.y,\r\n            z: node.position.z\r\n        },\r\n        rotation: {\r\n            x: node.rotation.x * 180 / Math.PI,\r\n            y: node.rotation.y * 180 / Math.PI,\r\n            z: node.rotation.z * 180 / Math.PI,\r\n            order: node.rotation.order\r\n        },\r\n        scale: {\r\n            x: node.scale.x,\r\n            y: node.scale.y,\r\n            z: node.scale.z\r\n        },\r\n        matrix: node.matrix.toArray(), // Local transform matrix\r\n        userData: JSON.parse(JSON.stringify(node.userData || {})),\r\n        children: [],\r\n        depth: depth,\r\n        // Additional properties based on type\r\n        meshInfo: null,\r\n        lightInfo: null,\r\n        cameraInfo: null,\r\n        // Reference IDs\r\n        materialId: null,\r\n        geometryId: null,\r\n        skeletonId: null\r\n    };\r\n    \r\n    // Add type-specific information\r\n    if (node.isMesh) {\r\n        nodeData.meshInfo = {\r\n            castShadow: node.castShadow,\r\n            receiveShadow: node.receiveShadow,\r\n            frustumCulled: node.frustumCulled,\r\n            renderOrder: node.renderOrder,\r\n            morphTargetInfluences: node.morphTargetInfluences ? node.morphTargetInfluences.length : 0,\r\n            morphTargetDictionary: node.morphTargetDictionary ? Object.keys(node.morphTargetDictionary).length : 0\r\n        };\r\n        \r\n        if (node.material) {\r\n            const materials = Array.isArray(node.material) ? node.material : [node.material];\r\n            nodeData.materialId = materials.map(m => m.uuid);\r\n        }\r\n        \r\n        if (node.geometry) {\r\n            nodeData.geometryId = node.geometry.uuid;\r\n            \r\n            // Add bounding box info\r\n            if (node.geometry.boundingBox) {\r\n                nodeData.meshInfo.boundingBox = {\r\n                    min: { ...node.geometry.boundingBox.min },\r\n                    max: { ...node.geometry.boundingBox.max }\r\n                };\r\n            }\r\n        }\r\n        \r\n        if (node.isSkinnedMesh && node.skeleton) {\r\n            nodeData.skeletonId = node.skeleton.uuid;\r\n        }\r\n    }\r\n    \r\n    if (node.isLight) {\r\n        nodeData.lightInfo = collectLightInfo(node);\r\n    }\r\n    \r\n    if (node.isCamera) {\r\n        nodeData.cameraInfo = collectCameraInfo(node);\r\n    }\r\n    \r\n    // Collect children and SORT them to put ModelWrapper first\r\n    if (node.children && node.children.length > 0) {\r\n        // Sort children: ModelWrapper first, then others alphabetically\r\n        const sortedChildren = [...node.children].sort((a, b) => {\r\n            // ModelWrapper always comes first\r\n            if (a.name === 'ModelWrapper') return -1;\r\n            if (b.name === 'ModelWrapper') return 1;\r\n            \r\n            // Then helpers and grids go last\r\n            const aIsHelper = a.name && (a.name.includes('Grid') || a.name.includes('Axes') || a.name.includes('Helper'));\r\n            const bIsHelper = b.name && (b.name.includes('Grid') || b.name.includes('Axes') || b.name.includes('Helper'));\r\n            \r\n            if (aIsHelper && !bIsHelper) return 1;\r\n            if (!aIsHelper && bIsHelper) return -1;\r\n            \r\n            // Everything else by name\r\n            return (a.name || '').localeCompare(b.name || '');\r\n        });\r\n        \r\n        nodeData.children = sortedChildren.map(child => \r\n            collectNodeHierarchy(child, depth + 1)\r\n        );\r\n    }\r\n    \r\n    return nodeData;\r\n}\r\n\r\n/**\r\n * Get user-friendly node type\r\n */\r\nfunction getNodeType(node) {\r\n    // Check for specific Three.js types\r\n    if (node.isScene) return 'Scene';\r\n    if (node.isSkinnedMesh) return 'SkinnedMesh';\r\n    if (node.isInstancedMesh) return 'InstancedMesh';\r\n    if (node.isMesh) return 'Mesh';\r\n    if (node.isBone) return 'Bone';\r\n    if (node.isLine) return 'Line';\r\n    if (node.isLineLoop) return 'LineLoop';\r\n    if (node.isLineSegments) return 'LineSegments';\r\n    if (node.isPoints) return 'Points';\r\n    if (node.isSprite) return 'Sprite';\r\n    if (node.isGroup) return 'Group';\r\n    if (node.isLOD) return 'LOD';\r\n    \r\n    // Lights\r\n    if (node.isLight) {\r\n        if (node.isDirectionalLight) return 'DirectionalLight';\r\n        if (node.isPointLight) return 'PointLight';\r\n        if (node.isSpotLight) return 'SpotLight';\r\n        if (node.isAmbientLight) return 'AmbientLight';\r\n        if (node.isHemisphereLight) return 'HemisphereLight';\r\n        if (node.isRectAreaLight) return 'RectAreaLight';\r\n        return 'Light';\r\n    }\r\n    \r\n    // Cameras\r\n    if (node.isCamera) {\r\n        if (node.isPerspectiveCamera) return 'PerspectiveCamera';\r\n        if (node.isOrthographicCamera) return 'OrthographicCamera';\r\n        if (node.isArrayCamera) return 'ArrayCamera';\r\n        if (node.isCubeCamera) return 'CubeCamera';\r\n        return 'Camera';\r\n    }\r\n    \r\n    // Check by constructor name\r\n    const className = node.constructor.name;\r\n    if (className === 'Object3D') return 'Object3D';\r\n    \r\n    return className || 'Unknown';\r\n}\r\n\r\n/**\r\n * Collect material data\r\n */\r\nfunction collectMaterialData(material) {\r\n    const data = {\r\n        id: material.uuid,\r\n        name: material.name || 'Unnamed Material',\r\n        type: material.type,\r\n        className: material.constructor.name,\r\n        // Common properties\r\n        visible: material.visible,\r\n        transparent: material.transparent,\r\n        opacity: material.opacity,\r\n        side: material.side,\r\n        blending: material.blending,\r\n        depthTest: material.depthTest,\r\n        depthWrite: material.depthWrite,\r\n        wireframe: material.wireframe,\r\n        vertexColors: material.vertexColors,\r\n        fog: material.fog,\r\n        // Color properties\r\n        color: material.color ? material.color.getHex() : null,\r\n        emissive: material.emissive ? material.emissive.getHex() : null,\r\n        emissiveIntensity: material.emissiveIntensity,\r\n        // PBR properties\r\n        metalness: material.metalness,\r\n        roughness: material.roughness,\r\n        // Standard properties\r\n        shininess: material.shininess,\r\n        specular: material.specular ? material.specular.getHex() : null,\r\n        // Maps\r\n        map: material.map ? material.map.uuid : null,\r\n        normalMap: material.normalMap ? material.normalMap.uuid : null,\r\n        roughnessMap: material.roughnessMap ? material.roughnessMap.uuid : null,\r\n        metalnessMap: material.metalnessMap ? material.metalnessMap.uuid : null,\r\n        emissiveMap: material.emissiveMap ? material.emissiveMap.uuid : null,\r\n        aoMap: material.aoMap ? material.aoMap.uuid : null,\r\n        bumpMap: material.bumpMap ? material.bumpMap.uuid : null,\r\n        displacementMap: material.displacementMap ? material.displacementMap.uuid : null,\r\n        alphaMap: material.alphaMap ? material.alphaMap.uuid : null,\r\n        envMap: material.envMap ? material.envMap.uuid : null,\r\n        lightMap: material.lightMap ? material.lightMap.uuid : null,\r\n        // Additional settings\r\n        alphaTest: material.alphaTest,\r\n        alphaToCoverage: material.alphaToCoverage,\r\n        userData: JSON.parse(JSON.stringify(material.userData || {}))\r\n    };\r\n    \r\n    // Shader-specific properties\r\n    if (material.isShaderMaterial) {\r\n        data.shaderInfo = {\r\n            uniforms: Object.keys(material.uniforms || {}),\r\n            vertexShader: material.vertexShader ? 'Custom' : 'Default',\r\n            fragmentShader: material.fragmentShader ? 'Custom' : 'Default'\r\n        };\r\n    }\r\n    \r\n    return data;\r\n}\r\n\r\n/**\r\n * Collect texture data from materials - FIXED VERSION\r\n */\r\nfunction collectTexturesFromMaterial(material, textureMap) {\r\n    const textureProperties = [\r\n        'map', 'normalMap', 'roughnessMap', 'metalnessMap', \r\n        'emissiveMap', 'aoMap', 'bumpMap', 'displacementMap',\r\n        'alphaMap', 'envMap', 'lightMap', 'specularMap',\r\n        'gradientMap', 'clearcoatMap', 'clearcoatNormalMap',\r\n        'clearcoatRoughnessMap'\r\n    ];\r\n    \r\n    console.log(`[SceneDataCollector] Checking material ${material.name} for textures`);\r\n    \r\n    textureProperties.forEach(prop => {\r\n        if (prop in material) {\r\n            const texture = material[prop];\r\n            console.log(`[SceneDataCollector] Material.${prop}:`, {\r\n                exists: !!texture,\r\n                value: texture,\r\n                isTexture: texture ? texture.isTexture : 'N/A',\r\n                type: texture ? typeof texture : 'N/A',\r\n                constructor: texture ? texture.constructor.name : 'N/A'\r\n            });\r\n            \r\n            if (texture) {\r\n                try {\r\n                    // Store texture with complete information\r\n                    const textureData = {\r\n                        id: textureId,  // Use the generated or existing ID\r\n                        uuid: textureId, // Also set uuid to the same value\r\n                        name: texture.name || `${material.name || 'Material'} - ${prop}`,\r\n                        type: prop,  // This should be the property name, not the texture.type\r\n                        materialName: material.name || 'Unnamed Material',\r\n                        className: texture.constructor.name,\r\n                        image: null,  // Initialize as null\r\n                        // Wrapping - with safe defaults\r\n                        wrapS: texture.wrapS || 1001,\r\n                        wrapT: texture.wrapT || 1001,\r\n                        // Safely access repeat, offset, center with defaults\r\n                        repeat: texture.repeat ? { \r\n                            x: texture.repeat.x || 1, \r\n                            y: texture.repeat.y || 1 \r\n                        } : { x: 1, y: 1 },\r\n                        offset: texture.offset ? { \r\n                            x: texture.offset.x || 0, \r\n                            y: texture.offset.y || 0 \r\n                        } : { x: 0, y: 0 },\r\n                        center: texture.center ? { \r\n                            x: texture.center.x || 0, \r\n                            y: texture.center.y || 0 \r\n                        } : { x: 0, y: 0 },\r\n                        rotation: texture.rotation || 0,\r\n                        // Filtering\r\n                        magFilter: texture.magFilter || 1006,\r\n                        minFilter: texture.minFilter || 1008,\r\n                        anisotropy: texture.anisotropy || 1,\r\n                        // Format\r\n                        format: texture.format || 1023,\r\n                        type: texture.type || 1009,  // This is the data type, keep it separate\r\n                        dataType: texture.type || 1009,  // Store as dataType to avoid confusion\r\n                        encoding: texture.encoding || 3000,\r\n                        // Mipmaps\r\n                        generateMipmaps: texture.generateMipmaps !== undefined ? texture.generateMipmaps : true,\r\n                        flipY: texture.flipY !== undefined ? texture.flipY : true,\r\n                        userData: JSON.parse(JSON.stringify(texture.userData || {}))\r\n                    };\r\n                    \r\n                    // Check if texture has image data and capture dimensions\r\n                    if (texture.image) {\r\n                        textureData.image = {\r\n                            width: texture.image.width || 0,\r\n                            height: texture.image.height || 0,\r\n                            src: texture.image.src || (texture.image.data ? 'data' : 'embedded'),\r\n                            hasData: true\r\n                        };\r\n                        \r\n                        console.log(`[SceneDataCollector] Texture ${prop} has image:`, \r\n                            `${textureData.image.width}x${textureData.image.height}`);\r\n                    }\r\n                    \r\n                    // Store the actual texture reference for later retrieval\r\n                    textureData._textureRef = texture;  // Store reference (won't be serialized)\r\n                    \r\n                    textureMap.set(textureId, textureData);\r\n                    \r\n                    console.log(`[SceneDataCollector] Added texture: ${textureData.name} (ID: ${textureData.id})`);\r\n                    \r\n                } catch (err) {\r\n                    console.warn(`[SceneDataCollector] Error collecting texture ${prop}:`, err);\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Collect geometry data\r\n */\r\nfunction collectGeometryData(geometry) {\r\n    const attributes = {};\r\n    \r\n    // Collect attribute information\r\n    for (const key in geometry.attributes) {\r\n        const attr = geometry.attributes[key];\r\n        attributes[key] = {\r\n            count: attr.count,\r\n            itemSize: attr.itemSize,\r\n            normalized: attr.normalized,\r\n            array: attr.array.constructor.name\r\n        };\r\n    }\r\n    \r\n    return {\r\n        id: geometry.uuid,\r\n        name: geometry.name || 'Unnamed Geometry',\r\n        type: geometry.type,\r\n        className: geometry.constructor.name,\r\n        attributes: attributes,\r\n        index: geometry.index ? {\r\n            count: geometry.index.count,\r\n            type: geometry.index.array.constructor.name\r\n        } : null,\r\n        groups: geometry.groups,\r\n        morphAttributes: Object.keys(geometry.morphAttributes || {}),\r\n        morphTargetsRelative: geometry.morphTargetsRelative,\r\n        boundingBox: geometry.boundingBox ? {\r\n            min: { ...geometry.boundingBox.min },\r\n            max: { ...geometry.boundingBox.max }\r\n        } : null,\r\n        boundingSphere: geometry.boundingSphere ? {\r\n            center: { ...geometry.boundingSphere.center },\r\n            radius: geometry.boundingSphere.radius\r\n        } : null,\r\n        drawRange: {\r\n            start: geometry.drawRange.start,\r\n            count: geometry.drawRange.count\r\n        },\r\n        userData: JSON.parse(JSON.stringify(geometry.userData || {}))\r\n    };\r\n}\r\n\r\n/**\r\n * Collect skeleton data\r\n */\r\nfunction collectSkeletonData(skeleton) {\r\n    return {\r\n        id: skeleton.uuid,\r\n        name: skeleton.name || 'Skeleton',\r\n        bones: skeleton.bones.map(bone => ({\r\n            id: bone.uuid,\r\n            name: bone.name || 'Bone',\r\n            type: 'Bone',\r\n            position: { x: bone.position.x, y: bone.position.y, z: bone.position.z },\r\n            rotation: { \r\n                x: bone.rotation.x * 180 / Math.PI, \r\n                y: bone.rotation.y * 180 / Math.PI, \r\n                z: bone.rotation.z * 180 / Math.PI,\r\n                order: bone.rotation.order\r\n            },\r\n            scale: { x: bone.scale.x, y: bone.scale.y, z: bone.scale.z },\r\n            parent: bone.parent ? bone.parent.name : null,\r\n            children: bone.children.map(c => c.name)\r\n        })),\r\n        boneInverses: skeleton.boneInverses.length,\r\n        boneMatrices: skeleton.boneMatrices ? skeleton.boneMatrices.length / 16 : 0, // 16 values per 4x4 matrix\r\n        userData: JSON.parse(JSON.stringify(skeleton.userData || {}))\r\n    };\r\n}\r\n\r\n/**\r\n * Collect animation data\r\n */\r\nfunction collectAnimations(animations) {\r\n    return animations.map(animation => ({\r\n        id: animation.uuid,\r\n        name: animation.name || 'Animation',\r\n        duration: animation.duration,\r\n        blendMode: animation.blendMode,\r\n        tracks: animation.tracks.map(track => ({\r\n            name: track.name,\r\n            type: track.constructor.name,\r\n            times: track.times.length,\r\n            values: track.values.length,\r\n            interpolation: track.getInterpolation ? track.getInterpolation() : 'linear',\r\n            // Parse track name to get target info\r\n            targetNode: track.name.split('.')[0],\r\n            targetProperty: track.name.split('.').slice(1).join('.')\r\n        })),\r\n        userData: JSON.parse(JSON.stringify(animation.userData || {}))\r\n    }));\r\n}\r\n\r\n/**\r\n * Collect light data\r\n */\r\nfunction collectLightData(light) {\r\n    const data = {\r\n        id: light.uuid,\r\n        name: light.name || 'Light',\r\n        type: getNodeType(light),\r\n        className: light.constructor.name,\r\n        color: light.color.getHex(),\r\n        intensity: light.intensity,\r\n        visible: light.visible,\r\n        castShadow: light.castShadow,\r\n        position: { x: light.position.x, y: light.position.y, z: light.position.z },\r\n        layers: light.layers.mask\r\n    };\r\n    \r\n    // Add type-specific properties\r\n    if (light.isDirectionalLight) {\r\n        data.target = light.target ? {\r\n            position: { \r\n                x: light.target.position.x, \r\n                y: light.target.position.y, \r\n                z: light.target.position.z \r\n            }\r\n        } : null;\r\n        data.shadow = collectShadowData(light.shadow);\r\n    }\r\n    \r\n    if (light.isSpotLight) {\r\n        data.angle = light.angle;\r\n        data.penumbra = light.penumbra;\r\n        data.decay = light.decay;\r\n        data.distance = light.distance;\r\n        data.target = light.target ? {\r\n            position: { \r\n                x: light.target.position.x, \r\n                y: light.target.position.y, \r\n                z: light.target.position.z \r\n            }\r\n        } : null;\r\n        data.shadow = collectShadowData(light.shadow);\r\n    }\r\n    \r\n    if (light.isPointLight) {\r\n        data.decay = light.decay;\r\n        data.distance = light.distance;\r\n        data.shadow = collectShadowData(light.shadow);\r\n    }\r\n    \r\n    if (light.isHemisphereLight) {\r\n        data.groundColor = light.groundColor ? light.groundColor.getHex() : null;\r\n    }\r\n    \r\n    if (light.isRectAreaLight) {\r\n        data.width = light.width;\r\n        data.height = light.height;\r\n    }\r\n    \r\n    return data;\r\n}\r\n\r\n/**\r\n * Collect light info for node\r\n */\r\nfunction collectLightInfo(light) {\r\n    return {\r\n        color: light.color ? light.color.getHex() : 0xffffff,\r\n        intensity: light.intensity,\r\n        castShadow: light.castShadow,\r\n        type: getNodeType(light)\r\n    };\r\n}\r\n\r\n/**\r\n * Collect shadow data\r\n */\r\nfunction collectShadowData(shadow) {\r\n    if (!shadow) return null;\r\n    \r\n    return {\r\n        enabled: shadow.enabled !== undefined ? shadow.enabled : true,\r\n        mapSize: {\r\n            width: shadow.mapSize.width,\r\n            height: shadow.mapSize.height\r\n        },\r\n        camera: {\r\n            near: shadow.camera.near,\r\n            far: shadow.camera.far\r\n        },\r\n        bias: shadow.bias,\r\n        normalBias: shadow.normalBias,\r\n        radius: shadow.radius,\r\n        blurSamples: shadow.blurSamples\r\n    };\r\n}\r\n\r\n/**\r\n * Collect camera data\r\n */\r\nfunction collectCameraData(camera) {\r\n    const data = {\r\n        id: camera.uuid,\r\n        name: camera.name || 'Camera',\r\n        type: getNodeType(camera),\r\n        className: camera.constructor.name,\r\n        position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },\r\n        rotation: { \r\n            x: camera.rotation.x * 180 / Math.PI, \r\n            y: camera.rotation.y * 180 / Math.PI, \r\n            z: camera.rotation.z * 180 / Math.PI,\r\n            order: camera.rotation.order\r\n        },\r\n        layers: camera.layers.mask\r\n    };\r\n    \r\n    if (camera.isPerspectiveCamera) {\r\n        data.fov = camera.fov;\r\n        data.aspect = camera.aspect;\r\n        data.near = camera.near;\r\n        data.far = camera.far;\r\n        data.zoom = camera.zoom;\r\n        data.filmGauge = camera.filmGauge;\r\n        data.filmOffset = camera.filmOffset;\r\n        data.focus = camera.focus;\r\n    }\r\n    \r\n    if (camera.isOrthographicCamera) {\r\n        data.left = camera.left;\r\n        data.right = camera.right;\r\n        data.top = camera.top;\r\n        data.bottom = camera.bottom;\r\n        data.near = camera.near;\r\n        data.far = camera.far;\r\n        data.zoom = camera.zoom;\r\n    }\r\n    \r\n    return data;\r\n}\r\n\r\n/**\r\n * Collect camera info for node\r\n */\r\nfunction collectCameraInfo(camera) {\r\n    const info = {\r\n        type: getNodeType(camera)\r\n    };\r\n    \r\n    if (camera.isPerspectiveCamera) {\r\n        info.fov = camera.fov;\r\n        info.aspect = camera.aspect;\r\n        info.near = camera.near;\r\n        info.far = camera.far;\r\n    }\r\n    \r\n    if (camera.isOrthographicCamera) {\r\n        info.left = camera.left;\r\n        info.right = camera.right;\r\n        info.top = camera.top;\r\n        info.bottom = camera.bottom;\r\n        info.near = camera.near;\r\n        info.far = camera.far;\r\n    }\r\n    \r\n    return info;\r\n}\r\n\r\n/**\r\n * Calculate total vertices from all geometries\r\n */\r\nfunction calculateTotalVertices(geometries) {\r\n    let total = 0;\r\n    geometries.forEach(geo => {\r\n        if (geo.attributes && geo.attributes.position) {\r\n            total += geo.attributes.position.count;\r\n        }\r\n    });\r\n    return total;\r\n}\r\n\r\n/**\r\n * Calculate total triangles from all geometries\r\n */\r\nfunction calculateTotalTriangles(geometries) {\r\n    let total = 0;\r\n    geometries.forEach(geo => {\r\n        if (geo.index) {\r\n            total += geo.index.count / 3;\r\n        } else if (geo.attributes && geo.attributes.position) {\r\n            total += geo.attributes.position.count / 3;\r\n        }\r\n    });\r\n    return Math.floor(total);\r\n}\r\n\r\n/**\r\n * Count total nodes in hierarchy\r\n */\r\nfunction countNodes(node) {\r\n    if (!node) return 0;\r\n    let count = 1;\r\n    if (node.children) {\r\n        node.children.forEach(child => {\r\n            count += countNodes(child);\r\n        });\r\n    }\r\n    return count;\r\n}\r\n\r\n// Export functions for use in worker\r\nif (typeof self !== 'undefined') {\r\n    self.SceneDataCollector = {\r\n        setLoadedGLTF,\r\n        collectSceneData\r\n    };\r\n}",
        "viewportGizmo": "/* FILE: editor/z3d-object-editor/templates/scripts/workers/viewport-gizmo.js */\r\n/* Viewport Gizmo - Navigation cube for quick camera orientation */\r\n\r\nclass ViewportGizmo {\r\n    constructor() {\r\n        this.gizmoCanvas = null;\r\n        this.gizmoRenderer = null;\r\n        this.gizmoScene = null;\r\n        this.gizmoCamera = null;\r\n        this.gizmoGroup = null;\r\n        this.hoveredFace = null;\r\n        this.isDragging = false;\r\n        \r\n        // Face definitions for cube - C3 coordinate system (Z-up)\r\n        this.faces = {\r\n            front: { normal: [0, -1, 0], label: 'Front', color: 0x4CAF50 },\r\n            back: { normal: [0, 1, 0], label: 'Back', color: 0x2196F3 },\r\n            left: { normal: [-1, 0, 0], label: 'Left', color: 0xFF9800 },\r\n            right: { normal: [1, 0, 0], label: 'Right', color: 0xE91E63 },\r\n            top: { normal: [0, 0, 1], label: 'Top', color: 0x9C27B0 },\r\n            bottom: { normal: [0, 0, -1], label: 'Bottom', color: 0x795548 }\r\n        };\r\n        \r\n        // Corner positions for isometric views - C3 coordinate system (Z-up)\r\n        this.corners = {\r\n            frontTopRight: { position: [1, -1, 1], label: 'ISO 1' },\r\n            frontTopLeft: { position: [-1, -1, 1], label: 'ISO 2' },\r\n            backTopRight: { position: [1, 1, 1], label: 'ISO 3' },\r\n            backTopLeft: { position: [-1, 1, 1], label: 'ISO 4' }\r\n        };\r\n    }\r\n    \r\n    initialize(parentScene, parentCamera, parentRenderer) {\r\n        console.log('[ViewportGizmo] Initializing viewport gizmo as overlay...');\r\n        \r\n        // Store parent references\r\n        this.parentCamera = parentCamera;\r\n        \r\n        // Create offscreen canvas for gizmo rendering\r\n        if (typeof OffscreenCanvas !== 'undefined') {\r\n            this.gizmoCanvas = new OffscreenCanvas(196, 196);\r\n        } else {\r\n            console.warn('[ViewportGizmo] OffscreenCanvas not available, gizmo will not render');\r\n            return;\r\n        }\r\n        \r\n        // Setup gizmo's own Three.js scene\r\n        this.setupGizmoScene();\r\n        \r\n        console.log('[ViewportGizmo] \u2705 Viewport gizmo initialized (worker-side)');\r\n        \r\n        // Notify main thread to create UI overlay\r\n        self.postMessage({\r\n            type: 'VIEWPORT_GIZMO_READY',\r\n            data: { ready: true }\r\n        });\r\n    }\r\n    \r\n    setupGizmoScene() {\r\n        // Create renderer for offscreen canvas\r\n        this.gizmoRenderer = new THREE.WebGLRenderer({\r\n            canvas: this.gizmoCanvas,\r\n            alpha: true,\r\n            antialias: true\r\n        });\r\n        this.gizmoRenderer.setSize(240, 240);\r\n        this.gizmoRenderer.setClearColor(0x000000, 0);\r\n        \r\n        // Create scene\r\n        this.gizmoScene = new THREE.Scene();\r\n        \r\n        // Create camera - will be synced with main camera\r\n        this.gizmoCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);\r\n        this.gizmoCamera.position.set(5, 5, 5);\r\n        this.gizmoCamera.up.set(0, 0, 1); // Z-up for C3 coordinate system\r\n        this.gizmoCamera.lookAt(0, 0, 0);\r\n        \r\n        // Create gizmo group\r\n        this.gizmoGroup = new THREE.Group();\r\n        this.gizmoScene.add(this.gizmoGroup);\r\n        \r\n        // Create cube faces\r\n        this.createCubeFaces();\r\n        \r\n        // Create corner spheres for isometric views\r\n        this.createCornerSpheres();\r\n        \r\n        // Create axes\r\n        this.createAxes();\r\n        \r\n        // Add lighting\r\n        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);\r\n        this.gizmoScene.add(ambientLight);\r\n        \r\n        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);\r\n        directionalLight.position.set(5, -5, 5);\r\n        this.gizmoScene.add(directionalLight);\r\n    }\r\n    \r\n    createCubeFaces() {\r\n        const faceSize = 0.8;\r\n        const faceGeometry = new THREE.BoxGeometry(faceSize, 0.05, faceSize);\r\n        \r\n        Object.entries(this.faces).forEach(([key, face]) => {\r\n            const material = new THREE.MeshPhongMaterial({\r\n                color: face.color,\r\n                opacity: 0.8,\r\n                transparent: true,\r\n                emissive: face.color,\r\n                emissiveIntensity: 0.2\r\n            });\r\n            \r\n            const mesh = new THREE.Mesh(faceGeometry, material);\r\n            mesh.userData = { type: 'face', faceKey: key, ...face };\r\n            \r\n            // Position based on normal\r\n            if (face.normal[0] !== 0) {\r\n                mesh.rotation.z = Math.PI / 2;\r\n                mesh.position.x = face.normal[0] * 0.5;\r\n            } else if (face.normal[1] !== 0) {\r\n                mesh.position.y = face.normal[1] * 0.5;\r\n            } else if (face.normal[2] !== 0) {\r\n                mesh.rotation.x = Math.PI / 2;\r\n                mesh.position.z = face.normal[2] * 0.5;\r\n            }\r\n            \r\n            this.gizmoGroup.add(mesh);\r\n        });\r\n    }\r\n    \r\n    createCornerSpheres() {\r\n        const sphereGeometry = new THREE.SphereGeometry(0.12, 16, 16);\r\n        \r\n        Object.entries(this.corners).forEach(([key, corner]) => {\r\n            const material = new THREE.MeshPhongMaterial({\r\n                color: 0xFFD700,\r\n                emissive: 0xFFD700,\r\n                emissiveIntensity: 0.3\r\n            });\r\n            \r\n            const mesh = new THREE.Mesh(sphereGeometry, material);\r\n            mesh.userData = { type: 'corner', cornerKey: key, ...corner };\r\n            \r\n            // Normalize position\r\n            const pos = new THREE.Vector3(...corner.position).normalize().multiplyScalar(0.7);\r\n            mesh.position.copy(pos);\r\n            \r\n            this.gizmoGroup.add(mesh);\r\n        });\r\n    }\r\n    \r\n    createAxes() {\r\n        const axisLength = 1.2;\r\n        const axisRadius = 0.02;\r\n        \r\n        // X axis - Red\r\n        const xGeometry = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8);\r\n        const xMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });\r\n        const xAxis = new THREE.Mesh(xGeometry, xMaterial);\r\n        xAxis.rotation.z = -Math.PI / 2;\r\n        xAxis.position.x = axisLength / 2;\r\n        this.gizmoGroup.add(xAxis);\r\n        \r\n        // Y axis - Green (negative for C3)\r\n        const yGeometry = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8);\r\n        const yMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\r\n        const yAxis = new THREE.Mesh(yGeometry, yMaterial);\r\n        yAxis.position.y = -axisLength / 2;\r\n        this.gizmoGroup.add(yAxis);\r\n        \r\n        // Z axis - Blue\r\n        const zGeometry = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8);\r\n        const zMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });\r\n        const zAxis = new THREE.Mesh(zGeometry, zMaterial);\r\n        zAxis.rotation.x = Math.PI / 2;\r\n        zAxis.position.z = axisLength / 2;\r\n        this.gizmoGroup.add(zAxis);\r\n        \r\n        // Add axis labels\r\n        this.createAxisLabels();\r\n    }\r\n    \r\n    createAxisLabels() {\r\n        // Create sprite labels for axes\r\n        const createLabel = (text, color, position) => {\r\n            const canvas = new OffscreenCanvas(64, 64);\r\n            const ctx = canvas.getContext('2d');\r\n            \r\n            ctx.fillStyle = color;\r\n            ctx.font = 'bold 48px Arial';\r\n            ctx.textAlign = 'center';\r\n            ctx.textBaseline = 'middle';\r\n            ctx.fillText(text, 32, 32);\r\n            \r\n            const texture = new THREE.CanvasTexture(canvas);\r\n            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });\r\n            const sprite = new THREE.Sprite(spriteMaterial);\r\n            sprite.scale.set(0.3, 0.3, 1);\r\n            sprite.position.copy(position);\r\n            \r\n            return sprite;\r\n        };\r\n        \r\n        this.gizmoGroup.add(createLabel('X', '#ff0000', new THREE.Vector3(1.5, 0, 0)));\r\n        this.gizmoGroup.add(createLabel('Y', '#00ff00', new THREE.Vector3(0, -1.5, 0)));\r\n        this.gizmoGroup.add(createLabel('Z', '#0000ff', new THREE.Vector3(0, 0, 1.5)));\r\n    }\r\n    \r\n    // Handle mouse events from main thread\r\n    handleMouseEvent(eventType, data) {\r\n        if (!this.gizmoScene || !this.gizmoCamera) return;\r\n        \r\n        const raycaster = new THREE.Raycaster();\r\n        const mouse = new THREE.Vector2(data.x, data.y);\r\n        \r\n        raycaster.setFromCamera(mouse, this.gizmoCamera);\r\n        const intersects = raycaster.intersectObjects(this.gizmoGroup.children);\r\n        \r\n        switch (eventType) {\r\n            case 'mousemove':\r\n                this.handleHover(intersects);\r\n                break;\r\n            case 'click':\r\n                this.handleClick(intersects);\r\n                break;\r\n            case 'mousedown':\r\n                if (!intersects.length) {\r\n                    this.isDragging = true;\r\n                }\r\n                break;\r\n            case 'mouseup':\r\n                this.isDragging = false;\r\n                break;\r\n            case 'drag':\r\n                if (this.isDragging) {\r\n                    this.gizmoGroup.rotation.z += data.deltaX * 0.01;\r\n                    this.gizmoGroup.rotation.x += data.deltaY * 0.01;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    \r\n    handleHover(intersects) {\r\n        // Reset all materials\r\n        this.gizmoGroup.children.forEach(child => {\r\n            if (child.material && child.material.emissiveIntensity !== undefined) {\r\n                child.material.emissiveIntensity = child.userData.type === 'corner' ? 0.3 : 0.2;\r\n            }\r\n        });\r\n        \r\n        // Highlight hovered object\r\n        if (intersects.length > 0) {\r\n            const object = intersects[0].object;\r\n            if (object.material && object.material.emissiveIntensity !== undefined) {\r\n                object.material.emissiveIntensity = 0.6;\r\n            }\r\n            this.hoveredFace = object.userData;\r\n            \r\n            // Notify main thread\r\n            self.postMessage({\r\n                type: 'VIEWPORT_GIZMO_HOVER',\r\n                data: { hovering: true, face: this.hoveredFace }\r\n            });\r\n        } else {\r\n            this.hoveredFace = null;\r\n            self.postMessage({\r\n                type: 'VIEWPORT_GIZMO_HOVER',\r\n                data: { hovering: false }\r\n            });\r\n        }\r\n    }\r\n    \r\n    handleClick(intersects) {\r\n        if (intersects.length > 0 && !this.isDragging) {\r\n            const object = intersects[0].object;\r\n            const clickedItem = object.userData;\r\n            \r\n            if (clickedItem.type === 'face') {\r\n                this.animateCameraToFace(clickedItem);\r\n            } else if (clickedItem.type === 'corner') {\r\n                this.animateCameraToCorner(clickedItem);\r\n            }\r\n        }\r\n    }\r\n    \r\n    animateCameraToFace(face) {\r\n        console.log(`[ViewportGizmo] Animating to ${face.label} view`);\r\n        \r\n        // Calculate target position based on face normal\r\n        const distance = 10;\r\n        const normal = new THREE.Vector3(...face.normal);\r\n        const targetPosition = normal.multiplyScalar(distance);\r\n        \r\n        // Send camera animation request (target will be preserved from current orbitTarget)\r\n        self.postMessage({\r\n            type: 'CAMERA_ANIMATE_TO',\r\n            data: {\r\n                position: targetPosition.toArray(),\r\n                // Don't specify target to use current orbit target\r\n                duration: 500,\r\n                viewName: face.label\r\n            }\r\n        });\r\n    }\r\n    \r\n    animateCameraToCorner(corner) {\r\n        console.log(`[ViewportGizmo] Animating to ${corner.label} view`);\r\n        \r\n        // Calculate isometric camera position\r\n        const distance = 10;\r\n        const pos = new THREE.Vector3(...corner.position).normalize().multiplyScalar(distance);\r\n        \r\n        self.postMessage({\r\n            type: 'CAMERA_ANIMATE_TO',\r\n            data: {\r\n                position: pos.toArray(),\r\n                // Don't specify target to use current orbit target\r\n                duration: 500,\r\n                viewName: corner.label\r\n            }\r\n        });\r\n    }\r\n    \r\n    update(parentCameraQuaternion) {\r\n        if (!this.gizmoGroup || !this.gizmoRenderer || !this.gizmoCamera) return;\r\n        \r\n        // Sync gizmo camera with main camera orientation\r\n        if (parentCameraQuaternion && this.parentCamera) {\r\n            // Copy the main camera's position relative to its target\r\n            const mainCameraDir = this.parentCamera.position.clone().normalize();\r\n            const distance = 5; // Fixed distance for gizmo camera\r\n            \r\n            // Set gizmo camera to match main camera's viewing angle\r\n            this.gizmoCamera.position.copy(mainCameraDir.multiplyScalar(distance));\r\n            this.gizmoCamera.up.copy(this.parentCamera.up);\r\n            this.gizmoCamera.lookAt(0, 0, 0);\r\n            \r\n            // Don't rotate the gizmo group - keep it aligned with world axes\r\n            this.gizmoGroup.quaternion.identity();\r\n        }\r\n        \r\n        // Render gizmo to offscreen canvas\r\n        if (this.gizmoRenderer && this.gizmoScene && this.gizmoCamera) {\r\n            this.gizmoRenderer.render(this.gizmoScene, this.gizmoCamera);\r\n            \r\n            // Get image data and send to main thread\r\n            if (this.gizmoCanvas && typeof this.gizmoCanvas.convertToBlob === 'function') {\r\n                // For browsers that support convertToBlob on OffscreenCanvas\r\n                // We'll render at a lower framerate to avoid overwhelming the message channel\r\n                if (!this._lastRenderTime || Date.now() - this._lastRenderTime > 33) { // ~30fps\r\n                    this._lastRenderTime = Date.now();\r\n                    \r\n                    // Instead of sending blob, we'll just notify that rendering is done\r\n                    // The main thread will handle its own rendering\r\n                    self.postMessage({\r\n                        type: 'VIEWPORT_GIZMO_UPDATED',\r\n                        data: { timestamp: Date.now() }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    dispose() {\r\n        if (this.gizmoRenderer) {\r\n            this.gizmoRenderer.dispose();\r\n        }\r\n        \r\n        // Dispose geometries and materials\r\n        this.gizmoGroup?.traverse((child) => {\r\n            if (child.geometry) child.geometry.dispose();\r\n            if (child.material) {\r\n                if (Array.isArray(child.material)) {\r\n                    child.material.forEach(mat => mat.dispose());\r\n                } else {\r\n                    child.material.dispose();\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n// Export for worker use\r\nif (typeof self !== 'undefined') {\r\n    self.ViewportGizmo = ViewportGizmo;\r\n}",
        "transformGizmo": "/* FILE: editor/z3d-object-editor/templates/scripts/workers/transform-gizmo.js */\r\n/* Transform Gizmo - Combined position, rotation, and scale controls */\r\n\r\nclass TransformGizmo {\r\n    constructor() {\r\n        this.gizmoGroup = null;\r\n        this.activeHandle = null;\r\n        this.isDragging = false;\r\n        this.hoveredHandle = null;\r\n        this.transformMode = 'all';\r\n        this.transformSpace = 'world';\r\n        \r\n        // Gizmo components\r\n        this.positionGizmo = null;\r\n        this.rotationGizmo = null;\r\n        this.scaleGizmo = null;\r\n        this.uniformScaleGizmo = null;\r\n        \r\n        // Rotation feedback visuals\r\n        this.rotationFeedbackGroup = null;\r\n        this.rotationStartLine = null;\r\n        this.rotationCurrentLine = null;\r\n        this.rotationPie = null;\r\n        \r\n        // Scale feedback visuals\r\n        this.scaleFeedbackGroup = null;\r\n        this.scaleFeedbackLine = null;\r\n        this.scalePlaceholderBox = null;\r\n        this.scaleInitialBoxPosition = null;\r\n        this.scaleInitialScale = null;\r\n        this.scaleClickDistance = null;\r\n        this.originalScaleBox = null;\r\n        \r\n        // Interaction state\r\n        this.dragStart = new THREE.Vector2();\r\n        this.dragCurrent = new THREE.Vector2();\r\n        this.initialTransform = {};\r\n        this.raycaster = new THREE.Raycaster();\r\n    this.positionDragStartWorld = null;\r\n        \r\n        // Rotation specific state\r\n        this.rotationStartAngle = 0;\r\n        this.rotationCurrentAngle = 0;\r\n        this.rotationAxis = null;\r\n        this.rotationPlane = null;\r\n        \r\n        // Visual settings - DOUBLED SIZE\r\n        this.colors = {\r\n            x: 0xff0000,\r\n            y: 0x00ff00,\r\n            z: 0x0000ff,\r\n            uniform: 0xffff00,\r\n            hover: 0xffffff,\r\n            inactive: 0x808080,\r\n            rotationFeedback: 0xffff00,\r\n            scaleFeedback: 0x00ffff\r\n        };\r\n        \r\n        // Optimized handle sizes - 20% larger than previous, thicker for easier selection\r\n        this.handleSize = {\r\n            position: 2.16,      // Increased by 20% from 1.8\r\n            rotation: 2.59,      // Increased by 20% from 2.16\r\n            scale: 0.22,         // Increased by 20% from 0.18\r\n            uniformScale: 0.36,  // Increased by 20% from 0.3\r\n            shaftThickness: 0.04,   // Significantly thicker for easier selection\r\n            coneSize: 0.12,      // Increased by 20% from 0.096\r\n            coneHeight: 0.29     // Increased by 20% from 0.24\r\n        };\r\n        \r\n        // Raycaster threshold for better picking\r\n        this.raycaster.params.Line = { threshold: 0.1 };\r\n\r\n        // Add position tracking for delta calculation\r\n        this.dragStartPosition = null;\r\n        this.dragEndPosition = null;\r\n\r\n        // Overlay (HUD) support\r\n        this.overlay = {\r\n            scene: null,\r\n            camera: null,\r\n            getViewportSize: null,\r\n            root: null,\r\n            group: null, // container for gizmo overlay visuals\r\n        };\r\n\r\n        // Delta label data\r\n        this.deltaLabelData = null;\r\n\r\n        // Unit conversion (C3 uses 64 pixels per world unit)\r\n        this.pixelsPerUnit = 64;\r\n\r\n        // Snap configuration (managed by worker via setSnapConfig)\r\n        this.snap = {\r\n            enabled: false,\r\n            angleDeg: 5,\r\n            snapScale: 0.1,\r\n            localGridCellPx: 32,\r\n            unitsPerCell: 1, // updated by worker using unit scale conversion\r\n            origin: new THREE.Vector3(0, 0, 0) // anchor for grid snapping in world space\r\n        };\r\n    }\r\n    \r\n    initialize(scene, camera, targetObject) {\r\n        console.log('[TransformGizmo] Initializing transform gizmo...');\r\n        \r\n        // Clean up any existing gizmos first\r\n        if (this.gizmoGroup && this.scene) {\r\n            this.dispose();\r\n        }\r\n        \r\n        this.scene = scene;\r\n        this.camera = camera;\r\n        this.targetObject = targetObject;\r\n        \r\n        // Create main gizmo group\r\n        this.gizmoGroup = new THREE.Group();\r\n        this.gizmoGroup.name = 'TransformGizmo';\r\n        \r\n        // Create rotation feedback group (separate for cleaner management)\r\n        this.rotationFeedbackGroup = new THREE.Group();\r\n        this.rotationFeedbackGroup.name = 'RotationFeedback';\r\n        this.rotationFeedbackGroup.visible = false;\r\n        \r\n        // Create scale feedback group\r\n        this.scaleFeedbackGroup = new THREE.Group();\r\n        this.scaleFeedbackGroup.name = 'ScaleFeedback';\r\n        this.scaleFeedbackGroup.visible = false;\r\n        \r\n        // Create all gizmo components\r\n        this.createPositionGizmo();\r\n        this.createRotationGizmo();\r\n        this.createScaleGizmo();\r\n        this.createUniformScaleGizmo();\r\n        this.createRotationFeedbackVisuals();\r\n        this.createScaleFeedbackVisuals();\r\n        \r\n        // Initialize delta label (doesn't require overlay)\r\n        this.createDeltaLabel();\r\n        \r\n        // Add to scene\r\n        scene.add(this.gizmoGroup);\r\n        scene.add(this.rotationFeedbackGroup);\r\n        scene.add(this.scaleFeedbackGroup);\r\n        \r\n        // Setup interaction\r\n        this.setupInteraction();\r\n        \r\n        // Update initial position\r\n        this.updateGizmoTransform();\r\n        \r\n        console.log('[TransformGizmo] \u2705 Transform gizmo initialized');\r\n    }\r\n\r\n    // Attach an overlay scene/camera for HUD drawing\r\n    setOverlay(overlayScene, overlayCamera, getViewportSize, overlayRoot) {\r\n        console.log('[Gizmo] setOverlay called:', {\r\n            overlayScene: !!overlayScene,\r\n            overlayCamera: !!overlayCamera,\r\n            getViewportSize: !!getViewportSize,\r\n            overlayRoot: !!overlayRoot\r\n        });\r\n        \r\n        this.overlay.scene = overlayScene || null;\r\n        this.overlay.camera = overlayCamera || null;\r\n        this.overlay.getViewportSize = getViewportSize || null;\r\n        this.overlay.root = overlayRoot || null;\r\n\r\n        if (this.overlay.scene && !this.overlay.group) {\r\n            this.overlay.group = new THREE.Group();\r\n            this.overlay.group.name = 'TransformGizmoOverlay';\r\n            (this.overlay.root || this.overlay.scene).add(this.overlay.group);\r\n            console.log('[Gizmo] Overlay group created and added to scene');\r\n        }\r\n    // Keep 3D feedback visible; overlay will only draw dashed line\r\n    }\r\n    \r\n    createDeltaLabel() {\r\n        // Initialize delta label data for HTML rendering in topbar\r\n        this.deltaLabelData = { text: '', visible: false };\r\n    }\r\n    \r\n    updateDeltaLabel(mouse) {\r\n        // If called with null or isDragging is false, hide the label\r\n        if (!mouse || !this.isDragging) {\r\n            // Hide the label\r\n            if (this.deltaLabelData) {\r\n                this.deltaLabelData.visible = false;\r\n                self.postMessage({\r\n                    type: 'UPDATE_DELTA_LABEL',\r\n                    data: { visible: false }\r\n                });\r\n            }\r\n            return;\r\n        }\r\n        \r\n        // Calculate deltas based on transform type\r\n        let deltaText = '';\r\n        \r\n        if (this.activeHandle.type === 'position' && this.initialTransform) {\r\n            // Convert world units to pixels and flip Y for C3 coordinates\r\n            const dx = (this.targetObject.position.x - this.initialTransform.position.x) * this.pixelsPerUnit;\r\n            const dy = -(this.targetObject.position.y - this.initialTransform.position.y) * this.pixelsPerUnit;\r\n            const dz = (this.targetObject.position.z - this.initialTransform.position.z) * this.pixelsPerUnit;\r\n            deltaText = `Position: \u0394x: ${dx.toFixed(0)}px, \u0394y: ${dy.toFixed(0)}px, \u0394z: ${dz.toFixed(0)}px`;\r\n        } else if (this.activeHandle.type === 'rotation' && this.initialTransform) {\r\n            const dx = ((this.targetObject.rotation.x - this.initialTransform.rotation.x) * 180 / Math.PI).toFixed(1);\r\n            const dy = ((this.targetObject.rotation.y - this.initialTransform.rotation.y) * 180 / Math.PI).toFixed(1);\r\n            const dz = ((this.targetObject.rotation.z - this.initialTransform.rotation.z) * 180 / Math.PI).toFixed(1);\r\n            const axis = this.activeHandle.axis;\r\n            if (axis === 'x') deltaText = `Rotation X: ${dx}\xB0`;\r\n            else if (axis === 'y') deltaText = `Rotation Y: ${dy}\xB0`;\r\n            else if (axis === 'z') deltaText = `Rotation Z: ${dz}\xB0`;\r\n        } else if (this.activeHandle.type === 'scale') {\r\n            if (this.activeHandle.axis === 'uniform') {\r\n                const scale = (this.targetObject.userData?.scale || 1.0).toFixed(3);\r\n                deltaText = `Scale: ${scale}`;\r\n            } else {\r\n                const axis = this.activeHandle.axis;\r\n                const scale = this.targetObject.scale[axis].toFixed(3);\r\n                deltaText = `Scale ${axis.toUpperCase()}: ${scale}`;\r\n            }\r\n        }\r\n        \r\n        // Send label data to main thread\r\n        this.deltaLabelData = {\r\n            text: deltaText,\r\n            visible: true\r\n        };\r\n        \r\n        self.postMessage({\r\n            type: 'UPDATE_DELTA_LABEL',\r\n            data: this.deltaLabelData\r\n        });\r\n    }\r\n    \r\n    createRotationFeedbackVisuals() {\r\n        // Start reference line (solid) - shows initial drag position\r\n        const startLineGeometry = new THREE.BufferGeometry();\r\n        const startLineVertices = new Float32Array([\r\n            0, 0, 0,  // Origin\r\n            1, 0, 0   // Will be updated to actual position\r\n        ]);\r\n        startLineGeometry.setAttribute('position', new THREE.BufferAttribute(startLineVertices, 3));\r\n        \r\n        const startLineMaterial = new THREE.LineBasicMaterial({\r\n            color: this.colors.rotationFeedback,\r\n            linewidth: 2,\r\n            depthTest: false,\r\n            depthWrite: false,\r\n            transparent: true,\r\n            opacity: 0.8\r\n        });\r\n        \r\n        this.rotationStartLine = new THREE.Line(startLineGeometry, startLineMaterial);\r\n        this.rotationStartLine.name = 'RotationStartLine';\r\n        this.rotationFeedbackGroup.add(this.rotationStartLine);\r\n        \r\n        // Current position line to circle (solid) - shows current drag position on circle\r\n        const currentLineGeometry = new THREE.BufferGeometry();\r\n        const currentLineVertices = new Float32Array([\r\n            0, 0, 0,  // Origin\r\n            1, 0, 0   // Will be updated to circle edge\r\n        ]);\r\n        currentLineGeometry.setAttribute('position', new THREE.BufferAttribute(currentLineVertices, 3));\r\n        \r\n        const currentLineMaterial = new THREE.LineBasicMaterial({\r\n            color: this.colors.rotationFeedback,\r\n            linewidth: 2,\r\n            depthTest: false,\r\n            depthWrite: false,\r\n            transparent: true,\r\n            opacity: 0.8\r\n        });\r\n        \r\n        this.rotationCurrentLine = new THREE.Line(currentLineGeometry, currentLineMaterial);\r\n        this.rotationCurrentLine.name = 'RotationCurrentLine';\r\n        this.rotationFeedbackGroup.add(this.rotationCurrentLine);\r\n        \r\n        // Pie slice (will be created dynamically)\r\n        this.rotationPie = null;\r\n        \r\n        // Note: Mouse indicator removed - now handled entirely by HUD overlay\r\n    }\r\n    \r\n    createScaleFeedbackVisuals() {\r\n        // Scale feedback line - bright line showing stretch\r\n        const lineGeometry = new THREE.BufferGeometry();\r\n        const lineVertices = new Float32Array([\r\n            0, 0, 0,  // Start position\r\n            1, 0, 0   // End position (will be updated)\r\n        ]);\r\n        lineGeometry.setAttribute('position', new THREE.BufferAttribute(lineVertices, 3));\r\n        \r\n        // Material will be updated with axis color when scale starts\r\n        const lineMaterial = new THREE.LineBasicMaterial({\r\n            color: 0xffffff,\r\n            linewidth: 3,\r\n            depthTest: false,\r\n            depthWrite: false,\r\n            transparent: true,\r\n            opacity: 0.9\r\n        });\r\n        \r\n        this.scaleFeedbackLine = new THREE.Line(lineGeometry, lineMaterial);\r\n        this.scaleFeedbackLine.name = 'ScaleFeedbackLine';\r\n        this.scaleFeedbackGroup.add(this.scaleFeedbackLine);\r\n        \r\n        // Create placeholder box that follows mouse\r\n        const boxGeometry = new THREE.BoxGeometry(\r\n            this.handleSize.scale * 1.2,  // Slightly larger than original\r\n            this.handleSize.scale * 1.2,\r\n            this.handleSize.scale * 1.2\r\n        );\r\n        const boxMaterial = new THREE.MeshBasicMaterial({\r\n            color: 0xffffff,\r\n            depthTest: false,\r\n            depthWrite: false,\r\n            transparent: true,\r\n            opacity: 1.0\r\n        });\r\n        \r\n        this.scalePlaceholderBox = new THREE.Mesh(boxGeometry, boxMaterial);\r\n        this.scalePlaceholderBox.name = 'ScalePlaceholderBox';\r\n        this.scaleFeedbackGroup.add(this.scalePlaceholderBox);\r\n        \r\n        // Create uniform scale feedback circles\r\n        // Start reference circle (where user clicked) - simple outline\r\n        this.uniformScaleStartCircle = new THREE.Line(\r\n            new THREE.BufferGeometry().setFromPoints(\r\n                new THREE.Path().absarc(0, 0, 0.5, 0, Math.PI * 2, false).getPoints(64)\r\n            ),\r\n            new THREE.LineBasicMaterial({\r\n                color: 0xffffff,\r\n                depthTest: false,\r\n                depthWrite: false,\r\n                transparent: true,\r\n                opacity: 0.3,  // Semi-transparent\r\n                linewidth: 1\r\n            })\r\n        );\r\n        this.uniformScaleStartCircle.name = 'UniformScaleStartCircle';\r\n        this.scaleFeedbackGroup.add(this.uniformScaleStartCircle);\r\n        \r\n        // Current reference circle (where mouse is) - more visible\r\n        this.uniformScaleCurrentCircle = new THREE.Line(\r\n            new THREE.BufferGeometry().setFromPoints(\r\n                new THREE.Path().absarc(0, 0, 0.5, 0, Math.PI * 2, false).getPoints(64)\r\n            ),\r\n            new THREE.LineBasicMaterial({\r\n                color: 0xffffff,\r\n                depthTest: false,\r\n                depthWrite: false,\r\n                transparent: true,\r\n                opacity: 0.7,  // More visible than start circle\r\n                linewidth: 2\r\n            })\r\n        );\r\n        this.uniformScaleCurrentCircle.name = 'UniformScaleCurrentCircle';\r\n        this.scaleFeedbackGroup.add(this.uniformScaleCurrentCircle);\r\n        \r\n        // Hide feedback circles initially\r\n        this.uniformScaleStartCircle.visible = false;\r\n        this.uniformScaleCurrentCircle.visible = false;\r\n        \r\n        // Hide entire feedback group initially\r\n        this.scaleFeedbackGroup.visible = false;\r\n    }\r\n    \r\n    updateRotationFeedback(startAngle, currentAngle, axis, radius, mouseWorldPos, mouseNDC) {\r\n        // Debug overlay state\r\n        console.log('[Gizmo] Overlay check:', {\r\n            hasScene: !!this.overlay.scene,\r\n            hasGroup: !!this.overlay.group,\r\n            hasCamera: !!this.overlay.camera\r\n        });\r\n        \r\n        // If overlay is available, draw dashed line in HUD space\r\n        if (this.overlay.scene && this.overlay.group && this.overlay.camera) {\r\n            this.updateRotationFeedbackOverlay(startAngle, currentAngle, axis, radius, mouseWorldPos, mouseNDC);\r\n        }\r\n        if (!this.rotationFeedbackGroup) return;\r\n        \r\n        // Adjust angles for left-handed coordinate system visual feedback\r\n        let visualStartAngle = startAngle;\r\n        let visualCurrentAngle = currentAngle;\r\n        \r\n        if (axis === 'x') {\r\n            // X rotation: Flip the angles to match left-handed visuals\r\n            visualStartAngle = -startAngle;\r\n            visualCurrentAngle = -currentAngle;\r\n        } else if (axis === 'y') {\r\n            // Y rotation: For left-handed system, we need to flip the angle\r\n            // and adjust by 90 degrees (PI/2) to match the click position\r\n            visualStartAngle = -startAngle + Math.PI/2;\r\n            visualCurrentAngle = -currentAngle + Math.PI/2;\r\n        } else if (axis === 'z') {\r\n            // Z rotation: Flip the angles to match left-handed visuals\r\n            visualStartAngle = -startAngle;\r\n            visualCurrentAngle = -currentAngle;\r\n        }\r\n        \r\n        // Calculate the angle difference\r\n        let angleDiff = visualCurrentAngle - visualStartAngle;\r\n        \r\n        // Normalize to [-PI, PI]\r\n        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;\r\n        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;\r\n        \r\n        // Update start line position\r\n        const startX = Math.cos(visualStartAngle) * radius;\r\n        const startY = Math.sin(visualStartAngle) * radius;\r\n        this.updateLinePosition(this.rotationStartLine, 0, 0, startX, startY, axis);\r\n        \r\n        // Update current line position (origin to circle)\r\n        const currentX = Math.cos(visualCurrentAngle) * radius;\r\n        const currentY = Math.sin(visualCurrentAngle) * radius;\r\n        this.updateLinePosition(this.rotationCurrentLine, 0, 0, currentX, currentY, axis);\r\n        \r\n        // Update or create pie slice\r\n        this.updatePieSlice(visualStartAngle, angleDiff, radius, axis);\r\n    }\r\n    \r\n    updateScaleFeedback(axis, currentMousePos) {\r\n        if (!this.scaleFeedbackGroup || !this.scaleFeedbackLine) return;\r\n        if (!this.scaleInitialBoxPosition || !this.targetObject) return;\r\n        \r\n        // The placeholder box should be at the mouse position\r\n        if (this.scalePlaceholderBox && currentMousePos) {\r\n            // Convert mouse position to local space of feedback group\r\n            const localBoxPos = currentMousePos.clone().sub(this.scaleFeedbackGroup.position);\r\n            const invScale = 1 / this.scaleFeedbackGroup.scale.x;\r\n            localBoxPos.multiplyScalar(invScale);\r\n            \r\n            this.scalePlaceholderBox.position.copy(localBoxPos);\r\n        }\r\n        \r\n        // Update feedback line from initial position (gizmo box click position) to mouse position\r\n        if (this.scaleFeedbackLine && currentMousePos) {\r\n            const positions = this.scaleFeedbackLine.geometry.attributes.position.array;\r\n            \r\n            // Convert positions to local space of the feedback group\r\n            const localStart = this.scaleInitialBoxPosition.clone().sub(this.scaleFeedbackGroup.position);\r\n            const localEnd = currentMousePos.clone().sub(this.scaleFeedbackGroup.position);\r\n            \r\n            // Apply inverse scale to get correct positions\r\n            const invScale = 1 / this.scaleFeedbackGroup.scale.x;\r\n            localStart.multiplyScalar(invScale);\r\n            localEnd.multiplyScalar(invScale);\r\n            \r\n            positions[0] = localStart.x;\r\n            positions[1] = localStart.y;\r\n            positions[2] = localStart.z;\r\n            positions[3] = localEnd.x;\r\n            positions[4] = localEnd.y;\r\n            positions[5] = localEnd.z;\r\n            \r\n            this.scaleFeedbackLine.geometry.attributes.position.needsUpdate = true;\r\n        }\r\n        \r\n        // Update overlay if available (dashed line from origin to mouse)\r\n        if (this.overlay.scene && this.overlay.group && this.overlay.camera) {\r\n            this.updateScaleFeedbackOverlay(axis);\r\n        }\r\n    }\r\n    \r\n    updateScaleFeedbackOverlay(axis) {\r\n        // Reuse the same overlay visualization as rotation (dashed line)\r\n        if (!this._overlayVis) {\r\n            this._overlayVis = {};\r\n            // Dashed line (center -> mouse) using LineDashedMaterial in screen-space (pixel units)\r\n            this._overlayVis.extGeom = new THREE.BufferGeometry().setAttribute(\r\n                'position', new THREE.Float32BufferAttribute([0,0,0, 0,0,0], 3)\r\n            );\r\n            this._overlayVis.extMat = new THREE.LineDashedMaterial({\r\n                color: 0x000000,\r\n                transparent: true,\r\n                opacity: 0.95,\r\n                depthTest: false,\r\n                depthWrite: false,\r\n                dashSize: .03, // pixels in overlay space\r\n                gapSize: .03,  // pixels in overlay space\r\n                scale: 1,\r\n                linewidth: 2\r\n            });\r\n            this._overlayVis.extLine = new THREE.Line(this._overlayVis.extGeom, this._overlayVis.extMat);\r\n            // Add only the dashed line to overlay group\r\n            this.overlay.group.add(this._overlayVis.extLine);\r\n        }\r\n        \r\n        const toScreen = (worldV3) => {\r\n            if (!this.camera) return new THREE.Vector3();\r\n            const v = worldV3.clone().project(this.camera);\r\n            const { width = 1, height = 1 } = (this.overlay.getViewportSize ? this.overlay.getViewportSize() : {});\r\n            const x = (v.x + 1) * 0.5 * width;\r\n            const y = (v.y + 1) * 0.5 * height;\r\n            return new THREE.Vector3(x, y, 0);\r\n        };\r\n        \r\n        // Get center and mouse positions in screen space\r\n        const centerWorld = this.gizmoGroup ? this.gizmoGroup.position.clone() : new THREE.Vector3();\r\n        const pCenter = toScreen(centerWorld);\r\n        \r\n        // Use current mouse NDC position\r\n        const { width = 1, height = 1 } = (this.overlay.getViewportSize ? this.overlay.getViewportSize() : {});\r\n        const pMouse = new THREE.Vector3(\r\n            (this.dragCurrent.x + 1) * 0.5 * width,\r\n            (this.dragCurrent.y + 1) * 0.5 * height,\r\n            0\r\n        );\r\n        \r\n        // Update dashed line\r\n        const arr = this._overlayVis.extGeom.attributes.position.array;\r\n        arr[0] = pCenter.x; arr[1] = pCenter.y; arr[2] = 0;\r\n        arr[3] = pMouse.x; arr[4] = pMouse.y; arr[5] = 0;\r\n        this._overlayVis.extGeom.attributes.position.needsUpdate = true;\r\n        this._overlayVis.extLine.computeLineDistances();\r\n        \r\n        // Ensure material is updated\r\n        this._overlayVis.extMat.needsUpdate = true;\r\n        \r\n        // Debug: Make line more visible\r\n        this._overlayVis.extLine.visible = true;\r\n        console.log('[Gizmo] Overlay line updated:', {center: [pCenter.x, pCenter.y], mouse: [pMouse.x, pMouse.y]});\r\n    }\r\n\r\n    // Draw dashed line from origin to mouse in overlay (HUD) space\r\n    updateRotationFeedbackOverlay(startAngle, currentAngle, axis, radius, mouseWorldPos, mouseNDC) {\r\n        // Use separate overlay for rotation to avoid conflicts with scale\r\n        if (!this._rotOverlay) {\r\n            this._rotOverlay = {};\r\n            // Dashed line (center -> mouse) using LineDashedMaterial in screen-space (pixel units)\r\n            this._rotOverlay.extGeom = new THREE.BufferGeometry().setAttribute(\r\n                'position', new THREE.Float32BufferAttribute([0,0,0, 0,0,0], 3)\r\n            );\r\n            this._rotOverlay.extMat = new THREE.LineDashedMaterial({\r\n                color: 0x000000,\r\n                transparent: true,\r\n                opacity: 0.95,\r\n                depthTest: false,\r\n                depthWrite: false,\r\n                dashSize: 0.03, // pixels in overlay space\r\n                gapSize: 0.03,  // pixels in overlay space\r\n                scale: 1,\r\n                linewidth: 2\r\n            });\r\n            this._rotOverlay.extLine = new THREE.Line(this._rotOverlay.extGeom, this._rotOverlay.extMat);\r\n            // Add only the dashed line to overlay group\r\n            this.overlay.group.add(this._rotOverlay.extLine);\r\n        }\r\n        \r\n        // Make sure the line is visible\r\n        this._rotOverlay.extLine.visible = true;\r\n\r\n        const toScreen = (worldV3) => {\r\n            // Project world position to NDC using 3D camera, then map to overlay pixel coords\r\n            if (!this.camera) return new THREE.Vector3();\r\n            const v = worldV3.clone().project(this.camera);\r\n            // NDC (-1..1) -> pixel (0..W, 0..H). Note overlayCamera has left=0,right=W, top=H, bottom=0\r\n            const { width = 1, height = 1 } = (this.overlay.getViewportSize ? this.overlay.getViewportSize() : {});\r\n            const x = (v.x + 1) * 0.5 * width;\r\n            const y = (v.y + 1) * 0.5 * height; // match overlay camera (bottom=0, top=height)\r\n            return new THREE.Vector3(x, y, 0);\r\n        };\r\n        const ndcToScreen = (ndc) => {\r\n            const { width = 1, height = 1 } = (this.overlay.getViewportSize ? this.overlay.getViewportSize() : {});\r\n            const x = ((ndc.x || 0) + 1) * 0.5 * width;\r\n            const y = ((ndc.y || 0) + 1) * 0.5 * height;\r\n            return new THREE.Vector3(x, y, 0);\r\n        };\r\n\r\n        // Compute world points for origin, start, current, and mouse\r\n        const centerWorld = this.gizmoGroup ? this.gizmoGroup.position.clone() : new THREE.Vector3();\r\n        // Build axis plane basis to place the arc on screen consistent with world ring\r\n        const angleToPoint = (ang) => {\r\n            // Unit circle in the ring plane, then transform to world\r\n            let dx=0, dy=0, dz=0;\r\n            const c = Math.cos(ang), s = Math.sin(ang);\r\n            if (axis === 'x') { dy = -s; dz = c; }\r\n            else if (axis === 'y') { dx = c; dz = s; }\r\n            else { dx = c; dy = s; }\r\n            return new THREE.Vector3(centerWorld.x + dx * radius, centerWorld.y + dy * radius, centerWorld.z + dz * radius);\r\n        };\r\n\r\n        // Compute mouse world point for overlay projection\r\n        const mouseWorld = mouseWorldPos ? mouseWorldPos.clone() : angleToPoint(currentAngle);\r\n\r\n        // Project to overlay pixel space\r\n        const pCenter = toScreen(centerWorld);\r\n        // Prefer the actual mouse NDC to ensure strict screen-space alignment\r\n        const pMouse = (mouseNDC && typeof mouseNDC.x === 'number' && typeof mouseNDC.y === 'number')\r\n            ? ndcToScreen(mouseNDC)\r\n            : toScreen(mouseWorld);\r\n\r\n        // Update overlay lines (positions are in overlay camera space: x,y in pixels)\r\n        const setLine = (geom, a, b) => {\r\n            const arr = geom.attributes.position.array;\r\n            arr[0]=a.x; arr[1]=a.y; arr[2]=0; arr[3]=b.x; arr[4]=b.y; arr[5]=0;\r\n            geom.attributes.position.needsUpdate = true;\r\n        };\r\n    // Dashed line from center to mouse (single line with dashed material)\r\n    setLine(this._rotOverlay.extGeom, pCenter, pMouse);\r\n    // Recompute line distances for dashed material\r\n    this._rotOverlay.extLine.computeLineDistances();\r\n    \r\n    // Ensure material is updated\r\n    this._rotOverlay.extMat.needsUpdate = true;\r\n    }\r\n    \r\n    updateLinePosition(line, startX, startY, endX, endY, axis) {\r\n        if (!line) return;\r\n        \r\n        const positions = line.geometry.attributes.position.array;\r\n        \r\n        // Start point\r\n        if (axis === 'x') {\r\n            positions[0] = 0;\r\n            positions[1] = -startY;  // Flip Y for C3 coordinate system\r\n            positions[2] = startX;\r\n        } else if (axis === 'y') {\r\n            positions[0] = startX;\r\n            positions[1] = 0;\r\n            positions[2] = startY;\r\n        } else { // z axis\r\n            positions[0] = startX;\r\n            positions[1] = startY;\r\n            positions[2] = 0;\r\n        }\r\n        \r\n        // End point\r\n        if (axis === 'x') {\r\n            positions[3] = 0;\r\n            positions[4] = -endY;  // Flip Y for C3 coordinate system\r\n            positions[5] = endX;\r\n        } else if (axis === 'y') {\r\n            positions[3] = endX;\r\n            positions[4] = 0;\r\n            positions[5] = endY;\r\n        } else { // z axis\r\n            positions[3] = endX;\r\n            positions[4] = endY;\r\n            positions[5] = 0;\r\n        }\r\n        \r\n        line.geometry.attributes.position.needsUpdate = true;\r\n    }\r\n    \r\n    updatePieSlice(startAngle, angleDiff, radius, axis) {\r\n        // Remove old pie if exists\r\n        if (this.rotationPie) {\r\n            this.rotationFeedbackGroup.remove(this.rotationPie);\r\n            if (this.rotationPie.geometry) this.rotationPie.geometry.dispose();\r\n            if (this.rotationPie.material) this.rotationPie.material.dispose();\r\n            this.rotationPie = null;\r\n        }\r\n        \r\n        // Don't create pie for very small angles\r\n        if (Math.abs(angleDiff) < 0.01) return;\r\n        \r\n        // Create pie geometry\r\n        const segments = Math.max(3, Math.floor(Math.abs(angleDiff) * 32 / Math.PI));\r\n        const geometry = new THREE.BufferGeometry();\r\n        const vertices = [];\r\n        \r\n        // Add center vertex\r\n        vertices.push(0, 0, 0);\r\n        \r\n        // Add arc vertices\r\n        for (let i = 0; i <= segments; i++) {\r\n            const angle = startAngle + (angleDiff * i / segments);\r\n            const x = Math.cos(angle) * radius;\r\n            const y = Math.sin(angle) * radius;\r\n            \r\n            if (axis === 'x') {\r\n                vertices.push(0, -y, x);  // Flip Y for C3 coordinate system\r\n            } else if (axis === 'y') {\r\n                vertices.push(x, 0, y);\r\n            } else { // z axis\r\n                vertices.push(x, y, 0);\r\n            }\r\n        }\r\n        \r\n        // Create faces\r\n        const indices = [];\r\n        for (let i = 1; i < vertices.length / 3 - 1; i++) {\r\n            indices.push(0, i, i + 1);\r\n        }\r\n        \r\n        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\r\n        geometry.setIndex(indices);\r\n        geometry.computeVertexNormals();\r\n        \r\n        // Create material with appropriate color\r\n        const color = this.colors[axis] || this.colors.rotationFeedback;\r\n        const material = new THREE.MeshBasicMaterial({\r\n            color: color,\r\n            opacity: 0.3,\r\n            transparent: true,\r\n            side: THREE.DoubleSide,\r\n            depthTest: false,\r\n            depthWrite: false\r\n        });\r\n        \r\n        this.rotationPie = new THREE.Mesh(geometry, material);\r\n        this.rotationPie.name = 'RotationPie';\r\n        this.rotationFeedbackGroup.add(this.rotationPie);\r\n    }\r\n    \r\n    createPositionGizmo() {\r\n        const group = new THREE.Group();\r\n        group.name = 'PositionGizmo';\r\n        \r\n    // Create arrows for each axis\r\n    ['x', 'y', 'z'].forEach((axis, index) => {\r\n            const color = this.colors[axis];\r\n            const direction = new THREE.Vector3();\r\n            direction[axis] = 1;\r\n            \r\n            // Arrow shaft - thicker for better visibility\r\n            const shaftGeometry = new THREE.CylinderGeometry(\r\n                this.handleSize.shaftThickness, \r\n                this.handleSize.shaftThickness, \r\n                this.handleSize.position, \r\n                8\r\n            );\r\n            const shaftMaterial = new THREE.MeshBasicMaterial({ \r\n                color: color,\r\n                depthTest: false,\r\n                depthWrite: false,\r\n                transparent: true,\r\n                opacity: 0.8\r\n            });\r\n            const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);\r\n            \r\n            // Arrow cone - larger for better visibility\r\n            const coneGeometry = new THREE.ConeGeometry(\r\n                this.handleSize.coneSize, \r\n                this.handleSize.coneHeight, \r\n                8\r\n            );\r\n            const coneMaterial = new THREE.MeshBasicMaterial({ \r\n                color: color,\r\n                depthTest: false,\r\n                depthWrite: false,\r\n                transparent: true,\r\n                opacity: 0.9\r\n            });\r\n            const cone = new THREE.Mesh(coneGeometry, coneMaterial);\r\n            \r\n            // Position based on axis\r\n            if (axis === 'x') {\r\n                shaft.rotation.z = -Math.PI / 2;\r\n                shaft.position.x = this.handleSize.position / 2;\r\n                cone.rotation.z = -Math.PI / 2;\r\n                cone.position.x = this.handleSize.position + this.handleSize.coneHeight / 2;\r\n            } else if (axis === 'y') {\r\n                shaft.position.y = -this.handleSize.position / 2; // Negative for C3\r\n                cone.rotation.z = Math.PI;\r\n                cone.position.y = -this.handleSize.position - this.handleSize.coneHeight / 2;\r\n            } else {\r\n                shaft.rotation.x = Math.PI / 2;\r\n                shaft.position.z = this.handleSize.position / 2;\r\n                cone.rotation.x = Math.PI / 2;  // Flipped from -Math.PI / 2\r\n                cone.position.z = this.handleSize.position + this.handleSize.coneHeight / 2;\r\n            }\r\n            \r\n            // Store axis info\r\n            shaft.userData = { type: 'position', axis: axis, component: 'shaft' };\r\n            cone.userData = { type: 'position', axis: axis, component: 'cone' };\r\n            \r\n            group.add(shaft);\r\n            group.add(cone);\r\n            \r\n            // Add plane handles for 2-axis movement\r\n            // We want exactly three planes: XY, YZ, XZ. Build one plane at each axis index using the next axis in cycle.\r\n            const nextAxis = ['y', 'z', 'x'][index];\r\n            const planeSize = 0.8;     // Bigger squares\r\n            const planeOffset = 0.45;  // Spacing from the corner\r\n\r\n            const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize);\r\n            // Blend the two axis colors safely\r\n            const c1 = new THREE.Color(this.colors[axis]);\r\n            const c2 = new THREE.Color(this.colors[nextAxis]);\r\n            const blendedColor = c1.clone().lerp(c2, 0.5);\r\n            const planeMaterial = new THREE.MeshBasicMaterial({\r\n                color: blendedColor,\r\n                opacity: 0.35,\r\n                transparent: true,\r\n                side: THREE.DoubleSide,\r\n                depthTest: false,\r\n                depthWrite: false\r\n            });\r\n            const plane = new THREE.Mesh(planeGeometry, planeMaterial);\r\n\r\n            // Position plane between the two axes with a consistent sign convention (Y is negative in C3)\r\n            const signedOffset = (a) => (a === 'y' ? -planeOffset : planeOffset);\r\n            const planePos = new THREE.Vector3(0, 0, 0);\r\n            planePos[axis] = signedOffset(axis);\r\n            planePos[nextAxis] = signedOffset(nextAxis);\r\n            plane.position.copy(planePos);\r\n\r\n            // Rotate plane to face correct direction\r\n            // Default plane geometry lies in the XY plane (normal +Z)\r\n            if ((axis === 'x' && nextAxis === 'y') || (axis === 'y' && nextAxis === 'x')) {\r\n                // XY plane: no rotation needed\r\n                plane.rotation.set(0, 0, 0);\r\n                plane.userData = { type: 'position', axis: 'xy', component: 'plane' };\r\n            } else if ((axis === 'y' && nextAxis === 'z') || (axis === 'z' && nextAxis === 'y')) {\r\n                // YZ plane: rotate into YZ by 90deg around Y\r\n                plane.rotation.set(0, Math.PI / 2, 0);\r\n                plane.userData = { type: 'position', axis: 'yz', component: 'plane' };\r\n            } else {\r\n                // XZ plane: rotate into XZ by 90deg around X\r\n                plane.rotation.set(Math.PI / 2, 0, 0);\r\n                plane.userData = { type: 'position', axis: 'xz', component: 'plane' };\r\n            }\r\n\r\n            group.add(plane);\r\n        });\r\n        \r\n        this.positionGizmo = group;\r\n        this.gizmoGroup.add(group);\r\n    }\r\n    \r\n    createRotationGizmo() {\r\n        const group = new THREE.Group();\r\n        group.name = 'RotationGizmo';\r\n        \r\n        // Create rotation rings for each axis\r\n        ['x', 'y', 'z'].forEach(axis => {\r\n            const color = this.colors[axis];\r\n            const geometry = new THREE.TorusGeometry(\r\n                this.handleSize.rotation, \r\n                this.handleSize.shaftThickness, // Thicker rings\r\n                8, \r\n                32\r\n            );\r\n            const material = new THREE.MeshBasicMaterial({ \r\n                color: color,\r\n                depthTest: false,\r\n                depthWrite: false,\r\n                transparent: true,\r\n                opacity: 0.7\r\n            });\r\n            const ring = new THREE.Mesh(geometry, material);\r\n            \r\n            // Rotate ring based on axis\r\n            if (axis === 'x') {\r\n                ring.rotation.y = Math.PI / 2;\r\n            } else if (axis === 'y') {\r\n                ring.rotation.x = Math.PI / 2;\r\n            }\r\n            \r\n            ring.userData = { type: 'rotation', axis: axis };\r\n            group.add(ring);\r\n        });\r\n        \r\n        this.rotationGizmo = group;\r\n        this.gizmoGroup.add(group);\r\n    }\r\n    \r\n    createScaleGizmo() {\r\n        const group = new THREE.Group();\r\n        group.name = 'ScaleGizmo';\r\n        \r\n        // Create scale handles for each axis\r\n        ['x', 'y', 'z'].forEach(axis => {\r\n            const color = this.colors[axis];\r\n            \r\n            // Line - thicker\r\n            const lineGeometry = new THREE.CylinderGeometry(\r\n                this.handleSize.shaftThickness * 0.75, \r\n                this.handleSize.shaftThickness * 0.75, \r\n                this.handleSize.position * 0.8, \r\n                8\r\n            );\r\n            const lineMaterial = new THREE.MeshBasicMaterial({ \r\n                color: color,\r\n                depthTest: false,\r\n                depthWrite: false,\r\n                transparent: true,\r\n                opacity: 0.7\r\n            });\r\n            const line = new THREE.Mesh(lineGeometry, lineMaterial);\r\n            \r\n            // Box handle - larger\r\n            const boxGeometry = new THREE.BoxGeometry(\r\n                this.handleSize.scale, \r\n                this.handleSize.scale, \r\n                this.handleSize.scale\r\n            );\r\n            const boxMaterial = new THREE.MeshBasicMaterial({ \r\n                color: color,\r\n                depthTest: false,\r\n                depthWrite: false,\r\n                transparent: true,\r\n                opacity: 0.9\r\n            });\r\n            const box = new THREE.Mesh(boxGeometry, boxMaterial);\r\n            \r\n            // Position based on axis\r\n            if (axis === 'x') {\r\n                line.rotation.z = -Math.PI / 2;\r\n                line.position.x = this.handleSize.position * 0.4;\r\n                box.position.x = this.handleSize.position * 0.8;\r\n            } else if (axis === 'y') {\r\n                line.position.y = -this.handleSize.position * 0.4;\r\n                box.position.y = -this.handleSize.position * 0.8;\r\n            } else {\r\n                line.rotation.x = Math.PI / 2;\r\n                line.position.z = this.handleSize.position * 0.4;\r\n                box.position.z = this.handleSize.position * 0.8;\r\n            }\r\n            \r\n            line.userData = { type: 'scale', axis: axis, component: 'line' };\r\n            box.userData = { type: 'scale', axis: axis, component: 'box' };\r\n            \r\n            group.add(line);\r\n            group.add(box);\r\n        });\r\n        \r\n        this.scaleGizmo = group;\r\n        this.gizmoGroup.add(group);\r\n    }\r\n    \r\n    createUniformScaleGizmo() {\r\n        const group = new THREE.Group();\r\n        group.name = 'UniformScaleGizmo';\r\n        \r\n        // Create donut shape with two concentric circles - 2.5x larger\r\n        const outerRadius = this.handleSize.uniformScale * 3.0;\r\n        const innerRadius = this.handleSize.uniformScale * 1.75;\r\n        \r\n        // Create outer ring\r\n        const outerRingGeometry = new THREE.TorusGeometry(\r\n            outerRadius,\r\n            0.01, // Very thin tube for a circle appearance\r\n            4,\r\n            32\r\n        );\r\n        const ringMaterial = new THREE.MeshBasicMaterial({ \r\n            color: 0xffffff, // White\r\n            depthTest: false,\r\n            depthWrite: false,\r\n            transparent: true,\r\n            opacity: 0.5  // More transparent\r\n        });\r\n        const outerRing = new THREE.Mesh(outerRingGeometry, ringMaterial);\r\n        \r\n        // Create inner ring\r\n        const innerRingGeometry = new THREE.TorusGeometry(\r\n            innerRadius,\r\n            0.01, // Very thin tube\r\n            4,\r\n            32\r\n        );\r\n        const innerRing = new THREE.Mesh(innerRingGeometry, ringMaterial);\r\n        \r\n        // Create semi-transparent donut fill between the rings\r\n        const donutGeometry = new THREE.RingGeometry(innerRadius, outerRadius, 32);\r\n        const donutMaterial = new THREE.MeshBasicMaterial({\r\n            color: 0xffffff, // White\r\n            depthTest: false,\r\n            depthWrite: false,\r\n            transparent: true,\r\n            opacity: 0.15, // More transparent\r\n            side: THREE.DoubleSide\r\n        });\r\n        const donutFill = new THREE.Mesh(donutGeometry, donutMaterial);\r\n        \r\n        // Set user data for all parts\r\n        outerRing.userData = { type: 'scale', axis: 'uniform' };\r\n        innerRing.userData = { type: 'scale', axis: 'uniform' };\r\n        donutFill.userData = { type: 'scale', axis: 'uniform' };\r\n        \r\n        // Add all parts to group\r\n        group.add(outerRing);\r\n        group.add(innerRing);\r\n        group.add(donutFill);\r\n        \r\n        this.uniformScaleGizmo = group;\r\n        this.gizmoGroup.add(group);\r\n    }\r\n    \r\n    setupInteraction() {\r\n        // This will be called from the main worker's event handlers\r\n        console.log('[TransformGizmo] Interaction setup ready');\r\n    }\r\n    \r\n    handleMouseDown(mouse, camera) {\r\n        if (!this.targetObject) return false;\r\n        \r\n        this.raycaster.setFromCamera(mouse, camera);\r\n        const intersects = this.raycaster.intersectObjects(this.gizmoGroup.children, true);\r\n        \r\n        if (intersects.length > 0) {\r\n            const object = intersects[0].object;\r\n            if (object.userData.type) {\r\n                this.activeHandle = object.userData;\r\n                this.isDragging = true;\r\n                this.dragStart.copy(mouse);\r\n                this.dragCurrent.copy(mouse);  // Initialize dragCurrent\r\n                \r\n                // Store initial transform\r\n                this.initialTransform = {\r\n                    position: this.targetObject.position.clone(),\r\n                    rotation: this.targetObject.rotation.clone(),\r\n                    scale: this.targetObject.scale.clone()\r\n                };\r\n                \r\n                // ADDED: Store drag start position for delta calculation\r\n                if (this.activeHandle.type === 'position') {\r\n                    this.dragStartPosition = this.targetObject.position.clone();\r\n                    // Store start world position for overlay delta line AFTER any snapping\r\n                    // This will be set after snapping in the position initialization below\r\n                }\r\n                \r\n                // For position gizmo, store the initial click world point\r\n                if (this.activeHandle.type === 'position' && intersects.length > 0) {\r\n                    this.initialClickPoint = intersects[0].point.clone();\r\n                    // If snapping is enabled, snap the object immediately to the nearest WORLD grid point\r\n                    if (this.snap.enabled) {\r\n                        const step = this.snap.unitsPerCell || 0;\r\n                        if (step > 0) {\r\n                            const origin = this.snap.origin || new THREE.Vector3();\r\n                            const snapped = this.targetObject.position.clone();\r\n                            snapped.x = this.snapValueToGrid(snapped.x, step, origin.x);\r\n                            snapped.y = this.snapValueToGrid(snapped.y, step, origin.y);\r\n                            snapped.z = this.snapValueToGrid(snapped.z, step, origin.z);\r\n                            this.targetObject.position.copy(snapped);\r\n                            // DO NOT update initialTransform - keep the original position for delta calculation\r\n                            // this.initialTransform.position.copy(snapped); // REMOVED\r\n                            // Keep gizmo in sync\r\n                            this.updateGizmoTransform();\r\n                            // Send an immediate update so UI reflects the snapped start\r\n                            this.sendTransformUpdate();\r\n                        }\r\n                    }\r\n                    // Compute click offset relative to (possibly snapped) position\r\n                    this.initialClickOffset = this.initialClickPoint.clone().sub(this.targetObject.position);\r\n                    \r\n                    // Store the position after snapping for the overlay line\r\n                    this.positionDragStartWorld = this.targetObject.position.clone();\r\n                }\r\n                \r\n                // Special handling for rotation\r\n                if (this.activeHandle.type === 'rotation') {\r\n                    this.initializeRotation(mouse, camera);\r\n                }\r\n                \r\n                // Special handling for scale\r\n                if (this.activeHandle.type === 'scale') {\r\n                    this.initializeScale(mouse, camera, intersects[0]);\r\n                }\r\n                \r\n                // Highlight active handle\r\n                this.highlightHandle(object, true);\r\n                \r\n                // Hide other gizmo types when dragging\r\n                this.hideInactiveGizmos(this.activeHandle.type);\r\n                \r\n                // Send activation message\r\n                self.postMessage({\r\n                    type: 'GIZMO_ACTIVE',\r\n                    data: { active: true }\r\n                });\r\n\r\n                // Initialize position after snapping but before overlay setup\r\n                if (this.activeHandle.type === 'position') {\r\n                    // This will be updated after snapping if needed\r\n                    this.positionDragStartWorld = this.targetObject.position.clone();\r\n                }\r\n                \r\n                // Clean up any previous overlay visuals from other transform types\r\n                if (this.overlay.scene && this.overlay.group) {\r\n                    // Hide scale overlay if it exists\r\n                    if (this._overlayVis && this._overlayVis.extLine) {\r\n                        this._overlayVis.extLine.visible = false;\r\n                    }\r\n                    // Hide rotation overlay if it exists\r\n                    if (this._rotOverlay && this._rotOverlay.extLine) {\r\n                        this._rotOverlay.extLine.visible = false;\r\n                    }\r\n                    \r\n                    // Prepare dashed delta line for position drag\r\n                    if (this.activeHandle.type === 'position' && this.overlay.camera) {\r\n                        if (!this._posOverlay) {\r\n                            this._posOverlay = {};\r\n                            this._posOverlay.geom = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute([0,0,0, 0,0,0], 3));\r\n                            this._posOverlay.mat = new THREE.LineDashedMaterial({ color: 0x000000, transparent: true, opacity: 0.95, depthTest: false, depthWrite: false, dashSize: 0.03, gapSize: 0.03, scale: 1, linewidth: 2 });\r\n                            this._posOverlay.line = new THREE.Line(this._posOverlay.geom, this._posOverlay.mat);\r\n                            this.overlay.group.add(this._posOverlay.line);\r\n                        }\r\n                        this._posOverlay.line.visible = true;\r\n                        this.overlay.group.visible = true;\r\n                        \r\n                        // Initialize the line positions immediately\r\n                        if (this.positionDragStartWorld) {\r\n                            const toScreen = (worldV3) => {\r\n                                const v = worldV3.clone().project(this.camera);\r\n                                const { width = 1, height = 1 } = (this.overlay.getViewportSize ? this.overlay.getViewportSize() : {});\r\n                                const x = (v.x + 1) * 0.5 * width;\r\n                                const y = (v.y + 1) * 0.5 * height;\r\n                                return new THREE.Vector3(x, y, 0);\r\n                            };\r\n                            const startScreen = toScreen(this.positionDragStartWorld);\r\n                            const arr = this._posOverlay.geom.attributes.position.array;\r\n                            // Both points start at the same position initially\r\n                            arr[0] = startScreen.x; arr[1] = startScreen.y; arr[2] = 0;\r\n                            arr[3] = startScreen.x; arr[4] = startScreen.y; arr[5] = 0;\r\n                            this._posOverlay.geom.attributes.position.needsUpdate = true;\r\n                            this._posOverlay.line.computeLineDistances();\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                return true; // Indicate gizmo is active\r\n            }\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    \r\n    initializeRotation(mouse, camera) {\r\n        if (!this.activeHandle || this.activeHandle.type !== 'rotation') return;\r\n        \r\n        // Hide other overlays\r\n        if (this._posOverlay && this._posOverlay.line) {\r\n            this._posOverlay.line.visible = false;\r\n        }\r\n        // Hide scale overlay if it was being used\r\n        if (this._overlayVis && this._overlayVis.extLine) {\r\n            this._overlayVis.extLine.visible = false;\r\n        }\r\n        \r\n        // Show rotation overlay\r\n        if (this.overlay.scene && this.overlay.group) {\r\n            this.overlay.group.visible = true;\r\n            // The rotation overlay will be created on first use in updateRotationFeedbackOverlay\r\n        }\r\n        \r\n        const axis = this.activeHandle.axis;\r\n        this.rotationAxis = axis;\r\n        \r\n        // Calculate the initial angle on the rotation plane\r\n        this.rotationStartAngle = this.calculateRotationAngle(mouse, camera, axis);\r\n        this.rotationCurrentAngle = this.rotationStartAngle;\r\n        \r\n        // Show 3D rotation feedback\r\n        this.rotationFeedbackGroup.visible = true;\r\n        this.rotationFeedbackGroup.position.copy(this.gizmoGroup.position);\r\n        this.rotationFeedbackGroup.quaternion.copy(this.gizmoGroup.quaternion);\r\n        this.rotationFeedbackGroup.scale.copy(this.gizmoGroup.scale);\r\n        \r\n        // Get mouse world position for feedback visuals\r\n        const mouseWorldPos = this.getMouseWorldPosition(mouse, camera, axis);\r\n        \r\n        // Show overlay feedback if available\r\n        if (this.overlay.scene && this.overlay.group) {\r\n            this.updateRotationFeedbackOverlay(this.rotationStartAngle, this.rotationCurrentAngle, axis, this.handleSize.rotation, mouseWorldPos, mouse);\r\n            this.overlay.group.visible = true;\r\n        }\r\n        \r\n        // Initialize 3D feedback visuals\r\n        this.updateRotationFeedback(\r\n            this.rotationStartAngle,\r\n            this.rotationCurrentAngle,\r\n            axis,\r\n            this.handleSize.rotation,\r\n            mouseWorldPos,\r\n            mouse\r\n        );\r\n    }\r\n    \r\n    initializeScale(mouse, camera, intersection) {\r\n        if (!this.activeHandle || this.activeHandle.type !== 'scale') return;\r\n        \r\n        // Hide other overlays\r\n        if (this._posOverlay && this._posOverlay.line) {\r\n            this._posOverlay.line.visible = false;\r\n        }\r\n        if (this._rotOverlay && this._rotOverlay.extLine) {\r\n            this._rotOverlay.extLine.visible = false;\r\n        }\r\n        \r\n        const axis = this.activeHandle.axis;\r\n        \r\n        if (axis === 'uniform') {\r\n            // For uniform scale, track initial mouse world position\r\n            this.raycaster.setFromCamera(mouse, camera);\r\n            const intersectPoint = new THREE.Vector3();\r\n            const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);\r\n            plane.translate(this.gizmoGroup.position);\r\n            \r\n            // If camera is looking along Z, use Y plane instead\r\n            const cameraDir = new THREE.Vector3();\r\n            camera.getWorldDirection(cameraDir);\r\n            if (Math.abs(cameraDir.z) > 0.9) {\r\n                plane.normal.set(0, 1, 0);\r\n            }\r\n            \r\n            this.raycaster.ray.intersectPlane(plane, intersectPoint);\r\n            \r\n            const initialDistance = intersectPoint.distanceTo(this.gizmoGroup.position);\r\n            this.uniformScaleInitialDistance = initialDistance;\r\n            this.uniformScaleInitialScale = this.targetObject.userData?.scale || 1.0;\r\n            \r\n            // Store the base scale values (individual scale components)\r\n            // These are the scale values WITHOUT the uniform scale applied\r\n            const currentUniformScale = this.targetObject.userData?.scale || 1.0;\r\n            this.baseScaleValues = {\r\n                x: this.targetObject.scale.x / currentUniformScale,\r\n                y: this.targetObject.scale.y / currentUniformScale,\r\n                z: this.targetObject.scale.z / currentUniformScale\r\n            };\r\n            \r\n            // Show feedback group\r\n            this.scaleFeedbackGroup.visible = true;\r\n            this.scaleFeedbackGroup.position.copy(this.gizmoGroup.position);\r\n            this.scaleFeedbackGroup.quaternion.copy(this.gizmoGroup.quaternion);\r\n            this.scaleFeedbackGroup.scale.copy(this.gizmoGroup.scale);\r\n            \r\n            // Setup reference circles\r\n            if (this.uniformScaleStartCircle && this.uniformScaleCurrentCircle) {\r\n                // Set circle sizes based on click distance in local space\r\n                const localRadius = initialDistance / this.scaleFeedbackGroup.scale.x;\r\n                const circlePoints = new THREE.Path().absarc(0, 0, localRadius, 0, Math.PI * 2, false).getPoints(64);\r\n                this.uniformScaleStartCircle.geometry.setFromPoints(circlePoints);\r\n                this.uniformScaleCurrentCircle.geometry.setFromPoints(circlePoints);\r\n                \r\n                this.uniformScaleStartCircle.visible = true;\r\n                this.uniformScaleCurrentCircle.visible = true;\r\n                \r\n                // Hide regular scale feedback\r\n                if (this.scaleFeedbackLine) this.scaleFeedbackLine.visible = false;\r\n                if (this.scalePlaceholderBox) this.scalePlaceholderBox.visible = false;\r\n            }\r\n            \r\n            // Hide the entire donut (rings and fill) during dragging to see the model better\r\n            if (this.uniformScaleGizmo) {\r\n                // Store references and hide all children\r\n                this.uniformScaleGizmoChildren = [];\r\n                this.uniformScaleGizmo.traverse(child => {\r\n                    if (child.isMesh) {\r\n                        this.uniformScaleGizmoChildren.push({\r\n                            mesh: child,\r\n                            wasVisible: child.visible\r\n                        });\r\n                        child.visible = false;\r\n                    }\r\n                });\r\n            }\r\n            \r\n            // Show overlay feedback if available\r\n            if (this.overlay.scene && this.overlay.group) {\r\n                this.overlay.group.visible = true;\r\n                this.dragCurrent = mouse.clone();\r\n                this.updateScaleFeedbackOverlay(axis);\r\n            }\r\n            \r\n            return;\r\n        }\r\n        \r\n        // Store the initial scale for this drag operation\r\n        this.scaleInitialScale = this.targetObject.scale[axis];\r\n        \r\n        // The VISUAL position of the gizmo box (not affected by object scale)\r\n        // This is where we're clicking in world space and where the feedback line should start\r\n        const visualBoxOffset = this.handleSize.position * 0.8;\r\n        const visualBoxPos = new THREE.Vector3();\r\n        visualBoxPos[axis] = (axis === 'y') ? -visualBoxOffset : visualBoxOffset;\r\n        visualBoxPos.applyMatrix4(this.gizmoGroup.matrixWorld);\r\n        \r\n        // Store this as the initial position for the feedback line\r\n        this.scaleInitialBoxPosition = visualBoxPos;\r\n        \r\n        // Store the distance from origin where we're clicking (visual position)\r\n        const origin = this.targetObject.position.clone();\r\n        this.scaleClickDistance = visualBoxPos.distanceTo(origin);\r\n        \r\n        // Hide the original scale box\r\n        if (intersection.object.userData.component === 'box') {\r\n            this.originalScaleBox = intersection.object;\r\n            this.originalScaleBox.visible = false;\r\n        }\r\n        \r\n        // Set colors to match axis\r\n        const axisColor = this.colors[axis];\r\n        this.scaleFeedbackLine.material.color.setHex(axisColor);\r\n        this.scalePlaceholderBox.material.color.setHex(axisColor);\r\n        \r\n        // Show scale feedback\r\n        this.scaleFeedbackGroup.visible = true;\r\n        this.scaleFeedbackGroup.position.copy(this.gizmoGroup.position);\r\n        this.scaleFeedbackGroup.quaternion.copy(this.gizmoGroup.quaternion);\r\n        this.scaleFeedbackGroup.scale.copy(this.gizmoGroup.scale);\r\n        \r\n        // Ensure feedback line and box are visible for individual axis scaling\r\n        if (this.scaleFeedbackLine) this.scaleFeedbackLine.visible = true;\r\n        if (this.scalePlaceholderBox) this.scalePlaceholderBox.visible = true;\r\n        \r\n        // Show overlay feedback if available\r\n        if (this.overlay.scene && this.overlay.group) {\r\n            this.overlay.group.visible = true;\r\n        }\r\n        \r\n        // Update dragCurrent with the current mouse position for overlay\r\n        this.dragCurrent = mouse.clone();\r\n        \r\n        // Get the current mouse position on the axis\r\n        const currentMousePos = this.getScaleMousePosition(mouse, camera, axis);\r\n        \r\n        // Initialize feedback line from box to mouse position\r\n        if (this.scaleFeedbackLine) {\r\n            const positions = this.scaleFeedbackLine.geometry.attributes.position.array;\r\n            \r\n            // Start at box position, end at mouse position\r\n            const localBoxPos = this.scaleInitialBoxPosition.clone().sub(this.scaleFeedbackGroup.position);\r\n            const localMousePos = currentMousePos.clone().sub(this.scaleFeedbackGroup.position);\r\n            const invScale = 1 / this.scaleFeedbackGroup.scale.x;\r\n            localBoxPos.multiplyScalar(invScale);\r\n            localMousePos.multiplyScalar(invScale);\r\n            \r\n            // Set line from box to mouse\r\n            positions[0] = localBoxPos.x;\r\n            positions[1] = localBoxPos.y;\r\n            positions[2] = localBoxPos.z;\r\n            positions[3] = localMousePos.x;\r\n            positions[4] = localMousePos.y;\r\n            positions[5] = localMousePos.z;\r\n            \r\n            this.scaleFeedbackLine.geometry.attributes.position.needsUpdate = true;\r\n        }\r\n        \r\n        // Initialize feedback visuals with current mouse position\r\n        this.updateScaleFeedback(axis, currentMousePos);\r\n        \r\n        // Force immediate overlay update to ensure dashed line is positioned correctly\r\n        if (this.overlay.scene && this.overlay.group && this.overlay.camera) {\r\n            this.updateScaleFeedbackOverlay(axis);\r\n        }\r\n    }\r\n    \r\n    getScaleMousePosition(mouse, camera, axis) {\r\n        // Get the axis direction in world space\r\n        const axisVector = new THREE.Vector3();\r\n        axisVector[axis] = 1;\r\n        \r\n        // Invert Y axis for C3 coordinate system\r\n        if (axis === 'y') {\r\n            axisVector.y = -1;\r\n        }\r\n        \r\n        // Transform to world space if needed\r\n        if (this.transformSpace === 'local' && this.targetObject) {\r\n            axisVector.applyQuaternion(this.targetObject.quaternion);\r\n        }\r\n        \r\n        // Create a ray from camera through mouse\r\n        this.raycaster.setFromCamera(mouse, camera);\r\n        const ray = this.raycaster.ray;\r\n        \r\n        // Find closest point on axis line to mouse ray\r\n        const axisOrigin = this.scaleInitialBoxPosition || this.targetObject.position.clone();\r\n        const axisDirection = axisVector.normalize();\r\n        \r\n        // Using the formula for closest points between two skew lines\r\n        const rayDir = ray.direction;\r\n        const rayOrigin = ray.origin;\r\n        \r\n        const a = rayDir.dot(rayDir);\r\n        const b = rayDir.dot(axisDirection);\r\n        const c = axisDirection.dot(axisDirection);\r\n        const d = rayDir.dot(rayOrigin.clone().sub(axisOrigin));\r\n        const e = axisDirection.dot(rayOrigin.clone().sub(axisOrigin));\r\n        \r\n        const denominator = a * c - b * b;\r\n        \r\n        if (Math.abs(denominator) > 0.00001) {\r\n            const s = (a * e - b * d) / denominator; // Distance along axis\r\n            return axisOrigin.clone().add(axisDirection.clone().multiplyScalar(s));\r\n        }\r\n        \r\n        return axisOrigin.clone();\r\n    }\r\n    \r\n    getMouseWorldPosition(mouse, camera, axis) {\r\n        // Create a plane perpendicular to the rotation axis\r\n        const planeNormal = new THREE.Vector3();\r\n        if (axis === 'x') planeNormal.set(1, 0, 0);\r\n        else if (axis === 'y') planeNormal.set(0, 1, 0);\r\n        else planeNormal.set(0, 0, 1);\r\n        \r\n        if (this.transformSpace === 'local' && this.targetObject) {\r\n            planeNormal.applyQuaternion(this.targetObject.quaternion);\r\n        }\r\n        \r\n        const plane = new THREE.Plane(planeNormal, 0);\r\n        plane.translate(this.gizmoGroup.position);\r\n        \r\n        this.raycaster.setFromCamera(mouse, camera);\r\n        const intersection = new THREE.Vector3();\r\n        this.raycaster.ray.intersectPlane(plane, intersection);\r\n        \r\n        return intersection;\r\n    }\r\n    \r\n    calculateRotationAngle(mouse, camera, axis) {\r\n        // Create a plane perpendicular to the rotation axis\r\n        const planeNormal = new THREE.Vector3();\r\n        if (axis === 'x') planeNormal.set(1, 0, 0);\r\n        else if (axis === 'y') planeNormal.set(0, 1, 0);\r\n        else planeNormal.set(0, 0, 1);\r\n        \r\n        // Transform plane normal to world space if needed\r\n        if (this.transformSpace === 'local' && this.targetObject) {\r\n            planeNormal.applyQuaternion(this.targetObject.quaternion);\r\n        }\r\n        \r\n        const plane = new THREE.Plane(planeNormal, 0);\r\n        plane.translate(this.gizmoGroup.position);\r\n        \r\n        // Cast ray and find intersection with plane\r\n        this.raycaster.setFromCamera(mouse, camera);\r\n        const intersection = new THREE.Vector3();\r\n        this.raycaster.ray.intersectPlane(plane, intersection);\r\n        \r\n        if (!intersection) return 0;\r\n        \r\n        // Convert intersection point to local space of gizmo\r\n        const localPoint = intersection.sub(this.gizmoGroup.position);\r\n        \r\n        // Calculate angle based on axis\r\n        // For left-handed coordinate system with Y-flipped\r\n        let angle = 0;\r\n        if (axis === 'x') {\r\n            // Rotation around X axis: YZ plane\r\n            // In left-handed system, looking from +X (right), clockwise is positive\r\n            angle = Math.atan2(localPoint.y, localPoint.z);\r\n        } else if (axis === 'y') {\r\n            // Rotation around Y axis: XZ plane\r\n            // In left-handed system with Y down, looking from +Y (down), clockwise is positive\r\n            angle = Math.atan2(localPoint.x, localPoint.z);\r\n        } else { // z axis\r\n            // Rotation around Z axis: XY plane\r\n            // In left-handed system, looking from +Z (out), clockwise is positive\r\n            angle = Math.atan2(-localPoint.y, localPoint.x);\r\n        }\r\n        \r\n        return angle;\r\n    }\r\n    \r\n    handleMouseMove(mouse, camera) {\r\n        if (!this.isDragging || !this.activeHandle) {\r\n            // Just hover effect\r\n            return this.updateHover(mouse, camera);\r\n        }\r\n        \r\n        this.dragCurrent.copy(mouse);\r\n        const delta = new THREE.Vector2().subVectors(this.dragCurrent, this.dragStart);\r\n        \r\n        // Apply transformation based on handle type\r\n        switch (this.activeHandle.type) {\r\n            case 'position':\r\n                this.applyPositionTransform(delta, camera);\r\n                break;\r\n            case 'rotation':\r\n                this.applyRotationTransform(mouse, camera);\r\n                break;\r\n            case 'scale':\r\n                this.applyScaleTransform(delta, camera);\r\n                break;\r\n        }\r\n        \r\n        // Update gizmo position to follow object\r\n        this.updateGizmoTransform();\r\n        \r\n        // Update delta label\r\n        this.updateDeltaLabel(mouse);\r\n\r\n        // Update position delta overlay line\r\n        if (this.isDragging && this.activeHandle && this.activeHandle.type === 'position' && this.overlay.scene && this.overlay.group && this.overlay.camera && this._posOverlay && this.positionDragStartWorld) {\r\n            const toScreen = (worldV3) => {\r\n                const v = worldV3.clone().project(this.camera);\r\n                const { width = 1, height = 1 } = (this.overlay.getViewportSize ? this.overlay.getViewportSize() : {});\r\n                const x = (v.x + 1) * 0.5 * width;\r\n                const y = (v.y + 1) * 0.5 * height;\r\n                return new THREE.Vector3(x, y, 0);\r\n            };\r\n            const startScreen = toScreen(this.positionDragStartWorld);\r\n            const currScreen = toScreen(this.targetObject.position);\r\n            const arr = this._posOverlay.geom.attributes.position.array;\r\n            arr[0] = startScreen.x; arr[1] = startScreen.y; arr[2] = 0;\r\n            arr[3] = currScreen.x;  arr[4] = currScreen.y;  arr[5] = 0;\r\n            this._posOverlay.geom.attributes.position.needsUpdate = true;\r\n            this._posOverlay.line.computeLineDistances();\r\n            this._posOverlay.mat.needsUpdate = true;\r\n        }\r\n        \r\n        // Send transform update to main worker\r\n        this.sendTransformUpdate();\r\n        \r\n        return true;\r\n    }\r\n\r\n    // Called from worker to update snap settings\r\n    setSnapConfig(cfg) {\r\n        if (!cfg) return;\r\n        if (typeof cfg.enabled === 'boolean') this.snap.enabled = cfg.enabled;\r\n        if (typeof cfg.angleDeg === 'number') this.snap.angleDeg = cfg.angleDeg;\r\n        if (typeof cfg.snapScale === 'number') this.snap.snapScale = cfg.snapScale;\r\n        if (typeof cfg.localGridCellPx === 'number') this.snap.localGridCellPx = cfg.localGridCellPx;\r\n        // unitsPerCell is derived in worker; if available, set it\r\n        if (typeof cfg.unitsPerCell === 'number') this.snap.unitsPerCell = cfg.unitsPerCell;\r\n        if (cfg.origin && typeof cfg.origin.x === 'number') {\r\n            this.snap.origin.set(cfg.origin.x, cfg.origin.y || 0, cfg.origin.z || 0);\r\n        }\r\n    }\r\n\r\n    // Snap helpers\r\n    snapValueToGrid(v, step, origin = 0) {\r\n        if (!step || step <= 0) return v;\r\n        return Math.round((v - origin) / step) * step + origin;\r\n    }\r\n    snapAngle(angleRad, stepDeg) {\r\n        if (!stepDeg || stepDeg <= 0) return angleRad;\r\n        const step = THREE.MathUtils.degToRad(stepDeg);\r\n        return Math.round(angleRad / step) * step;\r\n    }\r\n    \r\n    applyRotationTransform(mouse, camera) {\r\n        if (!this.activeHandle || !this.targetObject) return;\r\n        \r\n        const axis = this.activeHandle.axis;\r\n        \r\n        // Calculate current angle\r\n        this.rotationCurrentAngle = this.calculateRotationAngle(mouse, camera, axis);\r\n        \r\n        // Calculate angle difference\r\n        let angleDiff = this.rotationCurrentAngle - this.rotationStartAngle;\r\n        \r\n        // Normalize to [-PI, PI]\r\n        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;\r\n        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;\r\n        \r\n        // Snap angle if enabled\r\n        let appliedAngle = angleDiff;\r\n        if (this.snap.enabled) {\r\n            appliedAngle = this.snapAngle(angleDiff, this.snap.angleDeg);\r\n        }\r\n\r\n        // Apply rotation - angleDiff/appliedAngle is in radians\r\n        // For left-handed coordinate system:\r\n        // X and Z rotations: clockwise (from viewer perspective) should increase the value\r\n        // Y rotation: clockwise (from top-down) should increase the value\r\n        // The calculated angle diff needs to be inverted for X and Z to match this\r\n        if (axis === 'x') {\r\n            // Invert the angle diff for X to make clockwise positive\r\n            this.targetObject.rotation.x = this.initialTransform.rotation.x - appliedAngle;\r\n        } else if (axis === 'y') {\r\n            // Y rotation stays as is\r\n            this.targetObject.rotation.y = this.initialTransform.rotation.y + appliedAngle;\r\n        } else if (axis === 'z') {\r\n            // Invert the angle diff for Z to make clockwise positive\r\n            this.targetObject.rotation.z = this.initialTransform.rotation.z - appliedAngle;\r\n        }\r\n        \r\n        // Get mouse world position for extended line\r\n        const mouseWorldPos = this.getMouseWorldPosition(mouse, camera, axis);\r\n        \r\n        // Update rotation feedback visuals\r\n        // Use snapped angle for 3D visuals (lines and pie), keep overlay dashed line following mouse\r\n        const visualCurrent = (this.snap.enabled ? (this.rotationStartAngle + appliedAngle) : this.rotationCurrentAngle);\r\n        const savedCurrent = this.rotationCurrentAngle; // preserve for overlay\r\n        const prevRotationCurrentAngle = this.rotationCurrentAngle;\r\n        this.rotationCurrentAngle = visualCurrent;\r\n        this.updateRotationFeedback(\r\n            this.rotationStartAngle,\r\n            this.rotationCurrentAngle,\r\n            axis,\r\n            this.handleSize.rotation,\r\n            mouseWorldPos,\r\n            mouse\r\n        );\r\n        // Restore actual (unsnapped) current angle for continued computation; overlay uses mouseNDC already\r\n        this.rotationCurrentAngle = prevRotationCurrentAngle;\r\n        \r\n        // Make sure rotation order is preserved\r\n        this.targetObject.rotation.order = this.initialTransform.rotation.order || 'XYZ';\r\n    }\r\n    \r\n    handleMouseUp() {\r\n        if (this.isDragging) {\r\n            const wasPositionDragged = this.activeHandle && this.activeHandle.type === 'position';\r\n            \r\n            // ADDED: Calculate position delta before resetting\r\n            let positionDelta = null;\r\n            if (wasPositionDragged && this.dragStartPosition && this.targetObject) {\r\n                this.dragEndPosition = this.targetObject.position.clone();\r\n                positionDelta = {\r\n                    x: this.dragEndPosition.x - this.dragStartPosition.x,\r\n                    y: this.dragEndPosition.y - this.dragStartPosition.y,\r\n                    z: this.dragEndPosition.z - this.dragStartPosition.z\r\n                };\r\n            }\r\n            \r\n            // Reset drag state first\r\n            this.isDragging = false;\r\n            this.activeHandle = null;\r\n            \r\n            // Then hide delta label\r\n            this.updateDeltaLabel(null);\r\n            \r\n            // Hide rotation feedback\r\n            if (this.rotationFeedbackGroup) {\r\n                this.rotationFeedbackGroup.visible = false;\r\n            }\r\n            \r\n            // Hide scale feedback\r\n            if (this.scaleFeedbackGroup) {\r\n                this.scaleFeedbackGroup.visible = false;\r\n            }\r\n            \r\n            // Hide individual scale feedback elements\r\n            if (this.scaleFeedbackLine) {\r\n                this.scaleFeedbackLine.visible = false;\r\n            }\r\n            if (this.scalePlaceholderBox) {\r\n                this.scalePlaceholderBox.visible = false;\r\n            }\r\n            \r\n            // Hide uniform scale circles\r\n            if (this.uniformScaleStartCircle) {\r\n                this.uniformScaleStartCircle.visible = false;\r\n            }\r\n            if (this.uniformScaleCurrentCircle) {\r\n                this.uniformScaleCurrentCircle.visible = false;\r\n            }\r\n            \r\n            // Restore original scale box visibility\r\n            if (this.originalScaleBox) {\r\n                this.originalScaleBox.visible = true;\r\n                this.originalScaleBox = null;\r\n            }\r\n            \r\n            // Clean up uniform scale tracking\r\n            this.baseScaleValues = null;\r\n            \r\n            // Restore donut visibility (rings and fill)\r\n            if (this.uniformScaleGizmoChildren) {\r\n                this.uniformScaleGizmoChildren.forEach(item => {\r\n                    item.mesh.visible = item.wasVisible;\r\n                });\r\n                this.uniformScaleGizmoChildren = null;\r\n            }\r\n            \r\n            if (this.overlay && this.overlay.group) {\r\n                // Hide overlay visuals after drag\r\n                this.overlay.group.visible = false;\r\n                \r\n                // Hide all overlay lines instead of removing them\r\n                if (this._posOverlay && this._posOverlay.line) {\r\n                    this._posOverlay.line.visible = false;\r\n                }\r\n                if (this._overlayVis && this._overlayVis.extLine) {\r\n                    this._overlayVis.extLine.visible = false;\r\n                }\r\n                if (this._rotOverlay && this._rotOverlay.extLine) {\r\n                    this._rotOverlay.extLine.visible = false;\r\n                }\r\n            }\r\n            \r\n            // Clear scale tracking\r\n            this.scaleInitialBoxPosition = null;\r\n            this.scaleInitialScale = null;\r\n            this.scaleClickDistance = null;\r\n            \r\n            // Reset highlights\r\n            this.gizmoGroup.traverse(child => {\r\n                if (child.material) {\r\n                    this.highlightHandle(child, false);\r\n                }\r\n            });\r\n            \r\n            // Show all gizmos again after dragging\r\n            this.showAllGizmos();\r\n            \r\n            // Send deactivation message\r\n            self.postMessage({\r\n                type: 'GIZMO_ACTIVE',\r\n                data: { active: false }\r\n            });\r\n            \r\n            // If position was dragged, send a message with delta to update camera\r\n            if (wasPositionDragged && this.targetObject && positionDelta) {\r\n                self.postMessage({\r\n                    type: 'POSITION_DRAG_ENDED',\r\n                    data: {\r\n                        position: {\r\n                            x: this.targetObject.position.x,\r\n                            y: this.targetObject.position.y,\r\n                            z: this.targetObject.position.z\r\n                        },\r\n                        delta: positionDelta  // Include the delta for camera follow\r\n                    }\r\n                });\r\n            }\r\n            \r\n            // Clear position tracking\r\n            this.dragStartPosition = null;\r\n            this.dragEndPosition = null;\r\n            this.positionDragStartWorld = null;\r\n            \r\n            return true;\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    \r\n    updateHover(mouse, camera) {\r\n        this.raycaster.setFromCamera(mouse, camera);\r\n        const intersects = this.raycaster.intersectObjects(this.gizmoGroup.children, true);\r\n        \r\n        // Track previous hover state\r\n        const wasHovering = this.hoveredHandle !== null;\r\n        \r\n        // Reset all highlights\r\n        this.gizmoGroup.traverse(child => {\r\n            if (child.material && !this.isDragging) {\r\n                this.resetHandleMaterial(child);\r\n            }\r\n        });\r\n        \r\n        // Highlight hovered object\r\n        if (intersects.length > 0 && !this.isDragging) {\r\n            const object = intersects[0].object;\r\n            if (object.userData.type) {\r\n                this.highlightHandle(object, true);\r\n                this.hoveredHandle = object.userData;\r\n                \r\n                // Send hover message if state changed\r\n                if (!wasHovering) {\r\n                    self.postMessage({\r\n                        type: 'GIZMO_HOVER',\r\n                        data: { hovering: true }\r\n                    });\r\n                }\r\n                \r\n                return true;\r\n            }\r\n        } else {\r\n            this.hoveredHandle = null;\r\n            \r\n            // Send unhover message if state changed\r\n            if (wasHovering) {\r\n                self.postMessage({\r\n                    type: 'GIZMO_HOVER',\r\n                    data: { hovering: false }\r\n                });\r\n            }\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    \r\n    highlightHandle(object, highlight) {\r\n        if (!object.material) return;\r\n        \r\n        if (highlight) {\r\n            // Store original color if not already stored\r\n            if (!object.userData.originalColor) {\r\n                object.userData.originalColor = object.material.color.getHex();\r\n                object.userData.originalOpacity = object.material.opacity;\r\n            }\r\n            \r\n            // Apply highlight\r\n            object.material.color = new THREE.Color(this.colors.hover);\r\n            object.material.opacity = 1.0;\r\n            \r\n            if (object.material.emissive) {\r\n                object.material.emissive = new THREE.Color(this.colors.hover);\r\n                object.material.emissiveIntensity = 0.3;\r\n            }\r\n        } else {\r\n            this.resetHandleMaterial(object);\r\n        }\r\n    }\r\n    \r\n    resetHandleMaterial(object) {\r\n        if (!object.material) return;\r\n        \r\n        // Restore original color\r\n        if (object.userData.originalColor !== undefined) {\r\n            object.material.color.setHex(object.userData.originalColor);\r\n            object.material.opacity = object.userData.originalOpacity || 0.8;\r\n        }\r\n        \r\n        if (object.material.emissive) {\r\n            object.material.emissive = new THREE.Color(0x000000);\r\n            object.material.emissiveIntensity = 0;\r\n        }\r\n    }\r\n    \r\n    applyPositionTransform(delta, camera) {\r\n        if (!this.activeHandle || !this.targetObject) return;\r\n        \r\n        const axis = this.activeHandle.axis;\r\n        \r\n        // Use the current mouse position to find where the initial click point should be\r\n        const mouse = this.dragCurrent;\r\n        \r\n    if (axis.length === 1) {\r\n            // Single axis movement - find closest point on axis line to mouse ray\r\n            const axisVector = new THREE.Vector3();\r\n            axisVector[axis] = 1;\r\n            \r\n            // Invert Y axis for C3 coordinate system\r\n            if (axis === 'y') {\r\n                axisVector.y = -1;\r\n            }\r\n            \r\n            // Transform to world space if needed\r\n            if (this.transformSpace === 'local') {\r\n                axisVector.applyQuaternion(this.targetObject.quaternion);\r\n            }\r\n            \r\n            // Create a ray from camera through mouse position\r\n            this.raycaster.setFromCamera(mouse, camera);\r\n            const ray = this.raycaster.ray;\r\n            \r\n            // The axis line passes through the initial click point, not the object origin\r\n            const axisOrigin = this.initialClickPoint || this.initialTransform.position.clone();\r\n            const axisDirection = axisVector.normalize();\r\n            \r\n            // Find closest points between ray and axis line\r\n            // Using the formula for closest points between two skew lines\r\n            const rayDir = ray.direction;\r\n            const rayOrigin = ray.origin;\r\n            \r\n            const a = rayDir.dot(rayDir);\r\n            const b = rayDir.dot(axisDirection);\r\n            const c = axisDirection.dot(axisDirection);\r\n            const d = rayDir.dot(rayOrigin.clone().sub(axisOrigin));\r\n            const e = axisDirection.dot(rayOrigin.clone().sub(axisOrigin));\r\n            \r\n            const denominator = a * c - b * b;\r\n            \r\n            if (Math.abs(denominator) > 0.00001) {\r\n                // Lines are not parallel\r\n                const t = (b * e - c * d) / denominator; // Distance along ray\r\n                const s = (a * e - b * d) / denominator; // Distance along axis\r\n                \r\n                // Get the closest point on the axis to the mouse\r\n                const targetClickPoint = axisOrigin.clone().add(axisDirection.clone().multiplyScalar(s));\r\n                \r\n                // Calculate where the object should be to put the click point at the target\r\n                const objectOffset = this.initialClickOffset || new THREE.Vector3();\r\n                const newPosition = targetClickPoint.clone().sub(objectOffset);\r\n                \r\n                // Snap to grid on the active single axis only\r\n                if (this.snap.enabled) {\r\n                    const step = this.snap.unitsPerCell || 0; // fallback 0 = no snap\r\n                    if (step > 0) {\r\n                        if (axis === 'x') newPosition.x = this.snapValueToGrid(newPosition.x, step, this.snap.origin.x);\r\n                        else if (axis === 'y') newPosition.y = this.snapValueToGrid(newPosition.y, step, this.snap.origin.y);\r\n                        else if (axis === 'z') newPosition.z = this.snapValueToGrid(newPosition.z, step, this.snap.origin.z);\r\n                    }\r\n                }\r\n                this.targetObject.position.copy(newPosition);\r\n            }\r\n            \r\n        } else {\r\n            // Plane movement (2 axes)\r\n            const axes = axis.split('');\r\n            \r\n            // Create plane normal (perpendicular to the two axes)\r\n            const planeNormal = new THREE.Vector3();\r\n            if (axes.includes('x') && axes.includes('y')) {\r\n                planeNormal.set(0, 0, 1);\r\n            } else if (axes.includes('y') && axes.includes('z')) {\r\n                planeNormal.set(1, 0, 0);\r\n            } else if (axes.includes('x') && axes.includes('z')) {\r\n                planeNormal.set(0, 1, 0);\r\n            }\r\n            \r\n            // Transform to world space if needed\r\n            if (this.transformSpace === 'local') {\r\n                planeNormal.applyQuaternion(this.targetObject.quaternion);\r\n            }\r\n            \r\n            // Create plane at initial click position\r\n            const plane = new THREE.Plane(planeNormal, 0);\r\n            const planePoint = this.initialClickPoint || this.initialTransform.position.clone();\r\n            plane.setFromNormalAndCoplanarPoint(planeNormal, planePoint);\r\n            \r\n            // Cast ray and find intersection with plane\r\n            this.raycaster.setFromCamera(mouse, camera);\r\n            const intersection = new THREE.Vector3();\r\n            this.raycaster.ray.intersectPlane(plane, intersection);\r\n            \r\n            if (intersection) {\r\n                // Calculate where the object should be to put the click point at the intersection\r\n                const objectOffset = this.initialClickOffset || new THREE.Vector3();\r\n                const targetPosition = intersection.clone().sub(objectOffset);\r\n                \r\n                // Constrain movement to the allowed axes\r\n                const newPosition = this.targetObject.position.clone();\r\n                \r\n                if (axes.includes('x')) {\r\n                    newPosition.x = targetPosition.x;\r\n                }\r\n                if (axes.includes('y')) {\r\n                    newPosition.y = targetPosition.y;\r\n                }\r\n                if (axes.includes('z')) {\r\n                    newPosition.z = targetPosition.z;\r\n                }\r\n                \r\n                // Snap to grid on the two allowed axes\r\n                if (this.snap.enabled) {\r\n                    const step = this.snap.unitsPerCell || 0;\r\n                    if (step > 0) {\r\n                        if (axes.includes('x')) newPosition.x = this.snapValueToGrid(newPosition.x, step, this.snap.origin.x);\r\n                        if (axes.includes('y')) newPosition.y = this.snapValueToGrid(newPosition.y, step, this.snap.origin.y);\r\n                        if (axes.includes('z')) newPosition.z = this.snapValueToGrid(newPosition.z, step, this.snap.origin.z);\r\n                    }\r\n                }\r\n                this.targetObject.position.copy(newPosition);\r\n            }\r\n        }\r\n    }\r\n    \r\n    applyScaleTransform(delta, camera) {\r\n        if (!this.activeHandle || !this.targetObject) return;\r\n        \r\n        const axis = this.activeHandle.axis;\r\n        const mouse = this.dragCurrent;\r\n        \r\n        if (axis === 'uniform') {\r\n            // Calculate current mouse position in world space\r\n            this.raycaster.setFromCamera(mouse, camera);\r\n            const intersectPoint = new THREE.Vector3();\r\n            const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);\r\n            plane.translate(this.gizmoGroup.position);\r\n            \r\n            // If camera is looking along Z, use Y plane instead\r\n            const cameraDir = new THREE.Vector3();\r\n            camera.getWorldDirection(cameraDir);\r\n            if (Math.abs(cameraDir.z) > 0.9) {\r\n                plane.normal.set(0, 1, 0);\r\n            }\r\n            \r\n            this.raycaster.ray.intersectPlane(plane, intersectPoint);\r\n            \r\n            const currentDistance = intersectPoint.distanceTo(this.gizmoGroup.position);\r\n            const scaleRatio = currentDistance / this.uniformScaleInitialDistance;\r\n            \r\n            // Update SCALE property (not x/y/z)\r\n            let newScale = this.uniformScaleInitialScale * scaleRatio;\r\n            \r\n            // Apply snapping if enabled\r\n            if (this.snap.enabled && this.snap.snapScale) {\r\n                newScale = Math.round(newScale / this.snap.snapScale) * this.snap.snapScale;\r\n            }\r\n            \r\n            this.targetObject.userData = this.targetObject.userData || {};\r\n            this.targetObject.userData.scale = Math.max(0.01, newScale);\r\n            \r\n            // Also update visual scale uniformly to see the change\r\n            // Apply uniform scale while maintaining the base scale values\r\n            this.targetObject.scale.x = this.baseScaleValues.x * newScale;\r\n            this.targetObject.scale.y = this.baseScaleValues.y * newScale;\r\n            this.targetObject.scale.z = this.baseScaleValues.z * newScale;\r\n            \r\n            // Update visual feedback circles in local space\r\n            if (this.uniformScaleCurrentCircle && this.scaleFeedbackGroup) {\r\n                const localRadius = currentDistance / this.scaleFeedbackGroup.scale.x;\r\n                const circlePoints = new THREE.Path().absarc(0, 0, localRadius, 0, Math.PI * 2, false).getPoints(64);\r\n                this.uniformScaleCurrentCircle.geometry.setFromPoints(circlePoints);\r\n            }\r\n            \r\n            // Update overlay\r\n            if (this.overlay.scene && this.overlay.group) {\r\n                this.dragCurrent = mouse.clone();\r\n                this.updateScaleFeedbackOverlay(axis);\r\n            }\r\n        } else {\r\n            // Get current mouse position projected onto the axis\r\n            const currentMousePos = this.getScaleMousePosition(mouse, camera, axis);\r\n            \r\n            // Calculate the distance from origin to current mouse position\r\n            const origin = this.targetObject.position.clone();\r\n            const currentMouseDistance = currentMousePos.distanceTo(origin);\r\n            \r\n            // Avoid division by zero\r\n            if (this.scaleClickDistance < 0.001) return;\r\n            \r\n            // Calculate scale ratio: if we click at distance D and drag to 2D, scale doubles\r\n            const scaleRatio = currentMouseDistance / this.scaleClickDistance;\r\n            \r\n            // Apply this ratio to the initial scale\r\n            let newScale = this.scaleInitialScale * scaleRatio;\r\n            \r\n            // Apply snapping if enabled\r\n            if (this.snap.enabled && this.snap.snapScale) {\r\n                newScale = Math.round(newScale / this.snap.snapScale) * this.snap.snapScale;\r\n            }\r\n            \r\n            // Apply scale to the specific axis\r\n            this.targetObject.scale[axis] = newScale;\r\n            \r\n            // Update the base scale value for this axis (scale without uniform multiplier)\r\n            const currentUniformScale = this.targetObject.userData?.scale || 1.0;\r\n            if (!this.targetObject.userData) this.targetObject.userData = {};\r\n            if (!this.targetObject.userData.baseScale) {\r\n                this.targetObject.userData.baseScale = { x: 1, y: 1, z: 1 };\r\n            }\r\n            this.targetObject.userData.baseScale[axis] = newScale / currentUniformScale;\r\n            \r\n            // Update scale feedback with current mouse position\r\n            this.updateScaleFeedback(axis, currentMousePos);\r\n        }\r\n        \r\n        // Clamp minimum scale\r\n        this.targetObject.scale.x = Math.max(0.01, this.targetObject.scale.x);\r\n        this.targetObject.scale.y = Math.max(0.01, this.targetObject.scale.y);\r\n        this.targetObject.scale.z = Math.max(0.01, this.targetObject.scale.z);\r\n    }\r\n    \r\n    updateGizmoTransform() {\r\n        if (!this.targetObject || !this.gizmoGroup) return;\r\n        \r\n        // Update gizmo position to match target\r\n        this.gizmoGroup.position.copy(this.targetObject.position);\r\n        \r\n        // Update rotation if in local space\r\n        if (this.transformSpace === 'local') {\r\n            this.gizmoGroup.quaternion.copy(this.targetObject.quaternion);\r\n        } else {\r\n            this.gizmoGroup.quaternion.identity();\r\n        }\r\n        \r\n        // Make uniform scale gizmo face camera\r\n        if (this.uniformScaleGizmo && this.camera) {\r\n            // Calculate look direction from gizmo to camera\r\n            const lookDir = new THREE.Vector3();\r\n            lookDir.subVectors(this.camera.position, this.gizmoGroup.position).normalize();\r\n            \r\n            // Create a rotation that makes the donut face the camera\r\n            const up = new THREE.Vector3(0, 1, 0);\r\n            const rotationMatrix = new THREE.Matrix4();\r\n            rotationMatrix.lookAt(this.gizmoGroup.position, this.camera.position, up);\r\n            \r\n            const quaternion = new THREE.Quaternion();\r\n            quaternion.setFromRotationMatrix(rotationMatrix);\r\n            \r\n            // Apply to uniform scale gizmo within the group\r\n            this.uniformScaleGizmo.quaternion.copy(quaternion);\r\n        }\r\n        \r\n        // Scale gizmo based on camera distance for consistent size\r\n        if (this.camera) {\r\n            const distance = this.camera.position.distanceTo(this.gizmoGroup.position);\r\n            const scale = distance * 0.108; // Increased by 20% from 0.09\r\n            this.gizmoGroup.scale.setScalar(scale);\r\n            \r\n            // Also scale rotation feedback group\r\n            if (this.rotationFeedbackGroup && this.rotationFeedbackGroup.visible) {\r\n                this.rotationFeedbackGroup.position.copy(this.gizmoGroup.position);\r\n                this.rotationFeedbackGroup.quaternion.copy(this.gizmoGroup.quaternion);\r\n                this.rotationFeedbackGroup.scale.setScalar(scale);\r\n            }\r\n            \r\n            // Also scale scale feedback group\r\n            if (this.scaleFeedbackGroup && this.scaleFeedbackGroup.visible) {\r\n                this.scaleFeedbackGroup.position.copy(this.gizmoGroup.position);\r\n                \r\n                // Make feedback circles face camera too when uniform scale is active\r\n                if (this.uniformScaleStartCircle && this.uniformScaleStartCircle.visible && this.uniformScaleGizmo) {\r\n                    // Use same quaternion as uniform scale gizmo to face camera\r\n                    this.scaleFeedbackGroup.quaternion.copy(this.uniformScaleGizmo.quaternion);\r\n                } else {\r\n                    this.scaleFeedbackGroup.quaternion.copy(this.gizmoGroup.quaternion);\r\n                }\r\n                \r\n                this.scaleFeedbackGroup.scale.setScalar(scale);\r\n            }\r\n        }\r\n    }\r\n    \r\n    sendTransformUpdate() {\r\n        if (!this.targetObject) return;\r\n        \r\n        // Convert Three.js transforms to C3 coordinates\r\n        const c3Position = {\r\n            x: this.targetObject.position.x * 64, // Convert to pixels\r\n            y: -this.targetObject.position.y * 64, // Flip Y\r\n            z: this.targetObject.position.z * 64\r\n        };\r\n        \r\n        // Convert Three.js rotation (right-handed) to C3 rotation (left-handed)\r\n        // This is the inverse of convertC3ToThree\r\n        const c3Rotation = {\r\n            x: -(this.targetObject.rotation.x * 180 / Math.PI), // Invert X\r\n            y: this.targetObject.rotation.y * 180 / Math.PI,    // Y stays same\r\n            z: -(this.targetObject.rotation.z * 180 / Math.PI)  // Invert Z\r\n        };\r\n        \r\n        // Build the update message\r\n        const updateData = {\r\n            position: c3Position,\r\n            rotation: c3Rotation,\r\n            source: 'gizmo'\r\n        };\r\n        \r\n        // IMPORTANT: Only send scale data if scale handle was actually used\r\n        if (this.activeHandle && this.activeHandle.type === 'scale') {\r\n            if (this.activeHandle.axis === 'uniform') {\r\n                // Donut was dragged - send SCALE value only\r\n                updateData.uniformScale = this.targetObject.userData?.scale || 1.0;\r\n                // DO NOT send individual x/y/z scale values when uniform scale is used\r\n            } else {\r\n                // Individual axis scale - send ONLY the scale values\r\n                updateData.scale = {\r\n                    x: this.targetObject.scale.x,\r\n                    y: this.targetObject.scale.y,\r\n                    z: this.targetObject.scale.z\r\n                };\r\n                // DO NOT send uniformScale when individual axes are used\r\n                // C3 should maintain its own uniform scale value independently\r\n            }\r\n        }\r\n        \r\n        self.postMessage({\r\n            type: 'GIZMO_TRANSFORM_UPDATE',\r\n            data: updateData\r\n        });\r\n    }\r\n    \r\n    hideInactiveGizmos(activeType) {\r\n        // Get the active axis from the handle\r\n        const activeAxis = this.activeHandle ? this.activeHandle.axis : null;\r\n        \r\n        // Hide all gizmos except the active type\r\n        if (this.positionGizmo) {\r\n            if (activeType === 'position') {\r\n                // Show only the active axis/plane for position\r\n                this.positionGizmo.traverse(child => {\r\n                    if (child.userData && child.userData.axis) {\r\n                        // For single axis, show only that axis\r\n                        // For plane (2 axes), show the plane and its component axes\r\n                        if (activeAxis.length === 1) {\r\n                            // Single axis - hide everything except this axis\r\n                            child.visible = (child.userData.axis === activeAxis);\r\n                        } else {\r\n                            // Plane movement - show the plane and its component axes\r\n                            child.visible = (child.userData.axis === activeAxis || \r\n                                          activeAxis.includes(child.userData.axis));\r\n                        }\r\n                    }\r\n                });\r\n            } else {\r\n                this.positionGizmo.visible = false;\r\n            }\r\n        }\r\n        \r\n        if (this.rotationGizmo) {\r\n            if (activeType === 'rotation') {\r\n                // Show only the active rotation ring\r\n                this.rotationGizmo.traverse(child => {\r\n                    if (child.userData && child.userData.axis) {\r\n                        child.visible = (child.userData.axis === activeAxis);\r\n                    }\r\n                });\r\n            } else {\r\n                this.rotationGizmo.visible = false;\r\n            }\r\n        }\r\n        \r\n        if (this.scaleGizmo) {\r\n            if (activeType === 'scale' && activeAxis !== 'uniform') {\r\n                // Show only the active scale axis\r\n                this.scaleGizmo.traverse(child => {\r\n                    if (child.userData && child.userData.axis) {\r\n                        child.visible = (child.userData.axis === activeAxis);\r\n                    }\r\n                });\r\n            } else {\r\n                this.scaleGizmo.visible = (activeType === 'scale' && activeAxis !== 'uniform');\r\n            }\r\n        }\r\n        \r\n        if (this.uniformScaleGizmo) {\r\n            // Show uniform scale only if it's the active handle\r\n            this.uniformScaleGizmo.visible = (activeType === 'scale' && activeAxis === 'uniform');\r\n        }\r\n    }\r\n    \r\n    showAllGizmos() {\r\n        // Restore visibility based on current mode\r\n        this.setMode(this.transformMode);\r\n        \r\n        // Make sure all children of visible gizmos are also visible\r\n        if (this.positionGizmo && this.positionGizmo.visible) {\r\n            this.positionGizmo.traverse(child => {\r\n                child.visible = true;\r\n            });\r\n        }\r\n        \r\n        if (this.rotationGizmo && this.rotationGizmo.visible) {\r\n            this.rotationGizmo.traverse(child => {\r\n                child.visible = true;\r\n            });\r\n        }\r\n        \r\n        if (this.scaleGizmo && this.scaleGizmo.visible) {\r\n            this.scaleGizmo.traverse(child => {\r\n                child.visible = true;\r\n            });\r\n        }\r\n    }\r\n    \r\n    setMode(mode) {\r\n        this.transformMode = mode;\r\n        \r\n        // Show/hide appropriate gizmos\r\n        if (this.positionGizmo) this.positionGizmo.visible = (mode === 'position' || mode === 'all');\r\n        if (this.rotationGizmo) this.rotationGizmo.visible = (mode === 'rotation' || mode === 'all');\r\n        if (this.scaleGizmo) this.scaleGizmo.visible = (mode === 'scale' || mode === 'all');\r\n        if (this.uniformScaleGizmo) this.uniformScaleGizmo.visible = (mode === 'scale' || mode === 'all');\r\n    }\r\n    \r\n    setSpace(space) {\r\n        this.transformSpace = space;\r\n        this.updateGizmoTransform();\r\n    }\r\n    \r\n    setTarget(object) {\r\n        this.targetObject = object;\r\n        this.updateGizmoTransform();\r\n    }\r\n    \r\n    setVisible(visible) {\r\n        if (this.gizmoGroup) {\r\n            this.gizmoGroup.visible = visible;\r\n        }\r\n        // Rotation feedback visibility is managed during drag operations\r\n        // No need to manage it here since it's only shown during active rotation\r\n    }\r\n    \r\n    update() {\r\n        // Update gizmo each frame\r\n        this.updateGizmoTransform();\r\n    }\r\n    \r\n    dispose() {\r\n        // Dispose main gizmo group\r\n        if (this.gizmoGroup && this.scene) {\r\n            this.scene.remove(this.gizmoGroup);\r\n            \r\n            // Dispose geometries and materials\r\n            this.gizmoGroup.traverse(child => {\r\n                if (child.geometry) child.geometry.dispose();\r\n                if (child.material) {\r\n                    if (Array.isArray(child.material)) {\r\n                        child.material.forEach(mat => mat.dispose());\r\n                    } else {\r\n                        child.material.dispose();\r\n                    }\r\n                }\r\n            });\r\n            \r\n            this.gizmoGroup = null;\r\n        }\r\n        \r\n        // Dispose rotation feedback group\r\n        if (this.rotationFeedbackGroup && this.scene) {\r\n            this.scene.remove(this.rotationFeedbackGroup);\r\n            \r\n            this.rotationFeedbackGroup.traverse(child => {\r\n                if (child.geometry) child.geometry.dispose();\r\n                if (child.material) {\r\n                    if (Array.isArray(child.material)) {\r\n                        child.material.forEach(mat => mat.dispose());\r\n                    } else {\r\n                        child.material.dispose();\r\n                    }\r\n                }\r\n            });\r\n            \r\n            this.rotationFeedbackGroup = null;\r\n        }\r\n        \r\n        // Dispose scale feedback group\r\n        if (this.scaleFeedbackGroup && this.scene) {\r\n            this.scene.remove(this.scaleFeedbackGroup);\r\n            \r\n            this.scaleFeedbackGroup.traverse(child => {\r\n                if (child.geometry) child.geometry.dispose();\r\n                if (child.material) {\r\n                    if (Array.isArray(child.material)) {\r\n                        child.material.forEach(mat => mat.dispose());\r\n                    } else {\r\n                        child.material.dispose();\r\n                    }\r\n                }\r\n            });\r\n            \r\n            this.scaleFeedbackGroup = null;\r\n        }\r\n        \r\n        // Clear component references\r\n        this.positionGizmo = null;\r\n        this.rotationGizmo = null;\r\n        this.scaleGizmo = null;\r\n        this.uniformScaleGizmo = null;\r\n        this.rotationPie = null;\r\n        this.rotationStartLine = null;\r\n        this.rotationCurrentLine = null;\r\n        this.scaleFeedbackLine = null;\r\n        this.scalePlaceholderBox = null;\r\n    }\r\n    \r\n    // Add method to properly clean up existing gizmos\r\n    disposeGroup(group) {\r\n        if (!group) return;\r\n        \r\n        group.traverse((child) => {\r\n            if (child.geometry) child.geometry.dispose();\r\n            if (child.material) {\r\n                if (Array.isArray(child.material)) {\r\n                    child.material.forEach(mat => mat.dispose());\r\n                } else {\r\n                    child.material.dispose();\r\n                }\r\n            }\r\n        });\r\n        \r\n        if (group.parent) {\r\n            group.parent.remove(group);\r\n        }\r\n    }\r\n}\r\n\r\n// Export for worker use\r\nif (typeof self !== 'undefined') {\r\n    self.TransformGizmo = TransformGizmo;\r\n}"
      },
      "utils": {
        "cameraSetup": '// MAIN THREAD: camera-setup.js - C3-Style Camera Controls\r\nfunction setupCameraControls() {\r\n    console.log("[Z3D Editor] \u{1F504} Setting up C3-style camera controls...");\r\n    updateStatus("\u{1F504} Setting up camera controls...", "loading");\r\n    \r\n    const canvas = document.getElementById("three-canvas");\r\n    if (!canvas) {\r\n        console.error("[Z3D Editor] \u274C Canvas not found");\r\n        return false;\r\n    }\r\n    \r\n    try {\r\n        // \u2705 FIXED: Create camera with C3-style orientation (Z up)\r\n        window.camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);\r\n        \r\n        // \u2705 TEMPORARY: Set initial position (will be updated by worker)\r\n        window.camera.position.set(0, -5, 5); // Along NEGATIVE Y-axis\r\n        window.camera.up.set(0, 0, 1); // Z up vector like C3\r\n        window.camera.lookAt(0, 0, 0);\r\n        \r\n        // \u2705 CRITICAL: Make orbitControls global so worker message handler can access it\r\n        window.orbitControls = null; // Initialize as global\r\n        \r\n        if (THREE.OrbitControls) {\r\n            window.orbitControls = new THREE.OrbitControls(window.camera, canvas); // \u2705 Assign to global\r\n            window.orbitControls.enabled = true;\r\n            window.orbitControls.enableDamping = true;\r\n            window.orbitControls.dampingFactor = 0.05;\r\n            window.orbitControls.target.set(0, 0, 0);\r\n            \r\n            // \u2705 FIXED: Configure orbit controls for C3-style navigation\r\n            window.orbitControls.screenSpacePanning = false; // Important for Z-up\r\n            window.orbitControls.maxPolarAngle = Math.PI; // Allow full rotation\r\n            window.orbitControls.minDistance = 0.1;\r\n            window.orbitControls.maxDistance = 1000;\r\n            \r\n            // \u2705 ENHANCED: Update camera AND notify worker of target changes\r\n            let lastTargetUpdate = 0;\r\n            const TARGET_UPDATE_THROTTLE = 100; // ms\r\n            \r\n            window.orbitControls.addEventListener("change", () => {\r\n                console.log("[ORBIT CHANGE] Camera moved!"); // ADD THIS\r\n                const now = Date.now();\r\n                \r\n                if (window.worker) {\r\n                    console.log("[ORBIT CHANGE] Sending to worker"); // ADD THIS\r\n                    \r\n                    // Always send camera updates\r\n                    window.worker.postMessage({\r\n                        type: "CAMERA_UPDATE",\r\n                        data: {\r\n                            position: window.camera.position.toArray(),\r\n                            quaternion: window.camera.quaternion.toArray(),\r\n                            target: window.orbitControls.target.toArray()\r\n                        }\r\n                    });\r\n                    \r\n                    // Throttled target updates\r\n                    if (now - lastTargetUpdate > TARGET_UPDATE_THROTTLE) {\r\n                        window.worker.postMessage({\r\n                            type: "CAMERA_TARGET_UPDATE",\r\n                            data: {\r\n                                target: window.orbitControls.target.toArray(),\r\n                                timestamp: now\r\n                            }\r\n                        });\r\n                        lastTargetUpdate = now;\r\n                    }\r\n                } else {\r\n                    console.warn("[ORBIT CHANGE] No worker available!"); // ADD THIS\r\n                }\r\n            });\r\n            \r\n            // \u2705 NEW: Function to update camera target (called when model moves)\r\n            window.updateCameraTarget = function(newTarget) {\r\n                if (window.orbitControls && newTarget) {\r\n                    console.log("[Z3D Editor] Updating camera target to:", newTarget);\r\n                    window.orbitControls.target.set(newTarget.x || 0, newTarget.y || 0, newTarget.z || 0);\r\n                    window.orbitControls.update();\r\n                }\r\n            };\r\n            \r\n            // \u2705 NEW: Function to sync OrbitControls with worker camera state\r\n            window.syncOrbitControlsToCamera = function(cameraState) {\r\n                if (window.orbitControls && cameraState) {\r\n                    console.log("[Z3D Editor] Syncing OrbitControls to worker camera state:", cameraState);\r\n                    \r\n                    // Temporarily disable events to prevent feedback loop\r\n                    const originalEnabled = window.orbitControls.enabled;\r\n                    window.orbitControls.enabled = false;\r\n                    \r\n                    // Update camera position and target\r\n                    if (cameraState.position) {\r\n                        window.camera.position.fromArray(cameraState.position);\r\n                    }\r\n                    if (cameraState.target) {\r\n                        window.orbitControls.target.fromArray(cameraState.target);\r\n                        window.camera.lookAt(window.orbitControls.target);\r\n                    }\r\n                    if (cameraState.up) {\r\n                        window.camera.up.fromArray(cameraState.up);\r\n                    }\r\n                    \r\n                    // Force OrbitControls to update its internal state\r\n                    window.orbitControls.update();\r\n                    \r\n                    // Re-enable controls after a brief delay to prevent jump\r\n                    setTimeout(() => {\r\n                        window.orbitControls.enabled = true;\r\n                        console.log("[Z3D Editor] OrbitControls sync complete, controls re-enabled");\r\n                    }, 50);\r\n                }\r\n            };\r\n            \r\n            console.log("[Z3D Editor] \u2705 C3-style OrbitControls created and made global");\r\n\r\n            console.log("[Z3D Editor] Canvas for OrbitControls:", canvas);\r\n            console.log("[Z3D Editor] Canvas id:", canvas.id);\r\n            console.log("[Z3D Editor] Canvas in DOM:", document.body.contains(canvas));\r\n            console.log("[Z3D Editor] OrbitControls created:", window.orbitControls);\r\n            console.log("[Z3D Editor] OrbitControls enabled:", window.orbitControls.enabled);\r\n\r\n            // Also check after a delay\r\n            setTimeout(() => {\r\n                console.log("[Z3D Editor] After 1s - OrbitControls enabled:", window.orbitControls?.enabled);\r\n                console.log("[Z3D Editor] After 1s - Canvas in DOM:", document.body.contains(canvas));\r\n                \r\n                // FORCE ENABLE if still disabled\r\n                if (window.orbitControls && !window.orbitControls.enabled) {\r\n                    console.warn("[Z3D Editor] OrbitControls still disabled after 1s, forcing enable!");\r\n                    window.orbitControls.enabled = true;\r\n                }\r\n            }, 1000);\r\n        }\r\n        \r\n        // \u2705 ENHANCED: Animation loop with C3-style camera updates\r\n        function animate() {\r\n            if (window.orbitControls) {\r\n                window.orbitControls.update();\r\n                \r\n                // \u2705 Ensure camera up vector stays Z (in case it drifts)\r\n                if (window.camera.up.z < 0.9) { // Tolerance for drift\r\n                    window.camera.up.set(0, 0, 1);\r\n                    console.log("[Z3D Editor] Corrected camera up vector to Z");\r\n                }\r\n            }\r\n            requestAnimationFrame(animate);\r\n        }\r\n        animate();\r\n        \r\n        console.log("[Z3D Editor] \u2705 C3-style camera controls ready");\r\n        return true;\r\n        \r\n    } catch (error) {\r\n        console.error("[Z3D Editor] \u274C Camera setup failed:", error);\r\n        updateStatus("\u274C Camera setup failed: " + error.message, "error");\r\n        return false;\r\n    }\r\n}\r\n\r\n// \u2705 NEW: Function to handle model position changes\r\nfunction handleModelPositionChange(newPosition) {\r\n    console.log("[Z3D Editor] Model position changed:", newPosition);\r\n    \r\n    // Update camera target to follow the model\r\n    if (window.updateCameraTarget) {\r\n        window.updateCameraTarget(newPosition);\r\n    }\r\n}\r\n\r\n// \u2705 NEW: Global function to reset camera view\r\nfunction resetCameraView() {\r\n    if (window.camera) {\r\n        window.camera.position.set(5, -5, 5);\r\n        window.camera.up.set(0, 0, 1);\r\n        window.camera.lookAt(0, 0, 0);\r\n        \r\n        // Update orbit controls target if available\r\n        if (window.updateCameraTarget) {\r\n            window.updateCameraTarget({ x: 0, y: 0, z: 0 });\r\n        }\r\n        \r\n        console.log("[Z3D Editor] Camera view reset to C3-style default");\r\n    }\r\n}',
        "canvasManager": "/* FILE: templates/scripts/utils/canvas-manager.js */\r\n/* Manages canvas sizing for both offscreen and regular modes */\r\n\r\nclass CanvasManager {\r\n    constructor() {\r\n        this.canvas = null;\r\n        this.mode = 'regular'; // 'offscreen' or 'regular'\r\n        this.worker = null;\r\n        this.lastSize = { width: 0, height: 0 };\r\n        this.resizeObserver = null;\r\n    }\r\n\r\n    /**\r\n     * Initialize with worker reference\r\n     */\r\n    initialize(worker) {\r\n        this.worker = worker;\r\n        this.canvas = document.getElementById('three-canvas');\r\n        \r\n        if (!this.canvas) {\r\n            console.error('[CanvasManager] Canvas element not found');\r\n            return false;\r\n        }\r\n\r\n        console.log('[CanvasManager] Initializing...');\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Setup canvas for rendering (called from model-loader.js)\r\n     */\r\n    setupCanvas(config = {}) {\r\n        if (!this.canvas || !this.worker) {\r\n            console.error('[CanvasManager] Not properly initialized');\r\n            return false;\r\n        }\r\n\r\n        // Get initial size from viewport\r\n        const viewport = document.getElementById('viewport-area') || this.canvas.parentElement;\r\n        const rect = viewport.getBoundingClientRect();\r\n        const width = Math.max(1, Math.floor(rect.width));\r\n        const height = Math.max(1, Math.floor(rect.height));\r\n\r\n        console.log(`[CanvasManager] Setting up canvas at ${width}x${height}`);\r\n\r\n        // Check if offscreen is supported\r\n        if (typeof this.canvas.transferControlToOffscreen === 'function') {\r\n            return this.setupOffscreenCanvas(width, height, config);\r\n        } else {\r\n            return this.setupRegularCanvas(width, height, config);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Setup offscreen canvas (preferred for performance)\r\n     */\r\n    setupOffscreenCanvas(width, height, config) {\r\n        try {\r\n            console.log('[CanvasManager] Using OffscreenCanvas mode');\r\n            \r\n            // CRITICAL: Set dimensions BEFORE transfer\r\n            this.canvas.width = width;\r\n            this.canvas.height = height;\r\n            \r\n            // Remove any inline styles\r\n            this.cleanCanvasStyles();\r\n            \r\n            // Transfer to offscreen\r\n            const offscreen = this.canvas.transferControlToOffscreen();\r\n            this.mode = 'offscreen';\r\n            \r\n            // Send to worker with config\r\n            this.worker.postMessage({\r\n                type: 'SETUP_CANVAS',\r\n                data: {\r\n                    canvas: offscreen,\r\n                    width: width,\r\n                    height: height,\r\n                    mode: 'offscreen',\r\n                    cameraParams: config.cameraParams || {\r\n                        position: [5, -5, 5],\r\n                        target: [0, 0, 0]\r\n                    },\r\n                    initialState: config.initialState || {}\r\n                }\r\n            }, [offscreen]);\r\n            \r\n            // Setup resize monitoring\r\n            this.setupResizeMonitoring();\r\n            \r\n            this.lastSize = { width, height };\r\n            console.log('[CanvasManager] OffscreenCanvas setup complete');\r\n            return true;\r\n            \r\n        } catch (error) {\r\n            console.error('[CanvasManager] OffscreenCanvas setup failed:', error);\r\n            // Fall back to regular canvas\r\n            return this.setupRegularCanvas(width, height, config);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Setup regular canvas (fallback)\r\n     */\r\n    setupRegularCanvas(width, height, config) {\r\n        console.log('[CanvasManager] Using regular canvas mode (fallback)');\r\n        \r\n        this.mode = 'regular';\r\n        \r\n        // Set dimensions\r\n        this.canvas.width = width;\r\n        this.canvas.height = height;\r\n        \r\n        // Clean styles\r\n        this.cleanCanvasStyles();\r\n        \r\n        // Send setup message\r\n        this.worker.postMessage({\r\n            type: 'SETUP_CANVAS_FALLBACK',\r\n            data: {\r\n                canvasId: 'three-canvas',\r\n                width: width,\r\n                height: height,\r\n                mode: 'regular',\r\n                cameraParams: config.cameraParams || {\r\n                    position: [5, -5, 5],\r\n                    target: [0, 0, 0]\r\n                },\r\n                initialState: config.initialState || {}\r\n            }\r\n        });\r\n        \r\n        // Setup resize monitoring\r\n        this.setupResizeMonitoring();\r\n        \r\n        this.lastSize = { width, height };\r\n        console.log('[CanvasManager] Regular canvas setup complete');\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Clean canvas inline styles\r\n     */\r\n    cleanCanvasStyles() {\r\n        if (!this.canvas) return;\r\n        \r\n        // Remove size-related inline styles\r\n        this.canvas.style.removeProperty('width');\r\n        this.canvas.style.removeProperty('height');\r\n        this.canvas.style.removeProperty('position');\r\n        this.canvas.style.removeProperty('top');\r\n        this.canvas.style.removeProperty('left');\r\n        this.canvas.style.removeProperty('right');\r\n        this.canvas.style.removeProperty('bottom');\r\n        \r\n        // Keep only touch-action and ensure canvas is below topbar\r\n        this.canvas.style.touchAction = 'none';\r\n        this.canvas.style.zIndex = '0';\r\n    }\r\n\r\n    /**\r\n     * Setup resize monitoring\r\n     */\r\n    setupResizeMonitoring() {\r\n        const viewport = document.getElementById('viewport-area') || this.canvas.parentElement;\r\n        \r\n        // Use ResizeObserver for reliable size detection\r\n        this.resizeObserver = new ResizeObserver((entries) => {\r\n            if (entries.length === 0) return;\r\n            \r\n            const entry = entries[0];\r\n            const rect = entry.contentRect;\r\n            const width = Math.max(1, Math.floor(rect.width));\r\n            const height = Math.max(1, Math.floor(rect.height));\r\n            \r\n            // Skip if size hasn't changed\r\n            if (width === this.lastSize.width && height === this.lastSize.height) {\r\n                return;\r\n            }\r\n            \r\n            this.updateSize(width, height);\r\n        });\r\n        \r\n        this.resizeObserver.observe(viewport);\r\n        console.log('[CanvasManager] Resize monitoring active');\r\n    }\r\n\r\n    /**\r\n     * Update canvas size\r\n     */\r\n    updateSize(width, height) {\r\n        if (!this.worker) return;\r\n        \r\n        console.log(`[CanvasManager] Updating size to ${width}x${height} (mode: ${this.mode})`);\r\n        \r\n        if (this.mode === 'offscreen') {\r\n            // For offscreen canvas, we can ONLY send a message\r\n            // DO NOT touch canvas.width or canvas.height!\r\n            this.worker.postMessage({\r\n                type: 'UPDATE_RENDER_SIZE',\r\n                data: { width, height }\r\n            });\r\n        } else {\r\n            // For regular canvas, we can update dimensions\r\n            this.canvas.width = width;\r\n            this.canvas.height = height;\r\n            \r\n            // Clean any inline styles that might have been added\r\n            this.cleanCanvasStyles();\r\n            \r\n            // Also notify worker\r\n            this.worker.postMessage({\r\n                type: 'UPDATE_RENDER_SIZE',\r\n                data: { width, height }\r\n            });\r\n        }\r\n        \r\n        this.lastSize = { width, height };\r\n    }\r\n\r\n    /**\r\n     * Force immediate resize (called by resizers)\r\n     */\r\n    forceResize() {\r\n        const viewport = document.getElementById('viewport-area') || this.canvas.parentElement;\r\n        const rect = viewport.getBoundingClientRect();\r\n        const width = Math.max(1, Math.floor(rect.width));\r\n        const height = Math.max(1, Math.floor(rect.height));\r\n        \r\n        if (width !== this.lastSize.width || height !== this.lastSize.height) {\r\n            this.updateSize(width, height);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Cleanup\r\n     */\r\n    dispose() {\r\n        if (this.resizeObserver) {\r\n            this.resizeObserver.disconnect();\r\n            this.resizeObserver = null;\r\n        }\r\n        this.canvas = null;\r\n        this.worker = null;\r\n        console.log('[CanvasManager] Disposed');\r\n    }\r\n}\r\n\r\n// Create global instance\r\nwindow.canvasManager = new CanvasManager();",
        "commonFunctions": '// FILE: templates/scripts/utils/common-functions.js (NEW FILE TO CREATE)\r\n// Global variables\r\nlet camera = null;\r\nlet worker = null;\r\nlet uiManager = null;\r\n\r\nfunction waitForThreeJS() {\r\n    return new Promise((resolve, reject) => {\r\n        let attempts = 0;\r\n        const maxAttempts = 50;\r\n        \r\n        function check() {\r\n            attempts++;\r\n            \r\n            if (typeof THREE !== "undefined") {\r\n                console.log("[Z3D Editor] \u2705 THREE.js detected, version:", THREE.REVISION);\r\n                console.log("[Z3D Editor] Available extensions:", {\r\n                    GLTFLoader: typeof THREE.GLTFLoader !== "undefined" || typeof GLTFLoader !== "undefined",\r\n                    OrbitControls: typeof THREE.OrbitControls !== "undefined"\r\n                });\r\n                resolve(THREE);\r\n            } else if (attempts >= maxAttempts) {\r\n                reject(new Error("THREE.js failed to load within timeout"));\r\n            } else {\r\n                setTimeout(check, 100);\r\n            }\r\n        }\r\n        \r\n        check();\r\n    });\r\n}\r\n\r\nfunction updateStatus(message, type) {\r\n    console.log("[Z3D Editor]", message);\r\n    \r\n    const statusEl = document.getElementById("status-message");\r\n    if (statusEl) {\r\n        statusEl.className = "status-message " + (type || "info");\r\n        statusEl.innerHTML = "<strong>" + message + "</strong>";\r\n    }\r\n}\r\n\r\nfunction hideLoadingIndicator() {\r\n    const loading = document.getElementById("loading-indicator");\r\n    if (loading) {\r\n        loading.classList.add("hidden");\r\n        setTimeout(() => loading.style.display = "none", 500);\r\n    }\r\n}\r\n\r\nfunction getConfig() {\r\n    let config = {};\r\n    \r\n    // Try multiple methods to get the config\r\n    try {\r\n        // Method 1: Try from hidden div (most reliable)\r\n        const configEl = document.getElementById("z3d-config");\r\n        if (configEl && configEl.textContent) {\r\n            config = JSON.parse(configEl.textContent);\r\n            console.log("[Z3D Editor] Config loaded from z3d-config element");\r\n        }\r\n    } catch (error) {\r\n        console.warn("[Z3D Editor] Failed to parse z3d-config:", error);\r\n    }\r\n    \r\n    // Method 2: Try from script tag\r\n    if (!config.instanceId) {\r\n        try {\r\n            const buildConfigEl = document.getElementById("build-config");\r\n            if (buildConfigEl && buildConfigEl.textContent) {\r\n                const buildConfig = JSON.parse(buildConfigEl.textContent);\r\n                config = { ...config, ...buildConfig };\r\n                console.log("[Z3D Editor] Config loaded from build-config element");\r\n            }\r\n        } catch (error) {\r\n            console.warn("[Z3D Editor] Failed to parse build-config:", error);\r\n        }\r\n    }\r\n    \r\n    // Method 3: Fallback with reasonable defaults\r\n    if (!config.instanceId) {\r\n        console.warn("[Z3D Editor] No config found, using fallback");\r\n        config = {\r\n            instanceId: 0,\r\n            modelPath: "",\r\n            debugMode: false,\r\n            timestamp: Date.now()\r\n        };\r\n    }\r\n    \r\n    // Ensure required properties exist\r\n    config.instanceId = config.instanceId || 0;\r\n    config.modelPath = config.modelPath || "";\r\n    config.debugMode = config.debugMode || false;\r\n    \r\n    console.log("[Z3D Editor] Final config:", config);\r\n    return config;\r\n}',
        "parentCommunication": `/**\r
 * Parent Communication - COMPLETE VERSION\r
 */\r
\r
// Global state\r
let editorInitialized = false;\r
let editorIsDragging = false;\r
let pendingUpdate = null;\r
let updateTimeout = null;\r
\r
function setupParentCommunication() {\r
    console.log('[Z3D Editor] Setting up parent communication');\r
    \r
    window.addEventListener('message', function(event) {\r
        if (event.source !== window.opener) return;\r
        \r
        const { type, data } = event.data;\r
        console.log('[Z3D Editor] Received message:', type);\r
        \r
        switch (type) {\r
            case 'INITIAL_STATE':\r
                handleInitialState(data);\r
                break;\r
                \r
            case 'STATE_UPDATE':\r
                handleStateUpdate(data);\r
                break;\r
                \r
            case 'MODEL_DATA_RESPONSE':\r
                handleModelDataResponse(data);\r
                break;\r
        }\r
    });\r
    \r
    // Listen for drag events from object controls\r
    window.addEventListener('z3d-drag-state', (e) => {\r
        editorIsDragging = !!e.detail?.dragging;\r
        \r
        if (!editorIsDragging && pendingUpdate) {\r
            setTimeout(() => {\r
                if (pendingUpdate) {\r
                    handleStateUpdate(pendingUpdate);\r
                    pendingUpdate = null;\r
                }\r
            }, 50);\r
        }\r
    });\r
    \r
    // Notify parent that editor is ready\r
    if (window.opener && !window.opener.closed) {\r
        window.opener.postMessage({\r
            type: 'EDITOR_READY',\r
            data: { timestamp: Date.now() }\r
        }, '*');\r
    }\r
    \r
    console.log('[Z3D Editor] Parent communication ready');\r
}\r
\r
function handleInitialState(data) {\r
    if (editorInitialized) {\r
        console.log('[Z3D Editor] Already initialized, ignoring');\r
        return;\r
    }\r
    \r
    console.log('[Z3D Editor] Initial state received:', data);\r
    editorInitialized = true;\r
    \r
    // Store animation state for later use (only if it has actual data)\r
    if (data.animation) {\r
        console.log('[Z3D Editor] Received animation state:', data.animation);\r
        // Only store if there's an actual animation selected (not null/undefined)\r
        if (data.animation.currentAnimation !== null && data.animation.currentAnimation !== undefined) {\r
            window.initialAnimationState = data.animation;\r
            console.log('[Z3D Editor] Stored initial animation state:', data.animation);\r
        } else {\r
            console.log('[Z3D Editor] Animation state is default/empty, not storing');\r
        }\r
    }\r
    \r
    // Store node visibility state\r
    if (data.nodeVisibility) {\r
        window.initialNodeVisibility = data.nodeVisibility;\r
        console.log('[Z3D Editor] Stored initial node visibility:', data.nodeVisibility);\r
    }\r
    \r
    // Apply to UI\r
    if (window.objectControls) {\r
        window.objectControls.setState(data);\r
        console.log('[Z3D Editor] Applied initial state to UI');\r
    }\r
    \r
    // Send to worker if ready\r
    if (window.worker) {\r
        window.worker.postMessage({\r
            type: 'UPDATE_STATE',\r
            data: {\r
                ...data,\r
                source: 'initial'\r
            }\r
        });\r
    }\r
    \r
    // Request model if we have a path\r
    if (data.modelPath) {\r
        requestModelData(data.modelPath);\r
    }\r
    \r
    // Confirm initialization\r
    if (window.opener && !window.opener.closed) {\r
        window.opener.postMessage({\r
            type: 'INITIALIZATION_COMPLETE',\r
            data: { timestamp: Date.now() }\r
        }, '*');\r
    }\r
}\r
\r
function handleStateUpdate(data) {\r
    if (!editorInitialized) {\r
        console.log('[Z3D Editor] Not initialized, queuing update');\r
        pendingUpdate = data;\r
        return;\r
    }\r
    \r
    // Debounce rapid updates\r
    if (updateTimeout) {\r
        clearTimeout(updateTimeout);\r
    }\r
    \r
    updateTimeout = setTimeout(() => {\r
        if (editorIsDragging) {\r
            console.log('[Z3D Editor] Dragging, queuing update');\r
            pendingUpdate = data;\r
            return;\r
        }\r
        \r
        console.log('[Z3D Editor] Applying state update');\r
        \r
        // Update UI\r
        if (window.objectControls) {\r
            window.objectControls.setState(data);\r
        }\r
        \r
        // Update worker\r
        if (window.worker) {\r
            window.worker.postMessage({\r
                type: 'UPDATE_STATE',\r
                data: {\r
                    ...data,\r
                    source: 'c3'\r
                }\r
            });\r
        }\r
    }, 10);\r
}\r
\r
function handleModelDataResponse(data) {\r
    console.log('[Z3D Editor] Model data response received');\r
    \r
    if (data && data.success && data.modelData && window.worker) {\r
        try {\r
            updateStatus("Loading 3D model...", "loading");\r
            \r
            const modelBlob = new Blob([data.modelData], { type: "model/gltf-binary" });\r
            const modelUrl = URL.createObjectURL(modelBlob);\r
            \r
            window.worker.postMessage({ \r
                type: "LOAD_MODEL", \r
                data: { \r
                    modelUrl: modelUrl,\r
                    modelPath: data.modelPath \r
                } \r
            });\r
            \r
            setTimeout(() => {\r
                try {\r
                    URL.revokeObjectURL(modelUrl);\r
                } catch {}\r
            }, 10000);\r
            \r
        } catch (error) {\r
            console.error('[Z3D Editor] Error processing model:', error);\r
            updateStatus("Model processing failed: " + error.message, "error");\r
        }\r
    } else if (data && !data.success) {\r
        updateStatus("Model loading failed: " + (data.error || "Unknown error"), "error");\r
    }\r
}\r
\r
function requestModelData(modelPath) {\r
    if (!modelPath || !window.opener) return;\r
    \r
    console.log('[Z3D Editor] Requesting model data:', modelPath);\r
    \r
    window.opener.postMessage({\r
        type: 'REQUEST_MODEL_DATA',\r
        data: { modelPath: modelPath }\r
    }, '*');\r
}\r
\r
function sendTransformsToParent(transform, deltaTransform) {\r
    if (!window.opener || window.opener.closed) return;\r
    \r
    console.log('[Z3D Editor] Sending transforms to parent');\r
    \r
    window.opener.postMessage({\r
        type: 'TRANSFORMS_UPDATE',\r
        data: {\r
            transform: transform,\r
            deltaTransform: deltaTransform\r
        }\r
    }, '*');\r
}\r
\r
function sendSkinnedMeshToParent(skinnedMeshData) {\r
    if (!window.opener || window.opener.closed) return;\r
    \r
    console.log('[Z3D Editor] Sending skinned mesh update to parent');\r
    \r
    window.opener.postMessage({\r
        type: 'SKINNED_MESH_UPDATE',\r
        data: skinnedMeshData\r
    }, '*');\r
}\r
\r
function updateStatus(message, type) {\r
    const statusElement = document.getElementById('status-message');\r
    if (statusElement) {\r
        statusElement.textContent = message;\r
        statusElement.className = type || '';\r
    }\r
}\r
\r
// Make functions globally available\r
window.setupParentCommunication = setupParentCommunication;\r
window.sendTransformsToParent = sendTransformsToParent;\r
window.sendSkinnedMeshToParent = sendSkinnedMeshToParent;\r
window.requestModelData = requestModelData;\r
window.editorInitialized = editorInitialized;\r
\r
// Auto-setup\r
if (document.readyState === 'loading') {\r
    document.addEventListener('DOMContentLoaded', setupParentCommunication);\r
} else {\r
    setupParentCommunication();\r
}`,
        "workerInitialization": `// FILE: templates/scripts/utils/worker-initialization.js\r
\r
let modelRequested = false;\r
let canvasSetupComplete = false;\r
\r
function initializeWorker() {\r
    console.log("[Z3D Editor] \u{1F504} Initializing worker with Three.js support...");\r
    updateStatus("\u{1F504} Starting 3D renderer...", "loading");\r
    \r
    const workerCode = createWorkerCodeWithThreeJS();\r
    \r
    try {\r
        const workerBlob = new Blob([workerCode], { type: "application/javascript" });\r
        const workerUrl = URL.createObjectURL(workerBlob);\r
        window.worker = new Worker(workerUrl);\r
        \r
        window.worker.addEventListener("message", function(event) {\r
            const { type, data } = event.data;\r
            \r
            switch (type) {\r
                case "WORKER_READY":\r
                    console.log("[Z3D Editor] \u2705 Worker initialized with Three.js");\r
                    \r
                    // Attach ViewerManager to worker\r
                    if (window.viewerManager) {\r
                        window.viewerManager.attachToWorker();\r
                        console.log("[Z3D Editor] \u2705 ViewerManager attached to worker");\r
                    }\r
                    \r
                    // Setup canvas with initial state\r
                    setupCanvasInWorker();\r
                    break;\r
                    \r
                case "CANVAS_READY":\r
                    console.log("[Z3D Editor] \u2705 3D Scene ready");\r
                    canvasSetupComplete = true;\r
                    hideLoadingIndicator();\r
                    updateStatus("\u2705 3D Scene ready with camera controls", "success");\r
                    \r
                    // Mark canvas as ready for parent communication\r
                    if (window.markCanvasReady) {\r
                        window.markCanvasReady();\r
                    }\r
                    \r
                    // Request model ONLY ONCE after canvas is ready\r
                    if (!modelRequested) {\r
                        const config = getConfig();\r
                        if (config && config.modelPath) {\r
                            console.log("[Z3D Editor] Requesting model:", config.modelPath);\r
                            modelRequested = true;\r
                            requestModelFromParent(config.modelPath);\r
                        }\r
                    }\r
                    break;\r
                    \r
                case "MODEL_LOADED":\r
                    if (data && data.success) {\r
                        console.log("[Z3D Editor] \u2705 Model loaded successfully");\r
                        const config = getConfig();\r
                        updateStatus("\u2705 Model loaded: " + (config ? config.modelPath : "unknown"), "success");\r
                    } else {\r
                        console.error("[Z3D Editor] \u274C Model load failed:", data ? data.error : "unknown");\r
                        updateStatus("\u274C Model load failed", "error");\r
                    }\r
                    break;\r
                \r
                case 'INITIAL_CAMERA_STATE':\r
                    console.log("[Z3D Editor] Initial camera state received:", data);\r
                    if (window.syncOrbitControlsToCamera) {\r
                        window.syncOrbitControlsToCamera(data);\r
                    }\r
                    break;\r
\r
                case 'CAMERA_FOLLOW_REQUEST':\r
                    if (window.orbitControls && data.deltaPosition) {\r
                        const delta = data.deltaPosition;\r
                        if (!window._cameraFollowPendingOffset) {\r
                            window._cameraFollowPendingOffset = new THREE.Vector3();\r
                        }\r
                        \r
                        // First follow: apply instantly\r
                        if (!window._cameraFollowFirstApplied) {\r
                            window.camera.position.x += delta.x;\r
                            window.camera.position.y += delta.y;\r
                            window.camera.position.z += delta.z;\r
                            window.orbitControls.target.x += delta.x;\r
                            window.orbitControls.target.y += delta.y;\r
                            window.orbitControls.target.z += delta.z;\r
                            window.orbitControls.update();\r
                            window._cameraFollowFirstApplied = true;\r
                            break;\r
                        }\r
                        \r
                        // Subsequent follows: smooth\r
                        window._cameraFollowPendingOffset.x += delta.x;\r
                        window._cameraFollowPendingOffset.y += delta.y;\r
                        window._cameraFollowPendingOffset.z += delta.z;\r
\r
                        if (!window._cameraFollowSmoothingActive) {\r
                            window._cameraFollowSmoothingActive = true;\r
                            const SMOOTH_FACTOR = 0.25;\r
                            const EPS = 1e-4;\r
                            const applySmoothing = () => {\r
                                const off = window._cameraFollowPendingOffset;\r
                                const len = Math.abs(off.x) + Math.abs(off.y) + Math.abs(off.z);\r
                                if (len < EPS) {\r
                                    off.x = off.y = off.z = 0;\r
                                    window._cameraFollowSmoothingActive = false;\r
                                    return;\r
                                }\r
                                const stepX = off.x * SMOOTH_FACTOR;\r
                                const stepY = off.y * SMOOTH_FACTOR;\r
                                const stepZ = off.z * SMOOTH_FACTOR;\r
                                window.camera.position.x += stepX;\r
                                window.camera.position.y += stepY;\r
                                window.camera.position.z += stepZ;\r
                                window.orbitControls.target.x += stepX;\r
                                window.orbitControls.target.y += stepY;\r
                                window.orbitControls.target.z += stepZ;\r
                                off.x -= stepX;\r
                                off.y -= stepY;\r
                                off.z -= stepZ;\r
                                window.orbitControls.update();\r
                                requestAnimationFrame(applySmoothing);\r
                            };\r
                            requestAnimationFrame(applySmoothing);\r
                        }\r
                    }\r
                    break;\r
\r
                case 'CAMERA_FOLLOW_SETTING_CHANGED':\r
                    console.log('[Z3D Editor] Camera follow settings changed:', data);\r
                    break;\r
                    \r
                case "MODEL_ERROR":\r
                    console.error("[Z3D Editor] \u274C Model loading error:", data ? data.error : "unknown");\r
                    updateStatus("\u274C Model loading failed: " + (data ? data.error : "unknown"), "error");\r
                    break;\r
                    \r
                case "ERROR":\r
                    console.error("[Z3D Editor] \u274C Worker error:", data ? data.error : "unknown");\r
                    updateStatus("\u274C Worker error: " + (data ? data.error : "unknown"), "error");\r
                    break;\r
            }\r
        });\r
        \r
        setTimeout(() => URL.revokeObjectURL(workerUrl), 5000);\r
        return true;\r
        \r
    } catch (error) {\r
        console.error("[Z3D Editor] \u274C Worker creation failed:", error);\r
        updateStatus("\u274C Worker creation failed", "error");\r
        return false;\r
    }\r
}\r
\r
function setupCanvasInWorker() {\r
    console.log("[Z3D Editor] Setting up canvas in worker...");\r
    \r
    let config = null;\r
    if (typeof getConfig === 'function') {\r
        try {\r
            config = getConfig();\r
        } catch (error) {\r
            console.error("[Z3D Editor] Error calling getConfig():", error);\r
        }\r
    }\r
    \r
    if (!config) {\r
        const configElement = document.getElementById('z3d-config');\r
        if (configElement) {\r
            try {\r
                config = JSON.parse(configElement.textContent);\r
            } catch (parseError) {\r
                console.error("[Z3D Editor] Failed to parse config:", parseError);\r
            }\r
        }\r
    }\r
    \r
    if (!config) {\r
        console.error("[Z3D Editor] No configuration available");\r
        return;\r
    }\r
    \r
    // USE CANVAS MANAGER for setup\r
    if (window.canvasManager && window.worker) {\r
        console.log("[Z3D Editor] Using canvas manager for setup");\r
        \r
        // \u2705 FIX: Use the correct path to the initial state!\r
        const setupConfig = {\r
            cameraParams: {\r
                position: [5, -5, 5],\r
                target: [0, 0, 0]\r
            },\r
            initialState: config.initialState || {\r
                transform: {\r
                    position: { x: 0, y: 0, z: 0 },\r
                    rotation: { x: 0, y: 0, z: 0 },\r
                    scale: { x: 1, y: 1, z: 1 },\r
                    uniformScale: 1,\r
                    unitScale: 64,\r
                    rotationOrder: 'ZXY'\r
                },\r
                deltaTransform: {\r
                    position: { x: 0, y: 0, z: 0 },\r
                    rotation: { x: 0, y: 0, z: 0 },\r
                    scale: { x: 1, y: 1, z: 1 }\r
                },\r
                wireframe: false\r
            }\r
        };\r
        \r
        console.log("[Z3D Editor] Sending to canvas manager:", setupConfig);\r
        \r
        // Let canvas manager handle the setup\r
        window.canvasManager.setupCanvas(setupConfig);\r
    } else {\r
        console.error("[Z3D Editor] Canvas manager or worker not available");\r
    }\r
}\r
\r
// Request model data from parent window\r
function requestModelFromParent(modelPath) {\r
    if (window.opener && !window.opener.closed) {\r
        updateStatus("\u{1F504} Requesting model data...", "loading");\r
        window.opener.postMessage({\r
            type: "REQUEST_MODEL_DATA",\r
            data: { modelPath: modelPath }\r
        }, "*");\r
    } else {\r
        console.error("[Z3D Editor] No parent window available");\r
        updateStatus("\u274C No parent window available", "error");\r
    }\r
}\r
\r
// This function will be populated by template-builder with actual Three.js code\r
function createWorkerCodeWithThreeJS() {\r
    // This will be replaced by template-builder with the actual worker code\r
    console.error("[Z3D Editor] createWorkerCodeWithThreeJS not implemented - should be injected by template-builder");\r
    return "";\r
}`
      },
      "mainInitialization": `/* FILE: editor/z3d-object-editor/templates/scripts/main-initialization.js */\r
\r
async function initialize() {\r
    console.log("[Z3D Editor] Initializing...");\r
    updateStatus("\u{1F504} Waiting for Three.js...", "loading");\r
    \r
    try {\r
        await waitForThreeJS();\r
        updateStatus("\u2705 Three.js loaded successfully", "success");\r
        \r
        // Setup camera controls FIRST (creates the camera and OrbitControls)\r
        const cameraSetup = setupCameraControls();\r
        if (!cameraSetup) {\r
            console.error("[Z3D Editor] Camera setup failed");\r
            return;\r
        }\r
        \r
        // Initialize worker SECOND\r
        const workerSetup = initializeWorker();\r
        if (!workerSetup) {\r
            console.error("[Z3D Editor] Worker setup failed");\r
            return;\r
        }\r
        \r
        // Initialize canvas manager THIRD (just initialize, don't setup)\r
        if (window.canvasManager && window.worker) {\r
            console.log("[Z3D Editor] Initializing canvas manager...");\r
            const canvasReady = window.canvasManager.initialize(window.worker);\r
            \r
            if (canvasReady) {\r
                console.log("[Z3D Editor] \u2705 Canvas manager initialized");\r
                // DON'T call setupCanvas here - it's called from setupCanvasInWorker\r
            }\r
        }\r
        \r
        // Setup UI controls\r
        updateStatus("\u{1F504} Setting up UI controls...", "loading");\r
        uiManager = new UIManager(getConfig());\r
        await uiManager.initialize();\r
        \r
        // Setup parent communication\r
        setupParentCommunication();\r
        \r
        console.log("[Z3D Editor] \u2705 Initialization complete!");\r
        \r
        // Notify parent that editor is ready\r
        if (window.opener && !window.opener.closed) {\r
            const config = getConfig();\r
            window.opener.postMessage({\r
                type: 'EDITOR_READY',\r
                data: { \r
                    instanceId: config ? config.instanceId : 0, \r
                    timestamp: Date.now(),\r
                    editorVersion: '1.0.0'\r
                }\r
            }, '*');\r
        }\r
        \r
    } catch (error) {\r
        console.error("[Z3D Editor] \u274C Initialization failed:", error);\r
        updateStatus("\u274C Initialization failed: " + error.message, "error");\r
    }\r
}\r
\r
// Start initialization\r
if (document.readyState === "loading") {\r
    document.addEventListener("DOMContentLoaded", initialize);\r
} else {\r
    initialize();\r
}`
    },
    "config": {
      "editorConfig": {
        "version": "1.0.0",
        "editor": {
          "title": "Z3D Object Editor",
          "theme": "dark",
          "panels": {
            "transform": {
              "enabled": true,
              "collapsed": false,
              "order": 1
            },
            "material": {
              "enabled": true,
              "collapsed": false,
              "order": 2
            },
            "viewport": {
              "enabled": true,
              "collapsed": false,
              "order": 3
            },
            "animation": {
              "enabled": true,
              "collapsed": true,
              "order": 4
            }
          }
        },
        "viewport": {
          "defaultCamera": {
            "position": [
              5,
              5,
              5
            ],
            "target": [
              0,
              0,
              0
            ]
          },
          "controls": {
            "enableDamping": true,
            "dampingFactor": 0.05,
            "enableZoom": true,
            "enableRotate": true,
            "enablePan": true
          },
          "rendering": {
            "antialias": true,
            "shadows": true,
            "shadowMapSize": 2048
          }
        },
        "shortcuts": {
          "resetView": "r",
          "toggleWireframe": "w",
          "toggleFullscreen": "f",
          "focusTransform": "t",
          "focusMaterial": "m"
        },
        "performance": {
          "maxVertices": 1e5,
          "enableFrustumCulling": true,
          "enableOcclusion": false
        }
      }
    }
  };
  console.log("[Z3DObjectEditor] \u{1F680} Real template assets loaded from build script injection");
  console.log("[Z3DObjectEditor] Asset sizes:", {
    html: "8KB",
    styles: "66KB",
    scripts: "606KB",
    config: "1KB"
  });
  var TemplateBuilder = class {
    constructor() {
      this._assets = EMBEDDED_TEMPLATE_ASSETS;
      console.log("[Z3DObjectEditor] Using embedded template assets");
      this._logAssetStats();
    }
    /**
     * Build the complete HTML template for the Z3D Object Editor
     */
    async build(config) {
      console.log(`[Z3DObjectEditor] Building editor for instance ${config.instanceId}`);
      try {
        const threeJsResources = await this._loadThreeJSResources();
        console.log("[Z3DObjectEditor] Resources loaded:", {
          threeJs: Math.round(threeJsResources.threeJs.length / 1024) + "KB",
          gltf: Math.round(threeJsResources.gltfLoader.length / 1024) + "KB",
          orbit: Math.round(threeJsResources.orbitControls.length / 1024) + "KB"
        });
        const scriptUrls = await this._createScriptBlobs(threeJsResources, config);
        const html = this._buildHTMLWithScripts({
          title: `Z3D Object Editor - Instance ${config.instanceId}`,
          styles: this._combineStyles(),
          scriptUrls,
          config: JSON.stringify(config),
          editorConfig: JSON.stringify(this._assets.config.editorConfig)
        });
        setTimeout(() => {
          scriptUrls.forEach((url) => URL.revokeObjectURL(url));
        }, 1e4);
        const sizeKB = Math.round(html.length / 1024);
        console.log(`[Z3DObjectEditor] \u2705 Template built successfully (${sizeKB}KB)`);
        return html;
      } catch (error) {
        console.error("[Z3DObjectEditor] \u274C Build failed:", error);
        throw error;
      }
    }
    /**
     * Load Three.js resources
     */
    async _loadThreeJSResources() {
      console.log("[Z3DObjectEditor] Loading Three.js resources...");
      try {
        const [threeJs, gltfLoader, orbitControls] = await Promise.all([
          ThreeJSLoader.loadThreeJS(),
          ThreeJSLoader.loadGLTFLoader(),
          ThreeJSLoader.loadOrbitControls()
        ]);
        return { threeJs, gltfLoader, orbitControls };
      } catch (error) {
        console.warn("[Z3DObjectEditor] ThreeJSLoader not available:", error);
        return { threeJs: "", gltfLoader: "", orbitControls: "" };
      }
    }
    _combineStyles() {
      return [
        this._assets.styles.base,
        this._assets.styles.components,
        this._assets.styles.layout,
        this._assets.styles["object-controls"],
        this._assets.styles["outliner"],
        this._assets.styles["animation"] || "",
        this._assets.styles["texture"] || ""
      ].join("\n\n/* ===== NEXT SECTION ===== */\n\n");
    }
    async _createScriptBlobs(threeJsResources, config) {
      const scriptUrls = [];
      const combinedThreeJS = this._createCombinedThreeJSScript(threeJsResources);
      if (combinedThreeJS) {
        const threeBlob = new Blob([combinedThreeJS], { type: "application/javascript" });
        scriptUrls.push(URL.createObjectURL(threeBlob));
      }
      const mainScript = this._generateMainScript(config, threeJsResources);
      const mainBlob = new Blob([mainScript], { type: "application/javascript" });
      scriptUrls.push(URL.createObjectURL(mainBlob));
      return scriptUrls;
    }
    _createCombinedThreeJSScript(threeJsResources) {
      if (!threeJsResources.threeJs)
        return null;
      let combinedScript = "";
      combinedScript += "(function() {\n";
      combinedScript += '    "use strict";\n';
      combinedScript += "    \n";
      combinedScript += '    console.log("[Z3D Three.js] Starting safe Three.js loading...");\n';
      combinedScript += "    \n";
      combinedScript += "    // Clear existing THREE to prevent conflicts\n";
      combinedScript += '    if (typeof window !== "undefined" && window.THREE) {\n';
      combinedScript += '        console.log("[Z3D Three.js] Clearing existing window.THREE");\n';
      combinedScript += "        delete window.THREE;\n";
      combinedScript += "    }\n";
      combinedScript += '    if (typeof globalThis !== "undefined" && globalThis.THREE) {\n';
      combinedScript += '        console.log("[Z3D Three.js] Clearing existing globalThis.THREE");\n';
      combinedScript += "        delete globalThis.THREE;\n";
      combinedScript += "    }\n";
      combinedScript += '    if (typeof self !== "undefined" && self.THREE) {\n';
      combinedScript += '        console.log("[Z3D Three.js] Clearing existing self.THREE");\n';
      combinedScript += "        delete self.THREE;\n";
      combinedScript += "    }\n";
      combinedScript += "    \n";
      combinedScript += "    // Load Three.js Core in isolated scope\n";
      combinedScript += '    console.log("[Z3D Three.js] Loading Three.js core...");\n';
      combinedScript += "    try {\n";
      combinedScript += threeJsResources.threeJs;
      combinedScript += '\n        console.log("[Z3D Three.js] \u2705 Three.js core loaded, version:", typeof THREE !== "undefined" ? THREE.REVISION : "unknown");\n';
      combinedScript += "    } catch (error) {\n";
      combinedScript += '        console.error("[Z3D Three.js] \u274C Three.js core failed:", error);\n';
      combinedScript += "        return;\n";
      combinedScript += "    }\n";
      combinedScript += "    \n";
      combinedScript += "    // Verify THREE is available\n";
      combinedScript += '    if (typeof THREE === "undefined") {\n';
      combinedScript += '        console.error("[Z3D Three.js] \u274C THREE not available after loading");\n';
      combinedScript += "        return;\n";
      combinedScript += "    }\n";
      combinedScript += "    \n";
      if (threeJsResources.gltfLoader) {
        combinedScript += "    // Load GLTF Loader\n";
        combinedScript += '    console.log("[Z3D Three.js] Loading GLTF Loader...");\n';
        combinedScript += "    try {\n";
        combinedScript += threeJsResources.gltfLoader;
        combinedScript += "\n        // Register GLTFLoader with THREE\n";
        combinedScript += '        if (typeof GLTFLoader !== "undefined") {\n';
        combinedScript += "            THREE.GLTFLoader = GLTFLoader;\n";
        combinedScript += "        }\n";
        combinedScript += '        console.log("[Z3D Three.js] \u2705 GLTF Loader loaded");\n';
        combinedScript += "    } catch (error) {\n";
        combinedScript += '        console.warn("[Z3D Three.js] GLTF Loader failed:", error);\n';
        combinedScript += "    }\n";
        combinedScript += "    \n";
      }
      if (threeJsResources.orbitControls) {
        combinedScript += "    // Load Orbit Controls\n";
        combinedScript += '    console.log("[Z3D Three.js] Loading Orbit Controls...");\n';
        combinedScript += "    try {\n";
        combinedScript += threeJsResources.orbitControls;
        combinedScript += '\n        console.log("[Z3D Three.js] \u2705 Orbit Controls loaded");\n';
        combinedScript += "    } catch (error) {\n";
        combinedScript += '        console.warn("[Z3D Three.js] Orbit Controls failed:", error);\n';
        combinedScript += "    }\n";
        combinedScript += "    \n";
      }
      combinedScript += "    // Make THREE globally available\n";
      combinedScript += '    if (typeof window !== "undefined") window.THREE = THREE;\n';
      combinedScript += '    if (typeof globalThis !== "undefined") globalThis.THREE = THREE;\n';
      combinedScript += '    if (typeof self !== "undefined") self.THREE = THREE;\n';
      combinedScript += "    \n";
      combinedScript += '    console.log("[Z3D Three.js] \u2705 All components loaded successfully");\n';
      combinedScript += '    console.log("[Z3D Three.js] Available components:", {\n';
      combinedScript += "        core: true,\n";
      combinedScript += "        revision: THREE.REVISION,\n";
      combinedScript += '        gltfLoader: typeof THREE.GLTFLoader !== "undefined" || typeof GLTFLoader !== "undefined",\n';
      combinedScript += '        orbitControls: typeof THREE.OrbitControls !== "undefined"\n';
      combinedScript += "    });\n";
      combinedScript += "    \n";
      combinedScript += "})();\n";
      return combinedScript;
    }
    _generateMainScript(config, threeJsResources) {
      console.log("[Z3DObjectEditor] Assembling main script from embedded assets...");
      let mainScript = "";
      mainScript += 'console.log("[Z3D Object Editor] \u{1F680} Editor loading from embedded template assets...");\n\n';
      mainScript += "// ===== CORE COMPONENTS =====\n";
      mainScript += this._assets.scripts.core.eventEmitter + "\n\n";
      mainScript += this._assets.scripts.core.uiManager + "\n\n";
      mainScript += "// ===== UI COMPONENTS =====\n";
      mainScript += this._assets.scripts.components.objectControls + "\n\n";
      if (this._assets.scripts.components.viewportControls) {
        mainScript += this._assets.scripts.components.viewportControls + "\n\n";
      }
      if (this._assets.scripts.components.outlinerControls) {
        mainScript += this._assets.scripts.components.outlinerControls + "\n\n";
      }
      if (this._assets.scripts.components.animationControls) {
        mainScript += "// ===== ANIMATION CONTROLS =====\n";
        mainScript += this._assets.scripts.components.animationControls + "\n\n";
      }
      if (this._assets.scripts.components.textureControls) {
        mainScript += "// ===== TEXTURE CONTROLS =====\n";
        mainScript += this._assets.scripts.components.textureControls + "\n\n";
      }
      if (this._assets.scripts.components.viewerManager) {
        mainScript += "// ===== VIEWER MANAGER =====\n";
        mainScript += this._assets.scripts.components.viewerManager + "\n\n";
      }
      if (this._assets.scripts.components.viewportButtons) {
        mainScript += "// ===== VIEWPORT BUTTONS =====\n";
        mainScript += this._assets.scripts.components.viewportButtons + "\n\n";
      }
      if (this._assets.scripts.components.gizmoController) {
        mainScript += "// ===== GIZMO CONTROLLER =====\n";
        mainScript += this._assets.scripts.components.gizmoController + "\n\n";
      }
      if (this._assets.scripts.components.statsOverlay) {
        mainScript += "// ===== STATS OVERLAY =====\n";
        mainScript += this._assets.scripts.components.statsOverlay + "\n\n";
      }
      if (this._assets.scripts.components.sceneTopbarControls) {
        mainScript += "// ===== SCENE TOPBAR CONTROLS =====\n";
        mainScript += this._assets.scripts.components.sceneTopbarControls + "\n\n";
      }
      mainScript += this._assets.scripts.components.resizer + "\n\n";
      if (this._assets.scripts.utils) {
        mainScript += "// ===== UTILITY FUNCTIONS =====\n";
        const utilOrder = [
          "canvasManager",
          "commonFunctions",
          "cameraSetup",
          "modelLoader",
          "parentCommunication",
          "workerInitialization"
        ];
        utilOrder.forEach((utilName) => {
          if (this._assets.scripts.utils[utilName]) {
            mainScript += `// ${utilName}
`;
            mainScript += this._assets.scripts.utils[utilName];
            mainScript += "\n\n";
          }
        });
      }
      mainScript += "// ===== WORKER CODE GENERATION =====\n";
      mainScript += this._generateWorkerCodeFunction(threeJsResources);
      mainScript += "\n\n";
      mainScript += "// ===== MAIN INITIALIZATION =====\n";
      if (this._assets.scripts.mainInitialization) {
        mainScript += this._assets.scripts.mainInitialization;
      }
      mainScript += "\n\n// ===== AUTO-CLOSE IF PARENT WINDOW CLOSES =====\n";
      mainScript += "setInterval(() => {\n";
      mainScript += "    try {\n";
      mainScript += "        if (!window.opener || window.opener.closed) {\n";
      mainScript += '            console.log("[Z3D Object Editor] Parent window closed, closing editor");\n';
      mainScript += "            window.close();\n";
      mainScript += "        }\n";
      mainScript += "    } catch (e) {\n";
      mainScript += "        // Parent might be on different origin or closed\n";
      mainScript += '        console.log("[Z3D Object Editor] Cannot access parent, closing editor");\n';
      mainScript += "        window.close();\n";
      mainScript += "    }\n";
      mainScript += "}, 1000);\n";
      mainScript += "\n";
      console.log("[Z3DObjectEditor] \u2705 Main script assembled from embedded assets");
      return mainScript;
    }
    _generateWorkerCodeFunction(threeJsResources) {
      let workerFunction = "";
      workerFunction += "function createWorkerCodeWithThreeJS() {\n";
      workerFunction += '    console.log("[Z3D Object Editor] Generating worker code...");\n';
      workerFunction += "    \n";
      workerFunction += "    const threeJSCode = " + JSON.stringify(threeJsResources.threeJs || "") + ";\n";
      workerFunction += "    const gltfLoaderCode = " + JSON.stringify(threeJsResources.gltfLoader || "") + ";\n";
      workerFunction += "    const orbitControlsCode = " + JSON.stringify(threeJsResources.orbitControls || "") + ";\n";
      workerFunction += "    \n";
      workerFunction += '    let workerCode = "";\n';
      workerFunction += "    \n";
      workerFunction += "    // Worker header\n";
      workerFunction += '    workerCode += "console.log(\\"[Z3D Object Worker] Starting Three.js worker...\\");\\n\\n";\n';
      workerFunction += "    \n";
      workerFunction += "    // Clear existing THREE if present\n";
      workerFunction += '    workerCode += "// Clear existing THREE if present\\n";\n';
      workerFunction += '    workerCode += "if (typeof THREE !== \\"undefined\\") {\\n";\n';
      workerFunction += '    workerCode += "    console.log(\\"[Z3D Object Worker] Existing THREE detected, clearing...\\");\\n";\n';
      workerFunction += '    workerCode += "    delete globalThis.THREE;\\n";\n';
      workerFunction += '    workerCode += "    delete self.THREE;\\n";\n';
      workerFunction += '    workerCode += "}\\n\\n";\n';
      workerFunction += "    \n";
      workerFunction += "    // CSP-safe Three.js loading\n";
      workerFunction += "    if (threeJSCode) {\n";
      workerFunction += '        workerCode += "// Three.js Core - Direct execution (CSP-safe)\\n";\n';
      workerFunction += "        workerCode += threeJSCode;\n";
      workerFunction += '        workerCode += "\\n";\n';
      workerFunction += '        workerCode += "// Verify THREE is available\\n";\n';
      workerFunction += '        workerCode += "if (typeof THREE === \\"undefined\\") {\\n";\n';
      workerFunction += '        workerCode += "    console.error(\\"[Z3D Object Worker] THREE not found after execution\\");\\n";\n';
      workerFunction += '        workerCode += "} else {\\n";\n';
      workerFunction += '        workerCode += "    console.log(\\"[Z3D Object Worker] \u2705 Three.js loaded:\\", THREE.REVISION);\\n";\n';
      workerFunction += '        workerCode += "}\\n\\n";\n';
      workerFunction += "        \n";
      workerFunction += "        if (gltfLoaderCode) {\n";
      workerFunction += '            workerCode += "// GLTF Loader\\n";\n';
      workerFunction += "            workerCode += gltfLoaderCode;\n";
      workerFunction += '            workerCode += "\\n";\n';
      workerFunction += '            workerCode += "if (typeof GLTFLoader !== \\"undefined\\" && typeof THREE !== \\"undefined\\") {\\n";\n';
      workerFunction += '            workerCode += "    THREE.GLTFLoader = GLTFLoader;\\n";\n';
      workerFunction += '            workerCode += "}\\n";\n';
      workerFunction += '            workerCode += "console.log(\\"[Z3D Object Worker] \u2705 GLTF Loader loaded\\");\\n\\n";\n';
      workerFunction += "        }\n";
      workerFunction += "        \n";
      workerFunction += "        if (orbitControlsCode) {\n";
      workerFunction += '            workerCode += "// OrbitControls\\n";\n';
      workerFunction += "            workerCode += orbitControlsCode;\n";
      workerFunction += '            workerCode += "\\n";\n';
      workerFunction += '            workerCode += "console.log(\\"[Z3D Object Worker] \u2705 OrbitControls loaded\\");\\n\\n";\n';
      workerFunction += "        }\n";
      workerFunction += "    } else {\n";
      workerFunction += '        workerCode += "console.warn(\\"[Z3D Object Worker] No Three.js source - worker will run in basic mode\\");\\n";\n';
      workerFunction += "    }\n";
      workerFunction += "    \n";
      workerFunction += "    // Add Scene Data Collector (embedded to avoid importScripts issues)\n";
      workerFunction += "    if (" + JSON.stringify(!!this._assets.scripts.workers.sceneDataCollector) + ") {\n";
      workerFunction += '        workerCode += "\\n// ============================================\\n";\n';
      workerFunction += '        workerCode += "// SCENE DATA COLLECTOR (Embedded)\\n";\n';
      workerFunction += '        workerCode += "// ============================================\\n\\n";\n';
      workerFunction += "        workerCode += " + JSON.stringify(this._assets.scripts.workers.sceneDataCollector || "") + ";\n";
      workerFunction += '        workerCode += "\\n\\n";\n';
      workerFunction += "    }\n";
      workerFunction += "    \n";
      workerFunction += "    // Add Viewport Gizmo (embedded)\n";
      workerFunction += "    if (" + JSON.stringify(!!this._assets.scripts.workers.viewportGizmo) + ") {\n";
      workerFunction += '        workerCode += "\\n// ============================================\\n";\n';
      workerFunction += '        workerCode += "// VIEWPORT GIZMO (Embedded)\\n";\n';
      workerFunction += '        workerCode += "// ============================================\\n\\n";\n';
      workerFunction += "        workerCode += " + JSON.stringify(this._assets.scripts.workers.viewportGizmo || "") + ";\n";
      workerFunction += '        workerCode += "\\n\\n";\n';
      workerFunction += "    }\n";
      workerFunction += "    \n";
      workerFunction += "    // Add Transform Gizmo (embedded)\n";
      workerFunction += "    if (" + JSON.stringify(!!this._assets.scripts.workers.transformGizmo) + ") {\n";
      workerFunction += '        workerCode += "\\n// ============================================\\n";\n';
      workerFunction += '        workerCode += "// TRANSFORM GIZMO (Embedded)\\n";\n';
      workerFunction += '        workerCode += "// ============================================\\n\\n";\n';
      workerFunction += "        workerCode += " + JSON.stringify(this._assets.scripts.workers.transformGizmo || "") + ";\n";
      workerFunction += '        workerCode += "\\n\\n";\n';
      workerFunction += "    }\n";
      workerFunction += "    \n";
      workerFunction += "    // Add the main worker functionality\n";
      workerFunction += '    workerCode += "\\n// ============================================\\n";\n';
      workerFunction += '    workerCode += "// MAIN WORKER LOGIC\\n";\n';
      workerFunction += '    workerCode += "// ============================================\\n\\n";\n';
      workerFunction += "    workerCode += " + JSON.stringify(this._getFullWorkerLogic()) + ";\n";
      const nodeTreeAppend = `
        ; (function(){
        let __nodeTreeSent = false;
        function __safeUserData(obj){ try { return JSON.parse(JSON.stringify(obj||{})); } catch(e){ return {}; } }
        function __serializeNode(n){ var out={ id:n.uuid, name:n.name||"", type:n.type||"", userData:__safeUserData(n.userData), children:[] }; if(n.children&&n.children.length){ for(var i=0;i<n.children.length;i++){ out.children.push(__serializeNode(n.children[i])); } } return out; }
        function __getTreeRoot(){ try { if (typeof currentModel==="undefined"||!currentModel) return null; var root=currentModel; if(root.name==="ModelWrapper" && root.children && root.children.length===1){ root=root.children[0]; } return root; } catch(e){ return null; } }
        function __sendTreeOnce(){ if(__nodeTreeSent) return; var root=__getTreeRoot(); if(root){ try { var tree=__serializeNode(root); self.postMessage({ type:"MODEL_NODE_TREE", data:{ nodeTree: tree } }); __nodeTreeSent=true; } catch(e){} } }
        try { __sendTreeOnce(); } catch(e){}
        var __tries=0, __max=200; var __timer=setInterval(function(){ __sendTreeOnce(); __tries++; if(__nodeTreeSent||__tries>__max) clearInterval(__timer); }, 50);
        })();
        `;
      workerFunction += "    workerCode += " + JSON.stringify(nodeTreeAppend) + ";\n";
      workerFunction += "    \n";
      workerFunction += '    console.log("[Z3D Object Editor] \u2705 Worker code generated (" + Math.round(workerCode.length / 1024) + "KB)");\n';
      workerFunction += "    return workerCode;\n";
      workerFunction += "}";
      return workerFunction;
    }
    //  NEW: Get the full worker logic from embedded assets
    _getFullWorkerLogic() {
      if (this._assets.scripts.workers.threeWorker) {
        console.log("[Z3DObjectEditor] Using embedded three-worker.js");
        let workerCode = this._assets.scripts.workers.threeWorker;
        workerCode = workerCode.replace(
          /^.*importScripts\(['"]\.\/scene-data-collector\.js['"]\);.*$/gm,
          "// Scene data collector has been embedded above"
        );
        return workerCode;
      }
      console.warn("[Z3DObjectEditor] No embedded worker script found, using basic fallback");
      return this._getWorkerCoreLogic();
    }
    _buildHTMLWithScripts(options) {
      const scriptTags = options.scriptUrls.map(
        (url) => `    <script src="${url}"><\/script>`
      ).join("\n");
      let html = this._assets.html.main;
      html = html.replace("{{TITLE}}", options.title);
      html = html.replace("{{STYLES}}", options.styles);
      const configElements = `
    <!-- Hidden Config Data -->
    <div id="z3d-object-editor-config" style="display: none;">${options.config}</div>
    <script type="application/json" id="build-config">${options.config}<\/script>
    <script type="application/json" id="editor-config">${options.editorConfig}<\/script>`;
      if (html.includes("{{CONFIG}}")) {
        html = html.replace("{{CONFIG}}", options.config);
      }
      html = html.replace("</body>", configElements + "\n" + scriptTags + "\n</body>");
      return html;
    }
    _getWorkerCoreLogic() {
      return `
// Basic worker logic
let scene = null;
let camera = null;
let renderer = null;

self.addEventListener('message', function(event) {
    const { type, data } = event.data;
    console.log('[Z3D Object Worker] Message:', type);
    
    try {
        switch (type) {
            case 'SETUP_CANVAS':
                setupCanvas(data);
                break;
            case 'LOAD_MODEL':
                loadModel(data);
                break;
            case 'PING':
                self.postMessage({ type: 'WORKER_READY' });
                break;
        }
    } catch (error) {
        console.error('[Z3D Object Worker] Error:', error);
        self.postMessage({ type: 'ERROR', data: { error: error.message } });
    }
});

function setupCanvas(data) {
    console.log('[Z3D Object Worker] Setting up canvas...');
    self.postMessage({ type: 'CANVAS_READY' });
}

function loadModel(data) {
    console.log('[Z3D Object Worker] Loading model (basic mode)...');
    self.postMessage({ type: 'MODEL_LOADED', data: { success: true } });
}

console.log('[Z3D Object Worker] \u2705 Worker ready');
self.postMessage({ type: 'WORKER_READY' });
`;
    }
    /**
     * Log asset statistics for debugging
     */
    _logAssetStats() {
      const stats = {
        html: Object.keys(this._assets.html).length,
        styles: Object.keys(this._assets.styles).length,
        coreScripts: Object.keys(this._assets.scripts.core).length,
        componentScripts: Object.keys(this._assets.scripts.components).length,
        workerScripts: Object.keys(this._assets.scripts.workers).length,
        utilScripts: this._assets.scripts.utils ? Object.keys(this._assets.scripts.utils).length : 0,
        hasMainInit: !!this._assets.scripts.mainInitialization,
        config: Object.keys(this._assets.config).length
      };
      console.log("[Z3DObjectEditor] Asset statistics:", stats);
      console.log("[Z3DObjectEditor] Core scripts:", Object.keys(this._assets.scripts.core));
      console.log("[Z3DObjectEditor] Component scripts:", Object.keys(this._assets.scripts.components));
      if (this._assets.scripts.utils) {
        console.log("[Z3DObjectEditor] Utility scripts:", Object.keys(this._assets.scripts.utils));
      }
    }
    /**
     * Get template assets (for debugging)
     */
    getAssets() {
      return this._assets;
    }
    /**
     * Validate that all required assets are present
     */
    validateAssets() {
      const required = [
        "html.main",
        "styles.base",
        "styles.components",
        "styles.layout",
        "scripts.core.eventEmitter",
        "scripts.core.uiManager",
        "scripts.components.objectControls",
        "scripts.components.resizer",
        "config.editorConfig",
        "scripts.components.animationControls",
        "scripts.components.textureControls",
        "scripts.components.viewerManager",
        "scripts.components.outlinerControls",
        "styles.animation",
        "styles.texture"
      ];
      for (const path of required) {
        const keys = path.split(".");
        let current = this._assets;
        for (const key of keys) {
          current = current?.[key];
          if (!current) {
            console.error(`[Z3DObjectEditor] Missing required asset: ${path}`);
            return false;
          }
        }
      }
      return true;
    }
  };

  // packages/z3d-object/src/editor/editor-window.ts
  var EditorWindow = class {
    constructor(objectEditor) {
      this._window = null;
      this._isOpening = false;
      this._isReady = false;
      this._modelDataSent = false;
      this._messageHandler = null;
      this._windowCheckInterval = null;
      this._objectEditor = objectEditor;
    }
    async open(options = {}) {
      if (this._isOpening) {
        console.log("[EditorWindow] Already opening");
        return false;
      }
      if (this.isOpen()) {
        console.log("[EditorWindow] Already open");
        if (options.focus !== false)
          this.focus();
        return true;
      }
      try {
        this._isOpening = true;
        this._isReady = false;
        this._modelDataSent = false;
        const template = await this._buildEditorTemplate(options);
        const success = await this._createEditorWindow(template, options);
        if (success) {
          this._setupCommunication();
          this._startWindowMonitoring();
          console.log("[EditorWindow] \u2705 Editor opened");
          return true;
        }
        throw new Error("Failed to create editor window");
      } catch (error) {
        console.error("[EditorWindow] Failed to open:", error);
        this._cleanup();
        return false;
      } finally {
        this._isOpening = false;
      }
    }
    close() {
      if (this._window && !this._window.closed) {
        try {
          this._window.close();
        } catch (e) {
          console.error("[EditorWindow] Error closing:", e);
        }
      }
      this._cleanup();
    }
    isOpen() {
      return this._window !== null && !this._window.closed;
    }
    focus() {
      if (this._window && !this._window.closed) {
        try {
          this._window.focus();
        } catch {
        }
      }
    }
    sendMessage(message, transferable) {
      if (!this._window || this._window.closed)
        return;
      try {
        this._window.postMessage(message, "*", transferable);
      } catch (error) {
        console.error("[EditorWindow] Error sending message:", error);
      }
    }
    dispose() {
      this.close();
    }
    async _buildEditorTemplate(options) {
      const templateBuilder = new TemplateBuilder();
      const propertyAdapter = this._objectEditor.getPropertyAdapter();
      const initialState = propertyAdapter.getState();
      const host = this._objectEditor.getHost();
      const buildData = {
        instanceId: host?.inst?.GetUID?.() || 0,
        modelPath: initialState.modelPath || "",
        initialState,
        debugMode: false
      };
      return await templateBuilder.build(buildData);
    }
    async _createEditorWindow(template, options) {
      const blob = new Blob([template], { type: "text/html" });
      const blobUrl = URL.createObjectURL(blob);
      const features = this._calculateWindowFeatures(options);
      const host = this._objectEditor.getHost();
      const uid = host?.inst?.GetUID?.() || 0;
      this._window = window.open(blobUrl, `z3d-object-editor-${uid}`, features);
      if (!this._window) {
        URL.revokeObjectURL(blobUrl);
        return false;
      }
      setTimeout(() => URL.revokeObjectURL(blobUrl), 1e4);
      await this._waitForWindowLoad();
      return true;
    }
    async _waitForWindowLoad() {
      return new Promise((resolve, reject) => {
        if (!this._window) {
          reject(new Error("No window to wait for"));
          return;
        }
        const timeout = setTimeout(() => reject(new Error("Window load timeout")), 15e3);
        const checkReady = () => {
          if (!this._window || this._window.closed) {
            clearTimeout(timeout);
            reject(new Error("Window closed during load"));
            return;
          }
          try {
            if (this._window.document?.readyState === "complete") {
              clearTimeout(timeout);
              resolve();
              return;
            }
          } catch {
          }
          setTimeout(checkReady, 100);
        };
        checkReady();
      });
    }
    _setupCommunication() {
      if (this._messageHandler) {
        window.removeEventListener("message", this._messageHandler);
      }
      this._messageHandler = (event) => {
        if (!this._window || event.source !== this._window)
          return;
        this._handleMessage(event.data);
      };
      window.addEventListener("message", this._messageHandler);
    }
    _handleMessage(message) {
      if (!message.type)
        return;
      switch (message.type) {
        case "EDITOR_READY":
          this._isReady = true;
          console.log("[EditorWindow] Editor ready");
          break;
        case "INITIALIZATION_COMPLETE":
          console.log("[EditorWindow] Editor initialization complete");
          this._objectEditor.markInitializationComplete();
          break;
        case "TRANSFORMS_UPDATE":
          this._objectEditor.handlePropertyUpdate(message.data);
          break;
        case "REQUEST_MODEL_DATA":
          if (!this._modelDataSent) {
            this._modelDataSent = true;
            this._handleModelDataRequest(message.data);
          }
          break;
        case "ANIMATION_STATE_CHANGE":
          console.log("[EditorWindow] Animation state change:", message.data);
          this._objectEditor.handleAnimationStateChange(message.data);
          break;
        case "NODE_VISIBILITY_CHANGE":
          console.log("[EditorWindow] Node visibility change:", message.data);
          this._objectEditor.handleNodeVisibilityChange(message.data);
          break;
        case "SKINNED_MESH_UPDATE":
          console.log("[EditorWindow] Skinned mesh update, vertices:", message.data?.vertices?.length);
          this._objectEditor.handleSkinnedMeshUpdate(message.data);
          break;
        default:
          console.log("[EditorWindow] Unhandled message type:", message.type);
          break;
      }
    }
    async _handleModelDataRequest(data) {
      const propertyAdapter = this._objectEditor.getPropertyAdapter();
      const modelPath = data?.modelPath || propertyAdapter.getValue("modelPath");
      if (!modelPath) {
        this.sendMessage({
          type: "MODEL_DATA_RESPONSE",
          data: { success: false, error: "No model path specified" }
        });
        return;
      }
      try {
        const host = this._objectEditor.getHost();
        const modelData = await host.getProjectFile(modelPath);
        const z3dConfig = propertyAdapter.getZ3DConfig();
        const animationState = z3dConfig?.animation || null;
        this.sendMessage({
          type: "MODEL_DATA_RESPONSE",
          data: {
            modelPath,
            modelData,
            animationState,
            // Include animation state for restoration
            success: true
          }
        }, modelData ? [modelData] : void 0);
      } catch (error) {
        this.sendMessage({
          type: "MODEL_DATA_RESPONSE",
          data: {
            modelPath,
            success: false,
            error: error instanceof Error ? error.message : "Unknown error"
          }
        });
      }
    }
    _startWindowMonitoring() {
      if (this._windowCheckInterval) {
        clearInterval(this._windowCheckInterval);
      }
      let lastCheckFailed = false;
      const host = this._objectEditor.getHost();
      const originalUID = host?.inst?.GetUID?.() || 0;
      this._windowCheckInterval = window.setInterval(() => {
        if (!this._window || this._window.closed) {
          console.log("[EditorWindow] Window was closed");
          this._cleanup();
          return;
        }
        try {
          const currentHost = this._objectEditor.getHost();
          const project = currentHost?.inst?.GetProject?.();
          if (!project) {
            if (!lastCheckFailed) {
              console.log("[EditorWindow] Project not accessible, will close if next check fails");
              lastCheckFailed = true;
            } else {
              console.log("[EditorWindow] Project still not accessible, closing editor");
              this.close();
            }
            return;
          }
          const objectType = currentHost?.inst?.GetObjectType?.();
          if (objectType) {
            const allInstances = objectType.GetAllInstances?.();
            if (allInstances) {
              const stillExists = allInstances.some((inst) => {
                try {
                  return inst.GetUID() === originalUID;
                } catch {
                  return false;
                }
              });
              if (!stillExists) {
                console.log(`[EditorWindow] Instance ${originalUID} not found in object type instances, closing editor`);
                this.close();
                return;
              }
            }
          }
          const testAccess = currentHost?.getPropertyValue?.(
            currentHost.propertyMapping.modelPath || "model-path"
          );
          lastCheckFailed = false;
        } catch (e) {
          if (!lastCheckFailed) {
            console.log("[EditorWindow] Cannot access instance, will close if next check fails");
            lastCheckFailed = true;
          } else {
            console.log("[EditorWindow] Instance still not accessible, closing editor");
            this.close();
          }
        }
      }, 200);
    }
    _calculateWindowFeatures(options) {
      const features = [
        "width=1400",
        "height=900",
        "scrollbars=yes",
        "resizable=yes",
        "menubar=no",
        "toolbar=no",
        "location=no",
        "status=no"
      ];
      if (options.centerOnScreen) {
        const left = Math.max(0, (window.screen.availWidth - 1400) / 2);
        const top = Math.max(0, (window.screen.availHeight - 900) / 2);
        features.push(`left=${left}`, `top=${top}`);
      }
      return features.join(",");
    }
    _cleanup() {
      if (this._windowCheckInterval) {
        clearInterval(this._windowCheckInterval);
        this._windowCheckInterval = null;
      }
      if (this._messageHandler) {
        window.removeEventListener("message", this._messageHandler);
        this._messageHandler = null;
      }
      this._window = null;
      this._isReady = false;
      this._isOpening = false;
      this._modelDataSent = false;
      this._objectEditor.onWindowClosed();
    }
  };

  // packages/z3d-object/src/editor/index.ts
  var Z3DObjectEditor = class {
    constructor(host) {
      this._isOpen = false;
      // Property sync state
      this._syncTimer = null;
      this._syncInterval = 25;
      this._isActive = false;
      this._lastSyncHash = "";
      this._recentEditorUpdate = false;
      this._editorUpdateTimeout = null;
      this._isInitializing = true;
      this.host = host;
      this.propertyAdapter = new PropertyAdapter(host);
      this.editorWindow = new EditorWindow(this);
    }
    async openEditor(options = {}) {
      if (this._isOpen) {
        console.log("[Z3DObjectEditor] Editor already open");
        this.editorWindow.focus();
        return true;
      }
      try {
        const success = await this.editorWindow.open(options);
        if (success) {
          this._isOpen = true;
          this._isInitializing = true;
          setTimeout(() => {
            this.sendInitialState();
            this._startPropertySync();
          }, 100);
        }
        return success;
      } catch (error) {
        console.error("[Z3DObjectEditor] Failed to open editor:", error);
        return false;
      }
    }
    closeEditor() {
      if (!this._isOpen)
        return;
      this._stopPropertySync();
      this.editorWindow.close();
      this._isOpen = false;
    }
    isOpen() {
      return this._isOpen && this.editorWindow.isOpen();
    }
    focus() {
      if (this._isOpen) {
        this.editorWindow.focus();
      }
    }
    sendInitialState() {
      const state = this.propertyAdapter.getState();
      console.log("[Z3DObjectEditor] Sending initial state:", state);
      this.editorWindow.sendMessage({
        type: "INITIAL_STATE",
        data: state
      });
      this._lastSyncHash = JSON.stringify(state);
    }
    handlePropertyUpdate(data) {
      this._recentEditorUpdate = true;
      if (this._editorUpdateTimeout) {
        clearTimeout(this._editorUpdateTimeout);
      }
      this._editorUpdateTimeout = window.setTimeout(() => {
        this._recentEditorUpdate = false;
      }, 200);
      this.propertyAdapter.applyState(data);
      const currentState = this.propertyAdapter.getState();
      this._lastSyncHash = JSON.stringify(currentState);
      if (this.host.onPropertiesChanged) {
        this.host.onPropertiesChanged();
      }
    }
    handleAnimationStateChange(data) {
      console.log("[Z3DObjectEditor] Handling animation state change:", data);
      this.propertyAdapter.updateAnimationState(data);
      if (this.host.onPropertiesChanged) {
        this.host.onPropertiesChanged();
      }
    }
    handleNodeVisibilityChange(data) {
      console.log("[Z3DObjectEditor] Handling node visibility change:", data);
      if (data.nodeVisibility && typeof data.nodeVisibility === "object") {
        Object.entries(data.nodeVisibility).forEach(([nodeName, visible]) => {
          this.propertyAdapter.updateNodeVisibility(nodeName, visible);
        });
        if (this.host.onPropertiesChanged) {
          this.host.onPropertiesChanged();
        }
      } else if (data.nodeName && data.visible !== void 0) {
        this.propertyAdapter.updateNodeVisibility(data.nodeName, data.visible);
        if (this.host.onPropertiesChanged) {
          this.host.onPropertiesChanged();
        }
      }
    }
    handleSkinnedMeshUpdate(data) {
      console.log("[Z3DObjectEditor] Handling skinned mesh update");
      this.propertyAdapter.updateSkinnedMesh(data);
      if (this.host.onPropertiesChanged) {
        this.host.onPropertiesChanged();
      }
    }
    updateState() {
      if (!this._isOpen || this._isInitializing || this._recentEditorUpdate)
        return;
      const state = this.propertyAdapter.getState();
      const stateHash = JSON.stringify(state);
      if (stateHash !== this._lastSyncHash) {
        this._lastSyncHash = stateHash;
        console.log("[Z3DObjectEditor] Sending state update to editor");
        this.editorWindow.sendMessage({
          type: "STATE_UPDATE",
          data: state
        });
      }
    }
    _startPropertySync() {
      if (this._isActive)
        return;
      this._isActive = true;
      this._syncTimer = window.setInterval(() => {
        this._performSync();
      }, this._syncInterval);
      console.log("[Z3DObjectEditor] Property sync started");
    }
    _stopPropertySync() {
      this._isActive = false;
      if (this._syncTimer) {
        clearInterval(this._syncTimer);
        this._syncTimer = null;
      }
      if (this._editorUpdateTimeout) {
        clearTimeout(this._editorUpdateTimeout);
        this._editorUpdateTimeout = null;
      }
      console.log("[Z3DObjectEditor] Property sync stopped");
    }
    _performSync() {
      if (this._isInitializing || this._recentEditorUpdate || !this._isOpen)
        return;
      this.updateState();
    }
    markInitializationComplete() {
      this._isInitializing = false;
      this._recentEditorUpdate = false;
      this._lastSyncHash = "";
      console.log("[Z3DObjectEditor] Initialization complete, sync enabled");
    }
    onWindowClosed() {
      console.log("[Z3DObjectEditor] Editor window was closed");
      this._isOpen = false;
      this._stopPropertySync();
    }
    getHost() {
      return this.host;
    }
    getPropertyAdapter() {
      return this.propertyAdapter;
    }
    forceSync() {
      if (this._isInitializing)
        return;
      this._recentEditorUpdate = false;
      this.updateState();
    }
    dispose() {
      this._stopPropertySync();
      this.closeEditor();
      this.editorWindow.dispose();
    }
  };
  var editor_default = Z3DObjectEditor;
  return __toCommonJS(editor_exports);
})();
console.log('[Z3DPortable] Script completed, Z3DPortable set to:', Z3DPortable);
console.log('[Z3DPortable] Z3DPortable keys:', Z3DPortable ? Object.keys(Z3DPortable) : 'null');
globalThis.Z3DPortable = Z3DPortable;
console.log('[Z3DPortable] Set on globalThis');
//# sourceMappingURL=z3d-portable-editor.js.map
